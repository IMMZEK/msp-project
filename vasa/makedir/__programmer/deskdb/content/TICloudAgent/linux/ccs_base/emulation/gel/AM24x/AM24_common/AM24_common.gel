/* Copyright (c) 2021, Texas Instruments Incorporated
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * *  Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * *  Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * *  Neither the name of Texas Instruments Incorporated nor the names of
 *    its contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */

#define DEBUG 	  0 //turn on this for debugging messages
#define GEL_TRACE 0 //turn this on for gel_trace debug messages


//Common Register Definitions
#define MCU_PSC_BASE                (0x04000000)
#define MAIN_PSC_BASE               (0x00400000)

#define CTRLMMR_PID_OFFSET			(0x00000000U)
#define CTRLMMR_PID_VAL				(0x61800213U)

#define M3_MCUMAIN_OFFSET   (0x20000000)  //Mapped using RAT
#define M3_MAIN_OFFSET      (0x80000000)  //Mapped using RAT

#define CTRL_MMR0_CFG0_BASE 		(0x43000000U)
#define MCU_CTRL_MMR0_CFG0_BASE     (0x04500000U)

#define KICK0_UNLOCK_VAL				(0x68EF3490U)
#define KICK1_UNLOCK_VAL				(0xD172BC5AU)
#define KICK_LOCK_VAL					(0x00000000U)

#define LOCK0_KICK0_OFFSET	(0x00001008U)
#define LOCK0_KICK1_OFFSET	(0x0000100CU)
#define LOCK1_KICK0_OFFSET	(0x00005008U)
#define LOCK1_KICK1_OFFSET	(0x0000500CU)
#define LOCK2_KICK0_OFFSET	(0x00009008U)
#define LOCK2_KICK1_OFFSET	(0x0000900CU)
#define LOCK3_KICK0_OFFSET	(0x0000D008U)
#define LOCK3_KICK1_OFFSET	(0x0000D00CU)
#define LOCK5_KICK0_OFFSET	(0x00015008U)
#define LOCK5_KICK1_OFFSET	(0x0001500CU)
#define LOCK6_KICK0_OFFSET	(0x00019008U)
#define LOCK6_KICK1_OFFSET	(0x0001900CU)

#define CTRLMMR_MCU_LOCK0_KICK0		(0x00001008U)
#define CTRLMMR_MCU_LOCK0_KICK1		(0x0000100CU)
#define CTRLMMR_MCU_LOCK1_KICK0		(0x00005008U)
#define CTRLMMR_MCU_LOCK1_KICK1		(0x0000500CU)
#define CTRLMMR_MCU_LOCK2_KICK0		(0x00009008U)
#define CTRLMMR_MCU_LOCK2_KICK1		(0x0000900CU)
#define CTRLMMR_MCU_LOCK3_KICK0		(0x0000D008U)
#define CTRLMMR_MCU_LOCK3_KICK1		(0x0000D00CU)
#define CTRLMMR_MCU_LOCK6_KICK0		(0x00019008U)
#define CTRLMMR_MCU_LOCK6_KICK1		(0x0001900CU)

#define CTRLMMR_LOCK0_KICK0	(0x00001008U)
#define CTRLMMR_LOCK0_KICK1	(0x0000100CU)
#define CTRLMMR_LOCK1_KICK0	(0x00005008U)
#define CTRLMMR_LOCK1_KICK1	(0x0000500CU)
#define CTRLMMR_LOCK2_KICK0	(0x00009008U)
#define CTRLMMR_LOCK2_KICK1	(0x0000900CU)
#define CTRLMMR_LOCK3_KICK0	(0x0000D008U)
#define CTRLMMR_LOCK3_KICK1	(0x0000D00CU)
#define CTRLMMR_LOCK5_KICK0	(0x00015008U)
#define CTRLMMR_LOCK5_KICK1	(0x0001500CU)
#define CTRLMMR_LOCK6_KICK0	(0x00019008U)
#define CTRLMMR_LOCK6_KICK1	(0x0001900CU)

#define CSL_MAIN_SEC_MMR0_CFG0_CTRL_BASE (0x45A00000ul)
#define CSL_WKUP_DMSC0_RAT_BASE     (0x44200000)
#define CSL_WKUP_CTRL_MMR0_CFG0_BASE   (0x43000000)
#define CSL_MCU_CTRL_MMR0_CFG0_BASE    (0x4500000ul)
#define M4_IRAM_BASE_ADDRESS        (0x05000000)
#define DMSC0_SEC_MGR_BASE_ADDRESS  (0x44234000ul)
#define DEVICE_TYPE_OFFSET          (0x100)


/* ************************************************************************* */
/* Global Helper Functions */
/* ************************************************************************* */

/* Read from an MMR. */
Read_MMR(unsigned int mmr_address){
    unsigned int * p_mmr;
    p_mmr = (unsigned int *) mmr_address;
    return *p_mmr;
}

/* Write to an MMR. */
Write_MMR(unsigned int mmr_address, unsigned int mmr_value){
    unsigned int * p_mmr;
    p_mmr = (unsigned int *) mmr_address;
    *p_mmr = mmr_value;
}

/* Write to a specific field in an MMR. */
Write_MMR_Field(unsigned int mmr_address, unsigned int field_value, unsigned int width, unsigned int leftshift){
    unsigned int * p_mmr;
    unsigned int mask;
    p_mmr = (unsigned int *) mmr_address;   //Grab the MMR value
    mask = (1 << width) - 1 << leftshift; //Build a mask of 1s for the field. 
    mask = ~(mask); //Invert the mask so that the field will be zero'd out with the AND operation.
    *p_mmr &= mask; //Zero out the field in the register.
    *p_mmr |= (field_value << leftshift); //Assign the value to that specific field.
}

/* Read from a specific field in an MMR. */
Read_MMR_Field(unsigned int mmr_address, unsigned int width, unsigned int leftshift){
    unsigned int * p_mmr;
    unsigned int mask;
    unsigned int retval;
    p_mmr = (unsigned int *) mmr_address;
    mask = (1 << width) - 1 << leftshift; //Build a mask of 1s for the field. 
    retval = (*p_mmr & mask) >> leftshift; //Bitwise AND the mask with the register value, and then shift the field back down to the LSB
    return retval;
}

//Accesses from M3 needs to be adjusted based on RAT configuration
//map 512KB region  0x00000000-0x20000000 ==> 0x80000000-0xA0000000
//map 512KB region  0x40000000-0x60000000 ==> 0x60000000-0x80000000

AdjustBaseAddr(unsigned int addr)
{
	unsigned int read_pid, device_type;
	unsigned int debug_info = 1;
	unsigned int AdjustedAddr=addr;
	
	//Check if HSFS or GP device
    device_type = Read_MMR(DMSC0_SEC_MGR_BASE_ADDRESS + DEVICE_TYPE_OFFSET);
    if(device_type == 0x0A0A )
    {
        GEL_TextOut ("Device Type is HSFS\n");
        read_pid = Read_MMR(CTRL_MMR0_CFG0_BASE+CTRLMMR_PID_OFFSET); 
        if (read_pid != CTRLMMR_PID_VAL)
            GEL_TextOut ("ERROR: This is an HSFS device.  Script must be run from R5, or boot script must be executed.\n");
        else
            if(debug_info)
                GEL_TextOut("Running from R5\n");
    }
    else
    {
        GEL_TextOut ("Device Type is GP\n");
        //Check for running from M3
        read_pid = Read_MMR(CTRL_MMR0_CFG0_BASE+CTRLMMR_PID_OFFSET); 
        if (read_pid != CTRLMMR_PID_VAL)
        {
            if(debug_info)
                GEL_TextOut("Running from M3\n",,,,,);
            if ( (addr >= 0x40000000) && (addr < 0x60000000))
                AdjustedAddr += M3_MCUMAIN_OFFSET;
            if ( (addr >= 0x00000000) && (addr < 0x20000000))
                AdjustedAddr += M3_MAIN_OFFSET;
        }
        else
            if(debug_info)
                GEL_TextOut("Running from R5\n");
    } 
    return(AdjustedAddr);
}

AddrOffset()
{
    unsigned int read_pid;
    unsigned int debug_info = 1;
    unsigned int offset;
    
    //Check for running from DMSC
	read_pid = *((unsigned int *)(CTRL_MMR0_CFG0_BASE+CTRLMMR_PID_OFFSET)); 
	if (read_pid != CTRLMMR_PID_VAL)
	{
		if(debug_info)
		    GEL_TextOut("Running from DMSC\n",,,,,);
            offset = 0x80000000;
    }
	else
	{
		if(debug_info)
			GEL_TextOut("Running from R5\n");
		    offset = 0x00000000;
    }
    return(offset);
}

//read CLKIN value from BOOTMODE setting
Get_CLKIN()
{ int temp;
  float clock;
  unsigned int addr;
	
	addr = AdjustBaseAddr(WKUP_CTRL_MMR0_CFG0_BASE);
	temp = READ_BITS(addr,CTRLMMR_WKUP_DEVSTAT,2, 0); // Read CTRLMMR_WKUP_DEVSTAT to determine HFOSC0 frequency
	if(temp ==0)
	clock = 19.2;
	else if (temp==1)
	clock = 20;
	else if (temp==2)
	clock = 24;
	else if (temp==3)
	clock = 25;
	else if (temp==4)
	clock = 26;
	else if (temp==5)
	clock = 27;
	else
		GEL_TextOut("ERROR in determining CLKIN\n");
	return clock;
}

//Unlocks Control Module partitions for a particular address 
//Partition ranges
//                          WKUP/MCU/Main
//Partition 0               0x00000-0x04000      
//Partition 1  				0x04000-0x08000
//Partition 2  				0x08000-0x0C000
//Partition 3  				0x0C000-0x10000      
//Partition 4  				
//Partition 5  				0x014000-0x18000                            
//Partition 6  				0x018000-0x1C000
//Partition 7  				

menuitem "Lock-Unlock"
dialog Unlock_Register(unsigned int addr "Address to unlock:")
{
	CTRL_Unlock(addr);
}


CTRL_Unlock(unsigned int addr)
{
	int offset,base,partition,unlock_flag;
	unsigned int debug_info = 1;
	
	//Determine which partition the address offset is 
	
	base = 0xFFFE0000 & addr;   //get address base
	offset = 0x1FFFF & addr;  //get offset
	
	
	//get partition
	partition = offset >> 14;
	
	if(debug_info) {
	    GEL_TextOut("base = %x\n",,,,,base);
		GEL_TextOut("offset = %x\n",,,,,offset);
		GEL_TextOut("partition = %x\n",,,,,partition);
	}
	if(partition==0)
	{
		Write_MMR(base+LOCK0_KICK0_OFFSET, KICK0_UNLOCK_VAL);
		Write_MMR(base+LOCK0_KICK1_OFFSET, KICK1_UNLOCK_VAL);
		unlock_flag = Read_MMR(base+LOCK0_KICK0_OFFSET) & 0x1;
	}		
	else if (partition==1)
	{
		Write_MMR(base+LOCK1_KICK0_OFFSET, KICK0_UNLOCK_VAL);
		Write_MMR(base+LOCK1_KICK1_OFFSET, KICK1_UNLOCK_VAL);
		unlock_flag = Read_MMR(base+LOCK1_KICK0_OFFSET) & 0x1;
	}
	else if (partition==2)
	{
		Write_MMR(base+LOCK2_KICK0_OFFSET, KICK0_UNLOCK_VAL);
		Write_MMR(base+LOCK2_KICK1_OFFSET, KICK1_UNLOCK_VAL);
		unlock_flag = Read_MMR(base+LOCK2_KICK0_OFFSET) & 0x1;
	}	
	else if (partition==3)
	{
		Write_MMR(base+LOCK3_KICK0_OFFSET, KICK0_UNLOCK_VAL);
		Write_MMR(base+LOCK3_KICK1_OFFSET, KICK1_UNLOCK_VAL);
		unlock_flag = Read_MMR(base+LOCK3_KICK0_OFFSET) & 0x1;
	}	
	else if (partition==5)
	{
		Write_MMR(base+LOCK5_KICK0_OFFSET, KICK0_UNLOCK_VAL);
		Write_MMR(base+LOCK5_KICK1_OFFSET, KICK1_UNLOCK_VAL);
		unlock_flag = Read_MMR(base+LOCK5_KICK0_OFFSET) & 0x1;
	}
	else if (partition==6)
	{
		Write_MMR(base+LOCK6_KICK0_OFFSET, KICK0_UNLOCK_VAL);
		Write_MMR(base+LOCK6_KICK1_OFFSET, KICK1_UNLOCK_VAL);
		unlock_flag = Read_MMR(base+LOCK6_KICK0_OFFSET) & 0x1;
	}	
	else
	{
		GEL_TextOut("Invalid CTRLMMR Partition\n");
	}	
	
	//Check for unlock
	if(debug_info){
		if(unlock_flag == 1)
			GEL_TextOut("CTRLMMR Partition successfully unlocked!\n");
		else
			GEL_TextOut("Error: CTRLMMR Partition did not unlock!\n");
	}
}


PAD_Unlock(unsigned int addr)
{
	int offset,base,partition,unlock_flag;
	unsigned int debug_info = 1;
	
	//Determine which partition the address offset is 
	
	base = 0xFFFF0000 & addr;   //get address base
	offset = 0xFFFF & addr;  //get offset
	
	
	//get partition
	partition = offset >> 14;
	
	if(debug_info) {
	    GEL_TextOut("base = %x\n",,,,,base);
		GEL_TextOut("offset = %x\n",,,,,offset);
		GEL_TextOut("partition = %x\n",,,,,partition);
	}
	if(partition==0)
	{
		Write_MMR(base+LOCK0_KICK0_OFFSET, KICK0_UNLOCK_VAL);
		Write_MMR(base+LOCK0_KICK1_OFFSET, KICK1_UNLOCK_VAL);
		unlock_flag = Read_MMR(base+LOCK0_KICK0_OFFSET) & 0x1;
	}		
	else if (partition==1)
	{
		Write_MMR(base+LOCK1_KICK0_OFFSET, KICK0_UNLOCK_VAL);
		Write_MMR(base+LOCK1_KICK1_OFFSET, KICK1_UNLOCK_VAL);
		unlock_flag = Read_MMR(base+LOCK1_KICK0_OFFSET) & 0x1;
	}
	else
	{
		GEL_TextOut("Invalid PADCFG Partition\n");
	}	
	
	//Check for unlock
	if(debug_info){
		if(unlock_flag == 1)
			GEL_TextOut("PADCFG Partition successfully unlocked!\n");
		else
			GEL_TextOut("Error: PADCFG Partition did not unlock!\n");
	}
}


CTRL_Relock(int addr)
{
	int offset,base,partition,lock_flag;
	unsigned int debug_info = DEBUG;
	
	//Determine which partition the address offset is 
	
	base=0xFFFE0000 & addr;   //get address base
	offset = 0x1FFFF & addr;  //get offset
	
	//get partition
	partition = offset >> 14;
	if(partition==0)
	{
		Write_MMR(base+LOCK0_KICK0_OFFSET, KICK_LOCK_VAL);
		Write_MMR(base+LOCK0_KICK1_OFFSET, KICK_LOCK_VAL);
		lock_flag = Read_MMR(base+LOCK0_KICK0_OFFSET) & 0x1;
	}		
	else if (partition==1)
	{
		Write_MMR(base+LOCK1_KICK0_OFFSET, KICK_LOCK_VAL);
		Write_MMR(base+LOCK1_KICK1_OFFSET, KICK_LOCK_VAL);
		lock_flag = Read_MMR(base+LOCK1_KICK0_OFFSET) & 0x1;
	}
	else if (partition==2)
	{
		Write_MMR(base+LOCK2_KICK0_OFFSET, KICK_LOCK_VAL);
		Write_MMR(base+LOCK2_KICK1_OFFSET, KICK_LOCK_VAL);
		lock_flag = Read_MMR(base+LOCK2_KICK0_OFFSET) & 0x1;
	}	
	else if (partition==3)
	{
		Write_MMR(base+LOCK3_KICK0_OFFSET, KICK_LOCK_VAL);
		Write_MMR(base+LOCK3_KICK1_OFFSET, KICK_LOCK_VAL);
		lock_flag = Read_MMR(base+LOCK3_KICK0_OFFSET) & 0x1;
	}	
	else if (partition==5)
	{
		Write_MMR(base+LOCK5_KICK0_OFFSET, KICK_LOCK_VAL);
		Write_MMR(base+LOCK5_KICK1_OFFSET, KICK_LOCK_VAL);
		lock_flag = Read_MMR(base+LOCK5_KICK0_OFFSET) & 0x1;
	}
	else if (partition==6)
	{
		Write_MMR(base+LOCK6_KICK0_OFFSET, KICK_LOCK_VAL);
		Write_MMR(base+LOCK6_KICK1_OFFSET, KICK_LOCK_VAL);
		lock_flag = Read_MMR(base+LOCK6_KICK0_OFFSET) & 0x1;
	}	

	else
	{
		GEL_TextOut("Invalid CTRLMMR Partition\n");
	}	
	
	//Check for unlock
	if(debug_info) {
		if(lock_flag == 0)
			GEL_TextOut("CTRLMMR Partition successfully locked!\n");
		else
			GEL_TextOut("Error: CTRLMMR Partition still unlocked!\n");
	}
}

	
hotmenu CTRL_Unlock_All()
{
    int unlock_flag;
    unsigned int debug_info = DEBUG;
    unsigned int base;
    unsigned int read_pid;
     
	//Unlock Main CTRLMMR
	
    base = AdjustBaseAddr(0x43000000);
    Write_MMR(base+LOCK0_KICK0_OFFSET, KICK0_UNLOCK_VAL);
    Write_MMR(base+LOCK0_KICK1_OFFSET, KICK1_UNLOCK_VAL);
    unlock_flag = Read_MMR(base+LOCK0_KICK0_OFFSET) & 0x1;
    if(unlock_flag == 1)
        GEL_TextOut("CTRLMMR Partition0 successfully unlocked!\n");
    else
        GEL_TextOut("Error: CTRLMMR Partition0 did not unlock!\n");
    
    base = AdjustBaseAddr(0x43004000);
    Write_MMR(base+LOCK0_KICK0_OFFSET, KICK0_UNLOCK_VAL);
    Write_MMR(base+LOCK0_KICK1_OFFSET, KICK1_UNLOCK_VAL);
    unlock_flag = Read_MMR(base+LOCK0_KICK0_OFFSET) & 0x1;
    if(unlock_flag == 1)
        GEL_TextOut("CTRLMMR Partition1 successfully unlocked!\n");
    else
        GEL_TextOut("Error: CTRLMMR Partition1 did not unlock!\n");
    
    base = AdjustBaseAddr(0x43008000);
    Write_MMR(base+LOCK0_KICK0_OFFSET, KICK0_UNLOCK_VAL);
    Write_MMR(base+LOCK0_KICK1_OFFSET, KICK1_UNLOCK_VAL);
    unlock_flag = Read_MMR(base+LOCK0_KICK0_OFFSET) & 0x1;
    if(unlock_flag == 1)
        GEL_TextOut("CTRLMMR Partition2 successfully unlocked!\n");
    else
        GEL_TextOut("Error: CTRLMMR Partition2 did not unlock!\n");
    
    base = AdjustBaseAddr(0x4300C000);
    Write_MMR(base+LOCK0_KICK0_OFFSET, KICK0_UNLOCK_VAL);
    Write_MMR(base+LOCK0_KICK1_OFFSET, KICK1_UNLOCK_VAL);
    unlock_flag = Read_MMR(base+LOCK0_KICK0_OFFSET) & 0x1;
    if(unlock_flag == 1)
        GEL_TextOut("CTRLMMR Partition3 successfully unlocked!\n");
    else
        GEL_TextOut("Error: CTRLMMR Partition3 did not unlock!\n");
  
    base = AdjustBaseAddr(0x43014000);
    Write_MMR(base+LOCK0_KICK0_OFFSET, KICK0_UNLOCK_VAL);
    Write_MMR(base+LOCK0_KICK1_OFFSET, KICK1_UNLOCK_VAL);
    unlock_flag = Read_MMR(base+LOCK0_KICK0_OFFSET) & 0x1;
    if(unlock_flag == 1)
        GEL_TextOut("CTRLMMR Partition5 successfully unlocked!\n");
    else
        GEL_TextOut("Error: CTRLMMR Partition5 did not unlock!\n");
	
    base = AdjustBaseAddr(0x43018000);
    Write_MMR(base+LOCK0_KICK0_OFFSET, KICK0_UNLOCK_VAL);
    Write_MMR(base+LOCK0_KICK1_OFFSET, KICK1_UNLOCK_VAL);
    unlock_flag = Read_MMR(base+LOCK0_KICK0_OFFSET) & 0x1;
    if(unlock_flag == 1)
        GEL_TextOut("CTRLMMR Partition6 successfully unlocked!\n");
    else
        GEL_TextOut("Error: CTRLMMR Partition6 did not unlock!\n");
    
	//Unlock CTRLMMR_MCU

    base = AdjustBaseAddr(0x04500000);
    Write_MMR(base+LOCK0_KICK0_OFFSET, KICK0_UNLOCK_VAL);
    Write_MMR(base+LOCK0_KICK1_OFFSET, KICK1_UNLOCK_VAL);
    unlock_flag = Read_MMR(base+LOCK0_KICK0_OFFSET) & 0x1;
    if(unlock_flag == 1)
        GEL_TextOut("MCU CTRL Partition0 successfully unlocked!\n");
    else
        GEL_TextOut("Error: MCU CTRL Partition0 did not unlock!\n");
    
    base = AdjustBaseAddr(0x04504000);
    Write_MMR(base+LOCK0_KICK0_OFFSET, KICK0_UNLOCK_VAL);
    Write_MMR(base+LOCK0_KICK1_OFFSET, KICK1_UNLOCK_VAL);
    unlock_flag = Read_MMR(base+LOCK0_KICK0_OFFSET) & 0x1;
    if(unlock_flag == 1)
        GEL_TextOut("MCU CTRL Partition1 successfully unlocked!\n");
    else
        GEL_TextOut("Error: MCU CTRL Partition1 did not unlock!\n");
    
    base = AdjustBaseAddr(0x04508000);
    Write_MMR(base+LOCK0_KICK0_OFFSET, KICK0_UNLOCK_VAL);
    Write_MMR(base+LOCK0_KICK1_OFFSET, KICK1_UNLOCK_VAL);
    unlock_flag = Read_MMR(base+LOCK0_KICK0_OFFSET) & 0x1;
    if(unlock_flag == 1)
        GEL_TextOut("MCU CTRL Partition2 successfully unlocked!\n");
    else
        GEL_TextOut("Error: MCU CTRL Partition2 did not unlock!\n");
    
    base = AdjustBaseAddr(0x0450C000);
    Write_MMR(base+LOCK0_KICK0_OFFSET, KICK0_UNLOCK_VAL);
    Write_MMR(base+LOCK0_KICK1_OFFSET, KICK1_UNLOCK_VAL);
    unlock_flag = Read_MMR(base+LOCK0_KICK0_OFFSET) & 0x1;
    if(unlock_flag == 1)
        GEL_TextOut("MCU CTRL Partition3 successfully unlocked!\n");
    else
        GEL_TextOut("Error: MCU CTRL Partition3 did not unlock!\n");

    
    base = AdjustBaseAddr(0x04510000);
    Write_MMR(base+LOCK0_KICK0_OFFSET, KICK0_UNLOCK_VAL);
    Write_MMR(base+LOCK0_KICK1_OFFSET, KICK1_UNLOCK_VAL);
    unlock_flag = Read_MMR(base+LOCK0_KICK0_OFFSET) & 0x1;
    if(unlock_flag == 1)
        GEL_TextOut("MCU CTRL Partition0 successfully unlocked!\n");
    else
        GEL_TextOut("Error: MCU CTRL Partition0 did not unlock!\n");

	//Unlock Main PADCFG
    base = AdjustBaseAddr(0x000F0000);
    Write_MMR(base+LOCK0_KICK0_OFFSET, KICK0_UNLOCK_VAL);
    Write_MMR(base+LOCK0_KICK1_OFFSET, KICK1_UNLOCK_VAL);
    unlock_flag = Read_MMR(base+LOCK0_KICK0_OFFSET) & 0x1;
    if(unlock_flag == 1)
        GEL_TextOut("PADCFG Partition0 successfully unlocked!\n");
    else
        GEL_TextOut("Error: PADCFG Partition0 did not unlock!\n");

    base = AdjustBaseAddr(0x000F4000);
    Write_MMR(base+LOCK0_KICK0_OFFSET, KICK0_UNLOCK_VAL);
    Write_MMR(base+LOCK0_KICK1_OFFSET, KICK1_UNLOCK_VAL);
    unlock_flag = Read_MMR(base+LOCK0_KICK0_OFFSET) & 0x1;
    if(unlock_flag == 1)
        GEL_TextOut("PADCFG Partition1 successfully unlocked!\n");
    else
        GEL_TextOut("Error: PADCFG Partition1 did not unlock!\n");

	//Unlock MCU PADCFG
    base = AdjustBaseAddr(0x04080000);
    Write_MMR(base+LOCK0_KICK0_OFFSET, KICK0_UNLOCK_VAL);
    Write_MMR(base+LOCK0_KICK1_OFFSET, KICK1_UNLOCK_VAL);
    unlock_flag = Read_MMR(base+LOCK0_KICK0_OFFSET) & 0x1;
    if(unlock_flag == 1)
        GEL_TextOut("MCU_PADCFG Partition0 successfully unlocked!\n");
    else
        GEL_TextOut("Error: MCU_PADCFG Partition0 did not unlock!\n");

    base = AdjustBaseAddr(0x04084000);
    Write_MMR(base+LOCK0_KICK0_OFFSET, KICK0_UNLOCK_VAL);
    Write_MMR(base+LOCK0_KICK1_OFFSET, KICK1_UNLOCK_VAL);
    unlock_flag = Read_MMR(base+LOCK0_KICK0_OFFSET) & 0x1;
    if(unlock_flag == 1)
        GEL_TextOut("MCU PADCFG Partition1 successfully unlocked!\n");
    else
        GEL_TextOut("Error: MCU PADCFG Partition1 did not unlock!\n");

	
}
    
    
