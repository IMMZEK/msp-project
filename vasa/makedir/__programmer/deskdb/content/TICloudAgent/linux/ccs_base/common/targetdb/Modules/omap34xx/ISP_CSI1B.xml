<module name="ISP_CSI1B" acronym="" XML_version="1.0" HW_revision="n/a" description="">
  <register id="CSI1B_REVISION" acronym="CSI1B_REVISION" offset="0x0" width="32" description="MODULE REVISION This register contains the IP revision code in binary coded digital. For example, we have: 0x01 = revision 0.1 and 0x21 = revision 2.1">
    <bitfield id="RESERVED" width="24" begin="31" end="8" resetval="0x000000" description="Write 0s for future compatibility.Reads returns 0." range="" rwaccess="R"/>
    <bitfield id="REV" width="8" begin="7" end="0" resetval="TI internal data" description="IP revision [7:4] Major revision[3:0] Minor revision" range="" rwaccess="R"/>
  </register>
  <register id="CSI1B_SYSCONFIG" acronym="CSI1B_SYSCONFIG" offset="0x4" width="32" description="SYSTEM CONFIGURATION REGISTER This register is the CSI1 system configuration register.">
    <bitfield id="RESERVED" width="18" begin="31" end="14" resetval="0x00000" description="Write 0s for future compatibility.Reads returns 0." range="" rwaccess="RW"/>
    <bitfield id="MSTANDBY_MODE" width="2" begin="13" end="12" resetval="0x0" description="Sets the behavior of the master port power management signals." range="" rwaccess="RW">
      <bitenum value="0" token="MSTANDBY_MODE_0" description="Force-standby. Hardware signal is only asserted when the module is disabled."/>
      <bitenum value="1" token="MSTANDBY_MODE_1" description="No-standby. Hardware signal is never asserted."/>
      <bitenum value="2" token="MSTANDBY_MODE_2" description="Smart-standby: Hardware signal is asserted based on the activity of the module. The module tries to go to standby during the vertical blanking period."/>
    </bitfield>
    <bitfield id="RESERVED" width="10" begin="11" end="2" resetval="0x000" description="Write 0s for future compatibility.Reads returns 0." range="" rwaccess="RW"/>
    <bitfield id="SOFT_RESET" width="1" begin="1" end="1" resetval="0x0" description="Software reset. Set the bit to 1 to trigger a module reset. The bit is automatically reset by the HW. During reads return 0." range="" rwaccess="RW">
      <bitenum value="0" token="SOFT_RESET_0" description="Normal mode."/>
      <bitenum value="1" token="SOFT_RESET_1" description="The module is reset"/>
    </bitfield>
    <bitfield id="AUTO_IDLE" width="1" begin="0" end="0" resetval="0x1" description="Internal interface clock gating strategy." range="" rwaccess="RW">
      <bitenum value="0" token="AUTO_IDLE_0" description="Interface clock is free-running."/>
      <bitenum value="1" token="AUTO_IDLE_1" description="Automatic Interface clock gating strategy is applied based on the Interconnect interface activity."/>
    </bitfield>
  </register>
  <register id="CSI1B_SYSSTATUS" acronym="CSI1B_SYSSTATUS" offset="0x8" width="32" description="SYSTEM STATUS REGISTER This register provides status information about the module, excluding the interrupt status register.">
    <bitfield id="RESERVED" width="31" begin="31" end="1" resetval="0x00000000" description="Write 0s for future compatibility.Reads returns 0." range="" rwaccess="R"/>
    <bitfield id="RESET_DONE" width="1" begin="0" end="0" resetval="0x1" description="Internal reset monitoring" range="" rwaccess="R">
      <bitenum value="0" token="RESET_DONE_0" description="Internal module reset is on going."/>
      <bitenum value="1" token="RESET_DONE_1" description="Reset completed."/>
    </bitfield>
  </register>
  <register id="CSI1B_IRQENABLE" acronym="CSI1B_IRQENABLE" offset="0xC" width="32" description="INTERRUPT ENABLE REGISTER">
    <bitfield id="RESERVED" width="20" begin="31" end="12" resetval="0x00000" description="Write 0s for future compatibility.Reads returns 0." range="" rwaccess="RW"/>
    <bitfield id="FS_IRQ" width="1" begin="11" end="11" resetval="0x0" description="Frame start sync code detection." range="" rwaccess="RW">
      <bitenum value="0" token="FS_IRQ_0" description="Event is masked"/>
      <bitenum value="1" token="FS_IRQ_1" description="Event generates an interrupt when it occurs"/>
    </bitfield>
    <bitfield id="LE_IRQ" width="1" begin="10" end="10" resetval="0x0" description="Line end sync code detection." range="" rwaccess="RW">
      <bitenum value="0" token="LE_IRQ_0" description="Event is masked"/>
      <bitenum value="1" token="LE_IRQ_1" description="Event generates an interrupt when it occurs"/>
    </bitfield>
    <bitfield id="LS_IRQ" width="1" begin="9" end="9" resetval="0x0" description="Line start sync code detection." range="" rwaccess="RW">
      <bitenum value="0" token="LS_IRQ_0" description="Event is masked"/>
      <bitenum value="1" token="LS_IRQ_1" description="Event generates an interrupt when it occurs"/>
    </bitfield>
    <bitfield id="FE_IRQ" width="1" begin="8" end="8" resetval="0x0" description="Frame end sync code detection." range="" rwaccess="RW">
      <bitenum value="0" token="FE_IRQ_0" description="Event is masked"/>
      <bitenum value="1" token="FE_IRQ_1" description="Event generates an interrupt when it occurs"/>
    </bitfield>
    <bitfield id="COUNT_IRQ" width="1" begin="7" end="7" resetval="0x0" description="Frame counter reached." range="" rwaccess="RW">
      <bitenum value="0" token="COUNT_IRQ_0" description="Event is masked"/>
      <bitenum value="1" token="COUNT_IRQ_1" description="Event generates an interrupt when it occurs"/>
    </bitfield>
    <bitfield id="RESERVED" width="1" begin="6" end="6" resetval="0x0" description="Write 0s for future compatibility.Reads returns 0." range="" rwaccess="RW"/>
    <bitfield id="FIFO_OVF_IRQ" width="1" begin="5" end="5" resetval="0x0" description="FIFO overflow error." range="" rwaccess="RW">
      <bitenum value="0" token="FIFO_OVF_IRQ_0" description="Event is masked"/>
      <bitenum value="1" token="FIFO_OVF_IRQ_1" description="Event generates an interrupt when it occurs"/>
    </bitfield>
    <bitfield id="RESERVED" width="1" begin="4" end="4" resetval="0x0" description="Write 0s for future compatibility.Reads returns 0." range="" rwaccess="RW">
      <bitenum value="0" token="RESERVED_0" description="Event is masked"/>
      <bitenum value="1" token="RESERVED_1" description="Event generates an interrupt when it occurs"/>
    </bitfield>
    <bitfield id="FSP_IRQ" width="1" begin="3" end="3" resetval="0x0" description="FSP error." range="" rwaccess="RW">
      <bitenum value="0" token="FSP_IRQ_0" description="Event is masked"/>
      <bitenum value="1" token="FSP_IRQ_1" description="Event generates an interrupt when it occurs"/>
    </bitfield>
    <bitfield id="FW_IRQ" width="1" begin="2" end="2" resetval="0x0" description="Frame width error." range="" rwaccess="RW">
      <bitenum value="0" token="FW_IRQ_0" description="Event is masked"/>
      <bitenum value="1" token="FW_IRQ_1" description="Event generates an interrupt when it occurs"/>
    </bitfield>
    <bitfield id="FSC_IRQ" width="1" begin="1" end="1" resetval="0x0" description="False sync code error." range="" rwaccess="RW">
      <bitenum value="0" token="FSC_IRQ_0" description="Event is masked"/>
      <bitenum value="1" token="FSC_IRQ_1" description="Event generates an interrupt when it occurs"/>
    </bitfield>
    <bitfield id="SSC_IRQ" width="1" begin="0" end="0" resetval="0x0" description="Shifted sync code error. This interrupt cannot be triggered if the complex I/O is set in parallel mode (CSI1_CTRL.IO_OUT_SEL = 1)." range="" rwaccess="RW">
      <bitenum value="0" token="SSC_IRQ_0" description="Event is masked"/>
      <bitenum value="1" token="SSC_IRQ_1" description="Event generates an interrupt when it occurs"/>
    </bitfield>
  </register>
  <register id="CSI1B_IRQSTATUS" acronym="CSI1B_IRQSTATUS" offset="0x10" width="32" description="INTERRUPT STATUS REGISTER">
    <bitfield id="RESERVED" width="20" begin="31" end="12" resetval="0x00000" description="Write 0s for future compatibility.Reads returns 0." range="" rwaccess="RW"/>
    <bitfield id="FS_IRQ" width="1" begin="11" end="11" resetval="0x0" description="Frame start sync code detection status." range="" rwaccess="RW1toClr">
      <bitenum value="0" token="FS_IRQ_0" description="READS: Event is false. WRITES: Status bit unchanged."/>
      <bitenum value="1" token="FS_IRQ_1" description="READS: Event is true (pending). WRITES: Status bit is reset."/>
    </bitfield>
    <bitfield id="LE_IRQ" width="1" begin="10" end="10" resetval="0x0" description="Line end sync code detection status." range="" rwaccess="RW1toClr">
      <bitenum value="0" token="LE_IRQ_0" description="READS: Event is false. WRITES: Status bit unchanged."/>
      <bitenum value="1" token="LE_IRQ_1" description="READS: Event is true (pending). WRITES: Status bit is reset."/>
    </bitfield>
    <bitfield id="LS_IRQ" width="1" begin="9" end="9" resetval="0x0" description="Line start sync code detection status." range="" rwaccess="RW1toClr">
      <bitenum value="0" token="LS_IRQ_0" description="READS: Event is false. WRITES: Status bit unchanged."/>
      <bitenum value="1" token="LS_IRQ_1" description="READS: Event is true (pending). WRITES: Status bit is reset."/>
    </bitfield>
    <bitfield id="FE_IRQ" width="1" begin="8" end="8" resetval="0x0" description="Frame end sync code detection status." range="" rwaccess="RW1toClr">
      <bitenum value="0" token="FE_IRQ_0" description="READS: Event is false. WRITES: Status bit unchanged."/>
      <bitenum value="1" token="FE_IRQ_1" description="READS: Event is true (pending). WRITES: Status bit is reset."/>
    </bitfield>
    <bitfield id="COUNT_IRQ" width="1" begin="7" end="7" resetval="0x0" description="Frame counter reached status" range="" rwaccess="RW1toClr">
      <bitenum value="0" token="COUNT_IRQ_0" description="READS: Event is false. WRITES: Status bit unchanged."/>
      <bitenum value="1" token="COUNT_IRQ_1" description="READS: Event is true (pending). WRITES: Status bit is reset."/>
    </bitfield>
    <bitfield id="RESERVED" width="1" begin="6" end="6" resetval="0x0" description="Write 0s for future compatibility.Reads returns 0." range="" rwaccess="RW1toClr"/>
    <bitfield id="FIFO_OVF_IRQ" width="1" begin="5" end="5" resetval="0x0" description="FIFO overflow error status." range="" rwaccess="RW1toClr">
      <bitenum value="0" token="FIFO_OVF_IRQ_0" description="READS: Event is false. WRITES: Status bit unchanged."/>
      <bitenum value="1" token="FIFO_OVF_IRQ_1" description="READS: Event is true (pending). WRITES: Status bit is reset."/>
    </bitfield>
    <bitfield id="RESERVED" width="1" begin="4" end="4" resetval="0x0" description="Write 0s for future compatibility.Reads returns 0." range="" rwaccess="RW1toClr">
      <bitenum value="0" token="RESERVED_0" description="READS: Event is false. WRITES: Status bit unchanged."/>
      <bitenum value="1" token="RESERVED_1" description="READS: Event is true (pending). WRITES: Status bit is reset."/>
    </bitfield>
    <bitfield id="FSP_IRQ" width="1" begin="3" end="3" resetval="0x0" description="FSP error status." range="" rwaccess="RW1toClr">
      <bitenum value="0" token="FSP_IRQ_0" description="READS: Event is false. WRITES: Status bit unchanged."/>
      <bitenum value="1" token="FSP_IRQ_1" description="READS: Event is true (pending). WRITES: Status bit is reset."/>
    </bitfield>
    <bitfield id="FW_IRQ" width="1" begin="2" end="2" resetval="0x0" description="Frame width error status." range="" rwaccess="RW1toClr">
      <bitenum value="0" token="FW_IRQ_0" description="READS: Event is false. WRITES: Status bit unchanged."/>
      <bitenum value="1" token="FW_IRQ_1" description="READS: Event is true (pending). WRITES: Status bit is reset."/>
    </bitfield>
    <bitfield id="FSC_IRQ" width="1" begin="1" end="1" resetval="0x0" description="False sync code error status." range="" rwaccess="RW1toClr">
      <bitenum value="0" token="FSC_IRQ_0" description="READS: Event is false. WRITES: Status bit unchanged."/>
      <bitenum value="1" token="FSC_IRQ_1" description="READS: Event is true (pending). WRITES: Status bit is reset."/>
    </bitfield>
    <bitfield id="SSC_IRQ" width="1" begin="0" end="0" resetval="0x0" description="Shifted sync code error status." range="" rwaccess="RW1toClr">
      <bitenum value="0" token="SSC_IRQ_0" description="READS: Event is false. WRITES: Status bit unchanged."/>
      <bitenum value="1" token="SSC_IRQ_1" description="READS: Event is true (pending). WRITES: Status bit is reset."/>
    </bitfield>
  </register>
  <register id="CSI1B_LCM_IRQENABLE" acronym="CSI1B_LCM_IRQENABLE" offset="0x2C" width="32" description="INTERRUPT ENABLE REGISTER - Memory channel This register regroups all the events related to the memory channel 2. The events related to memory channel trigger SINTERRUPTN[8]. The channel must be enabled for events to be generated on that channel.">
    <bitfield id="RESERVED" width="30" begin="31" end="2" resetval="0x00000000" description="Write 0s for future compatibility.Reads returns 0." range="" rwaccess="RW"/>
    <bitfield id="LCM_OCPERROR" width="1" begin="1" end="1" resetval="0x0" description="An OCP error occurred on the master read port." range="" rwaccess="RW">
      <bitenum value="0" token="LCM_OCPERROR_0" description="Event is masked"/>
      <bitenum value="1" token="LCM_OCPERROR_1" description="Event generates an interrupt when it occurs"/>
    </bitfield>
    <bitfield id="LCM_EOF" width="1" begin="0" end="0" resetval="0x0" description="Memory read channel - End of frame" range="" rwaccess="RW">
      <bitenum value="0" token="LCM_EOF_0" description="Event generates an interrupt when it occurs"/>
      <bitenum value="1" token="LCM_EOF_1" description="Event is masked"/>
    </bitfield>
  </register>
  <register id="CSI1B_LCM_IRQSTATUS" acronym="CSI1B_LCM_IRQSTATUS" offset="0x30" width="32" description="INTERRUPT STATUS REGISTER - Memory channel This register regroups all the events related to memory channel. The events related to memory channel trigger SINTERRUPTN[8]. The channel must be enabled for events to be generated on that channel.">
    <bitfield id="RESERVED" width="30" begin="31" end="2" resetval="0x00000000" description="Write 0s for future compatibility.Reads returns 0." range="" rwaccess="RW"/>
    <bitfield id="LCM_OCPERROR" width="1" begin="1" end="1" resetval="0x0" description="An OCP error occurred on the master read port." range="" rwaccess="RW 1toClr">
      <bitenum value="0" token="LCM_OCPERROR_0" description="READS: Event is true (pending). WRITES: Status bit is reset."/>
      <bitenum value="1" token="LCM_OCPERROR_1" description="READS: Event is false. WRITES: Status bit unchanged."/>
    </bitfield>
    <bitfield id="LCM_EOF" width="1" begin="0" end="0" resetval="0x0" description="Memory read channel - End of frame" range="" rwaccess="RW 1toClr">
      <bitenum value="0" token="LCM_EOF_0" description="READS: Event is false. WRITES: Status bit unchanged."/>
      <bitenum value="1" token="LCM_EOF_1" description="READS: Event is true (pending). WRITES: Status bit is reset."/>
    </bitfield>
  </register>
  <register id="CSI1B_CTRL" acronym="CSI1B_CTRL" offset="0x40" width="32" description="GLOBAL CONTROL REGISTER This register controls the CSI1 RECEIVER module. This register must not be modified dynamically (except IF_EN bit field).">
    <bitfield id="RESERVED" width="19" begin="31" end="13" resetval="0x00000" description="Write 0s for future compatibility.Reads returns 0." range="" rwaccess="RW"/>
    <bitfield id="VP_CLK_POL" width="1" begin="12" end="12" resetval="0x0" description="VP clock polarity" range="" rwaccess="RW">
      <bitenum value="0" token="VP_CLK_POL_0" description="The RECEIVER module writes the data on the VP on the pixel clock falling edge. The module connected to the VP must sample the data on the pixel clock rising edge."/>
      <bitenum value="1" token="VP_CLK_POL_1" description="The RECEIVER module writes the data on the VP on the pixel clock raising edge. The module connected to the VP must sample the data on the pixel clock falling edge."/>
    </bitfield>
    <bitfield id="VP_ONLY_EN" width="1" begin="11" end="11" resetval="0x0" description="VP only enable." range="" rwaccess="RW">
      <bitenum value="0" token="VP_ONLY_EN_0" description="The VP is enabled and the Interconnect master port are enabled."/>
      <bitenum value="1" token="VP_ONLY_EN_1" description="The VP is enabled and the Interconnect master port is disabled. The embedded data and pixel data are output on the VP."/>
    </bitfield>
    <bitfield id="INV" width="1" begin="10" end="10" resetval="0x0" description="Strobe/clock inversion control signal" range="" rwaccess="RW">
      <bitenum value="0" token="INV_0" description="Not inverted."/>
      <bitenum value="1" token="INV_1" description="Inverted."/>
    </bitfield>
    <bitfield id="VP_OUT_CTRL" width="2" begin="9" end="8" resetval="0x1" description="Video port output clock control. Sets the video port output clock as a function of the interface clock (OCPCLK)." range="" rwaccess="RW">
      <bitenum value="0" token="VP_OUT_CTRL_0" description="No division: video port clock = OCPCLK."/>
      <bitenum value="1" token="VP_OUT_CTRL_1" description="Division by 2: video port clock = OCPCLK/2."/>
      <bitenum value="2" token="VP_OUT_CTRL_2" description="Division by 3: video port clock = OCPCLK/3."/>
      <bitenum value="3" token="VP_OUT_CTRL_3" description="Division by 4: video port clock = OCPCLK/4."/>
    </bitfield>
    <bitfield id="DBG_EN" width="1" begin="7" end="7" resetval="0x0" description="Enables the debug mode." range="" rwaccess="RW">
      <bitenum value="0" token="DBG_EN_0" description="Disable"/>
      <bitenum value="1" token="DBG_EN_1" description="Enable"/>
    </bitfield>
    <bitfield id="BURST" width="2" begin="6" end="5" resetval="0x0" description="Forces the write burst size used by the module. The write burst size must never exceed the output FIFO size. The output FIFO size can be read with the CSI1_GNQ.FIFODEPTH bit field." range="" rwaccess="RW">
      <bitenum value="0" token="BURST_0" description="1x 64-bit burst = single request."/>
      <bitenum value="1" token="BURST_1" description="2x 64-bit bursts."/>
      <bitenum value="2" token="BURST_2" description="4x 64-bit bursts."/>
      <bitenum value="3" token="BURST_3" description="8x 64-bit bursts."/>
    </bitfield>
    <bitfield id="RESERVED" width="1" begin="4" end="4" resetval="0x0" description="Write 0s for future compatibility.Reads returns 0." range="" rwaccess="RW"/>
    <bitfield id="FRAME" width="1" begin="3" end="3" resetval="0x0" description="Set the modality in which IF_EN works." range="" rwaccess="RW">
      <bitenum value="0" token="FRAME_0" description="When SW writes IF_EN = 0 the interface is disabled immediately."/>
      <bitenum value="1" token="FRAME_1" description="When SW writes IF_EN = 1 the interface is disabled after the next FEC sync code."/>
    </bitfield>
    <bitfield id="IO_OUT_SEL" width="1" begin="2" end="2" resetval="0x0" description="I/O cell output mode selection." range="" rwaccess="RW">
      <bitenum value="0" token="IO_OUT_SEL_0" description="I/O output is serial: DATA, STROBE"/>
      <bitenum value="1" token="IO_OUT_SEL_1" description="I/O output is parallel: DATA32, DATATOG, SYNTOG. Note that the SSC_IRQ error cannot be triggered in this configuration."/>
    </bitfield>
    <bitfield id="PHY_SEL" width="1" begin="1" end="1" resetval="0x0" description="Physical layer protocol selection." range="" rwaccess="RW">
      <bitenum value="0" token="PHY_SEL_0" description="Data/Clock physical layer"/>
      <bitenum value="1" token="PHY_SEL_1" description="Data/Strobe physical layer"/>
    </bitfield>
    <bitfield id="IF_EN" width="1" begin="0" end="0" resetval="0x0" description="Enables the physical interface to the module." range="" rwaccess="RW">
      <bitenum value="0" token="IF_EN_0" description="The interface is disabled. If FRAME = 0, it is disabled immediately. If FRAME = 1, it is disabled on the next FEC sync code."/>
      <bitenum value="1" token="IF_EN_1" description="The interface is enabled immediately, the data acquisition starts on the next FSC sync code. Writing 1 to this register when the current value is 0 has the effect to clear the output FIFO. The pixel data of the following frame is written in the PING buffer, that is, the CSI1_CTRL.PING_PONG bits are reset to 1 as well."/>
    </bitfield>
  </register>
  <register id="CSI1B_DBG" acronym="CSI1B_DBG" offset="0x44" width="32" description="DEBUG REGISTER This register provides a way to debug the CSI1 RECEIVER module with no image sensor connected to the module. The debug mode is enabled by CSI1_CTRL.DBG_EN. Only full 32-bit values must be written.">
    <bitfield id="DBG" width="32" begin="31" end="0" resetval="0x00000000" description="32-bit input value." range="" rwaccess="W"/>
  </register>
  <register id="CSI1B_GNQ" acronym="CSI1B_GNQ" offset="0x48" width="32" description="GENERIC PARAMETER REGISTER This register provide a way to read the generic parameters used in the design.">
    <bitfield id="RESERVED" width="27" begin="31" end="5" resetval="0x0000000" description="Reads returns 0." range="" rwaccess="R"/>
    <bitfield id="FIFODEPTH" width="3" begin="4" end="2" resetval="0x1" description="Output FIFO size in multiple of 64 bits." range="" rwaccess="R">
      <bitenum value="0" token="FIFODEPTH_0" description="2x 64 bits"/>
      <bitenum value="1" token="FIFODEPTH_1" description="4x 64 bits"/>
      <bitenum value="2" token="FIFODEPTH_2" description="8x 64 bits"/>
      <bitenum value="3" token="FIFODEPTH_3" description="16x 64 bits"/>
      <bitenum value="4" token="FIFODEPTH_4" description="32x 64 bits"/>
      <bitenum value="5" token="FIFODEPTH_5" description="64x 64 bits"/>
    </bitfield>
    <bitfield id="RESERVED" width="2" begin="1" end="0" resetval="0x2" description="Read returns 2." range="" rwaccess="R"/>
  </register>
  <register id="CSI1B_CTRL1" acronym="CSI1B_CTRL1" offset="0x50" width="32" description="CONTROL REGISTER This register is shadowed: modifications are taken into account after the next FSC sync code.">
    <bitfield id="COUNT" width="8" begin="31" end="24" resetval="0x00" description="Sets the number of frame to acquire. Once the frame acquisition starts, the COUNT value is decremented after every frame. When COUNT reaches 0, the COUNT_IRQ interrupt is triggered and CHAN_EN is set to 0. Writes to this bit field are controlled by the COUNT_UNLOCK bit. COUNT can be overwritten dynamically with a new count value.' 0: Infinite number of frames (no count).1: 1 frame to acquire...255: 255 frames to acquire." range="" rwaccess="RW"/>
    <bitfield id="RESERVED" width="5" begin="23" end="19" resetval="0x00" description="Write 0s for future compatibility.Reads returns 0." range="" rwaccess="RW"/>
    <bitfield id="RESERVED" width="1" begin="18" end="18" resetval="0x0" description="Write 0s for future compatibility.Reads returns 0." range="" rwaccess="RW"/>
    <bitfield id="PING_PONG" width="1" begin="17" end="17" resetval="0x1" description="Indicates whether the PING or PONG destination address (CSI1_DAT_PING_ADDR or CSI1_DAT_PONG_ADDR) was used to write the last frame. This bit field toggles after every FEC sync code." range="" rwaccess="R">
      <bitenum value="0" token="PING_PONG_0" description="PING buffer"/>
      <bitenum value="1" token="PING_PONG_1" description="PONG buffer"/>
    </bitfield>
    <bitfield id="COUNT_UNLOCK" width="1" begin="16" end="16" resetval="0x0" description="Unlock writes to the COUNT bit field." range="" rwaccess="W">
      <bitenum value="0" token="COUNT_UNLOCK_0" description="COUNT bit field is locked. Writes have no effect"/>
      <bitenum value="1" token="COUNT_UNLOCK_1" description="COUNT bit field is unlocked. Writes are possible."/>
    </bitfield>
    <bitfield id="ALPHA" width="8" begin="15" end="8" resetval="0x00" description="Alpha value for RGB888 and RBG444." range="" rwaccess="RW"/>
    <bitfield id="FORMAT" width="5" begin="7" end="3" resetval="0x00" description="Data format selection." range="" rwaccess="RW">
      <bitenum value="0" token="FORMAT_0" description="YUV422 BIG ENDIAN"/>
      <bitenum value="1" token="FORMAT_1" description="YUV422 LITTLE ENDIAN"/>
      <bitenum value="2" token="FORMAT_2" description="YUV420"/>
      <bitenum value="3" token="FORMAT_3" description="YUV422 + VP or RAW8 + VP"/>
      <bitenum value="4" token="FORMAT_4" description="RGB444 + EXP16"/>
      <bitenum value="5" token="FORMAT_5" description="RGB565"/>
      <bitenum value="6" token="FORMAT_6" description="RGB888"/>
      <bitenum value="7" token="FORMAT_7" description="RGB888 + EXP32"/>
      <bitenum value="16" token="FORMAT_16" description="RAW8"/>
      <bitenum value="20" token="FORMAT_20" description="RAW10"/>
      <bitenum value="21" token="FORMAT_21" description="RAW10 + EXP16"/>
      <bitenum value="22" token="FORMAT_22" description="RAW10 + VP"/>
      <bitenum value="24" token="FORMAT_24" description="RAW12"/>
      <bitenum value="25" token="FORMAT_25" description="RAW12 + EXP16"/>
      <bitenum value="26" token="FORMAT_26" description="RAW12 + VP"/>
      <bitenum value="28" token="FORMAT_28" description="JPEG8 + FSP"/>
      <bitenum value="29" token="FORMAT_29" description="JPEG8"/>
      <bitenum value="30" token="FORMAT_30" description="RAW10 - RAW8 RAW10 data from sensor is right shifted to produce RAW8 before it is sent to memory."/>
    </bitfield>
    <bitfield id="RESERVED" width="1" begin="2" end="2" resetval="0x0" description="Write 0s for future compatibility.Reads returns 0." range="" rwaccess="RW"/>
    <bitfield id="REGION_EN" width="1" begin="1" end="1" resetval="0x0" description="Enables the setting of regions of interest in the frame: SOF region, EOF region and DAT region." range="" rwaccess="RW">
      <bitenum value="0" token="REGION_EN_0" description="Disabled"/>
      <bitenum value="1" token="REGION_EN_1" description="Enabled"/>
    </bitfield>
    <bitfield id="RESERVED" width="1" begin="0" end="0" resetval="0x1" description="Write 1 for future compatibility.Reads returns 1." range="" rwaccess="RW"/>
  </register>
  <register id="CSI1B_CODE" acronym="CSI1B_CODE" offset="0x54" width="32" description="CODE REGISTER This register sets the codes that are used in the 32-bit synchronization codes to recognize frame start, frame end, line start and line end codes. The default values are usually not supposed to be modified. Updating this register with new codes under a flowing serial transmission causes unexpected results.">
    <bitfield id="RESERVED" width="12" begin="31" end="20" resetval="0x000" description="Write 0s for future compatibility.Reads returns 0." range="" rwaccess="RW"/>
    <bitfield id="RESERVED" width="4" begin="19" end="16" resetval="0x0" description="Write 0s for future compatibility.Reads returns 0." range="" rwaccess="RW"/>
    <bitfield id="FEC" width="4" begin="15" end="12" resetval="0x3" description="End sync code identifier. The sync code identifier is located between bits 0 to 3 in the 32-bit synchronization codes." range="" rwaccess="RW"/>
    <bitfield id="FSC" width="4" begin="11" end="8" resetval="0x2" description="Start sync code identifier. The sync code identifier is located between bits 0 to 3 in the 32-bit synchronization codes." range="" rwaccess="RW"/>
    <bitfield id="LEC" width="4" begin="7" end="4" resetval="0x1" description="End sync code identifier. The sync code identifier is located between bits 0 to 3 in the 32-bit synchronization codes." range="" rwaccess="RW"/>
    <bitfield id="LSC" width="4" begin="3" end="0" resetval="0x0" description="Start sync code identifier. The sync code identifier is located between bits 0 to 3 in the 32-bit synchronization codes." range="" rwaccess="RW"/>
  </register>
  <register id="CSI1B_STAT_START" acronym="CSI1B_STAT_START" offset="0x58" width="32" description="STATUS LINE START REGISTER This register is shadowed: modifications are taken into account after the next FSC sync code.">
    <bitfield id="RESERVED" width="4" begin="31" end="28" resetval="0x0" description="Write 0s for future compatibility.Reads returns 0." range="" rwaccess="RW"/>
    <bitfield id="EOF" width="12" begin="27" end="16" resetval="0x000" description="Sets the vertical position of the EOF status lines in regards of the FSC sync code. From 0 to 4095." range="" rwaccess="RW"/>
    <bitfield id="RESERVED" width="4" begin="15" end="12" resetval="0x0" description="Write 0s for future compatibility.Reads returns 0." range="" rwaccess="RW"/>
    <bitfield id="SOF" width="12" begin="11" end="0" resetval="0x000" description="Sets the vertical position of the EOF status lines in regards of the FSC sync code. Should always be 0." range="" rwaccess="RW"/>
  </register>
  <register id="CSI1B_STAT_SIZE" acronym="CSI1B_STAT_SIZE" offset="0x5C" width="32" description="STATUS LINE SIZE REGISTER This register is shadowed: modifications are taken into account after the next FSC sync code.">
    <bitfield id="RESERVED" width="4" begin="31" end="28" resetval="0x0" description="Write 0s for future compatibility.Reads returns 0." range="" rwaccess="RW"/>
    <bitfield id="EOF" width="12" begin="27" end="16" resetval="0x000" description="Sets the number of EOF status linesFrom 0 to 4095" range="" rwaccess="RW"/>
    <bitfield id="RESERVED" width="4" begin="15" end="12" resetval="0x0" description="Write 0s for future compatibility.Reads returns 0." range="" rwaccess="RW"/>
    <bitfield id="SOF" width="12" begin="11" end="0" resetval="0x000" description="Sets the number of SOF status line(s)From 0 to 4095" range="" rwaccess="RW"/>
  </register>
  <register id="CSI1B_SOF_ADDR" acronym="CSI1B_SOF_ADDR" offset="0x60" width="32" description="SOF STATUS LINE MEM ADDRESS REGISTER This register sets the 32-bit memory address where the SOF data are stored. Note that the 5 LSBs are ignored: the address should be aligned on a 32-byte boundary. This register is shadowed: modifications are taken into account after the next FSC sync code.">
    <bitfield id="ADDR" width="27" begin="31" end="5" resetval="0x0000000" description="27 most significant bits of the 32-bit address." range="" rwaccess="RW"/>
    <bitfield id="RESERVED" width="5" begin="4" end="0" resetval="0x00" description="5 least significant bits of the 32-bit address. Write 0s for future compatibility.Reads returns 0." range="" rwaccess="RW"/>
  </register>
  <register id="CSI1B_EOF_ADDR" acronym="CSI1B_EOF_ADDR" offset="0x64" width="32" description="EOF STATUS LINE MEM ADDRESS REGISTER This register sets the 32-bit memory address where the EOF data are stored. Note that the 5 LSBs are ignored: the address should be aligned on a 32-byte boundary. This register is shadowed: modifications are taken into account after the next FSC sync code.">
    <bitfield id="ADDR" width="27" begin="31" end="5" resetval="0x0000000" description="27 most significant bits of the 32-bit address." range="" rwaccess="RW"/>
    <bitfield id="RESERVED" width="5" begin="4" end="0" resetval="0x00" description="5 least significant bits of the 32-bit address. Write 0s for future compatibility.Reads returns 0." range="" rwaccess="RW"/>
  </register>
  <register id="CSI1B_DAT_START" acronym="CSI1B_DAT_START" offset="0x68" width="32" description="DATA START REGISTER This register is shadowed: modifications are taken into account after the next FSC sync code.">
    <bitfield id="RESERVED" width="4" begin="31" end="28" resetval="0x0" description="Write 0s for future compatibility.Reads returns 0." range="" rwaccess="RW"/>
    <bitfield id="VERT" width="12" begin="27" end="16" resetval="0x000" description="Sets the vertical position of the data in regards of the FSC sync code. From 0 to 4095 lines." range="" rwaccess="RW"/>
    <bitfield id="RESERVED" width="16" begin="15" end="0" resetval="0x0000" description="Write 0s for future compatibility.Reads returns 0." range="" rwaccess="RW"/>
  </register>
  <register id="CSI1B_DAT_SIZE" acronym="CSI1B_DAT_SIZE" offset="0x6C" width="32" description="DATA SIZE REGISTER This register is shadowed: modifications are taken into account after the next FSC sync code.">
    <bitfield id="RESERVED" width="4" begin="31" end="28" resetval="0x0" description="Write 0s for future compatibility.Reads returns 0." range="" rwaccess="RW"/>
    <bitfield id="VERT" width="12" begin="27" end="16" resetval="0x000" description="Sets the vertical size of the data window. From 0 to 4095 lines. If VERT = '0', no data is output." range="" rwaccess="RW"/>
    <bitfield id="RESERVED" width="16" begin="15" end="0" resetval="0x0000" description="Write 0s for future compatibility.Reads returns 0." range="" rwaccess="RW"/>
  </register>
  <register id="CSI1B_DAT_PING_ADDR" acronym="CSI1B_DAT_PING_ADDR" offset="0x70" width="32" description="DATA MEM PING ADDRESS REGISTER This register sets the 32-bit memory address where the pixel data are stored. The destination is double buffered: this register sets the PING address. Double buffering is enabled when the addresses CSI1_DAT_PING_ADDR and CSI1_DAT_PONG_ADDR are different. Note that the 5 LSBs are ignored: the address should be aligned on a 32-byte boundary. This register is shadowed: modifications are taken into account after the next FSC sync code.">
    <bitfield id="ADDR" width="27" begin="31" end="5" resetval="0x0000000" description="27 most significant bits of the 32-bit address." range="" rwaccess="RW"/>
    <bitfield id="RESERVED" width="5" begin="4" end="0" resetval="0x00" description="5 least significant bits of the 32-bit address. Write 0s for future compatibility.Reads returns 0." range="" rwaccess="RW"/>
  </register>
  <register id="CSI1B_DAT_PONG_ADDR" acronym="CSI1B_DAT_PONG_ADDR" offset="0x74" width="32" description="DATA MEM PONG ADDRESS REGISTER - LOG CHAN 0 This register sets the 32-bit memory address where the pixel data are stored. The destination is double buffered: this register sets the PONG address. Double buffering is enabled when the addresses CSI1_DAT_PING_ADDR andCSI1_DAT_PONG_ADDR are different. Note that the 5 LSBs are ignored: the address should be aligned on a 32-byte boundary. This register is shadowed: modifications are taken into account after the next FSC sync code.">
    <bitfield id="ADDR" width="27" begin="31" end="5" resetval="0x0000000" description="27 most significant bits of the 32-bit address." range="" rwaccess="RW"/>
    <bitfield id="RESERVED" width="5" begin="4" end="0" resetval="0x00" description="5 least significant bits of the 32-bit address. Write 0s for future compatibility.Reads returns 0." range="" rwaccess="RW"/>
  </register>
  <register id="CSI1B_DAT_OFST" acronym="CSI1B_DAT_OFST" offset="0x78" width="32" description="DATA MEM ADDRESS OFFSET REGISTER This register sets the offset, which is applied on the destination address after each line is written to memory. This register applies for both CSI1_DAT_PING_ADDR and CSI1_DAT_PONG_ADDR. For example, it enables to perform 2D data transfers of the pixel data into a frame buffer. In such case, the pixel data and frame buffer data must have the same data format. Note that the 5 LSBs are ignored: the offset must be a multiple of 32 bytes. The usage of this register is limited to the following data formats: YUV422 LITTLE ENDIAN, YUV422 BIG ENDIAN, RGB565, RGB444 + EXP16, RGB888 + EXP32. This register is shadowed: modifications are taken into account after the next FSC sync code.">
    <bitfield id="OFST" width="27" begin="31" end="5" resetval="0x0000000" description="Line offset programmed in bytes. If OFST = 0, the data is written contiguously in memory. Otherwise, OFST sets the destination offset between the first pixel of the previous line and the first pixel of the current line." range="" rwaccess="RW"/>
    <bitfield id="RESERVED" width="5" begin="4" end="0" resetval="0x00" description="Write 0s for future compatibility.Reads returns 0." range="" rwaccess="RW"/>
  </register>
  <register id="CSI1B_LCM_CTRL" acronym="CSI1B_LCM_CTRL" offset="0x1D0" width="32" description="Control register for the memory channel. It defines the data format of the source frame stored in memory and how this frame is processed.">
    <bitfield id="DST_PACK" width="1" begin="31" end="31" resetval="0x0" description="Data is packed before it is sent to memory." range="" rwaccess="RW">
      <bitenum value="0" token="DST_PACK_0" description="Enabled"/>
      <bitenum value="1" token="DST_PACK_1" description="Disabled"/>
    </bitfield>
    <bitfield id="RESERVED" width="1" begin="30" end="30" resetval="0x0" description="Write 0s for future compatibility.Reads returns 0." range="" rwaccess="RW"/>
    <bitfield id="RESERVED" width="1" begin="29" end="29" resetval="0x0" description="Write 0s for future compatibility.Reads returns 0." range="" rwaccess="RW"/>
    <bitfield id="RESERVED" width="2" begin="28" end="27" resetval="0x0" description="Write 0s for future compatibility.Reads returns 0." range="" rwaccess="RW"/>
    <bitfield id="DST_FORMAT" width="3" begin="26" end="24" resetval="0x0" description="Output format selection.Not every combination between input and output formats are possible. Check the specification for allowed modes." range="" rwaccess="RW">
      <bitenum value="0" token="DST_FORMAT_0" description="Reserved"/>
      <bitenum value="1" token="DST_FORMAT_1" description="Reserved"/>
      <bitenum value="2" token="DST_FORMAT_2" description="RAW8"/>
      <bitenum value="3" token="DST_FORMAT_3" description="RAW10"/>
      <bitenum value="4" token="DST_FORMAT_4" description="RAW12"/>
    </bitfield>
    <bitfield id="SRC_PACK" width="1" begin="23" end="23" resetval="0x0" description="Data stored in memory is packed and must be unpacked." range="" rwaccess="RW">
      <bitenum value="0" token="SRC_PACK_0" description="Enabled"/>
      <bitenum value="1" token="SRC_PACK_1" description="Disabled"/>
    </bitfield>
    <bitfield id="RESERVED" width="1" begin="22" end="22" resetval="0x0" description="Write 0s for future compatibility.Reads returns 0." range="" rwaccess="RW"/>
    <bitfield id="RESERVED" width="1" begin="21" end="21" resetval="0x0" description="Write 0s for future compatibility.Reads returns 0." range="" rwaccess="RW"/>
    <bitfield id="RESERVED" width="2" begin="20" end="19" resetval="0x0" description="Write 0s for future compatibility.Reads returns 0." range="" rwaccess="RW"/>
    <bitfield id="SRC_FORMAT" width="3" begin="18" end="16" resetval="0x0" description="Data format of the data stored in memory.As there is no header embedded in the data sent to memory, users are responsible of choosing the proper format." range="" rwaccess="RW">
      <bitenum value="0" token="SRC_FORMAT_0" description="Reserved"/>
      <bitenum value="1" token="SRC_FORMAT_1" description="Reserved"/>
      <bitenum value="2" token="SRC_FORMAT_2" description="RAW8"/>
      <bitenum value="3" token="SRC_FORMAT_3" description="RAW10"/>
      <bitenum value="4" token="SRC_FORMAT_4" description="RAW12"/>
    </bitfield>
    <bitfield id="RESERVED" width="8" begin="15" end="8" resetval="0x00" description="Write 0s for future compatibility.Reads returns 0." range="" rwaccess="RW"/>
    <bitfield id="BURST_SIZE" width="3" begin="7" end="5" resetval="0x0" description="Defines the burst size of the master read port" range="" rwaccess="RW">
      <bitenum value="0" token="BURST_SIZE_0" description="1x 64-bit burst = single request."/>
      <bitenum value="1" token="BURST_SIZE_1" description="2x 64-bit bursts."/>
      <bitenum value="2" token="BURST_SIZE_2" description="4x 64-bit bursts."/>
      <bitenum value="3" token="BURST_SIZE_3" description="8x 64-bit bursts."/>
      <bitenum value="4" token="BURST_SIZE_4" description="16x 64-bit bursts."/>
      <bitenum value="5" token="BURST_SIZE_5" description="32x 64-bit bursts."/>
    </bitfield>
    <bitfield id="READ_THROTTLE" width="2" begin="4" end="3" resetval="0x0" description="Limit maximum data read speed for memory to memory operation" range="" rwaccess="RW">
      <bitenum value="0" token="READ_THROTTLE_0" description="Full speed. Throughput is limited by internal processing capabilities."/>
      <bitenum value="1" token="READ_THROTTLE_1" description="speed"/>
      <bitenum value="3" token="READ_THROTTLE_3" description="1/4 speed"/>
      <bitenum value="4" token="READ_THROTTLE_4" description="1/8 speed"/>
    </bitfield>
    <bitfield id="DST_PORT" width="1" begin="2" end="2" resetval="0x0" description="Select the destination port" range="" rwaccess="RW">
      <bitenum value="0" token="DST_PORT_0" description="Data is sent to memory."/>
      <bitenum value="1" token="DST_PORT_1" description="Data is sent to video port, it is always sent without compression or packing."/>
    </bitfield>
    <bitfield id="RESERVED" width="1" begin="1" end="1" resetval="0x0" description="Write 0s for future compatibility.Reads returns 0." range="" rwaccess="RW"/>
    <bitfield id="CHAN_EN" width="1" begin="0" end="0" resetval="0x0" description="Enables the read from memory channel.Before enabling the memory read channel SW must:- disable the physical interface using the IF_EN bit- wait until disabling of the physical interface is effective (depends on the FRAME bit) Read from memory starts as soon as this bit is set, therefore all CSI1_LCM_x registers must be configured correctly before.This bit is cleared by HW at the end of the frame." range="" rwaccess="RW">
      <bitenum value="0" token="CHAN_EN_0" description="Disabled"/>
      <bitenum value="1" token="CHAN_EN_1" description="Enabled"/>
    </bitfield>
  </register>
  <register id="CSI1B_LCM_VSIZE" acronym="CSI1B_LCM_VSIZE" offset="0x1D4" width="32" description="Memory channel vertical framing register">
    <bitfield id="RESERVED" width="4" begin="31" end="28" resetval="0x0" description="Write 0s for future compatibility.Reads returns 0." range="" rwaccess="RW"/>
    <bitfield id="COUNT" width="12" begin="27" end="16" resetval="0x001" description="Defines the line count to be read from memory. From 1 to 4095 lines." range="" rwaccess="RW"/>
    <bitfield id="RESERVED" width="16" begin="15" end="0" resetval="0x0000" description="Write 0s for future compatibility.Reads returns 0." range="" rwaccess="RW"/>
  </register>
  <register id="CSI1B_LCM_HSIZE" acronym="CSI1B_LCM_HSIZE" offset="0x1D8" width="32" description="Memory read channel horizontal framing register.">
    <bitfield id="RESERVED" width="4" begin="31" end="28" resetval="0x0" description="Write 0s for future compatibility.Reads returns 0." range="" rwaccess="RW"/>
    <bitfield id="COUNT" width="12" begin="27" end="16" resetval="0x000" description="Horizontal count of pixels to output after the skipped pixels.Valid values: 1-4095." range="" rwaccess="RW"/>
    <bitfield id="RESERVED" width="4" begin="15" end="12" resetval="0x0" description="Write 0s for future compatibility.Reads returns 0." range="" rwaccess="RW"/>
    <bitfield id="SKIP" width="12" begin="11" end="0" resetval="0x000" description="Horizontal count of pixels to skip after the start of the line.Valid values: 0-4095.0 disables pixel skipping" range="" rwaccess="RW"/>
  </register>
  <register id="CSI1B_LCM_PREFETCH" acronym="CSI1B_LCM_PREFETCH" offset="0x1DC" width="32" description="This register defines the amount of data to be fetched from memory. Is must be consistent with the CSI1_LCM_HSIZE register (check programing model)">
    <bitfield id="RESERVED" width="18" begin="31" end="14" resetval="0x00000" description="Write 0s for future compatibility.Reads returns 0." range="" rwaccess="RW"/>
    <bitfield id="HWORDS" width="11" begin="13" end="3" resetval="0x001" description="64 bit words to read from memory for each line of the image.Possible values 1..2047" range="" rwaccess="RW"/>
    <bitfield id="RESERVED" width="3" begin="2" end="0" resetval="0x0" description="Write 0s for future compatibility.Reads returns 0." range="" rwaccess="RW"/>
  </register>
  <register id="CSI1B_LCM_SRC_ADDR" acronym="CSI1B_LCM_SRC_ADDR" offset="0x1E0" width="32" description="Memory channel source address register This register sets the 32-bit memory address where the pixel data are stored. Note that the 5 LSBs are ignored: the address should be aligned on a 32-byte boundary.">
    <bitfield id="ADDR" width="27" begin="31" end="5" resetval="0x0000000" description="27 most significant bits of the 32-bit address." range="" rwaccess="RW"/>
    <bitfield id="RESERVED" width="5" begin="4" end="0" resetval="0x00" description="5 least significant bits of the 32-bit address. Write 0s for future compatibility.Reads returns 0." range="" rwaccess="RW"/>
  </register>
  <register id="CSI1B_LCM_SRC_OFST" acronym="CSI1B_LCM_SRC_OFST" offset="0x1E4" width="32" description="Memory channel source offset register. This register sets the offset, which is applied on the source address after each line is read from memory. For example, it enables to perform 2D data transfers of the pixel data from a frame buffer. In such case, the pixel data and frame buffer data must have the same data format. Note that the 5 LSBs are ignored: the offset must be a multiple of 32 bytes.">
    <bitfield id="OFST" width="27" begin="31" end="5" resetval="0x0000000" description="Line offset programmed in bytes. If OFST = 0, the data is read contiguously from memory. Otherwise, OFST sets the source offset between the first pixel of the previous line and the first pixel of the current line." range="" rwaccess="RW"/>
    <bitfield id="RESERVED" width="5" begin="4" end="0" resetval="0x00" description="Write 0s for future compatibility.Reads returns 0." range="" rwaccess="RW"/>
  </register>
  <register id="CSI1B_LCM_DST_ADDR" acronym="CSI1B_LCM_DST_ADDR" offset="0x1E8" width="32" description="Memory channel destination address. This register sets the 32-bit memory address where the pixel data are stored. Note that the 5 LSBs are ignored: the address should be aligned on a 32-byte boundary.">
    <bitfield id="ADDR" width="27" begin="31" end="5" resetval="0x0000000" description="27 most significant bits of the 32-bit address." range="" rwaccess="RW"/>
    <bitfield id="RESERVED" width="5" begin="4" end="0" resetval="0x00" description="5 least significant bits of the 32-bit address. Write 0s for future compatibility.Reads returns 0." range="" rwaccess="RW"/>
  </register>
  <register id="CSI1B_LCM_DST_OFST" acronym="CSI1B_LCM_DST_OFST" offset="0x1EC" width="32" description="Memory channel destination offset register. This register sets the offset, which is applied on the destination address after each line is written to memory. For example, it enables to perform 2D data transfers of the pixel data into a frame buffer. In such case, the pixel data and frame buffer data must have the same data format. Note that the 5 LSBs are ignored: the offset must be a multiple of 32 bytes.">
    <bitfield id="OFST" width="27" begin="31" end="5" resetval="0x0000000" description="Line offset programmed in bytes. If OFST = 0, the data is written contiguously to memory if possible. At the end of a line only full 32 bit words are written, creating eventually gaps at the end of lines. Otherwise, OFST sets the destination offset between the first pixel of the previous line and the first pixel of the current line." range="" rwaccess="RW"/>
    <bitfield id="RESERVED" width="5" begin="4" end="0" resetval="0x00" description="Write 0s for future compatibility.Reads returns 0." range="" rwaccess="RW"/>
  </register>
</module>
