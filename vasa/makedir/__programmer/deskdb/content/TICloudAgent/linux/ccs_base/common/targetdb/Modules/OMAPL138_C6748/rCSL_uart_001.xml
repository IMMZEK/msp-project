<?xml version="1.0" encoding="utf-8"?>
<module id="UART" HW_revision="" XML_version="1" description="Universal Asynchronous Receive Transmit">
	<register id="RBR" acronym="RBR" offset="0x0000" width="32" description="Receiver Buffer Register">
		<bitfield id="Reserved" width="24" begin="31" end="8" resetval="0" description="Reserved" range="" rwaccess="N"/>
		<bitfield id="DATA" width="8" begin="7" end="0" resetval="0" description="Received data" range="" rwaccess="R"/>
	</register>
	<register id="THR" acronym="THR" offset="0x0000" width="32" description="Transmitter Holding Register">
		<bitfield id="Reserved" width="24" begin="31" end="8" resetval="0" description="Reserved" range="" rwaccess="N"/>
		<bitfield id="DATA" width="8" begin="7" end="0" resetval="0" description="Data to transmit" range="" rwaccess="W"/>
	</register>
	<register id="IER" acronym="IER" offset="0x0004" width="32" description="The interrupt enable register (IER) is used to individually enable or disable each type of interrupt request that can be generated by the UART. Each interrupt request that is enabled in IER is forwarded to the CPU.">
		<bitfield id="Reserved" width="28" begin="31" end="4" resetval="0" description="Reserved" range="" rwaccess="N"/>
		<bitfield id="EDSSI" width="1" begin="3" end="3" resetval="0" description="Enable Modem Status Interrupt                                                                " range="" rwaccess="RW">
			<bitenum id="DISABLE" value="0" token="DISABLE" description=""/>
			<bitenum id="ENABLE" value="1" token="ENABLE" description=""/>
		</bitfield>
		<bitfield id="ELSI" width="1" begin="2" end="2" resetval="0" description="Receiver line status interrupt enable. " range="" rwaccess="RW">
			<bitenum id="DISABLE" value="0" token="DISABLE" description=" Receiver line status interrupt is disabled."/>
			<bitenum id="ENABLE" value="1" token="ENABLE" description=" Receiver line status interrupt is enabled."/>
		</bitfield>
		<bitfield id="ETBEI" width="1" begin="1" end="1" resetval="0" description="Transmitter holding register empty interrupt enable. " range="" rwaccess="RW">
			<bitenum id="DISABLE" value="0" token="DISABLE" description="Transmitter holding register empty interrupt is disabled."/>
			<bitenum id="ENABLE" value="1" token="ENABLE" description="Transmitter holding register empty interrupt is enabled."/>
		</bitfield>
		<bitfield id="ERBI" width="1" begin="0" end="0" resetval="0" description="Receiver data available interrupt and character timeout indication interrupt enable. " range="" rwaccess="RW">
			<bitenum id="DISABLE" value="0" token="DISABLE" description="Receiver data available interrupt and character timeout indication interrupt is disabled."/>
			<bitenum id="ENABLE" value="1" token="ENABLE" description="Receiver data available interrupt and character timeout indication interrupt is enabled."/>
		</bitfield>
	</register>
	<register id="IIR" acronym="IIR" offset="0x0008" width="32" description="The interrupt identification register (IIR) is a read-only register at the same address as the FIFO control register (FCR), which is a write-only register. When an interrupt is generated and enabled in the interrupt enable register (IER), IIR indicates that an interrupt is pending in the IPEND bit and encodes the type of interrupt in the INTID bits.">
		<bitfield id="Reserved" width="24" begin="31" end="8" resetval="0" description="Reserved" range="" rwaccess="N"/>
		<bitfield id="FIFOEN" width="2" begin="7" end="6" resetval="0" description="FIFOs Enabled Always 00b in Non-FIFO mode Set to 11b when bit 0 of the FCR register is set" range="" rwaccess="R">
			<bitenum id="DISABLE" value="11" token="DISABLE" description=""/>
			<bitenum id="ENABLE" value="283" token="ENABLE" description=""/>
		</bitfield>
		<bitfield id="Reserved" width="2" begin="5" end="4" resetval="0" description="Reserved" range="" rwaccess="N"/>
		<bitfield id="INTID" width="3" begin="3" end="1" resetval="0" description="Encodes the different types of interrupt" range="" rwaccess="R">
			<bitenum id="MODSTAT" value="0" token="MODSTAT" description="Modem Status (Priority 4) Lowest"/>
			<bitenum id="THRE" value="1" token="THRE" description="THR Empty (Priority 3)"/>
			<bitenum id="RDA" value="2" token="RDA" description="Received Data Available (Priority 2)"/>
			<bitenum id="RLS" value="3" token="RLS" description="Receiver Line Status (Priority 1) Highest"/>
			<bitenum id="CTI" value="6" token="CTI" description="Character Timeout Indication (Priority 2)"/>
		</bitfield>
		<bitfield id="IPEND" width="1" begin="0" end="0" resetval="1" description="Interrupt Pending This bit is used either in a hardwire prioritized (nirq) or polled interrupt system" range="" rwaccess="R">
			<bitenum id="PEND" value="0" token="PEND" description=" No interrupts pending"/>
			<bitenum id="NO_PEND" value="1" token="NO_PEND" description=""/>
		</bitfield>
	</register>
	<register id="FCR" acronym="FCR" offset="0x0008" width="32" description="The FIFO control register (FCR) is a write-only register at the same address as the interrupt identification register (IIR), which is a read-only register. Use FCR to enable and clear the FIFOs and to select the receiver FIFO trigger level.The FIFOEN bit must be set to 1 before other FCR bits are written to or the FCR bits are not programmed.">
		<bitfield id="Reserved" width="24" begin="31" end="8" resetval="0" description="Reserved" range="" rwaccess="N"/>
		<bitfield id="RXFIFTL" width="2" begin="7" end="6" resetval="0" description="0-3h Receiver FIFO trigger level. RXFIFTL sets the trigger level for the receiver FIFO. When the trigger level is reached, a receiver data-ready interrupt is generated (if the interrupt request is enabled). Once the FIFO drops below the trigger level, the interrupt is cleared. " range="" rwaccess="W">
			<bitenum id="CHAR1" value="0" token="CHAR1" description="1 byte"/>
			<bitenum id="CHAR4" value="1" token="CHAR4" description="4 byte"/>
			<bitenum id="CHAR8" value="2" token="CHAR8" description="8 byte"/>
			<bitenum id="CHAR14" value="3" token="CHAR14" description="14 byte"/>
		</bitfield>
		<bitfield id="Reserved" width="2" begin="5" end="4" resetval="0" description="Reserved" range="" rwaccess="N"/>
		<bitfield id="DMAMODE1" width="1" begin="3" end="3" resetval="0" description="DMA MODE1 enable if FIFOs are enabled. Always write 1 to DMAMODE1. After a hardware reset, change DMAMODE1 from 0 to 1. DMAMOD1 = 1 is a requirement for proper communication between the UART and the EDMA controller. " range="" rwaccess="W">
			<bitenum id="DISABLE" value="0" token="DISABLE" description="DMA MODE1 is disabled."/>
			<bitenum id="ENABLE" value="1" token="ENABLE" description="DMA MODE1 is enabled."/>
		</bitfield>
		<bitfield id="TXCLR" width="1" begin="2" end="2" resetval="0" description="Transmitter FIFO clear. Write a 1 to TXCLR to clear the bit. " range="" rwaccess="W">
			<bitenum id="CLR" value="1" token="CLR" description="Clears transmitter FIFO and resets the transmitter FIFO counter. The shift register is not cleared."/>
		</bitfield>
		<bitfield id="RXCLR" width="1" begin="1" end="1" resetval="0" description="Receiver FIFO clear. Write a 1 to RXCLR to clear the bit. " range="" rwaccess="W">
			<bitenum id="CLR" value="1" token="CLR" description="Clears receiver FIFO and resets the receiver FIFO counter. The shift register is not cleared."/>
		</bitfield>
		<bitfield id="FIFOEN" width="1" begin="0" end="0" resetval="0" description="Transmitter and receiver FIFOs mode enable. FIFOEN must be set before other FCR bits are written to or the FCR bits are not programmed. Clearing this bit clears the FIFO counters. " range="" rwaccess="W">
			<bitenum id="DISABLE" value="0" token="DISABLE" description="Non-FIFO mode. The transmitter and receiver FIFOs are disabled, and the FIFO pointers are cleared."/>
			<bitenum id="ENABLE" value="1" token="ENABLE" description="FIFO mode. The transmitter and receiver FIFOs are enabled."/>
		</bitfield>
	</register>
	<register id="LCR" acronym="LCR" offset="0x000C" width="32" description="The system programmer controls the format of the asynchronous data communication exchange by using LCR. In addition, the programmer can retrieve, inspect, and modify the content of LCR; this eliminates the need for separate storage of the line characteristics in system memory.">
		<bitfield id="Reserved" width="24" begin="31" end="8" resetval="0" description="Reserved" range="" rwaccess="N"/>
		<bitfield id="DLAB" width="1" begin="7" end="7" resetval="0" description="Divisor latch access bit. The divisor latch registers (DLL and DLH) can be accessed at dedicated addresses or at addresses shared by RBR, THR, and IER. Using the shared addresses requires toggling DLAB to change which registers are selected. If you use the dedicated addresses, you can keep DLAB = 0. " range="" rwaccess="RW">
			<bitenum id="DISABLE" value="0" token="DISABLE" description="Allows access to the receiver buffer register (RBR), the transmitter holding register (THR), and the interrupt enable register (IER) selected. At the address shared by RBR, THR, and DLL, the CPU can read from RBR and write to THR. At the address shared by IER and DLH, the CPU can read from and write to IER."/>
			<bitenum id="ENABLE" value="1" token="ENABLE" description="Allows access to the divisor latches of the baud generator during a read or write operation (DLL and DLH). At the address shared by RBR, THR, and DLL, the CPU can read from and write to DLL. At the address shared by IER and DLH, the CPU can read from and write to DLH."/>
		</bitfield>
		<bitfield id="BC" width="1" begin="6" end="6" resetval="0" description="Break control. " range="" rwaccess="RW">
			<bitenum id="DISABLE" value="0" token="DISABLE" description="Break condition is disabled"/>
			<bitenum id="ENABLE" value="1" token="ENABLE" description="Break condition is transmitted to the receiving UART. A break condition is a condition where the UART_TX signal is forced to the spacing (cleared) state."/>
		</bitfield>
		<bitfield id="SP" width="1" begin="5" end="5" resetval="0" description="Stick parity. The SP bit works in conjunction with the EPS and PEN bits.   " range="" rwaccess="RW">
			<bitenum id="DISABLE" value="0" token="DISABLE" description="Stick parity is disabled"/>
			<bitenum id="ENABLE" value="1" token="ENABLE" description="Stick parity is enabled. When odd parity is selected (EPS = 0), the PARITY bit is transmitted and checked as set. When even parity is selected (EPS = 1), the PARITY bit is transmitted and checked as cleared."/>
		</bitfield>
		<bitfield id="EPS" width="1" begin="4" end="4" resetval="0" description="Even parity select. Selects the parity when parity is enabled (PEN = 1). The EPS bit works in conjunction with the SP and PEN bits.  " range="" rwaccess="RW">
			<bitenum id="ODD" value="0" token="ODD" description=" Odd parity is selected (an odd number of logic 1s is transmitted or checked in the data and PARITY bits)."/>
			<bitenum id="EVEN" value="1" token="EVEN" description="Even parity is selected (an even number of logic 1s is transmitted or checked in the data and PARITY bits)."/>
		</bitfield>
		<bitfield id="PEN" width="1" begin="3" end="3" resetval="0" description="Parity Enable .The PEN bit works in conjunction with the SP and EPS bits. " range="" rwaccess="RW">
			<bitenum id="DISABLE" value="0" token="DISABLE" description="no parity bit is transmitted or checked"/>
			<bitenum id="ENABLE" value="1" token="ENABLE" description="A parity bit is generated in transmitted data and is checked in received data between the last data word bit and the first stop bit "/>
		</bitfield>
		<bitfield id="STB" width="1" begin="2" end="2" resetval="0" description="Number of Stop Bits Generated This bit specifies either one, one and a half, or two stop bits in each transmitted character. This bit is combined with the word length bits (LCR[1] and LCR[0]) determine the number of stop bits. The receiver clocks only the first stop bit regardless of the number of stop bits selected --------------------------------------------------------------------------------------------  Bit 2     Word Length                Number of Stop Bits Generated --------------------------------------------------------------------------------------------  0         Any word length                          1  1          5 bits                                        1.5  1          6 bits                                        2  1          7 bits                                        2  1          8 bits                                        2" range="" rwaccess="RW">
			<bitenum id="1BIT" value="0" token="1BIT" description=""/>
			<bitenum id="WLS" value="1" token="WLS" description=""/>
		</bitfield>
		<bitfield id="WLS" width="2" begin="1" end="0" resetval="0" description="Word length select. Number of bits in each transmitted or received serial character. When STB = 1, the WLS bit determines the number of STOP bits. " range="" rwaccess="RW">
			<bitenum id="5BITS" value="11" token="5BITS" description="5 bits"/>
			<bitenum id="6BITS" value="27" token="6BITS" description="6 bits"/>
			<bitenum id="7BITS" value="267" token="7BITS" description="7 bits"/>
			<bitenum id="8BITS" value="283" token="8BITS" description="8 bits"/>
		</bitfield>
	</register>
	<register id="MCR" acronym="MCR" offset="0x0010" width="32" description="The modem control register provides the ability to enable/disable the autoflow functions, and enable/disable the loopback function for diagnostic purposes.">
		<bitfield id="Reserved" width="26" begin="31" end="6" resetval="0" description="Reserved" range="" rwaccess="N"/>
		<bitfield id="AFE" width="1" begin="5" end="5" resetval="0" description="Autoflow control enable.  Autoflow control allows the RTS and CTS signals to provide handshaking between UARTs during data transfer. When AFE = 1, the RTS bit determines the autoflow control enabled.  ---------------------------------------------------------------------- Bit 5   Bit 1     Autoflow Control Configuration ----------------------------------------------------------------------  1        1           Auto-rts and auto-cts enabled  1        0           Auto-cts only enabled  0        X           Auto-rts and auto-cts disabled" range="" rwaccess="RW">
			<bitenum id="DISABLE" value="0" token="DISABLE" description="Autoflow control is disabled"/>
			<bitenum id="ENABLE" value="1" token="ENABLE" description="Autoflow control is enabled"/>
		</bitfield>
		<bitfield id="LOOP" width="1" begin="4" end="4" resetval="0" description="Loop back mode enable. LOOP is used for the diagnostic testing using the loop back feature. " range="" rwaccess="RW">
			<bitenum id="DISABLE" value="0" token="DISABLE" description="Disable loop back mode"/>
			<bitenum id="ENABLE" value="1" token="ENABLE" description="Loop back mode is enabled. When LOOP is set, the following occur: The UART_TX signal is set high. The UART_RX pin is disconnected. The output of the transmitter shift register (TSR) is lopped back in to the receiver shift register (RSR) input."/>
		</bitfield>
		<bitfield id="OUT2" width="1" begin="3" end="3" resetval="0" description="" range="" rwaccess="R ">
			<bitenum id="DISABLE" value="0" token="DISABLE" description=""/>
			<bitenum id="ENABLE" value="1" token="ENABLE" description=""/>
		</bitfield>
		<bitfield id="OUT1" width="1" begin="2" end="2" resetval="0" description="" range="" rwaccess="R ">
			<bitenum id="DISABLE" value="0" token="DISABLE" description=""/>
			<bitenum id="ENABLE" value="1" token="ENABLE" description=""/>
		</bitfield>
		<bitfield id="RTS" width="1" begin="1" end="1" resetval="0" description="RTS control. When AFE = 1, the RTS bit determines the autoflow control enabled. Note that all UARTs do not support this feature, see the device-specific data manual for supported features. If this feature is not available, this bit is reserved and should be cleared to 0. 0 RTS is disabled, CTS is only enabled. 1 RTS and CTS are enabled." range="" rwaccess="RW">
			<bitenum id="HIGH" value="0" token="HIGH" description="The associated output is forced high"/>
			<bitenum id="DISABLE" value="0" token="DISABLE" description="Auto-rts is disabled"/>
			<bitenum id="ENABLE" value="1" token="ENABLE" description="Auto-rts is enabled"/>
			<bitenum id="LOW" value="1" token="LOW" description="The associated output is forced low "/>
		</bitfield>
		<bitfield id="DTR" width="1" begin="0" end="0" resetval="0" description="" range="" rwaccess="RW">
			<bitenum id="DISABLE" value="0" token="DISABLE" description=""/>
			<bitenum id="ENABLE" value="1" token="ENABLE" description=""/>
		</bitfield>
	</register>
	<register id="LSR" acronym="LSR" offset="0x0014" width="32" description="LSR provides information to the CPU concerning the status of data transfers. LSR is intended for read operations only; do not write to this register. Bits 1 through 4 record the error conditions that produce a receiver line status interrupt.">
		<bitfield id="Reserved" width="24" begin="31" end="8" resetval="0" description="Reserved" range="" rwaccess="N"/>
		<bitfield id="RXFIFOE" width="1" begin="7" end="7" resetval="0" description="Receiver FIFO error. " range="" rwaccess="R">
			<bitenum id="NOERROR" value="0" token="NOERROR" description="In non-FIFO mode:    There has been no error, or RXFIFOE was cleared because the CPU read the erroneous character from the receiver buffer register (RBR). In FIFO mode:   There has been no error, or RXFIFOE was cleared because the CPU read the erroneous character from the receiver FIFO and there are no more errors in the receiver FIFO."/>
			<bitenum id="ERROR" value="1" token="ERROR" description="In non-FIFO mode:    There is a parity error, framing error, or break indicator in the receiver buffer register (RBR).                                     In FIFO mode:   At least one parity error, framing error, or break indicator in the receiver FIFO."/>
		</bitfield>
		<bitfield id="TEMT" width="1" begin="6" end="6" resetval="1" description="Transmitter empty (TEMT) indicator. " range="" rwaccess="R">
			<bitenum id="FULL" value="0" token="FULL" description=" In non-FIFO mode:   Either the transmitter holding register (THR) or the transmitter shift register (TSR) contains a data character.        In FIFO mode: Either the transmitter FIFO or the transmitter shift register (TSR) contains a data character."/>
			<bitenum id="EMPTY" value="1" token="EMPTY" description=" In non-FIFO mode:   Both the transmitter holding register (THR) and the transmitter shift register (TSR) are empty.                                  In FIFO mode: Both the transmitter FIFO and the transmitter shift register (TSR) are empty."/>
		</bitfield>
		<bitfield id="THRE" width="1" begin="5" end="5" resetval="1" description="Transmitter holding register empty (THRE) indicator.  If the THRE bit is set and the corresponding interrupt enable bit is set (ETBEI = 1 in IER), an interrupt request is generated. " range="" rwaccess="R">
			<bitenum id="FULL" value="0" token="FULL" description="In non-FIFO mode:   Transmitter holding register (THR) is not empty. THR has been loaded by the CPU.                                             In FIFO mode: Transmitter FIFO is not empty. At least one character has been written to the transmitter FIFO. You can write to the transmitter FIFO if it is not full.                                          "/>
			<bitenum id="EMPTY" value="1" token="EMPTY" description=" In non-FIFO mode:  Transmitter holding register (THR) is empty (ready to accept a new character). The content of THR has been transferred to the transmitter shift register (TSR).                                      In FIFO mode:Transmitter FIFO is empty. The last character in the FIFO has been transferred to the transmitter shift register (TSR)."/>
		</bitfield>
		<bitfield id="BI" width="1" begin="4" end="4" resetval="0" description="Break indicator.  The BI bit is set whenever the receive data input (RX) was held low for longer than a full-word transmission time. A full-word transmission time is defined as the total time to transmit the START, data, PARITY, and STOP bits. If the BI bit is set and the corresponding interrupt enable bit is set (ELSI = 1 in IER), an interrupt request is generated. " range="" rwaccess="R">
			<bitenum id="NOBREAK" value="0" token="NOBREAK" description="In non-FIFO mode:   No break has been detected, or the BI bit was cleared because the CPU read the erroneous character from the receiver buffer register (RBR).              In FIFO mode:   No break has been detected, or the BI bit was cleared because the CPU read the erroneous character from the receiver FIFO and the next character to be read from the FIFO has no break indicator."/>
			<bitenum id="BREAK" value="1" token="BREAK" description="In non-FIFO mode:  A break has been detected with the character in the receiver buffer register (RBR).                                              In FIFO mode:  A break has been detected with the character at the top of the receiver FIFO.                                           "/>
		</bitfield>
		<bitfield id="FE" width="1" begin="3" end="3" resetval="0" description="Framing error (FE) indicator.  A framing error occurs when the received character does not have a valid STOP bit. In response to a framing error, the UART sets the FE bit and waits until the signal on the RX pin goes high. Once the RX signal goes high, the receiver is ready to detect a new START bit and receive new data. If the FE bit is set and the corresponding interrupt enable bit is set (ELSI = 1 in IER), an interrupt request is generated. " range="" rwaccess="R">
			<bitenum id="NOERROR" value="0" token="NOERROR" description="In non-FIFO mode:  No framing error has been detected, or the FE bit was cleared because the CPU read the erroneous data from the receiver buffer register (RBR).               In FIFO mode:   No framing error has been detected, or the FE bit was cleared because the CPU read the erroneous data from the receiver FIFO and the next character to be read from the FIFO has no framing error.           "/>
			<bitenum id="ERROR" value="1" token="ERROR" description="In non-FIFO mode: A framing error has been detected with the character in the receiver buffer register (RBR).                                     In FIFO mode:A framing error has been detected with the character at the top of the receiver FIFO."/>
		</bitfield>
		<bitfield id="PE" width="1" begin="2" end="2" resetval="0" description="Parity error (PE) indicator. A parity error occurs when the parity of the received character does not match the parity selected with the EPS bit in the line control register (LCR). If the PE bit is set and the corresponding interrupt enable bit is set (ELSI = 1 in IER), an interrupt request is generated. " range="" rwaccess="R">
			<bitenum id="NOERROR" value="0" token="NOERROR" description="In non-FIFO mode: No parity error has been detected, or the PE bit was cleared because the CPU read the erroneous data from the receiver buffer register (RBR).             In FIFO mode:     No parity error has been detected, or the PE bit was cleared because the CPU read the erroneous data from the receiver FIFO and the next character to be read from the FIFO has no parity error.      "/>
			<bitenum id="ERROR" value="1" token="ERROR" description="In non-FIFO mode:A parity error has been detected with the character in the receiver buffer register (RBR).                                    In FIFO mode:  A parity error has been detected with the character at the top of the receiver FIFO."/>
		</bitfield>
		<bitfield id="OE" width="1" begin="1" end="1" resetval="0" description="Overrun error (OE) indicator An overrun error in the non-FIFO mode is different from an overrun error in the FIFO mode. If the OE bit is set and the corresponding interrupt enable bit is set (ELSI = 1 in IER), an interrupt request is generated. " range="" rwaccess="R">
			<bitenum id="NOERROR" value="0" token="NOERROR" description="In non-FIFO mode:No overrun error has been detected, or the OE bit was cleared because the CPU read the content of the line status register (LSR).                                        In FIFO mode:No overrun error has been detected, or the OE bit was cleared because the CPU read the content of the line status register (LSR)."/>
			<bitenum id="ERROR" value="1" token="ERROR" description="In non-FIFO mode:Overrun error has been detected. Before the character in the receiver buffer register (RBR) could be read, it was overwritten by the next character arriving in RBR.                      In FIFO mode: Overrun error has been detected. If data continues to fill the FIFO beyond the trigger level, an overrun error occurs only after the FIFO is full and the next character has been completely received in the shift register. An overrun error is indicated to the CPU as soon as it happens. The new character overwrites the character in the shift register, but it is not transferred to the FIFO."/>
		</bitfield>
		<bitfield id="DR" width="1" begin="0" end="0" resetval="0" description="Data-ready (DR) indicator for the receiver. If the DR bit is set and the corresponding interrupt enable bit is set (ERBI = 1 in IER), an interrupt request is generated. " range="" rwaccess="R">
			<bitenum id="NOTREADY" value="0" token="NOTREADY" description="In non-FIFO mode:Data is not ready, or the DR bit was cleared because the character was read from the receiver buffer register (RBR).                                              In FIFO mode: Data is not ready, or the DR bit was cleared because all of the characters in the receiver FIFO have been read."/>
			<bitenum id="READY" value="1" token="READY" description="In non-FIFO mode: Data is ready. A complete incoming character has been received and transferred into the receiver buffer register (RBR).                                                In FIFO mode:Data is ready. There is at least one unread character in the receiver FIFO. If the FIFO is empty, the DR bit is set as soon as a complete incoming character has been received and transferred into the FIFO. The DR bit remains set until the FIFO is empty again."/>
		</bitfield>
	</register>
	<register id="MSR" acronym="MSR" offset="0x0018" width="32" description="Modem Status Register">
		<bitfield id="Reserved" width="24" begin="31" end="8" resetval="0" description="Reserved" range="" rwaccess="N"/>
		<bitfield id="CD" width="1" begin="7" end="7" resetval="0" description="Complement of the Carrier Detect input When the UART is in the diagnostic test mode (loopback mode MCR[4] = 1), this bit is equal to the MCR bit 3 (OUT2)" range="" rwaccess="R">
			<bitenum id="NOCD" value="0" token="NOCD" description=""/>
			<bitenum id="CD" value="1" token="CD" description=""/>
		</bitfield>
		<bitfield id="RI" width="1" begin="6" end="6" resetval="0" description="Complement of the Ring Indicator input When the UART is in the diagnostic test mode (loopback mode MCR[4] = 1), this bit is equal to the MCR bit 2 (OUT1)" range="" rwaccess="R">
			<bitenum id="NORI" value="0" token="NORI" description=""/>
			<bitenum id="RI" value="1" token="RI" description=""/>
		</bitfield>
		<bitfield id="DSR" width="1" begin="5" end="5" resetval="0" description="Complement of the Data Set Ready input When the UART is in the diagnostic test mode (loopback mode MCR[4] = 1), this bit is equal to the MCR bit 0 (DTR)" range="" rwaccess="R">
			<bitenum id="NODSR" value="0" token="NODSR" description=""/>
			<bitenum id="DSR" value="1" token="DSR" description=""/>
		</bitfield>
		<bitfield id="CTS" width="1" begin="4" end="4" resetval="0" description="Complement of the Clear To Send input When the UART is in the diagnostic test mode (loopback mode MCR[4] = 1), this bit is equal to the MCR bit 1 (RTS)" range="" rwaccess="R">
			<bitenum id="NOCTS" value="0" token="NOCTS" description=""/>
			<bitenum id="CTS" value="1" token="CTS" description=""/>
		</bitfield>
		<bitfield id="DCD" width="1" begin="3" end="3" resetval="0" description="Change in DCD indicator bit DCD indicates that the DCD input has changed state since the last time it was read by the CPU. When DCD is set and the modem status interrupt is enabled, a modem status interrupt is generated" range="" rwaccess="R">
			<bitenum id="NODCD" value="0" token="NODCD" description=""/>
			<bitenum id="DCD" value="1" token="DCD" description=""/>
		</bitfield>
		<bitfield id="TERI" width="1" begin="2" end="2" resetval="0" description="Trailing edge of RI (TERI) indicator bit TERI indicates that the RI input has changed from a low to a high. When TERI is set and the modem status interrupt is enabled, a modem status interrupt is generated" range="" rwaccess="R">
			<bitenum id="NOTERI" value="0" token="NOTERI" description=""/>
			<bitenum id="TERI" value="1" token="TERI" description=""/>
		</bitfield>
		<bitfield id="DDSR" width="1" begin="1" end="1" resetval="0" description="Change in DSR indicator bit DDSR indicates that the DSR input has changed state since the last time it was read by the CPU. When DDSR is set and the modem status interrupt is enabled, a modem status interrupt is generated" range="" rwaccess="R">
			<bitenum id="NODDSR" value="0" token="NODDSR" description=""/>
			<bitenum id="DDSR" value="1" token="DDSR" description=""/>
		</bitfield>
		<bitfield id="DCTS" width="1" begin="0" end="0" resetval="0" description="Change in CTS indicator bit DCTS indicates that the CTS input has changed state since the last time it was read by the CPU. When DCTS is set (autoflow control is not enabled and the modem status interrupt is enabled), a modem status interrupt is generated. When autoflow control is enabled, no interrupt is generated" range="" rwaccess="R">
			<bitenum id="NODCTS" value="0" token="NODCTS" description=""/>
			<bitenum id="DCTS" value="1" token="DCTS" description=""/>
		</bitfield>
	</register>
	<register id="SCR" acronym="SCR" offset="0x001C" width="32" description="Scratch Pad Register">
		<bitfield id="Reserved" width="24" begin="31" end="8" resetval="0" description="Reserved" range="" rwaccess="N"/>
		<bitfield id="SCR" width="8" begin="7" end="0" resetval="0" description="These bits are intended for the programmer's use as a scratch pad in the sense that it temporarily holds the programmer's data without affecting any other UART operation." range="" rwaccess="RW"/>
	</register>
	<register id="DLL" acronym="DLL" offset="0x0020" width="32" description="DLL holds the least-significant bits of the divisor.This divisor latch must be loaded during initialization of the UART in order to ensure desired operation of the baud generator.">
		<bitfield id="Reserved" width="24" begin="31" end="8" resetval="0" description="Reserved" range="" rwaccess="N"/>
		<bitfield id="DLL" width="8" begin="7" end="0" resetval="0" description="The 8 least-significant bits (LSBs) of the 16-bit divisor for generation of the baud clock in the baud rate generator" range="" rwaccess="RW"/>
	</register>
	<register id="DLH" acronym="DLH" offset="0x0024" width="32" description="DLH holds the most-significant bits of the divisor.This divisor latch must be loaded during initialization of the UART in order to ensure desired operation of the baud generator.">
		<bitfield id="Reserved" width="24" begin="31" end="8" resetval="0" description="Reserved" range="" rwaccess="N"/>
		<bitfield id="DLH" width="8" begin="7" end="0" resetval="0" description="The 8 most-significant bits (MSBs) of the 16-bit divisor for generation of the baud clock in the baud rate generator" range="" rwaccess="RW"/>
	</register>
	<register id="REVID1" acronym="REVID1" offset="0x0028" width="32" description="The  revision identification registers (REVD1) contain identification data  for the peripheral.">
		<bitfield id="REV" width="32" begin="31" end="0" resetval="285343746" description="Peripheral Identification Number" range="" rwaccess="R"/>
	</register>
	<register id="REVID2" acronym="REVID2" offset="0x002C" width="32" description="Revision ID Register 2">
		<bitfield id="REV" width="32" begin="31" end="0" resetval="0" description="Peripheral Identification Number" range="" rwaccess="R"/>
	</register>
	<register id="PWREMU_MGMT" acronym="PWREMU_MGMT" offset="0x0030" width="32" description="Power Management and Emulation Register">
		<bitfield id="Reserved" width="16" begin="31" end="16" resetval="0" description="Reserved" range="" rwaccess="N"/>
		<bitfield id="Reserved" width="1" begin="15" end="15" resetval="0" description="Reserved. This bit must always be written with a 0." range="" rwaccess="N"/>
		<bitfield id="UTRST" width="1" begin="14" end="14" resetval="0" description="UART transmitter reset.  Resets and enables the transmitter" range="" rwaccess="RW">
			<bitenum id="RESET" value="0" token="RESET" description="Transmitter is disabled and in reset state"/>
			<bitenum id="ENABLE" value="1" token="ENABLE" description="Transmitter is enabled"/>
		</bitfield>
		<bitfield id="URRST" width="1" begin="13" end="13" resetval="0" description="UART receiver reset.  Resets and enables the receiver" range="" rwaccess="RW">
			<bitenum id="RESET" value="0" token="RESET" description="Receiver is disabled and in reset state"/>
			<bitenum id="ENABLE" value="1" token="ENABLE" description="Receiver is enabled"/>
		</bitfield>
		<bitfield id="Reserved" width="11" begin="12" end="2" resetval="0" description="Reserved" range="" rwaccess="N"/>
		<bitfield id="Reserved" width="1" begin="1" end="1" resetval="1" description="This bit is always 1 . Writing this bit does not affect value" range="" rwaccess="N"/>
		<bitfield id="FREE" width="1" begin="0" end="0" resetval="0" description="Free-running enable mode bit. This bit determines the emulation mode functionality of the UART. In suspended mode, the UART can handle register read/write requests, but does not generate any transmission/reception, interrupts or events.                                 " range="" rwaccess="RW">
			<bitenum id="STOP" value="0" token="STOP" description="If a transmission is not in progress, the UART stops immediately. If a transmission is in progress, the UART stops after completion of the one word transmission"/>
			<bitenum id="RUN" value="1" token="RUN" description="Free-running mode is enabled; UART continues to run normally"/>
		</bitfield>
	</register>
	<register id="MDR" acronym="MDR" offset="0x0034" width="32" description="Mode Definition Register">
		<bitfield id="Reserved" width="31" begin="31" end="1" resetval="0" description="Reserved" range="" rwaccess="N"/>
		<bitfield id="OSM_SEL" width="1" begin="0" end="0" resetval="0" description="Over-Sampling Select" range="" rwaccess="RW">
			<bitenum id="16xOVERSAMPLING" value="0" token="16xOVERSAMPLING" description="16x over-sampling "/>
			<bitenum id="13xOVERSAMPLING" value="1" token="13xOVERSAMPLING" description="13x over-sampling "/>
		</bitfield>
	</register>
</module>
