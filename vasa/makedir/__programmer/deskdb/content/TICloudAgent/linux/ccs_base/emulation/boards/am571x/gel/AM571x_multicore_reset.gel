/*******************************************************************/
/* This GEL file is loaded on the command line of Code Composer    */
/* The StartUp() function is called every time you start           */
/* Code Composer.  You can customize this function to              */
/* initialize wait states or to perform other initialization.      */
/*                                                                 */
/* AM571x multicore reset config                                   */
/*                                                                 */
/*                                                                 */
/*******************************************************************/

#define WR_MEM_32(addr, data)   *(unsigned int*)(addr) =(unsigned int)(data)
#define RD_MEM_32(addr)         *(unsigned int*)(addr)
#define uint32_t                unsigned int

#define DEBUG_PRINT            1

/*******************************************************************************
        AM571x Registers Map Defines: CortexA15_CPU1 view
*******************************************************************************/
#define GPMC_TARG                    0x00000000
#define MPU_RAM                      0x402F0000
#define OCMC_RAM1_TARG               0x40300000
#define DSP1_L2_SRAM_TARG            0x40800000
#define DSP1_SYSTEM_TARG             0x40D00000
#define DSP1_MMU0CFG_TARG            0x40D01000
#define DSP1_MMU1CFG_TARG            0x40D02000
#define DSP1_FW0CFG_TARG             0x40D03000
#define DSP1_FW1CFG_TARG             0x40D04000
#define DSP1_EDMA_TC0_TARG           0x40D05000
#define DSP1_EDMA_TC1_TARG           0x40D06000
#define DSP1_NoC_TARG                0x40D07000
#define DSP1_EDMA_CC_TARG            0x40D10000
#define DSP1_L1P_SRAM_TARG           0x40E00000
#define DSP1_L1D_SRAM_TARG           0x40F00000
#define OCMC_RAM1_CBUF_TARG          0x41800000
#define EDMA_TPCC_TARG               0x43300000
#define EDMA_TC0_TARG                0x43400000
#define EDMA_TC1_TARG                0x43500000
#define OCMC_ROM_TARG                0x43A00000
#define SN_L3_MAIN_TARG              0x44000000
#define McASP1_TARG                  0x45800000
#define McASP2_TARG                  0x45C00000
#define McASP3_TARG                  0x46000000
#define L4_PER1_TARG                 0x48000000
#define MPU_MA                       0x482AF000
#define L4_PER2_TARG                 0x48400000
#define L4_PER3_TARG                 0x48800000
#define OCMC_RAM2_CBUF_TARG          0x49000000
#define OCMC_RAM3_CBUF_TARG          0x49800000
#define L4_CFG_TARG                  0x4A000000
#define L4_WKUP_TARG                 0x4AE00000
#define QSPI_ADDRSP0_TARG            0x4B300000
#define EMIF1_CONF_REGS              0x4C000000
#define EMIF2_CONF_REGS              0x4D000000
#define DMM_CONF_REGS_TARG           0x4E000000
#define GPMC_CONF_REGS_TARG          0x50000000
#define IPU2_TARGET_TARG             0x55000000
#define GPU_TARG                     0x56000000
#define DSS_TARG                     0x58000000
#define IPU1_TARGET_TARG             0x58800000
#define BB2D_TARG                    0x59000000
#define IVA_CONFIG_TARG              0x5A000000
#define IVA_SL2IF_TARG               0x5B000000
#define QSPI_ADDRSP1_TARG            0x5C000000
#define TILER                        0x60000000
#define EMIF1_SDRAM_CS0              0x80000000

/*******************************************************************************
        L4_CFG Registers Map Defines: CortexA15_CPU1 view
*******************************************************************************/
#define CTRL_MODULE_CORE             (L4_CFG_TARG + 0x2000)
#define CM_CORE_AON                  (L4_CFG_TARG + 0x5000)
#define CM_CORE                      (L4_CFG_TARG + 0x8000)

/*******************************************************************************
        L4_WKUP Registers Map Defines: CortexA15_CPU1 view
*******************************************************************************/
#define PRM                          (L4_WKUP_TARG + 0x6000)

/*******************************************************************************
        PRCM Registers Map Defines: CortexA15_CPU1 view
*******************************************************************************/
#define IPU_CM_CORE_AON              (CM_CORE_AON + 0x500)
#define DSP1_CM_CORE_AON             (CM_CORE_AON + 0x400)
#define CORE_CM_CORE                 (CM_CORE + 0x700)
#define IVA_CM_CORE                  (CM_CORE + 0xF00)
#define DSP1_PRM                     (PRM + 0x400)
#define IPU_PRM                      (PRM + 0x500)
#define CORE_PRM                     (PRM + 0x700)
#define IVA_PRM                      (PRM + 0xF00)

/*******************************************************************************
        IPU1 Address Map defines: CortexA15_CPU1 view
*******************************************************************************/
#define RM_IPU1_RSTCTRL              (IPU_PRM + 0x10)
#define RM_IPU1_RSTST                (IPU_PRM + 0x14)
#define CM_IPU1_CLKSTCTRL            (IPU_CM_CORE_AON + 0x0)
#define CM_IPU1_IPU1_CLKCTRL         (IPU_CM_CORE_AON + 0x20)

#define IPU1_BASE_ADDR               (IPU1_TARGET_TARG + 0x20000)
#define IPU1_MMU_CFG                 (IPU1_TARGET_TARG + 0x80000)

/*******************************************************************************
        IPU2 Address Map defines: CortexA15_CPU1 view
*******************************************************************************/
#define RM_IPU2_RSTCTRL              (CORE_PRM + 0x210)
#define RM_IPU2_RSTST                (CORE_PRM + 0x214)
#define CM_IPU2_CLKSTCTRL            (CORE_CM_CORE + 0x200)
#define CM_IPU2_IPU2_CLKCTRL         (CORE_CM_CORE + 0x220)

#define IPU2_BASE_ADDR               (IPU2_TARGET_TARG + 0x20000)
#define IPU2_MMU_CFG                 (IPU2_TARGET_TARG + 0x80000)

/*******************************************************************************
            IPU CPU Independent defines
*******************************************************************************/
#define RM_IPU_RSTCTRL               ((cpu_num == 1) ? (RM_IPU1_RSTCTRL) : (RM_IPU2_RSTCTRL))
#define RM_IPU_RSTST                 ((cpu_num == 1) ? (RM_IPU1_RSTST) : (RM_IPU2_RSTST))

#define IPU_BASE_ADDR                ((cpu_num == 1) ? (IPU1_BASE_ADDR) : (IPU2_BASE_ADDR))
#define IPU_MMU_CFG                  ((cpu_num == 1) ? (IPU1_MMU_CFG) : (IPU2_MMU_CFG))

/*******************************************************************************
        DSPSS1 Address Map defines: CortexA15_CPU1 view
*******************************************************************************/
#define CM_DSP1_CLKSTCTRL            (DSP1_CM_CORE_AON + 0x0)
#define CM_DSP1_DSP1_CLKCTRL         (DSP1_CM_CORE_AON + 0x20)
#define RM_DSP1_RSTCTRL              (DSP1_PRM + 0x10)
#define RM_DSP1_RSTST                (DSP1_PRM + 0x14)

#define DSPSS1BOOTADDR               (CTRL_MODULE_CORE + 0x55C)
#define DSPSS1BOOTADDRVALUE          (DSP1_L2_SRAM_TARG - 0x40000000)

/*******************************************************************************
            DSPSS CPU Independent defines
*******************************************************************************/
#define CM_DSP_CLKSTCTRL             (CM_DSP1_CLKSTCTRL)
#define CM_DSP_DSP_CLKCTRL           (CM_DSP1_DSP1_CLKCTRL)
#define RM_DSP_RSTCTRL               (RM_DSP1_RSTCTRL)
#define RM_DSP_RSTST                 (RM_DSP1_RSTST)

#define DSPSSBOOTADDR                (DSPSS1BOOTADDR)
#define DSPSSBOOTADDRVALUE           (DSPSS1BOOTADDRVALUE)

#define DSP_L2_SRAM_TARG             (DSP1_L2_SRAM_TARG)


/*******************************************************************************
        IVASS Address Map defines: CortexA15_CPU1 view
*******************************************************************************/
#define CM_IVA_CLKSTCTRL             (IVA_CM_CORE + 0x0)
#define CM_IVA_IVA_CLKCTRL           (IVA_CM_CORE + 0x20)
#define CM_IVA_SL2_CLKCTRL           (IVA_CM_CORE + 0x28)
#define RM_IVA_RSTCTRL               (IVA_PRM + 0x10)
#define RM_IVA_RSTST                 (IVA_PRM + 0x14)

#define ICONT1_ITCM                  (IVA_CONFIG_TARG + 0x08000)
#define ICONT2_ITCM                  (IVA_CONFIG_TARG + 0x18000)

#define L3_CLK_EN 					(0x4A008E28)

#define DRM_SUSPEND_CTRL             0x54160200
#define DRM_SUSPEND_CTRL_TIMER1     (DRM_SUSPEND_CTRL + 0x00000040)
#define DRM_SUSPEND_CTRL_TIMER2     (DRM_SUSPEND_CTRL + 0x00000044)
#define DRM_SUSPEND_CTRL_TIMER3     (DRM_SUSPEND_CTRL + 0x00000048)
#define DRM_SUSPEND_CTRL_TIMER4     (DRM_SUSPEND_CTRL + 0x0000004C)
#define DRM_SUSPEND_CTRL_TIMER5     (DRM_SUSPEND_CTRL + 0x00000014)
#define DRM_SUSPEND_CTRL_TIMER6     (DRM_SUSPEND_CTRL + 0x00000018)
#define DRM_SUSPEND_CTRL_TIMER7     (DRM_SUSPEND_CTRL + 0x0000001C)
#define DRM_SUSPEND_CTRL_TIMER8     (DRM_SUSPEND_CTRL + 0x00000020)
#define DRM_SUSPEND_CTRL_TIMER9     (DRM_SUSPEND_CTRL + 0x00000050)
#define DRM_SUSPEND_CTRL_TIMER10    (DRM_SUSPEND_CTRL + 0x00000054)
#define DRM_SUSPEND_CTRL_TIMER11    (DRM_SUSPEND_CTRL + 0x00000058)
#define DRM_SUSPEND_CTRL_TIMER12    (DRM_SUSPEND_CTRL + 0x0000005C)
#define DRM_SUSPEND_CTRL_TIMER13    (DRM_SUSPEND_CTRL + 0x00000028)
#define DRM_SUSPEND_CTRL_TIMER14    (DRM_SUSPEND_CTRL + 0x00000030)
#define DRM_SUSPEND_CTRL_TIMER15    (DRM_SUSPEND_CTRL + 0x00000060)
#define DRM_SUSPEND_CTRL_TIMER16    (DRM_SUSPEND_CTRL + 0x00000074)

#define DRM_SUSPEND_SRC_DSP1    (0x0)
#define DRM_SUSPEND_SRC_IVA1    (0x1)
#define DRM_SUSPEND_SRC_IVA2    (0x2)
#define DRM_SUSPEND_SRC_IPU1_C0 (0x3)
#define DRM_SUSPEND_SRC_IPU1_C1 (0x4)
#define DRM_SUSPEND_SRC_MPU_C0  (0x5)
#define DRM_SUSPEND_SRC_MPU_C1  (0x6)
#define DRM_SUSPEND_SRC_DSP2    (0x7)

menuitem "AM571x MULTICORE Initialization"

/************ Enable all slave cores ***************/
hotmenu AM571x_MULTICORE_EnableAllCores()
{
    GEL_TextOut("--->>> Mapping TIMER supsend sources to default cores <<<<<<----\n");
    
    /*   --------------------------------------------
     *  | Target       | Default availMask           |
     *   --------------------------------------------
     *  | A15          | 0x0202 (GPTimer 2 & 10)     |
     *  | DSP          | 0x0030 (GPTimer 5 & 6)      |
     *  | IPU(Dual-M4) | 0x050C (GPTimer 3,4,9 & 11) |
     *   --------------------------------------------
     */
    WR_MEM_32(DRM_SUSPEND_CTRL_TIMER2,  (DRM_SUSPEND_SRC_MPU_C0 << 4)  | 0x1);
    WR_MEM_32(DRM_SUSPEND_CTRL_TIMER5,  (DRM_SUSPEND_SRC_DSP1 << 4)    | 0x1);
    WR_MEM_32(DRM_SUSPEND_CTRL_TIMER3,  (DRM_SUSPEND_SRC_IPU1_C0 << 4) | 0x1);
    WR_MEM_32(DRM_SUSPEND_CTRL_TIMER4,  (DRM_SUSPEND_SRC_IPU1_C1 << 4) | 0x1);

    IPU1SSClkEnable_API();
    IPU2SSClkEnable_API();	//IPU2 subsystem is dedicated to IVA support and is not available for other processing      

    DSP1SSClkEnable_API();

    IVAHDSSClkEnable_API();

    PRUSS_1_2_ClkEnable();
}

/************ Enable the PRUSS Clocks **************/
hotmenu PRUSS_1_2_ClkEnable()
{
    GEL_TextOut("--->>> PRUSS 1 and 2 Initialization is in progress ... <<<---\n");
    WR_MEM_32(0x4a009718, 0x0); //PRUSS_1_CLKCTRL
    WR_MEM_32(0x4a009720, 0x0); //PRUSS_2_CLKCTRL

    WR_MEM_32(0x4a009718, 0x2); //PRUSS_1_CLKCTRL
    WR_MEM_32(0x4a009720, 0x2); //PRUSS_2_CLKCTRL
    while ((RD_MEM_32(0x4a0098FC) & 0x100) != 0x100); //L4PER2 - ICSS_CLKACTIVITY
    GEL_TextOut("--->>> PRUSS 1 and 2 Initialization is in complete ... <<<---\n");
}

/************ Enable the IPU1 Clocks ***************/
hotmenu IPU1SSClkEnable_API()
{
    IPUSSClkEnable(1);
}

/************ Enable the IPU2 Clocks ***************/
hotmenu IPU2SSClkEnable_API()
{
    IPUSSClkEnable(2);
}
/* END REMOVE FOR ADAS */

/************ Enable the DSP1 Clocks ***************/
hotmenu DSP1SSClkEnable_API()
{
    DSPSSClkEnable(1);
}

/************ Enable the IVA Clocks ***************/
hotmenu IVAHDSSClkEnable_API()
{
    IVAHDSSClkEnable();
}

IPUSSClkEnable(uint32_t cpu_num)
{
    uint32_t regVal, regAddr;

    GEL_TextOut("--->>> IPU%dSS Initialization is in progress ... <<<---\n",,,,, cpu_num);
    /* Reset asserted for IPU CPU0, CPU1, Unicache and MMU */
    WR_MEM_32(RM_IPU_RSTCTRL, 0x7);

    /* Reset deassertion for IPU Unicache/MMU */
    WR_MEM_32(RM_IPU_RSTST, 0x7);
    WR_MEM_32(RM_IPU_RSTCTRL, 0x3);
    while ((RD_MEM_32(RM_IPU_RSTST) & 0x4) != 0x4);
   
	/*---------------- Setup the UNICACHE MMU -----------------*/
	/*Large Page Translations */
	/* Logical Address */
	regAddr = IPU_MMU_CFG;
	regAddr += 0x800;
	WR_MEM_32(regAddr,         0x40000000); regAddr += 0x4;
	WR_MEM_32(regAddr,         0x80000000); regAddr += 0x4;
	WR_MEM_32(regAddr,         0xA0000000); regAddr += 0x4;
	WR_MEM_32(regAddr,         0x60000000); regAddr += 0x4;

	/* Physical Address */
	regAddr = IPU_MMU_CFG;
	regAddr += 0x820;
	WR_MEM_32(regAddr,         0x40000000); regAddr += 0x4;
	WR_MEM_32(regAddr,         0x80000000); regAddr += 0x4;
	WR_MEM_32(regAddr,         0xA0000000); regAddr += 0x4;
	WR_MEM_32(regAddr,         0x40000000); regAddr += 0x4;

	/* Policy Register */
	regAddr = IPU_MMU_CFG;
	regAddr += 0x840;
	WR_MEM_32(regAddr,         0x00000007); regAddr += 0x4;
	WR_MEM_32(regAddr,         0x000B0007); regAddr += 0x4;
	WR_MEM_32(regAddr,         0x00020007); regAddr += 0x4;
	WR_MEM_32(regAddr,         0x00000007); regAddr += 0x4;

	/*Medium Page*/
	regAddr = IPU_MMU_CFG;
	regAddr += 0x860;
	WR_MEM_32(regAddr,         0x00300000); regAddr += 0x4;
	WR_MEM_32(regAddr,         0x00400000); regAddr += 0x4;

	regAddr = IPU_MMU_CFG;
	regAddr += 0x8A0;
	WR_MEM_32(regAddr,         0x40300000); regAddr += 0x4;
	WR_MEM_32(regAddr,         0x40400000); regAddr += 0x4;

	regAddr = IPU_MMU_CFG;
	regAddr += 0x8E0;
	WR_MEM_32(regAddr,         0x00000007); regAddr += 0x4;
	WR_MEM_32(regAddr,         0x00020007); regAddr += 0x4;

	/*Small Page*/
	regAddr = IPU_MMU_CFG;
	regAddr += 0x920;
	WR_MEM_32(regAddr,         0x00000000); regAddr += 0x4;
	WR_MEM_32(regAddr,         0x40000000); regAddr += 0x4;
	WR_MEM_32(regAddr,         0x00004000); regAddr += 0x4;
	WR_MEM_32(regAddr,         0x00008000); regAddr += 0x4;
	WR_MEM_32(regAddr,         0x20000000); regAddr += 0x4;

	regAddr = IPU_MMU_CFG;
	regAddr += 0x9A0;
	WR_MEM_32(regAddr,         0x55020000); regAddr += 0x4;
	WR_MEM_32(regAddr,         0x55080000); regAddr += 0x4;
	WR_MEM_32(regAddr,         0x55024000); regAddr += 0x4;
	WR_MEM_32(regAddr,         0x55028000); regAddr += 0x4;
	WR_MEM_32(regAddr,         0x55020000); regAddr += 0x4;

	regAddr = IPU_MMU_CFG;
	regAddr += 0xA20;
	WR_MEM_32(regAddr,         0x0001000B); regAddr += 0x4;
	WR_MEM_32(regAddr,         0x0000000B); regAddr += 0x4;
	WR_MEM_32(regAddr,         0x00010007); regAddr += 0x4;
	WR_MEM_32(regAddr,         0x00000007); regAddr += 0x4;
	WR_MEM_32(regAddr,         0x00000007); regAddr += 0x4;
    
    /*---------------- Write IPU IRAM Boot Image ---------------*/
    /* This puts the cores into dummy loops to prevent them from running bad code */
    WR_MEM_32(IPU_BASE_ADDR, 0x10000);
    WR_MEM_32(IPU_BASE_ADDR + 0x4, 0x9);
    WR_MEM_32(IPU_BASE_ADDR + 0x8, 0xE7FEE7FE);
    while (RD_MEM_32(IPU_BASE_ADDR) != 0x10000);
    while (RD_MEM_32(IPU_BASE_ADDR + 0x4) != 0x9);
    while (RD_MEM_32(IPU_BASE_ADDR + 0x8) != 0xE7FEE7FE);


    /* Reset deassertion for IPU CPU0, CPU1 */
    WR_MEM_32(RM_IPU_RSTCTRL, 0x0);

    /* Check the reset state: IPU CPU0, CPU1, Unicache and MMU are out of reset */
    while ((RD_MEM_32(RM_IPU_RSTST) & 0x3) != 0x3);
    WR_MEM_32(RM_IPU_RSTST, 0x7);


    GEL_TextOut("--->>> IPU%dSS Initialization is DONE! <<<---\n",,,,,cpu_num);
}

DSPSSClkEnable(uint32_t cpu_num)
{
    uint32_t i, fail = 0;
    GEL_TextOut("--->>> DSP%dSS Initialization is in progress ... <<<---\n",,,,,cpu_num);

    /* DSPSS Boot Address */
    WR_MEM_32(DSPSSBOOTADDR, (DSPSSBOOTADDRVALUE >> 10));

    /* Ware reset asserted for DSP_LRST, DSP Cache and Slave */
    WR_MEM_32(RM_DSP_RSTCTRL, 0x3);

    /* Start a SW force wakeup for DSPSS */
    WR_MEM_32(CM_DSP_CLKSTCTRL, 0x2);
    /* Enable DSPSS clock */
    WR_MEM_32(CM_DSP_DSP_CLKCTRL, 0x1);

    /* Check whether GFCLK is gated or not */
    while ((RD_MEM_32(CM_DSP_CLKSTCTRL) & 0x100) != 0x100);
    if (DEBUG_PRINT)
    {
        GEL_TextOut("DEBUG: Clock is active ... \n");
    }

    /* Reset de-assertion for DSPSS */
    WR_MEM_32(RM_DSP_RSTCTRL, 0x1);
    /* Check the reset state: DSPSS */
    while ((RD_MEM_32(RM_DSP_RSTST) & 0x2) != 0x2);

    WR_MEM_32(DSP_L2_SRAM_TARG, 0x0000A120); //Self branch loop for DSP

    /* Reset de-assertion for DSP CPUs */
    WR_MEM_32(RM_DSP_RSTCTRL, 0x0);
    /* Check the reset state: DSPSS Core, Cache and Slave interface */
    while ((RD_MEM_32(RM_DSP_RSTST) & 0x3) != 0x3);
    /* Check module mode */
    while ((RD_MEM_32(CM_DSP_DSP_CLKCTRL) & 0x30000) != 0x0);

    if (DEBUG_PRINT)
    {
        GEL_TextOut("DEBUG: Checking for data integrity in DSPSS L2RAM ... \n");
    }
    for (i = 1; i < 16; i++)
    {
        WR_MEM_32((DSP_L2_SRAM_TARG + (i << 2)), 0x12345678);
    }

    for (i = 1; i < 16; i++)
    {
        if (RD_MEM_32(DSP_L2_SRAM_TARG + (i << 2)) != 0x12345678)
        {
            fail++;
            break;
        }
    }

    if (fail)
    {
        GEL_TextOut("ERROR: Data integrity check in GEM L2RAM has failed! \n");
    }
    else
    {
        if (DEBUG_PRINT)
        {
            GEL_TextOut("DEBUG: Data integrity check in GEM L2RAM is sucessful! \n");
        }
    }


    GEL_TextOut("--->>> DSP%dSS Initialization is DONE! <<<---\n",,,,,cpu_num);
}

IVAHDSSClkEnable()
{
    GEL_TextOut("--->>> IVAHD Initialization is in progress ... <<<---\n");

    /* Start a SW force wakeup for IVASS */
    WR_MEM_32(CM_IVA_CLKSTCTRL, 0x2);
    /* Enable IVASS clock */
    WR_MEM_32(CM_IVA_IVA_CLKCTRL, 0x1);
    /* Enable IVA SL2 clock */
    WR_MEM_32(CM_IVA_SL2_CLKCTRL, 0x1);

    /* Check whether GFCLK is gated or not */
    while ((RD_MEM_32(CM_IVA_CLKSTCTRL) & 0x100) != 0x100);
    if (DEBUG_PRINT)
    {
        GEL_TextOut("DEBUG: Clock is active ... \n");
    }

    /* Warm reset asserted for CPU1, CPU2, IVA Logic */
    WR_MEM_32(RM_IVA_RSTCTRL, 0x7);
    WR_MEM_32(RM_IVA_RSTST, 0x7);

    /* Warm reset asserted for CPU1, CPU2 */
    WR_MEM_32(RM_IVA_RSTCTRL, 0x3);

    /* Check the reset state: IVA Logic */
    while ((RD_MEM_32(RM_IVA_RSTST) & 0x4) != 0x4);

    /* Self branch instruction */
    WR_MEM_32(ICONT1_ITCM, 0xEAFFFFFE);
    WR_MEM_32(ICONT2_ITCM, 0xEAFFFFFE);

    /* Reset de-assertion for CPU1, CPU2 */
    WR_MEM_32(RM_IVA_RSTCTRL, 0x1);
    while ((RD_MEM_32(RM_IVA_RSTST) & 0x6) != 0x6);
    WR_MEM_32(RM_IVA_RSTCTRL, 0x0);
    while ((RD_MEM_32(RM_IVA_RSTST) & 0x7) != 0x7);

    WR_MEM_32(RM_IVA_RSTST, 0x7);

    GEL_TextOut("--->>> IVAHD Initialization is DONE! ... <<<---\n");
}

