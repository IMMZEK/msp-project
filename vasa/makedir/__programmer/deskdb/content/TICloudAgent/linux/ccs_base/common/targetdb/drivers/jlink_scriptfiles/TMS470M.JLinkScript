/*********************************************************************
*                    SEGGER Microcontroller GmbH                     *
*       Solutions for real time microcontroller applications         *
**********************************************************************
*                                                                    *
*            (c) 1995 - 2018 SEGGER Microcontroller GmbH             *
*                                                                    *
*       www.segger.com     Support: support@segger.com               *
*                                                                    *
**********************************************************************
----------------------------------------------------------------------
File    : TMS470M.JLinkScript
Purpose : J-Link target setup file for TMS470M.
          Configures the ICEPick to enable the core.
          This script file also contains a special reset strategy which performs
          a reset via the ICEPick.
---------------------------END-OF-HEADER------------------------------
*/

/*********************************************************************
*
*       Constants (similar to defines)
*
**********************************************************************
*/

//
// Cortex-M SFRs
//
__constant U32 _AIRCR_ADDR                    = 0xE000ED0C;
__constant U32 _DHCSR_ADDR                    = 0xE000EDF0;
__constant U32 _DCRSR_ADDR                    = 0xE000EDF4;
__constant U32 _DCRDR_ADDR                    = 0xE000EDF8;
__constant U32 _DEMCR_ADDR                    = 0xE000EDFC;
//
// Cortex-A/R SFRs
//
__constant U32 _APB_ADDR_CORE_DEBUG_REGS  = 0x80001000;
__constant U32 _APB_ADDR_DSCR             = 0x80001000 + 0x88;  // Debug Status and Control Register
__constant U32 _APB_ADDR_DRCR             = 0x80001000 + 0x90;  // Debug Run Control Register
__constant U32 _APB_ADDR_VCR              = 0x80001000 + 0x1C;  // Vector catch register
__constant U32 _APB_ADDR_PRCR             = 0x80001000 + 0x310;  // Device Power-down and Reset Control Register
__constant U32 _APB_ADDR_PRSR             = 0x80001000 + 0x314;  // Device Power-down and Reset Status Register
__constant U32 _APB_ADDR_LOCKACCESS       = 0x80001000 + 0xFB0;
__constant U32 _APB_ADDR_LOCKSTATUS       = 0x80001000 + 0xFB4;
//
// DAP SFRs
//
__constant U32 _DAP_ACC_32BIT_AUTO_INC        = (1 << 29) | (1 << 25) | (1 << 24) | (1 << 4) | (2 << 0);  // HMASTER = DEBUG, Private access, Auto-increment, Access size: word;
__constant U32 _DAP_ACC_8BIT_NO_AUTO_INC      = (1 << 29) | (1 << 25) | (1 << 24) | (0 << 4) | (0 << 0);  // HMASTER = DEBUG, Private access, no Auto-increment, Access size: byte;
__constant U32 _DAP_ACC_16BIT_NO_AUTO_INC     = (1 << 29) | (1 << 25) | (1 << 24) | (0 << 4) | (1 << 0);  // HMASTER = DEBUG, Private access, no Auto-increment, Access size: half word;
__constant U32 _DAP_ACC_32BIT_NO_AUTO_INC     = (1 << 29) | (1 << 25) | (1 << 24) | (0 << 4) | (2 << 0);  // HMASTER = DEBUG, Private access, no Auto-increment, Access size: word;
__constant U32 _APB_CFG_32BIT_NO_AUTO_INC     = 0
                                              | (1 << 31)   // Enable software access to the Debug APB bus.
                                              | (0 << 4)    // Not auto-increment TAR after read/write access. Increment is never performed on access to banked data registers 0-3.
                                              | (2 << 0)    // AP-access size: 32-bit
                                              ;
__constant U32 _AHB_ACC_32BIT_NO_AUTO_INC     = 0
                                              | (1 << 29)
                                              | (1 << 25)
                                              | (1 << 24)
                                              | (0 << 4)    // Not auto-increment TAR after read/write access. Increment is never performed on access to banked data registers 0-3.
                                              | (2 << 0)    // AP-access size: 32-bit
                                              ;
__constant U32 _DP_CTRL_STAT_BIT_DBGPWRUPREQ  = (1 << 30);
__constant U32 _DP_CTRL_STAT_BIT_SYSPWRUPREQ  = (1 << 28);
__constant U32 _DP_CTRL_STAT_BIT_STICKYERR    = (1 <<  5);

/*********************************************************************
*
*       Local functions
*
**********************************************************************
*/

/*********************************************************************
*
*       _ResetViaIcePick
*
*  Function description
*    Reset CPU core via Ice Pick.
*    This function can be used if the reset pin of the CPU is
*    not connected to the reset pin of the JTAG connector
*/
void  _ResetViaIcePick(void) {
  int v;
  int demcr;
  int Speed;
  int BitPos;
  //
  // Reduce target interface speed, as ICEPick does not seem to like high interface speeds
  //
  Speed = JTAG_Speed;
  JTAG_Speed = 100;
  //
  // Set vector catch on reset
  //
  JLINK_CORESIGHT_WriteDP(JLINK_CORESIGHT_DP_REG_SELECT, (0 << 24) | (0 << 4));                  // Select AP[0] bank 0
  JLINK_CORESIGHT_WriteAP(JLINK_CORESIGHT_AP_REG_CTRL, _DAP_ACC_32BIT_NO_AUTO_INC);
  JLINK_CORESIGHT_WriteAP(JLINK_CORESIGHT_AP_REG_ADDR, _DHCSR_ADDR);
  v = 0
    | (1 << 0)         // C_DEBUGEN
    | (1 << 1)         // C_HALT
    | (0xA05F << 16);  // Make sure that write to DHCSR is accepted as valid
    ;
  JLINK_CORESIGHT_WriteAP(JLINK_CORESIGHT_AP_REG_DATA, v);
  JTAG_WriteClocks(1);
  JLINK_CORESIGHT_WriteAP(JLINK_CORESIGHT_AP_REG_ADDR, _DEMCR_ADDR);
  demcr = JLINK_CORESIGHT_ReadAP(JLINK_CORESIGHT_AP_REG_DATA);
  JLINK_CORESIGHT_WriteAP(JLINK_CORESIGHT_AP_REG_DATA, demcr | 1);      // DEMCR.VC_CORERESET
  JTAG_WriteClocks(1);
  //
  // Perform reset via ICEPick:
  // 1) Switch JTAG config to ICEPick
  // 2) Perform reset (via ICEPick SFR accesses)
  // 3) Switch JTAG config back to CPU core
  //
  JLINK_CORESIGHT_Configure("IRPre=4;DRPre=1;IRPost=0;DRPost=0;IRLenDevice=6;PerformTIFInit=0");  // Make sure we do not output the JTAG <-> SWD switching sequence as TI devices with ICEPick do not support SWD anyhow and do not like the switching sequence
  JTAG_StoreIR(2);         // Cmd: ROUTER
  v = 0x01000000;          // Read SYS_CNTL
  JTAG_StoreDR(v, 32);
  BitPos = JTAG_StoreDR(v, 32);
  v = JTAG_GetU32(BitPos);
  v &= 0x00FFFFFF;
  v |= 0x81000001;         // Write SYS_CNTL and set SysReset bit
  JTAG_StoreDR(v, 32);
  v &= 0xFFFFFFFE;
  v &= 0x00FFFFFF;
  v |= 0x81000000;         // Write SYS_CNTL and clear SysReset bit
  JTAG_WriteDR(v, 32);
  JLINK_CORESIGHT_Configure("IRPre=0;DRPre=0;IRPost=6;DRPost=1;IRLenDevice=4;PerformTIFInit=0");  // Make sure we do not output the JTAG <-> SWD switching sequence as TI devices with ICEPick do not support SWD anyhow and do not like the switching sequence
  //
  // Restore vector catch state
  //
  JLINK_CORESIGHT_WriteAP(JLINK_CORESIGHT_AP_REG_ADDR, _DEMCR_ADDR);
  JLINK_CORESIGHT_WriteAP(JLINK_CORESIGHT_AP_REG_DATA, demcr);
  JTAG_WriteClocks(1);
  //
  // Restore target interface speed
  //
  JTAG_Speed = Speed;
}

/*********************************************************************
*
*       _InitIcePick
*
*  Function description
*    Configures the ICEPick so that the CPU core also becomes
*    visible in the JTAG chain.
*/
void _InitIcePick(void) {
  int v;
  int BitPos;
  int Speed;
  int ICEPickIdCode;
  int DAPIdCode;
  //
  // Reduce target interface speed, as ICEPick does not seem to like high interface speeds
  //
  Speed = JTAG_Speed;
  JTAG_Speed = 50;
  //
  // After power-on and TAP reset, only the TI ICEPick is in the scan chain
  //
  Report("J-Link script: Init ICEPick");
  JTAG_Reset();                           // Perform TAP reset and auto-detection of total IR Len
  if (JTAG_TotalIRLen != 6) {
    MessageBox1("Can not find ICE-Pick (IRLen mismatch). Expected 0x00000006, found: ", JTAG_TotalIRLen);
  }
  Report("J-Link script: ICEPick found, enabling CPU core.");
  JLINK_CORESIGHT_Configure("IRPre=0;DRPre=0;IRPost=0;DRPost=0;IRLenDevice=6;PerformTIFInit=0");  // Make sure we do not output the JTAG <-> SWD switching sequence as TI devices with ICEPick do not support SWD anyhow and do not like the switching sequence
  //
  // Check IDCODE of ICEPick
  //
  JTAG_WriteIR(4);                              // ICEPICK IDCODE instruction
  BitPos = JTAG_WriteDR(0x00000000, 32);
  ICEPickIdCode = JTAG_GetU32(BitPos);
  if ((ICEPickIdCode & 0x00000FFF) != 0x0000002F) {
    MessageBox1("Can not find ICE-Pick (IDCODE mismatch). Expected 0xXXXXXX2F, found: ", ICEPickIdCode);
  }
  //
  // Put ARM core in JTAG chain
  //  
  JTAG_WriteIR(7);         // CONNECT
  JTAG_WriteDR(0x89, 8);   // The ICEPick documentation (SPRUE64, 2.6 CONNECT instruction: Accessing the debug connect register). Bit 7 set means: Write debug connect register. We write 0x9 to the debug connect register which is the debug connect key.
  JTAG_WriteIR(2);         // ROUTER (Accessing the mapped registers)
  v = 0
    | (1 << 31)     // Write mapped register
    | (0x20 << 24)  // SDTAP0 register
    | (1 << 13)     // Debug connect
    | (1 << 8)      // TAP select
    | (1 << 3)      // Force active
    ;
  JTAG_WriteDR(v, 32);     // Write register SDTAP0
  JTAG_WriteIR(0x3F);      // Bypass
  JTAG_WriteClocks(10);
  //
  // Configure JTAG chain, so J-Link knows to which devices it has to "talk" to.
  // CPU core is in scan chain now, so we have to re-configure the JTAG chain settings
  //
  JLINK_CORESIGHT_Configure("IRPre=0;DRPre=0;IRPost=6;DRPost=1;IRLenDevice=4;PerformTIFInit=0");  // Make sure we do not output the JTAG <-> SWD switching sequence as TI devices with ICEPick do not support SWD anyhow and do not like the switching sequence
  CPU=CORTEX_M3;
  JTAG_AllowTAPReset=0; 
  //
  // Get IDCODE of CoreSight DAP
  //
  JTAG_WriteIR(0xE);
  BitPos = JTAG_WriteDR(0x00000000, 32);
  DAPIdCode = JTAG_GetU32(BitPos);
  //
  // Register JTAG devices
  //
  JTAG_SetDeviceId(0, DAPIdCode);
  JTAG_SetDeviceId(1, ICEPickIdCode);
  //
  // Restore target interface speed
  //
  JTAG_Speed = Speed;  // Restore original JTAG speed
}

/*********************************************************************
*
*       Global functions
*
**********************************************************************
*/

/*********************************************************************
*
*       ResetTarget
*/
void ResetTarget(void) {
  Report("J-Link script: ResetTarget()");
  _ResetViaIcePick();
}

/*********************************************************************
*
*       InitTarget
*/
void InitTarget(void) {
  Report("J-Link script: InitTarget()");
  //
  // Reset debug logic in order to make sure that ONLY the ICEPick is in the JTAG chain
  //
  JTAG_Write(0x1F, 0, 6);
  _InitIcePick();
}