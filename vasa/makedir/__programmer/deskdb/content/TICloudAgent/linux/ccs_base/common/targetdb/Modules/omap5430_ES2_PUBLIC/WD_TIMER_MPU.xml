<module name="WD_TIMER_MPU" acronym="" XML_version="1.0" HW_revision="n/a" description="">
  <register id="WDT_LOAD_REGISTER_i_0" acronym="WDT_LOAD_REGISTER_i_0" offset="0x0" width="32" description="When this register is stored, the is immediately loaded with this value and the prescaler state is cleared. This register is reset by warm reset of the corresponding MPU core.">
    <bitfield id="NEWCOUNT" width="32" begin="31" end="0" resetval="0x0000 0000" description="New value to load intoWDT_COUNT_REGISTER_i." range="" rwaccess="RW"/>
  </register>
  <register id="WDT_LOAD_REGISTER_i_1" acronym="WDT_LOAD_REGISTER_i_1" offset="0x20" width="32" description="When this register is stored, the is immediately loaded with this value and the prescaler state is cleared. This register is reset by warm reset of the corresponding MPU core.">
    <bitfield id="NEWCOUNT" width="32" begin="31" end="0" resetval="0x0000 0000" description="New value to load intoWDT_COUNT_REGISTER_i." range="" rwaccess="RW"/>
  </register>
  <register id="WDT_COUNT_REGISTER_i_0" acronym="WDT_COUNT_REGISTER_i_0" offset="0x4" width="32" description="This register is a 32-bit decrementing counter. The decrement rate is programmed in the. The can be read to get the current count. It decrements if the WD_TIMER_MPU_Cx is enabled ([0] ENABLE = 0x1). If the processor corresponding to the watchdog channel is in debug state, the counter does not decrement until the processor returns to non-debug state. The decrements down to zero and stops. The only way to update the is to write to the . If a software failure prevents the from being refreshed, the reaches zero, the watchdog timeout status flag is set and all interrupt requests or reset requests enabled in the are signalled. If a reset request is enabled, the global PRCM is then responsible for resetting the MPUSS. Debug state is inferred by monitoring the DBGACK signal corresponding to this core. This register is reset by warm reset of the corresponding MPU core.">
    <bitfield id="CURRENTCOUNT" width="32" begin="31" end="0" resetval="0x0000 0000" description="Current count of the WD_TIMER_MPU." range="" rwaccess="R"/>
  </register>
  <register id="WDT_COUNT_REGISTER_i_1" acronym="WDT_COUNT_REGISTER_i_1" offset="0x24" width="32" description="This register is a 32-bit decrementing counter. The decrement rate is programmed in the. The can be read to get the current count. It decrements if the WD_TIMER_MPU_Cx is enabled ([0] ENABLE = 0x1). If the processor corresponding to the watchdog channel is in debug state, the counter does not decrement until the processor returns to non-debug state. The decrements down to zero and stops. The only way to update the is to write to the . If a software failure prevents the from being refreshed, the reaches zero, the watchdog timeout status flag is set and all interrupt requests or reset requests enabled in the are signalled. If a reset request is enabled, the global PRCM is then responsible for resetting the MPUSS. Debug state is inferred by monitoring the DBGACK signal corresponding to this core. This register is reset by warm reset of the corresponding MPU core.">
    <bitfield id="CURRENTCOUNT" width="32" begin="31" end="0" resetval="0x0000 0000" description="Current count of the WD_TIMER_MPU." range="" rwaccess="R"/>
  </register>
  <register id="WDT_WARNING_REGISTER_i_0" acronym="WDT_WARNING_REGISTER_i_0" offset="0x8" width="32" description="The is compared to the . If is less than or equal to the and [8] WARNEN = 0b1, a warning interrupt is signalled to the INTC_MPU. The warning condition can be used to signal an interrupt that gives software a notice that the WD_TIMER_MPU_Cx is getting close to a timeout, when a more serious action should be taken.">
    <bitfield id="WARNING_WATERMARK" width="32" begin="31" end="0" resetval="0x0000 0000" description="A warning condition occurs when theWDT_COUNT_REGISTER_i value is less than or equal to the WDT_WARNING_REGISTER_i." range="" rwaccess="RW"/>
  </register>
  <register id="WDT_WARNING_REGISTER_i_1" acronym="WDT_WARNING_REGISTER_i_1" offset="0x28" width="32" description="The is compared to the . If is less than or equal to the and [8] WARNEN = 0b1, a warning interrupt is signalled to the INTC_MPU. The warning condition can be used to signal an interrupt that gives software a notice that the WD_TIMER_MPU_Cx is getting close to a timeout, when a more serious action should be taken.">
    <bitfield id="WARNING_WATERMARK" width="32" begin="31" end="0" resetval="0x0000 0000" description="A warning condition occurs when theWDT_COUNT_REGISTER_i value is less than or equal to the WDT_WARNING_REGISTER_i." range="" rwaccess="RW"/>
  </register>
  <register id="WDT_PRESCALER_REGISTER_i_0" acronym="WDT_PRESCALER_REGISTER_i_0" offset="0xC" width="32" description="This register is used to set the count rate of the WD_TIMER_MPU_Cx counter.">
    <bitfield id="RESERVED" width="22" begin="31" end="10" resetval="0x00 0000" description="Reserved. Ignored on writes. Reads return 0s." range="" rwaccess="R"/>
    <bitfield id="PRESCALER" width="10" begin="9" end="0" resetval="0x000" description="Sets the prescaler ratio.WDT_COUNT_REGISTER_i decrements every (PRESCALER + 1) MPU_DPLL_CLK clocks. Note: If the prescaler is set to (MPU_DPLL_CLK [in MHz] - 1), the WD_TIMER_MPU_Cx counter counts at a 1 microsecond rate." range="" rwaccess="RW"/>
  </register>
  <register id="WDT_PRESCALER_REGISTER_i_1" acronym="WDT_PRESCALER_REGISTER_i_1" offset="0x2C" width="32" description="This register is used to set the count rate of the WD_TIMER_MPU_Cx counter.">
    <bitfield id="RESERVED" width="22" begin="31" end="10" resetval="0x00 0000" description="Reserved. Ignored on writes. Reads return 0s." range="" rwaccess="R"/>
    <bitfield id="PRESCALER" width="10" begin="9" end="0" resetval="0x000" description="Sets the prescaler ratio.WDT_COUNT_REGISTER_i decrements every (PRESCALER + 1) MPU_DPLL_CLK clocks. Note: If the prescaler is set to (MPU_DPLL_CLK [in MHz] - 1), the WD_TIMER_MPU_Cx counter counts at a 1 microsecond rate." range="" rwaccess="RW"/>
  </register>
  <register id="WDT_CONTROL_REGISTER_i_0" acronym="WDT_CONTROL_REGISTER_i_0" offset="0x10" width="32" description="This register controls the behavior of the WD_TIMER_MPU_Cx. This register is reset by warm reset of the corresponding MPU core.">
    <bitfield id="RESERVED" width="23" begin="31" end="9" resetval="0x00 0000" description="Reserved. Ignored on writes. Reads return 0s." range="" rwaccess="R"/>
    <bitfield id="WARNEN" width="1" begin="8" end="8" resetval="0" description="Warning Interrupt Enable. If this bit is set and the warning watermark test is true, a warning interrupt is generated to the INTC_MPU." range="" rwaccess="RW"/>
    <bitfield id="RESERVED" width="4" begin="7" end="4" resetval="0x0" description="Reserved. Ignored on writes. Reads return 0s." range="" rwaccess="R"/>
    <bitfield id="MPUSSRSTEN" width="1" begin="3" end="3" resetval="0" description="MPUSS Reset Enable. If this field is 0b1 when the timer reaches zero, a request is sent to the PRCM to reset the MPUSS including both MPU cores." range="" rwaccess="RW"/>
    <bitfield id="RESERVED" width="1" begin="2" end="2" resetval="0" description="Reserved. Ignored on writes. Reads return 0s." range="" rwaccess="R"/>
    <bitfield id="INTREN" width="1" begin="1" end="1" resetval="0" description="Interrupt Enable. If this field is 0b1 when the timer reaches zero, an interrupt request is sent to the INTC_MPU." range="" rwaccess="RW"/>
    <bitfield id="ENABLE" width="1" begin="0" end="0" resetval="0" description="Enable for WD_TIMER_MPU_Cx. 0: WD_TIMER_MPU_Cx is disabled. It will not count down and it will not generate a reset request. All WD_TIMER_MPU_Cx registers may be accessed. 1: WD_TIMER_MPU_Cx is enabled. It will count down and generate a reset request if it reaches 0. This bit is reset by warm or power-on reset." range="" rwaccess="RW"/>
  </register>
  <register id="WDT_CONTROL_REGISTER_i_1" acronym="WDT_CONTROL_REGISTER_i_1" offset="0x30" width="32" description="This register controls the behavior of the WD_TIMER_MPU_Cx. This register is reset by warm reset of the corresponding MPU core.">
    <bitfield id="RESERVED" width="23" begin="31" end="9" resetval="0x00 0000" description="Reserved. Ignored on writes. Reads return 0s." range="" rwaccess="R"/>
    <bitfield id="WARNEN" width="1" begin="8" end="8" resetval="0" description="Warning Interrupt Enable. If this bit is set and the warning watermark test is true, a warning interrupt is generated to the INTC_MPU." range="" rwaccess="RW"/>
    <bitfield id="RESERVED" width="4" begin="7" end="4" resetval="0x0" description="Reserved. Ignored on writes. Reads return 0s." range="" rwaccess="R"/>
    <bitfield id="MPUSSRSTEN" width="1" begin="3" end="3" resetval="0" description="MPUSS Reset Enable. If this field is 0b1 when the timer reaches zero, a request is sent to the PRCM to reset the MPUSS including both MPU cores." range="" rwaccess="RW"/>
    <bitfield id="RESERVED" width="1" begin="2" end="2" resetval="0" description="Reserved. Ignored on writes. Reads return 0s." range="" rwaccess="R"/>
    <bitfield id="INTREN" width="1" begin="1" end="1" resetval="0" description="Interrupt Enable. If this field is 0b1 when the timer reaches zero, an interrupt request is sent to the INTC_MPU." range="" rwaccess="RW"/>
    <bitfield id="ENABLE" width="1" begin="0" end="0" resetval="0" description="Enable for WD_TIMER_MPU_Cx. 0: WD_TIMER_MPU_Cx is disabled. It will not count down and it will not generate a reset request. All WD_TIMER_MPU_Cx registers may be accessed. 1: WD_TIMER_MPU_Cx is enabled. It will count down and generate a reset request if it reaches 0. This bit is reset by warm or power-on reset." range="" rwaccess="RW"/>
  </register>
  <register id="WDT_RESET_STATUS_REGISTER_i_0" acronym="WDT_RESET_STATUS_REGISTER_i_0" offset="0x14" width="32" description="The TO bit indicated that this WD_TIMER_MPU_Cx has timed out. This might be used to figure out which WD_TIMER_MPU_Cx signalled a reset. This register is not reset by warm reset, but only by cold reset.">
    <bitfield id="RESERVED" width="30" begin="31" end="2" resetval="0x0000 0000" description="Reserved. Ignored on writes. Reads return 0s." range="" rwaccess="R"/>
    <bitfield id="WARN" width="1" begin="1" end="1" resetval="0" description="Warning. Indicates that the count has passed the warning watermark level while theWDT_CONTROL_REGISTER_i[8] WARNEN bit was set. Write a '1' to this bit to reset it." range="" rwaccess="RW W1toClr"/>
    <bitfield id="TO" width="1" begin="0" end="0" resetval="0" description="Timeout. Indicates theWDT_COUNT_REGISTER_i has reached zero (timed out) and the signalling enabled in the WDT_CONTROL_REGISTER_i has occurred. Can be used to determine which WD_TIMER_MPU_Cx instance caused a reset. Write a '1' to this bit to reset it." range="" rwaccess="RW W1toClr"/>
  </register>
  <register id="WDT_RESET_STATUS_REGISTER_i_1" acronym="WDT_RESET_STATUS_REGISTER_i_1" offset="0x34" width="32" description="The TO bit indicated that this WD_TIMER_MPU_Cx has timed out. This might be used to figure out which WD_TIMER_MPU_Cx signalled a reset. This register is not reset by warm reset, but only by cold reset.">
    <bitfield id="RESERVED" width="30" begin="31" end="2" resetval="0x0000 0000" description="Reserved. Ignored on writes. Reads return 0s." range="" rwaccess="R"/>
    <bitfield id="WARN" width="1" begin="1" end="1" resetval="0" description="Warning. Indicates that the count has passed the warning watermark level while theWDT_CONTROL_REGISTER_i[8] WARNEN bit was set. Write a '1' to this bit to reset it." range="" rwaccess="RW W1toClr"/>
    <bitfield id="TO" width="1" begin="0" end="0" resetval="0" description="Timeout. Indicates theWDT_COUNT_REGISTER_i has reached zero (timed out) and the signalling enabled in the WDT_CONTROL_REGISTER_i has occurred. Can be used to determine which WD_TIMER_MPU_Cx instance caused a reset. Write a '1' to this bit to reset it." range="" rwaccess="RW W1toClr"/>
  </register>
</module>
