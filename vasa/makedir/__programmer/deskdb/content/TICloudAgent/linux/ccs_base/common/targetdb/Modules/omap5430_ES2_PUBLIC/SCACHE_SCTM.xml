<module name="SCACHE_SCTM" acronym="" XML_version="1.0" HW_revision="n/a" description="">
  <register id="SCACHE_SCTM_CTCNTL" acronym="SCACHE_SCTM_CTCNTL" offset="0x0" width="32" description="">
    <bitfield id="NUMSTM" width="6" begin="31" end="26" resetval="0x00" description="Number of timers that can export via STM" range="" rwaccess="R"/>
    <bitfield id="NUMINPT" width="8" begin="25" end="18" resetval="0x1F" description="Number of event input signals" range="" rwaccess="R"/>
    <bitfield id="NUMTIMR" width="5" begin="17" end="13" resetval="0x02" description="Number of timers in the module" range="" rwaccess="R"/>
    <bitfield id="NUMCNTR" width="6" begin="12" end="7" resetval="0x08" description="Number of counters in the module" range="" rwaccess="R"/>
    <bitfield id="REVISION" width="4" begin="6" end="3" resetval="0x- TI internal data" description="Revision ID of SCTM" range="" rwaccess="R"/>
    <bitfield id="IDLEMODE" width="2" begin="2" end="1" resetval="0x2" description="Idle mode control" range="" rwaccess="RW">
      <bitenum value="0" id="Force_Idle_mode" token="IDLEMODE_0" description="Force Idle mode"/>
      <bitenum value="1" id="SCTM_1" token="IDLEMODE_1" description="Ths SCTM will acknoledge the idle request, but never transition to the idle state"/>
      <bitenum value="2" id="SCTM_2" token="IDLEMODE_2" description="Ths SCTM uses the smart idle protocol. This is the default mode"/>
      <bitenum value="3" id="SCTM_3" token="IDLEMODE_3" description="Since the SCTM does not support internal wakeup, this mode is identical to smart_idle"/>
    </bitfield>
    <bitfield id="ENBL" width="1" begin="0" end="0" resetval="0" description="SCTM global enable" range="" rwaccess="RW">
      <bitenum value="0" id="0" token="ENBL_0" description="Ths mode is disable. Only the configuration interface is functional. All other logic is reset"/>
      <bitenum value="1" id="1" token="ENBL_1" description="The module is enabled and individual counter/timers can be configured"/>
    </bitfield>
  </register>
  <register id="SCACHE_SCTM_TINTVLR_i_0" acronym="SCACHE_SCTM_TINTVLR_i_0" offset="0x40" width="32" description="These registers contain the interval match value for the corresponding timers in the SCTM">
    <bitfield id="INTERVAL" width="32" begin="31" end="0" resetval="0x0000 0000" description="Interval match value for the timers in the SCTM" range="" rwaccess="RW"/>
  </register>
  <register id="SCACHE_SCTM_TINTVLR_i_1" acronym="SCACHE_SCTM_TINTVLR_i_1" offset="0x44" width="32" description="These registers contain the interval match value for the corresponding timers in the SCTM">
    <bitfield id="INTERVAL" width="32" begin="31" end="0" resetval="0x0000 0000" description="Interval match value for the timers in the SCTM" range="" rwaccess="RW"/>
  </register>
  <register id="SCACHE_SCTM_CTDBGNUM" acronym="SCACHE_SCTM_CTDBGNUM" offset="0x7C" width="32" description="Counter Timer Number Debug Event Register">
    <bitfield id="RESERVED" width="29" begin="31" end="3" resetval="0x0000 0000" description="Reserved." range="" rwaccess="R"/>
    <bitfield id="NUMEVT" width="3" begin="2" end="0" resetval="0x0" description="Number of input selectors for debug events" range="" rwaccess="R"/>
  </register>
  <register id="SCACHE_SCTM_CTGNBL" acronym="SCACHE_SCTM_CTGNBL" offset="0xF0" width="32" description="These registers provide for simultaneous enable/disable of 32 counters">
    <bitfield id="RESERVED" width="24" begin="31" end="8" resetval="0x000000" description="Reserved." range="" rwaccess="R"/>
    <bitfield id="ENABLE" width="8" begin="7" end="0" resetval="0x00" description="The counter enable bit field" range="" rwaccess="RW"/>
  </register>
  <register id="SCACHE_SCTM_CTGRST" acronym="SCACHE_SCTM_CTGRST" offset="0xF8" width="32" description="These registers provide for simultaneous reset of 32 counters">
    <bitfield id="RESERVED" width="24" begin="31" end="8" resetval="0x000000" description="Reserved." range="" rwaccess="R"/>
    <bitfield id="RESET" width="8" begin="7" end="0" resetval="0x00" description="The counter reset bit field" range="" rwaccess="RW"/>
  </register>
  <register id="SCACHE_SCTM_CTCR_WT_i_0" acronym="SCACHE_SCTM_CTCR_WT_i_0" offset="0x100" width="32" description="These registers contain the control and status settings for a single counter in the module. There will be a CTCR for every counter in the module (WT: with timer)">
    <bitfield id="RESERVED" width="11" begin="31" end="21" resetval="0x000" description="Reserved." range="" rwaccess="R"/>
    <bitfield id="INPSEL" width="5" begin="20" end="16" resetval="0x00" description="Counter Timer input selection1-31: Index of event input signal selected ." range="" rwaccess="RW">
      <bitenum value="0" id="0" token="INPSEL_0" description="Constantly asserted input that results in a free-running counter/timer"/>
    </bitfield>
    <bitfield id="RESERVED" width="5" begin="15" end="11" resetval="0x00" description="Reserved." range="" rwaccess="R"/>
    <bitfield id="RESTART" width="1" begin="10" end="10" resetval="0" description="Restart the timer after an interval match" range="" rwaccess="RW">
      <bitenum value="0" id="0" token="RESTART_0" description="The timer stops after the first interval match. It must be manually reset by software before it starts counting again (run-once timer mode)."/>
      <bitenum value="1" id="1" token="RESTART_1" description="The timer immediately resets to 0 and begins incrementing again based on the current input configuration (restart timer mode)."/>
    </bitfield>
    <bitfield id="DBG" width="1" begin="9" end="9" resetval="0" description="Signal debug logic on interval match" range="" rwaccess="RW">
      <bitenum value="0" id="No_debug_event_is_generated." token="DBG_0" description="No debug event is generated."/>
      <bitenum value="1" id="1" token="DBG_1" description="Upon interval match, generates a debug event on the corresponding debug output event signal"/>
    </bitfield>
    <bitfield id="INT" width="1" begin="8" end="8" resetval="0" description="Generate interrupt on interval match" range="" rwaccess="RW">
      <bitenum value="0" id="No_interrupt_is_generated." token="INT_0" description="No interrupt is generated."/>
      <bitenum value="1" id="1" token="INT_1" description="Upon interval match, generates an interrupt on the corresponding interrupt output event signal"/>
    </bitfield>
    <bitfield id="CHNSDW" width="1" begin="7" end="7" resetval="0" description="Counter has a shadow register for chain reads." range="" rwaccess="R">
      <bitenum value="0" id="0" token="CHNSDW_0" description="The read of the corresponding counter register returns the current value."/>
      <bitenum value="1" id="1" token="CHNSDW_1" description="Read of the high-order counter register, simultaneously loads the current value of the 32 LSBs into a shadow register. The read of the counter register that corresponds to this counter returns the value of the shadow register. This is applicable only when the counter is chained."/>
    </bitfield>
    <bitfield id="OVRFLW" width="1" begin="6" end="6" resetval="0" description="Counter has wrapped since it was last read" range="" rwaccess="R">
      <bitenum value="0" id="0" token="OVRFLW_0" description="The counter has not wrapped since the last read."/>
      <bitenum value="1" id="1" token="OVRFLW_1" description="The counter has wrapped since the last read."/>
    </bitfield>
    <bitfield id="IDLE" width="1" begin="5" end="5" resetval="0" description="Counter ignores processor IDLE state" range="" rwaccess="RW">
      <bitenum value="0" id="IDLE_0" token="IDLE_0" description="The counter does not increment during IDLE state."/>
      <bitenum value="1" id="IDLE_IDLEMODE_1" token="IDLE_1" description="The counter continues to function during IDLE state; applicable if IDLEMODE = 1."/>
    </bitfield>
    <bitfield id="FREE" width="1" begin="4" end="4" resetval="0" description="Counter ignores processor debug halt state" range="" rwaccess="RW">
      <bitenum value="0" id="0" token="FREE_0" description="The counter does not increment (decrement) during the debug halt state."/>
      <bitenum value="1" id="1" token="FREE_1" description="The counter continues to function during debug halt state."/>
    </bitfield>
    <bitfield id="DURMODE" width="1" begin="3" end="3" resetval="0" description="Counter is in duration or occurrence mode" range="" rwaccess="RW">
      <bitenum value="0" id="0" token="DURMODE_0" description="The counter operates in event mode. The counter increments by 1 each time a rising edge is seen on the designated input event signal."/>
      <bitenum value="1" id="1" token="DURMODE_1" description="The counter operates in duration mode. The counter increments every time a clock cycle is seen and the corresponding input event signal is asserted."/>
    </bitfield>
    <bitfield id="CHAIN" width="1" begin="2" end="2" resetval="0" description="Counter is chained to an adjacent counter" range="" rwaccess="RW">
      <bitenum value="0" id="The_counter_is_not_chained." token="CHAIN_0" description="The counter is not chained."/>
      <bitenum value="1" id="Reserved" token="CHAIN_1" description="Reserved"/>
    </bitfield>
    <bitfield id="RESET" width="1" begin="1" end="1" resetval="0" description="Counter reset control" range="" rwaccess="RW">
      <bitenum value="0" id="No_effect" token="RESET_0" description="No effect"/>
      <bitenum value="1" id="OVERFLW_1" token="RESET_1" description="The corresponding counter is reset to the initial value and the OVERFLW bit is cleared. It continues to function if it is still enabled."/>
    </bitfield>
    <bitfield id="ENBL" width="1" begin="0" end="0" resetval="0" description="Counter enable control" range="" rwaccess="RW">
      <bitenum value="0" id="The_counter_does_not_increment." token="ENBL_0" description="The counter does not increment."/>
      <bitenum value="1" id="The_counter_increments_as_configured." token="ENBL_1" description="The counter increments as configured."/>
    </bitfield>
  </register>
  <register id="SCACHE_SCTM_CTCR_WT_i_1" acronym="SCACHE_SCTM_CTCR_WT_i_1" offset="0x104" width="32" description="These registers contain the control and status settings for a single counter in the module. There will be a CTCR for every counter in the module (WT: with timer)">
    <bitfield id="RESERVED" width="11" begin="31" end="21" resetval="0x000" description="Reserved." range="" rwaccess="R"/>
    <bitfield id="INPSEL" width="5" begin="20" end="16" resetval="0x00" description="Counter Timer input selection1-31: Index of event input signal selected ." range="" rwaccess="RW">
      <bitenum value="0" id="0" token="INPSEL_0" description="Constantly asserted input that results in a free-running counter/timer"/>
    </bitfield>
    <bitfield id="RESERVED" width="5" begin="15" end="11" resetval="0x00" description="Reserved." range="" rwaccess="R"/>
    <bitfield id="RESTART" width="1" begin="10" end="10" resetval="0" description="Restart the timer after an interval match" range="" rwaccess="RW">
      <bitenum value="0" id="0" token="RESTART_0" description="The timer stops after the first interval match. It must be manually reset by software before it starts counting again (run-once timer mode)."/>
      <bitenum value="1" id="1" token="RESTART_1" description="The timer immediately resets to 0 and begins incrementing again based on the current input configuration (restart timer mode)."/>
    </bitfield>
    <bitfield id="DBG" width="1" begin="9" end="9" resetval="0" description="Signal debug logic on interval match" range="" rwaccess="RW">
      <bitenum value="0" id="No_debug_event_is_generated." token="DBG_0" description="No debug event is generated."/>
      <bitenum value="1" id="1" token="DBG_1" description="Upon interval match, generates a debug event on the corresponding debug output event signal"/>
    </bitfield>
    <bitfield id="INT" width="1" begin="8" end="8" resetval="0" description="Generate interrupt on interval match" range="" rwaccess="RW">
      <bitenum value="0" id="No_interrupt_is_generated." token="INT_0" description="No interrupt is generated."/>
      <bitenum value="1" id="1" token="INT_1" description="Upon interval match, generates an interrupt on the corresponding interrupt output event signal"/>
    </bitfield>
    <bitfield id="CHNSDW" width="1" begin="7" end="7" resetval="0" description="Counter has a shadow register for chain reads." range="" rwaccess="R">
      <bitenum value="0" id="0" token="CHNSDW_0" description="The read of the corresponding counter register returns the current value."/>
      <bitenum value="1" id="1" token="CHNSDW_1" description="Read of the high-order counter register, simultaneously loads the current value of the 32 LSBs into a shadow register. The read of the counter register that corresponds to this counter returns the value of the shadow register. This is applicable only when the counter is chained."/>
    </bitfield>
    <bitfield id="OVRFLW" width="1" begin="6" end="6" resetval="0" description="Counter has wrapped since it was last read" range="" rwaccess="R">
      <bitenum value="0" id="0" token="OVRFLW_0" description="The counter has not wrapped since the last read."/>
      <bitenum value="1" id="1" token="OVRFLW_1" description="The counter has wrapped since the last read."/>
    </bitfield>
    <bitfield id="IDLE" width="1" begin="5" end="5" resetval="0" description="Counter ignores processor IDLE state" range="" rwaccess="RW">
      <bitenum value="0" id="IDLE_0" token="IDLE_0" description="The counter does not increment during IDLE state."/>
      <bitenum value="1" id="IDLE_IDLEMODE_1" token="IDLE_1" description="The counter continues to function during IDLE state; applicable if IDLEMODE = 1."/>
    </bitfield>
    <bitfield id="FREE" width="1" begin="4" end="4" resetval="0" description="Counter ignores processor debug halt state" range="" rwaccess="RW">
      <bitenum value="0" id="0" token="FREE_0" description="The counter does not increment (decrement) during the debug halt state."/>
      <bitenum value="1" id="1" token="FREE_1" description="The counter continues to function during debug halt state."/>
    </bitfield>
    <bitfield id="DURMODE" width="1" begin="3" end="3" resetval="0" description="Counter is in duration or occurrence mode" range="" rwaccess="RW">
      <bitenum value="0" id="0" token="DURMODE_0" description="The counter operates in event mode. The counter increments by 1 each time a rising edge is seen on the designated input event signal."/>
      <bitenum value="1" id="1" token="DURMODE_1" description="The counter operates in duration mode. The counter increments every time a clock cycle is seen and the corresponding input event signal is asserted."/>
    </bitfield>
    <bitfield id="CHAIN" width="1" begin="2" end="2" resetval="0" description="Counter is chained to an adjacent counter" range="" rwaccess="RW">
      <bitenum value="0" id="The_counter_is_not_chained." token="CHAIN_0" description="The counter is not chained."/>
      <bitenum value="1" id="Reserved" token="CHAIN_1" description="Reserved"/>
    </bitfield>
    <bitfield id="RESET" width="1" begin="1" end="1" resetval="0" description="Counter reset control" range="" rwaccess="RW">
      <bitenum value="0" id="No_effect" token="RESET_0" description="No effect"/>
      <bitenum value="1" id="OVERFLW_1" token="RESET_1" description="The corresponding counter is reset to the initial value and the OVERFLW bit is cleared. It continues to function if it is still enabled."/>
    </bitfield>
    <bitfield id="ENBL" width="1" begin="0" end="0" resetval="0" description="Counter enable control" range="" rwaccess="RW">
      <bitenum value="0" id="The_counter_does_not_increment." token="ENBL_0" description="The counter does not increment."/>
      <bitenum value="1" id="The_counter_increments_as_configured." token="ENBL_1" description="The counter increments as configured."/>
    </bitfield>
  </register>
  <register id="SCACHE_SCTM_CTCR_WOT_j_0" acronym="SCACHE_SCTM_CTCR_WOT_j_0" offset="0x108" width="32" description="These registers contain the control and status settings for a single counter in the module. There will be a CTCR for every counter in the module (WOT: without timer)">
    <bitfield id="RESERVED" width="11" begin="31" end="21" resetval="0x000" description="Reserved." range="" rwaccess="R"/>
    <bitfield id="INPSEL" width="5" begin="20" end="16" resetval="0x000" description="Counter input selection1&#8211;31: Index of event input signal selected ." range="" rwaccess="RW">
      <bitenum value="0" id="0" token="INPSEL_0" description="Constant low signal on the output interface"/>
    </bitfield>
    <bitfield id="RESERVED" width="8" begin="15" end="8" resetval="0x00" description="Reserved." range="" rwaccess="R"/>
    <bitfield id="CHNSDW" width="1" begin="7" end="7" resetval="0" description="Counter has a shadow register for chain reads." range="" rwaccess="R">
      <bitenum value="0" id="0" token="CHNSDW_0" description="The read of the corresponding counter register returns the current value."/>
      <bitenum value="1" id="1" token="CHNSDW_1" description="Read of the high-order counter register, simultaneously loads the current value of the 32 LSBs into a shadow register. The read of the counter register that corresponds to this counter returns the value of the shadow register. This is applicable only when the counter is chained."/>
    </bitfield>
    <bitfield id="OVRFLW" width="1" begin="6" end="6" resetval="0" description="Counter has wrapped since it was last read" range="" rwaccess="R">
      <bitenum value="0" id="0" token="OVRFLW_0" description="The counter has not wrapped since the last read."/>
      <bitenum value="1" id="1" token="OVRFLW_1" description="The counter has wrapped since the last read."/>
    </bitfield>
    <bitfield id="IDLE" width="1" begin="5" end="5" resetval="0" description="Counter ignores processor IDLE state" range="" rwaccess="RW">
      <bitenum value="0" id="IDLE_0" token="IDLE_0" description="The counter does not increment during IDLE state."/>
      <bitenum value="1" id="IDLE_IDLEMODE_1" token="IDLE_1" description="The counter continues to function during IDLE state; applicable if IDLEMODE = 1."/>
    </bitfield>
    <bitfield id="FREE" width="1" begin="4" end="4" resetval="0" description="Counter ignores processor debug halt state" range="" rwaccess="RW">
      <bitenum value="0" id="0" token="FREE_0" description="The counter does not increment (decrement) during the debug halt state."/>
      <bitenum value="1" id="1" token="FREE_1" description="The counter continues to function during debug halt state."/>
    </bitfield>
    <bitfield id="DURMODE" width="1" begin="3" end="3" resetval="0" description="Counter is in duration or occurrence mode" range="" rwaccess="RW">
      <bitenum value="0" id="0" token="DURMODE_0" description="The counter operates in event mode. The counter increments by 1 each time a rising edge is seen on the designated input event signal."/>
      <bitenum value="1" id="1" token="DURMODE_1" description="The counter operates in duration mode. The counter increments every time a clock cycle is seen and the corresponding input event signal is asserted."/>
    </bitfield>
    <bitfield id="CHAIN" width="1" begin="2" end="2" resetval="0" description="Counter is chained to an adjacent counter" range="" rwaccess="RW">
      <bitenum value="0" id="The_counter_is_not_chained." token="CHAIN_0" description="The counter is not chained."/>
      <bitenum value="1" id="Reserved" token="CHAIN_1" description="Reserved"/>
    </bitfield>
    <bitfield id="RESET" width="1" begin="1" end="1" resetval="0" description="Counter reset control" range="" rwaccess="RW">
      <bitenum value="0" id="No_effect" token="RESET_0" description="No effect"/>
      <bitenum value="1" id="OVERFLW_1" token="RESET_1" description="The corresponding counter is reset to the initial value and the OVERFLW bit is cleared. It continues to function if it is still enabled."/>
    </bitfield>
    <bitfield id="ENBL" width="1" begin="0" end="0" resetval="0" description="Counter enable control" range="" rwaccess="RW">
      <bitenum value="0" id="The_counter_does_not_increment." token="ENBL_0" description="The counter does not increment."/>
      <bitenum value="1" id="The_counter_increments_as_configured." token="ENBL_1" description="The counter increments as configured."/>
    </bitfield>
  </register>
  <register id="SCACHE_SCTM_CTCR_WOT_j_1" acronym="SCACHE_SCTM_CTCR_WOT_j_1" offset="0x10C" width="32" description="These registers contain the control and status settings for a single counter in the module. There will be a CTCR for every counter in the module (WOT: without timer)">
    <bitfield id="RESERVED" width="11" begin="31" end="21" resetval="0x000" description="Reserved." range="" rwaccess="R"/>
    <bitfield id="INPSEL" width="5" begin="20" end="16" resetval="0x000" description="Counter input selection1&#8211;31: Index of event input signal selected ." range="" rwaccess="RW">
      <bitenum value="0" id="0" token="INPSEL_0" description="Constant low signal on the output interface"/>
    </bitfield>
    <bitfield id="RESERVED" width="8" begin="15" end="8" resetval="0x00" description="Reserved." range="" rwaccess="R"/>
    <bitfield id="CHNSDW" width="1" begin="7" end="7" resetval="0" description="Counter has a shadow register for chain reads." range="" rwaccess="R">
      <bitenum value="0" id="0" token="CHNSDW_0" description="The read of the corresponding counter register returns the current value."/>
      <bitenum value="1" id="1" token="CHNSDW_1" description="Read of the high-order counter register, simultaneously loads the current value of the 32 LSBs into a shadow register. The read of the counter register that corresponds to this counter returns the value of the shadow register. This is applicable only when the counter is chained."/>
    </bitfield>
    <bitfield id="OVRFLW" width="1" begin="6" end="6" resetval="0" description="Counter has wrapped since it was last read" range="" rwaccess="R">
      <bitenum value="0" id="0" token="OVRFLW_0" description="The counter has not wrapped since the last read."/>
      <bitenum value="1" id="1" token="OVRFLW_1" description="The counter has wrapped since the last read."/>
    </bitfield>
    <bitfield id="IDLE" width="1" begin="5" end="5" resetval="0" description="Counter ignores processor IDLE state" range="" rwaccess="RW">
      <bitenum value="0" id="IDLE_0" token="IDLE_0" description="The counter does not increment during IDLE state."/>
      <bitenum value="1" id="IDLE_IDLEMODE_1" token="IDLE_1" description="The counter continues to function during IDLE state; applicable if IDLEMODE = 1."/>
    </bitfield>
    <bitfield id="FREE" width="1" begin="4" end="4" resetval="0" description="Counter ignores processor debug halt state" range="" rwaccess="RW">
      <bitenum value="0" id="0" token="FREE_0" description="The counter does not increment (decrement) during the debug halt state."/>
      <bitenum value="1" id="1" token="FREE_1" description="The counter continues to function during debug halt state."/>
    </bitfield>
    <bitfield id="DURMODE" width="1" begin="3" end="3" resetval="0" description="Counter is in duration or occurrence mode" range="" rwaccess="RW">
      <bitenum value="0" id="0" token="DURMODE_0" description="The counter operates in event mode. The counter increments by 1 each time a rising edge is seen on the designated input event signal."/>
      <bitenum value="1" id="1" token="DURMODE_1" description="The counter operates in duration mode. The counter increments every time a clock cycle is seen and the corresponding input event signal is asserted."/>
    </bitfield>
    <bitfield id="CHAIN" width="1" begin="2" end="2" resetval="0" description="Counter is chained to an adjacent counter" range="" rwaccess="RW">
      <bitenum value="0" id="The_counter_is_not_chained." token="CHAIN_0" description="The counter is not chained."/>
      <bitenum value="1" id="Reserved" token="CHAIN_1" description="Reserved"/>
    </bitfield>
    <bitfield id="RESET" width="1" begin="1" end="1" resetval="0" description="Counter reset control" range="" rwaccess="RW">
      <bitenum value="0" id="No_effect" token="RESET_0" description="No effect"/>
      <bitenum value="1" id="OVERFLW_1" token="RESET_1" description="The corresponding counter is reset to the initial value and the OVERFLW bit is cleared. It continues to function if it is still enabled."/>
    </bitfield>
    <bitfield id="ENBL" width="1" begin="0" end="0" resetval="0" description="Counter enable control" range="" rwaccess="RW">
      <bitenum value="0" id="The_counter_does_not_increment." token="ENBL_0" description="The counter does not increment."/>
      <bitenum value="1" id="The_counter_increments_as_configured." token="ENBL_1" description="The counter increments as configured."/>
    </bitfield>
  </register>
  <register id="SCACHE_SCTM_CTCR_WOT_j_2" acronym="SCACHE_SCTM_CTCR_WOT_j_2" offset="0x110" width="32" description="These registers contain the control and status settings for a single counter in the module. There will be a CTCR for every counter in the module (WOT: without timer)">
    <bitfield id="RESERVED" width="11" begin="31" end="21" resetval="0x000" description="Reserved." range="" rwaccess="R"/>
    <bitfield id="INPSEL" width="5" begin="20" end="16" resetval="0x000" description="Counter input selection1&#8211;31: Index of event input signal selected ." range="" rwaccess="RW">
      <bitenum value="0" id="0" token="INPSEL_0" description="Constant low signal on the output interface"/>
    </bitfield>
    <bitfield id="RESERVED" width="8" begin="15" end="8" resetval="0x00" description="Reserved." range="" rwaccess="R"/>
    <bitfield id="CHNSDW" width="1" begin="7" end="7" resetval="0" description="Counter has a shadow register for chain reads." range="" rwaccess="R">
      <bitenum value="0" id="0" token="CHNSDW_0" description="The read of the corresponding counter register returns the current value."/>
      <bitenum value="1" id="1" token="CHNSDW_1" description="Read of the high-order counter register, simultaneously loads the current value of the 32 LSBs into a shadow register. The read of the counter register that corresponds to this counter returns the value of the shadow register. This is applicable only when the counter is chained."/>
    </bitfield>
    <bitfield id="OVRFLW" width="1" begin="6" end="6" resetval="0" description="Counter has wrapped since it was last read" range="" rwaccess="R">
      <bitenum value="0" id="0" token="OVRFLW_0" description="The counter has not wrapped since the last read."/>
      <bitenum value="1" id="1" token="OVRFLW_1" description="The counter has wrapped since the last read."/>
    </bitfield>
    <bitfield id="IDLE" width="1" begin="5" end="5" resetval="0" description="Counter ignores processor IDLE state" range="" rwaccess="RW">
      <bitenum value="0" id="IDLE_0" token="IDLE_0" description="The counter does not increment during IDLE state."/>
      <bitenum value="1" id="IDLE_IDLEMODE_1" token="IDLE_1" description="The counter continues to function during IDLE state; applicable if IDLEMODE = 1."/>
    </bitfield>
    <bitfield id="FREE" width="1" begin="4" end="4" resetval="0" description="Counter ignores processor debug halt state" range="" rwaccess="RW">
      <bitenum value="0" id="0" token="FREE_0" description="The counter does not increment (decrement) during the debug halt state."/>
      <bitenum value="1" id="1" token="FREE_1" description="The counter continues to function during debug halt state."/>
    </bitfield>
    <bitfield id="DURMODE" width="1" begin="3" end="3" resetval="0" description="Counter is in duration or occurrence mode" range="" rwaccess="RW">
      <bitenum value="0" id="0" token="DURMODE_0" description="The counter operates in event mode. The counter increments by 1 each time a rising edge is seen on the designated input event signal."/>
      <bitenum value="1" id="1" token="DURMODE_1" description="The counter operates in duration mode. The counter increments every time a clock cycle is seen and the corresponding input event signal is asserted."/>
    </bitfield>
    <bitfield id="CHAIN" width="1" begin="2" end="2" resetval="0" description="Counter is chained to an adjacent counter" range="" rwaccess="RW">
      <bitenum value="0" id="The_counter_is_not_chained." token="CHAIN_0" description="The counter is not chained."/>
      <bitenum value="1" id="Reserved" token="CHAIN_1" description="Reserved"/>
    </bitfield>
    <bitfield id="RESET" width="1" begin="1" end="1" resetval="0" description="Counter reset control" range="" rwaccess="RW">
      <bitenum value="0" id="No_effect" token="RESET_0" description="No effect"/>
      <bitenum value="1" id="OVERFLW_1" token="RESET_1" description="The corresponding counter is reset to the initial value and the OVERFLW bit is cleared. It continues to function if it is still enabled."/>
    </bitfield>
    <bitfield id="ENBL" width="1" begin="0" end="0" resetval="0" description="Counter enable control" range="" rwaccess="RW">
      <bitenum value="0" id="The_counter_does_not_increment." token="ENBL_0" description="The counter does not increment."/>
      <bitenum value="1" id="The_counter_increments_as_configured." token="ENBL_1" description="The counter increments as configured."/>
    </bitfield>
  </register>
  <register id="SCACHE_SCTM_CTCR_WOT_j_3" acronym="SCACHE_SCTM_CTCR_WOT_j_3" offset="0x114" width="32" description="These registers contain the control and status settings for a single counter in the module. There will be a CTCR for every counter in the module (WOT: without timer)">
    <bitfield id="RESERVED" width="11" begin="31" end="21" resetval="0x000" description="Reserved." range="" rwaccess="R"/>
    <bitfield id="INPSEL" width="5" begin="20" end="16" resetval="0x000" description="Counter input selection1&#8211;31: Index of event input signal selected ." range="" rwaccess="RW">
      <bitenum value="0" id="0" token="INPSEL_0" description="Constant low signal on the output interface"/>
    </bitfield>
    <bitfield id="RESERVED" width="8" begin="15" end="8" resetval="0x00" description="Reserved." range="" rwaccess="R"/>
    <bitfield id="CHNSDW" width="1" begin="7" end="7" resetval="0" description="Counter has a shadow register for chain reads." range="" rwaccess="R">
      <bitenum value="0" id="0" token="CHNSDW_0" description="The read of the corresponding counter register returns the current value."/>
      <bitenum value="1" id="1" token="CHNSDW_1" description="Read of the high-order counter register, simultaneously loads the current value of the 32 LSBs into a shadow register. The read of the counter register that corresponds to this counter returns the value of the shadow register. This is applicable only when the counter is chained."/>
    </bitfield>
    <bitfield id="OVRFLW" width="1" begin="6" end="6" resetval="0" description="Counter has wrapped since it was last read" range="" rwaccess="R">
      <bitenum value="0" id="0" token="OVRFLW_0" description="The counter has not wrapped since the last read."/>
      <bitenum value="1" id="1" token="OVRFLW_1" description="The counter has wrapped since the last read."/>
    </bitfield>
    <bitfield id="IDLE" width="1" begin="5" end="5" resetval="0" description="Counter ignores processor IDLE state" range="" rwaccess="RW">
      <bitenum value="0" id="IDLE_0" token="IDLE_0" description="The counter does not increment during IDLE state."/>
      <bitenum value="1" id="IDLE_IDLEMODE_1" token="IDLE_1" description="The counter continues to function during IDLE state; applicable if IDLEMODE = 1."/>
    </bitfield>
    <bitfield id="FREE" width="1" begin="4" end="4" resetval="0" description="Counter ignores processor debug halt state" range="" rwaccess="RW">
      <bitenum value="0" id="0" token="FREE_0" description="The counter does not increment (decrement) during the debug halt state."/>
      <bitenum value="1" id="1" token="FREE_1" description="The counter continues to function during debug halt state."/>
    </bitfield>
    <bitfield id="DURMODE" width="1" begin="3" end="3" resetval="0" description="Counter is in duration or occurrence mode" range="" rwaccess="RW">
      <bitenum value="0" id="0" token="DURMODE_0" description="The counter operates in event mode. The counter increments by 1 each time a rising edge is seen on the designated input event signal."/>
      <bitenum value="1" id="1" token="DURMODE_1" description="The counter operates in duration mode. The counter increments every time a clock cycle is seen and the corresponding input event signal is asserted."/>
    </bitfield>
    <bitfield id="CHAIN" width="1" begin="2" end="2" resetval="0" description="Counter is chained to an adjacent counter" range="" rwaccess="RW">
      <bitenum value="0" id="The_counter_is_not_chained." token="CHAIN_0" description="The counter is not chained."/>
      <bitenum value="1" id="Reserved" token="CHAIN_1" description="Reserved"/>
    </bitfield>
    <bitfield id="RESET" width="1" begin="1" end="1" resetval="0" description="Counter reset control" range="" rwaccess="RW">
      <bitenum value="0" id="No_effect" token="RESET_0" description="No effect"/>
      <bitenum value="1" id="OVERFLW_1" token="RESET_1" description="The corresponding counter is reset to the initial value and the OVERFLW bit is cleared. It continues to function if it is still enabled."/>
    </bitfield>
    <bitfield id="ENBL" width="1" begin="0" end="0" resetval="0" description="Counter enable control" range="" rwaccess="RW">
      <bitenum value="0" id="The_counter_does_not_increment." token="ENBL_0" description="The counter does not increment."/>
      <bitenum value="1" id="The_counter_increments_as_configured." token="ENBL_1" description="The counter increments as configured."/>
    </bitfield>
  </register>
  <register id="SCACHE_SCTM_CTCR_WOT_j_4" acronym="SCACHE_SCTM_CTCR_WOT_j_4" offset="0x118" width="32" description="These registers contain the control and status settings for a single counter in the module. There will be a CTCR for every counter in the module (WOT: without timer)">
    <bitfield id="RESERVED" width="11" begin="31" end="21" resetval="0x000" description="Reserved." range="" rwaccess="R"/>
    <bitfield id="INPSEL" width="5" begin="20" end="16" resetval="0x000" description="Counter input selection1&#8211;31: Index of event input signal selected ." range="" rwaccess="RW">
      <bitenum value="0" id="0" token="INPSEL_0" description="Constant low signal on the output interface"/>
    </bitfield>
    <bitfield id="RESERVED" width="8" begin="15" end="8" resetval="0x00" description="Reserved." range="" rwaccess="R"/>
    <bitfield id="CHNSDW" width="1" begin="7" end="7" resetval="0" description="Counter has a shadow register for chain reads." range="" rwaccess="R">
      <bitenum value="0" id="0" token="CHNSDW_0" description="The read of the corresponding counter register returns the current value."/>
      <bitenum value="1" id="1" token="CHNSDW_1" description="Read of the high-order counter register, simultaneously loads the current value of the 32 LSBs into a shadow register. The read of the counter register that corresponds to this counter returns the value of the shadow register. This is applicable only when the counter is chained."/>
    </bitfield>
    <bitfield id="OVRFLW" width="1" begin="6" end="6" resetval="0" description="Counter has wrapped since it was last read" range="" rwaccess="R">
      <bitenum value="0" id="0" token="OVRFLW_0" description="The counter has not wrapped since the last read."/>
      <bitenum value="1" id="1" token="OVRFLW_1" description="The counter has wrapped since the last read."/>
    </bitfield>
    <bitfield id="IDLE" width="1" begin="5" end="5" resetval="0" description="Counter ignores processor IDLE state" range="" rwaccess="RW">
      <bitenum value="0" id="IDLE_0" token="IDLE_0" description="The counter does not increment during IDLE state."/>
      <bitenum value="1" id="IDLE_IDLEMODE_1" token="IDLE_1" description="The counter continues to function during IDLE state; applicable if IDLEMODE = 1."/>
    </bitfield>
    <bitfield id="FREE" width="1" begin="4" end="4" resetval="0" description="Counter ignores processor debug halt state" range="" rwaccess="RW">
      <bitenum value="0" id="0" token="FREE_0" description="The counter does not increment (decrement) during the debug halt state."/>
      <bitenum value="1" id="1" token="FREE_1" description="The counter continues to function during debug halt state."/>
    </bitfield>
    <bitfield id="DURMODE" width="1" begin="3" end="3" resetval="0" description="Counter is in duration or occurrence mode" range="" rwaccess="RW">
      <bitenum value="0" id="0" token="DURMODE_0" description="The counter operates in event mode. The counter increments by 1 each time a rising edge is seen on the designated input event signal."/>
      <bitenum value="1" id="1" token="DURMODE_1" description="The counter operates in duration mode. The counter increments every time a clock cycle is seen and the corresponding input event signal is asserted."/>
    </bitfield>
    <bitfield id="CHAIN" width="1" begin="2" end="2" resetval="0" description="Counter is chained to an adjacent counter" range="" rwaccess="RW">
      <bitenum value="0" id="The_counter_is_not_chained." token="CHAIN_0" description="The counter is not chained."/>
      <bitenum value="1" id="Reserved" token="CHAIN_1" description="Reserved"/>
    </bitfield>
    <bitfield id="RESET" width="1" begin="1" end="1" resetval="0" description="Counter reset control" range="" rwaccess="RW">
      <bitenum value="0" id="No_effect" token="RESET_0" description="No effect"/>
      <bitenum value="1" id="OVERFLW_1" token="RESET_1" description="The corresponding counter is reset to the initial value and the OVERFLW bit is cleared. It continues to function if it is still enabled."/>
    </bitfield>
    <bitfield id="ENBL" width="1" begin="0" end="0" resetval="0" description="Counter enable control" range="" rwaccess="RW">
      <bitenum value="0" id="The_counter_does_not_increment." token="ENBL_0" description="The counter does not increment."/>
      <bitenum value="1" id="The_counter_increments_as_configured." token="ENBL_1" description="The counter increments as configured."/>
    </bitfield>
  </register>
  <register id="SCACHE_SCTM_CTCR_WOT_j_5" acronym="SCACHE_SCTM_CTCR_WOT_j_5" offset="0x11C" width="32" description="These registers contain the control and status settings for a single counter in the module. There will be a CTCR for every counter in the module (WOT: without timer)">
    <bitfield id="RESERVED" width="11" begin="31" end="21" resetval="0x000" description="Reserved." range="" rwaccess="R"/>
    <bitfield id="INPSEL" width="5" begin="20" end="16" resetval="0x000" description="Counter input selection1&#8211;31: Index of event input signal selected ." range="" rwaccess="RW">
      <bitenum value="0" id="0" token="INPSEL_0" description="Constant low signal on the output interface"/>
    </bitfield>
    <bitfield id="RESERVED" width="8" begin="15" end="8" resetval="0x00" description="Reserved." range="" rwaccess="R"/>
    <bitfield id="CHNSDW" width="1" begin="7" end="7" resetval="0" description="Counter has a shadow register for chain reads." range="" rwaccess="R">
      <bitenum value="0" id="0" token="CHNSDW_0" description="The read of the corresponding counter register returns the current value."/>
      <bitenum value="1" id="1" token="CHNSDW_1" description="Read of the high-order counter register, simultaneously loads the current value of the 32 LSBs into a shadow register. The read of the counter register that corresponds to this counter returns the value of the shadow register. This is applicable only when the counter is chained."/>
    </bitfield>
    <bitfield id="OVRFLW" width="1" begin="6" end="6" resetval="0" description="Counter has wrapped since it was last read" range="" rwaccess="R">
      <bitenum value="0" id="0" token="OVRFLW_0" description="The counter has not wrapped since the last read."/>
      <bitenum value="1" id="1" token="OVRFLW_1" description="The counter has wrapped since the last read."/>
    </bitfield>
    <bitfield id="IDLE" width="1" begin="5" end="5" resetval="0" description="Counter ignores processor IDLE state" range="" rwaccess="RW">
      <bitenum value="0" id="IDLE_0" token="IDLE_0" description="The counter does not increment during IDLE state."/>
      <bitenum value="1" id="IDLE_IDLEMODE_1" token="IDLE_1" description="The counter continues to function during IDLE state; applicable if IDLEMODE = 1."/>
    </bitfield>
    <bitfield id="FREE" width="1" begin="4" end="4" resetval="0" description="Counter ignores processor debug halt state" range="" rwaccess="RW">
      <bitenum value="0" id="0" token="FREE_0" description="The counter does not increment (decrement) during the debug halt state."/>
      <bitenum value="1" id="1" token="FREE_1" description="The counter continues to function during debug halt state."/>
    </bitfield>
    <bitfield id="DURMODE" width="1" begin="3" end="3" resetval="0" description="Counter is in duration or occurrence mode" range="" rwaccess="RW">
      <bitenum value="0" id="0" token="DURMODE_0" description="The counter operates in event mode. The counter increments by 1 each time a rising edge is seen on the designated input event signal."/>
      <bitenum value="1" id="1" token="DURMODE_1" description="The counter operates in duration mode. The counter increments every time a clock cycle is seen and the corresponding input event signal is asserted."/>
    </bitfield>
    <bitfield id="CHAIN" width="1" begin="2" end="2" resetval="0" description="Counter is chained to an adjacent counter" range="" rwaccess="RW">
      <bitenum value="0" id="The_counter_is_not_chained." token="CHAIN_0" description="The counter is not chained."/>
      <bitenum value="1" id="Reserved" token="CHAIN_1" description="Reserved"/>
    </bitfield>
    <bitfield id="RESET" width="1" begin="1" end="1" resetval="0" description="Counter reset control" range="" rwaccess="RW">
      <bitenum value="0" id="No_effect" token="RESET_0" description="No effect"/>
      <bitenum value="1" id="OVERFLW_1" token="RESET_1" description="The corresponding counter is reset to the initial value and the OVERFLW bit is cleared. It continues to function if it is still enabled."/>
    </bitfield>
    <bitfield id="ENBL" width="1" begin="0" end="0" resetval="0" description="Counter enable control" range="" rwaccess="RW">
      <bitenum value="0" id="The_counter_does_not_increment." token="ENBL_0" description="The counter does not increment."/>
      <bitenum value="1" id="The_counter_increments_as_configured." token="ENBL_1" description="The counter increments as configured."/>
    </bitfield>
  </register>
  <register id="SCACHE_SCTM_CTCNTR_k_0" acronym="SCACHE_SCTM_CTCNTR_k_0" offset="0x180" width="32" description="These registers contain the value of an individual counter in the moduel. There will be a CTCNTR for every counter in the module">
    <bitfield id="COUNT" width="32" begin="31" end="0" resetval="0x0000 0000" description="Counter value" range="" rwaccess="R"/>
  </register>
  <register id="SCACHE_SCTM_CTCNTR_k_1" acronym="SCACHE_SCTM_CTCNTR_k_1" offset="0x184" width="32" description="These registers contain the value of an individual counter in the moduel. There will be a CTCNTR for every counter in the module">
    <bitfield id="COUNT" width="32" begin="31" end="0" resetval="0x0000 0000" description="Counter value" range="" rwaccess="R"/>
  </register>
  <register id="SCACHE_SCTM_CTCNTR_k_2" acronym="SCACHE_SCTM_CTCNTR_k_2" offset="0x188" width="32" description="These registers contain the value of an individual counter in the moduel. There will be a CTCNTR for every counter in the module">
    <bitfield id="COUNT" width="32" begin="31" end="0" resetval="0x0000 0000" description="Counter value" range="" rwaccess="R"/>
  </register>
  <register id="SCACHE_SCTM_CTCNTR_k_3" acronym="SCACHE_SCTM_CTCNTR_k_3" offset="0x18C" width="32" description="These registers contain the value of an individual counter in the moduel. There will be a CTCNTR for every counter in the module">
    <bitfield id="COUNT" width="32" begin="31" end="0" resetval="0x0000 0000" description="Counter value" range="" rwaccess="R"/>
  </register>
  <register id="SCACHE_SCTM_CTCNTR_k_4" acronym="SCACHE_SCTM_CTCNTR_k_4" offset="0x190" width="32" description="These registers contain the value of an individual counter in the moduel. There will be a CTCNTR for every counter in the module">
    <bitfield id="COUNT" width="32" begin="31" end="0" resetval="0x0000 0000" description="Counter value" range="" rwaccess="R"/>
  </register>
  <register id="SCACHE_SCTM_CTCNTR_k_5" acronym="SCACHE_SCTM_CTCNTR_k_5" offset="0x194" width="32" description="These registers contain the value of an individual counter in the moduel. There will be a CTCNTR for every counter in the module">
    <bitfield id="COUNT" width="32" begin="31" end="0" resetval="0x0000 0000" description="Counter value" range="" rwaccess="R"/>
  </register>
  <register id="SCACHE_SCTM_CTCNTR_k_6" acronym="SCACHE_SCTM_CTCNTR_k_6" offset="0x198" width="32" description="These registers contain the value of an individual counter in the moduel. There will be a CTCNTR for every counter in the module">
    <bitfield id="COUNT" width="32" begin="31" end="0" resetval="0x0000 0000" description="Counter value" range="" rwaccess="R"/>
  </register>
  <register id="SCACHE_SCTM_CTCNTR_k_7" acronym="SCACHE_SCTM_CTCNTR_k_7" offset="0x19C" width="32" description="These registers contain the value of an individual counter in the moduel. There will be a CTCNTR for every counter in the module">
    <bitfield id="COUNT" width="32" begin="31" end="0" resetval="0x0000 0000" description="Counter value" range="" rwaccess="R"/>
  </register>
</module>
