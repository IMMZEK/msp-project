<?xml version="1.0" encoding="UTF-8" standalone="yes"?>


<module description="MSS_SPI" id="MSS_SPI">
  
  
  <register acronym="SPIGCR0" description="SPI / MibSPI Global Control Register 0" id="SPIGCR0" offset="0x0" width="32">
    
  <bitfield begin="31" description="Reserved, Reads return ‘0’ and writes have no effect." end="1" id="NU" rwaccess="R" width="31"></bitfield>
    
  <bitfield begin="0" description="This is the local reset control for the module. This bit needs to be set to ‘1’ before any operation on SPI / MibSPI can be done. Only after setting this bit to ‘1’, the Auto Initialization of Multibuffer RAM starts. Clearing this bit to ‘0’ will result in all of the control and status register values to return to their default values. 0 = SPI / MibSPI is in reset state 1 = SPI / MibSPI is out of reset state." end="0" id="nRESET" rwaccess="RW" width="1"></bitfield>
  </register>
  
  
  <register acronym="SPIGCR1" description="SPI / MibSPI Global control register 1" id="SPIGCR1" offset="0x4" width="32">
    
  <bitfield begin="31" description="Reserved. Reads return ‘0’ and writes have no effect." end="25" id="NU4" rwaccess="R" width="7"></bitfield>
    
  <bitfield begin="24" description="SPI enable. This bit enables the SPI/MibSPI transfers. This bit must be set to 1 after all other SPI / MibSPI configuration bits have been written. When SPIEN bit is 0 or cleared to 0, the following SPI/MibSPI registers get forced to their default states (to ‘0’s except for RXEMPTY bit in SPIBUF): - Both TX &amp; RX Shift Registers - The TXDATA fields of SPIDAT0 and SPIDAT1 registers - All the fields of SPIFLG register - Contents of SPIBUF &amp; the internal RXBUF registers 0=SPI / MibSPI is not activated for transfers. 1=Activates SPI / MibSPI" end="24" id="SPIEN" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="23" description="Reserved. Reads return ‘0’ and writes have no effect." end="17" id="NU3" rwaccess="R" width="7"></bitfield>
    
  <bitfield begin="16" description="LOOP BACK. Internal loop-back test mode. The internal self-test option can be enabled by setting this bit. If the SPISIMO and SPISOMI pins are configured with SPI functionality, then the SPISIMO pin is internally connected to the SPISOMI pin. The transmit data is looped back as receive data and is stored in the receive field of the concerned buffer. Externally, during loop-back operation, the SPICLK pin outputs an inactive value and SPISOMI remains in high-impedance state. The SPI / MibSPI has to be initialized in master mode before the loop-back can be selected. If the SPI / MibSPI is initialized in slave mode or a data transfer is ongoing, errors may result. 1 =Internal loop-back test mode enabled. 0 =Internal loop-back test mode disabled.  This loopback mode can be used only in Master mode. This automatically selects digital loopback path. When this Loopback mode is selected, CLKMOD bit should be set to ‘1’, meaning that SPICLK can only be internal." end="16" id="LOOPBACK" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="15" description="Reserved. Reads return ‘0’ and writes have no effect." end="9" id="NU2" rwaccess="R" width="7"></bitfield>
    
  <bitfield begin="8" description="POWERDOWN. When active, the SPI / MibSPI state machines enter a powerdown state. 0=MibSPI in active mode 1=MibSPI in powerdown mode" end="8" id="POWERDOWN" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="7" description="Reserved. Reads return ‘0’ and writes have no effect." end="2" id="NU1" rwaccess="R" width="6"></bitfield>
    
  <bitfield begin="1" description="CLKMOD. Clock mode Selects either an internal or external clock source. This bit also determines the I/O direction of the SPIENA and SPISCS[7:0] pins in functional mode. 0=Clock is external 1=Clock is internal" end="1" id="CLKMOD" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="0" description="MASTER: SPISIMO/SPISOMI pin direction determination. Determines the direction of the SPISIMO and SPISOMI pins. This bit determines whether the SPI/MibSPI is in Master mode or Slave mode. This bit also controls the Master-only features like the C2T/T2C counters, C2E/T2E timers, most of the Error conditions specific to Master mode. 0=SPISIMO pin an input, SPISOMI pin an output 1=SPISOMI pin an input, SPISIMO pin an output Note: Although there are two different bits which control the Master/Slave mode functions, only two of their combinations are valid. For compatibility reasons both the bits are retained. For Master mode of operation: MASTER = ‘1’, CLKMOD = ‘1’ For Slave mode of operation: MASTER = ‘0’, CLKMOD = ‘0’ Any other combinations of these two bits may not yield any desirable operation of the module." end="0" id="MASTER" rwaccess="RW" width="1"></bitfield>
  </register>
  
  
  <register acronym="SPIINT0" description="SPI / MibSPI Interrupt Enable Register" id="SPIINT0" offset="0x8" width="32">
    
  <bitfield begin="31" description="Reserved. Reads return ‘0’ and writes have no effect." end="25" id="NU5" rwaccess="R" width="7"></bitfield>
    
  <bitfield begin="24" description="SPIENA pin high-z enable. When active, the SPIENA pin (when it is configured as a WAIT functional output signal in a slave SPI) is forced to place it is output in high-z when not driving a low signal. If inactive, then the pin will output both a high and a low signal. 0=SPIENA pin is pulled high when not active. 1=SPIENA pin remains in high-z when not active." end="24" id="ENABLEHIGHZ" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="23" description="Reserved. Reads return ‘0’ and writes have no effect." end="17" id="NU4" rwaccess="R" width="7"></bitfield>
    
  <bitfield begin="16" description="DMA request enable. Enables the DMA request signal to be generated for both receive and transmit channels. Enable DMA REQ only after setting the SPIEN bit to ‘1’. 0=DMA is not used 1=DMA Requests will be generated. A DMA request will be generated on TX DMA REQ line each time a transmit data is copied to the Shift Register either from TXBUF or directly from SPIDAT0/SPIDAT1 writes. A DMA request will be generated on RX DMA REQ line each time a received data is copied to SPIBUF register either from RXBUF or directly from the Shift Register." end="16" id="DMAREQEN" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="15" description="Reserved. Reads return ‘0’ and writes have no effect." end="10" id="NU3" rwaccess="R" width="6"></bitfield>
    
  <bitfield begin="9" description="An interrupt is to be generated everytime data is written to the “Shift Register”, so that a new data can be written to TXBUF. Setting this bit will generate an interrupt if TXINTFLG bit (SPIFLG.9) is set to ‘1’. 0=No interrupt will be generated upon TXINTFLG getting set to ‘1’. 1=Interrupt will be generated upon TXINTFLG getting set to ‘1’. An interrupt request will be generated as soon as this bit is set to ‘1’. By default it will be generated on INT0 line. SPILVL register can be programmed before-hand to change this default." end="9" id="TXINTENA" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="8" description="An interrupt is to be generated when the RXINTFLAG bit (SPIFLG.8) is set by hardware. Otherwise, no interrupt will be generated. 0=Interrupt will not be generated 1=Interrupt will be generated Both Transmitter Empty &amp; Receiver Full interrupts are valid in SPI or Compatibility mode of MibSPI only. In Multibuffered mode these interrupts will not be generated even if enabled." end="8" id="RXINTENA" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="7" description="Reserved. Reads return ‘0’ and writes have no effect." end="7" id="NU2" rwaccess="R" width="1"></bitfield>
    
  <bitfield begin="6" description="Overrun interrupt enable. An interrupt is to be generated when the RCVR OVRN flag bit (SPIFLG.6) is set by hardware. Otherwise, no interrupt will be generated. 0=Overrun interrupt will not be generated 1=Overrun interrupt will be generated" end="6" id="OVRNINTENA" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="5" description="Reserved. Reads return ‘0’ and writes have no effect." end="5" id="NU1" rwaccess="R" width="1"></bitfield>
    
  <bitfield begin="4" description="Enables interrupt on bit error. 1 =Enables an interrupt on a bit error (BITERR = 1). 0 =No interrupt asserted upon bit error." end="4" id="BITERRENA" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="3" description="Enables interrupt on de-synchronized slave. DESYNCENA is used in master mode only. 1 =Enables an interrupt on de-synchronization of the slave (DESYNC = 1). 0 =No interrupt asserted upon de-synchronization error." end="3" id="DESYNCENA" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="2" description="Enables interrupt on parity error. 1 =Enables an interrupt on a parity error (PARITYERR = 1). 0 =No interrupt asserted upon parity error." end="2" id="PARERRENA" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="1" description="Enables interrupt on ENA signal time-out. 1 =Enables an interrupt on a time-out of the ENA signal (TIMEOUT = 1). 0 =No interrupt asserted upon ENA signal time-out." end="1" id="TIMEOUTENA" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="0" description="Data Length Error interrupt Enable. 1 = Enables an interrupt when Data Length Error occurs. 0 = No interrupt is generated upon Data Length Error. A Data Length Error occurs under the following conditions. Master: In a 4-pin with SPIENA mode or 5-pin mode, if the SPIENA pin from the slave is deasserted before the Master has completed its transfer, the Data Length Error is set. That is, if the Character Length counter has not completed counting while SPIENA deassertion is detected, then it means that the Slave has neither received full data from the Master nor has it transmitted complete data. Slave: In a 4-pin with ChipSelects mode or 5-pin mode, if the incoming valid SPISCS pin is de-activated before the Character Length counter completes counting, then Data Length Error is set." end="0" id="DLENERRENA" rwaccess="RW" width="1"></bitfield>
  </register>
  
  
  <register acronym="SPILVL" description="SPI / MibSPI Interrupt Level Register" id="SPILVL" offset="0xC" width="32">
    
  <bitfield begin="31" description="Reserved. Reads return ‘0’ and writes have no effect." end="10" id="NU3" rwaccess="R" width="22"></bitfield>
    
  <bitfield begin="9" description="Transmit Interrupt Level. 1 =Transmit interrupt is mapped to interrupt line INT1. 0 =Transmit interrupt is mapped to interrupt line INT0." end="9" id="TXINTLVL" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="8" description="Receive interrupt level. 1 =Receive interrupt is mapped to interrupt line INT1. 0 =Receive interrupt is mapped to interrupt line INT0." end="8" id="RXINTLVL" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="7" description="Reserved. Reads return ‘0’ and writes have no effect." end="7" id="NU2" rwaccess="R" width="1"></bitfield>
    
  <bitfield begin="6" description="Receive Overrun interrupt level. 1 =Receive Overrun interrupt is mapped to interrupt line INT1. 0 =Receive Overrun interrupt is mapped to interrupt line INT0." end="6" id="OVRNINTLVL" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="5" description="Reserved. Reads return ‘0’ and writes have no effect." end="5" id="NU1" rwaccess="R" width="1"></bitfield>
    
  <bitfield begin="4" description="Bit error interrupt level. 1 =bit error interrupt is mapped to interrupt line INT1. 0 =bit error interrupt is mapped to interrupt line INT0." end="4" id="BITERRLVL" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="3" description="De-synchronized slave interrupt level. DESYNCLVL is used in master mode only. 1 =An interrupt due to de-synchronization of the slave (DESYNC = 1) is mapped to interrupt line INT1. 0 =An interrupt due to de-synchronization of the slave (DESYNC = 1) is mapped to interrupt line INT0." end="3" id="DESYNCLVL" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="2" description="Parity error interrupt level. 1 =A parity error interrupt (PARITYERR = 1) is mapped to interrupt line INT1. 0 =A parity error interrupt (PARITYERR = 1) is mapped to interrupt line INT0." end="2" id="PARERRLVL" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="1" description="SPIENA pin Time-out interrupt level. 1 =An interrupt on a time-out of the ENA signal (TIMEOUT = 1) is mapped to interrupt line INT1. 0 =An interrupt on a time-out of the ENA signal (TIMEOUT = 1) is mapped to interrupt line INT0." end="1" id="TIMEOUTLVL" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="0" description="Data Length Error interrupt Enable Level. 1 = An interrupt on Data Length Error is mapped to interrupt line INT1. 0 = An interrupt on Data Length Error is mapped to interrupt line INT0." end="0" id="DLENERRLVL" rwaccess="RW" width="1"></bitfield>
  </register>
  
  
  <register acronym="SPIFLG" description="SPI / MibSPI Flag Register" id="SPIFLG" offset="0x10" width="32">
    
  <bitfield begin="31" description="Reserved. Reads return ‘0’ and writes have no effect." end="25" id="NU4" rwaccess="R" width="7"></bitfield>
    
  <bitfield begin="24" description="Indicates the status of Multibuffer initialization process. Software should poll this bit to determine if it can proceed with the configuration of Multibuffer mode registers or Multibuffer RAM handling. Refer to Section 3.10.7 for details on Initialization of Multibuffer RAM. 1 = Multibuffer RAM is still being initialized. Do not attempt to write to either Multibuffer RAM or any Multibuffer mode registers. Refer to Section 3.3 for a classification of registers into compatibility mode and Multibuffer mode. 0 = Multibuffer RAM initialization is complete. This bit will show a value of ‘1’ as long as the nRESET bit is ‘0’, but does not really indicate that Buffer initialization is underway. Internal automatic buffer initialization starts only when the nRESET bit is set to ‘1’. For SPI, this bit reads ‘1’ always. For MibSPI, BUF INIT ACTIVE bit will show up as ‘1’ for a maximum of 128/256 (will vary depending upon the actual size of the Multibuffer RAM implemented) VCLK cycles after the nRESET bit in GCR0 is set to ‘1’ and then settle to ‘0’. If Auto Memory Initialization is triggered through System (MEM_AUTO_INIT pulse), then BUF INIT ACTIVE bit will show up as ‘1’ for a maximum of 128/256 (will vary depending upon the actual size of the Multibuffer RAM implemented) VCLK cycles and then settle to ‘0’." end="24" id="BUFINITACTIVE" rwaccess="R" width="1"></bitfield>
    
  <bitfield begin="23" description="Reserved. Reads return ‘0’ and writes have no effect." end="10" id="NU3" rwaccess="R" width="14"></bitfield>
    
  <bitfield begin="9" description="Transmitter Empty Interrupt Flag. Serves as an interrupt flag indicating that Transmit Buffer (TXBUF) is empty and a new data can be written to it. This flag is set when a data is copied to the “Shift Register” either directly or from the TXBUF register. This bit is cleared by one of following ways: Writing a new data to either SPIDAT0 or SPIDAT1 Writing a ‘0’ to SPIEN (SPIGCR1.24) 0= Transmit Buffer is now full. No interrupt pending for Transmitter Empty 1= Transmit Buffer is empty. An interrupt is pending to fill the transmitter." end="9" id="TXINTFLG" rwaccess="R" width="1"></bitfield>
    
  <bitfield begin="8" description="Receiver Full Interrupt Flag. This flag is set when a word is received and copied into the buffer register (SPIBUF). If RXINTEN is enabled, an interrupt is also generated. During emulation mode, however, a read to the emulation register (SPIEMU) does not clear this flag bit. This bit is cleared under the following ways: Reading the SPIBUF register Reading TGINTVECT0 or TGINTVECT1 register when there is a “Receive Buffer Full” interrupt Writing a ‘1’ to this bit Writing a ‘0’ to SPIEN (SPIGCR1.24) System reset 0= No new received data pending. Receive buffer is Empty. 1= A newly received data is ready to be read. Receive buffer is full. Note: Exception for clearing of RXINT If both SPIBUF and RXBUF (internal buffer) are full, then, reading TGINTVECT0 or TGINTVECT1 register (while it shows 10010) does not clear the RXINTFLG in SPIFLG register. In this case, only way to clear the Interrupt is to read the SPIBUF (twice) and clear all the received data. Note: Side effects of Write Clear to RXINTFLG Clearing RXINTFLG bit by writing a ‘1’ before reading the SPIBUF sets the RXEMPTY bit of the SPIBUF register too. This way, one can ignore a received data. However, if the internal RXBUF is already full, the data from RXBUF will be copied to SPIBUF and RXEMPTY bit will be cleared again. SPIBUF contents should be read first if this situation needs to be avoided." end="8" id="RXINTFLG" rwaccess="" width="1"></bitfield>
    
  <bitfield begin="7" description="Reserved. Reads return ‘0’ and writes have no effect." end="7" id="NU2" rwaccess="R" width="1"></bitfield>
    
  <bitfield begin="6" description="Receiver overrun flag. The SPI / MibSPI hardware sets this bit when a receive operation completes before the previous character has been read from the receive buffer. The bit indicates that the last received character has been overwritten and therefore lost. The SPI / MibSPI will generate an interrupt request if this bit is set and the OVRN INTEN bit (SPIINT0.6) is set high. 0 = Overrun condition did not occur 1 = Overrun condition has occurred In SPI or Compatibility mode of MibSPI, this bit is cleared under the following conditions: Reading TGINTVECT0 or TGINTVECT1 register when there is a “Receive Buffer Overrun” interrupt Writing a ‘1’ to OVRNINTFLG in SPIFLG register itself Reading SPIBUF register does not clear this OVRNINTFLG bit. If an RXOVRN interrupt is detected, then the SPIBUF may need to be read twice to get to the Overrun buffer. This is due to the fact that the Overrun will always occur to the internal RXBUF. Each read to the SPIBUF will result in RXBUF contents (if it is full) getting copied to SPIBUF. Note: A special condition under which OVRNINTFLG flag gets set. If both SPIBUF &amp; RXBUF are already full and while another buffer receive is underway, if any errors like TIMEOUT, BITERR &amp; DLEN_ERR occur, then RXOVR in RXBUF &amp; OVRNINTFLG in SPIFLG registers will be set to indicate that the status flags are getting overwritten by the new transfer. This overrun should be treated like a normal Receiver Overrun. In Multibuffer mode of MibSPI, this bit is cleared under the following conditions. Reading the RXOVRN_BUF_ADDR register Writing a ‘1’ to OVRNINTFLG in SPIFLG register itself In Multibuffer mode, if OVRNINTFLG is set, then the address of the buffer which experienced the Overrun is available in RXOVRN_BUF_ADDR." end="6" id="OVRNINTFLG" rwaccess="" width="1"></bitfield>
    
  <bitfield begin="5" description="Reserved. Reads return ‘0’ and writes have no effect." end="5" id="NU1" rwaccess="R" width="1"></bitfield>
    
  <bitfield begin="4" description="Mismatch of internal transmit data and transmitted data. 1 =A bit error occurred. The SPI / MibSPI samples the signal of the transmit pin (master: SIMO, slave: SOMI) at the receive point (half clock cycle after transmit point). If the sampled value differs from the transmitted value a bit error is detected and the Flag BITERR is set. If BITERRENA is set an interrupt is asserted. A possible reason for a bit error can be a to high bit rate / capacitive load or another master/slave trying to transmit at the same time. 0 =No bit error occurred. This flag can be cleared by one of the following ways. Write a ‘1’ to this bit. Set SPIEN bit to ‘0’." end="4" id="BITERRFLG" rwaccess="" width="1"></bitfield>
    
  <bitfield begin="3" description="De-synchronization of slave device. De-synchronization monitor is active in master mode only. 1 = A slave device is de-synchronized. The master monitors the ENAble signal coming from the slave device and sets the DESYNC flag after the last bit is transmitted plus tT2EDELAY (see Section 8.21). If DESYNCENA is set an interrupt is asserted. De-synchronization can occur if a slave device misses a clock edge coming from the master. 0 =No slave de-synchronization detected. This flag can be cleared by one of the following ways. Write a ‘1’ to this bit. Set SPIEN bit to ‘0’. Note: Inconsistency of Desync flag in SPI/Compatibility mode MibSPI Due to the nature of this Error, under some circumstances it is possible for Desync error detected for the previous buffer to be visible in the current buffer. This is due to the fact that Receive Completion flag/interrupt will be generated when the buffer transfer is completed. But Desync will be detected after the buffer transfer is completed. So, if VBUS master reads the received data quickly when an RXINT is detected, then the status flag may not reflect the correct Desync condition. This inconsistency in Desync flag is valid only in SPI or Compatibility mode of MibSPI. In Multibuffer mode, Desync flag is always guaranteed to be for the current buffer." end="3" id="DESYNCFLG" rwaccess="" width="1"></bitfield>
    
  <bitfield begin="2" description="Calculated parity differs from received parity bit. 1 =A parity error occurred. If the parity generator is enabled (can be selected individually for each buffer) an even or odd parity bit is added at the end of a data word (see Section 8.23). During reception of the data word the parity generator calculates the reference parity and compares it to the received parity bit. In the event of a mismatch the PARITYERR flag is set and an interrupt is asserted if PARERRENA is set. 0 =No parity error detected. This flag can be cleared by one of the following ways. Write a ‘1’ to this bit. Set SPIEN bit to ‘0’." end="2" id="PARERRFLG" rwaccess="" width="1"></bitfield>
    
  <bitfield begin="1" description="Time-out due to non-activation of ENA signal. 1 =An ENA signal time-out occurred. The SPI / MibSPI generates a time-out because the slave hasn’t responded in time by activating the ENA signal after the chip select signal has been activated. If a time-out condition is detected the corresponding chip select is deactivated immediately and the TIMEOUT flag is set. In addition the TIMOUT flag in the status field of the corresponding buffer is set. The transmit request of the concerned buffer is cleared, i.e. the SPI / MibSPI doesn’t re-start a data transfer from this buffer. 0 =No ENA-signal time-out occurred. This flag can be cleared by one of the following ways. Write a ‘1’ to this bit. Set SPIEN bit to ‘0’." end="1" id="TIMEOUTFLG" rwaccess="" width="1"></bitfield>
    
  <bitfield begin="0" description="Data Length Error Flag. 1 = A Data Length Error has occured. 0 = No Data Length Error has occured. This flag can be cleared by one of the following ways. Write a ‘1’ to this bit. Set SPIEN bit to ‘0’. A Data Length Error occurs under the following conditions. Master: In a 4-pin with SPIENA mode or 5-pin mode, if the SPIENA pin from the slave is deasserted before the Master has completed its transfer, the Data Length Error is set. That is, if the Character Length counter has not completed counting while SPIENA pin deassertion is detected, then it means that the Slave has neither received full data from the Master nor has it transmitted complete data. Slave: In a 4-pin with ChipSelects mode or 5-pin mode, if the incoming valid SPISCS pin is de-activated before the Character Length counter completes counting, then Data Length Error is set. Note: Clearing of Transmission Error Flags in SPIBUF during Error conditions Whenever any Transmission Errors (TIMEOUT, BITERR, DLEN_ERR, PARITY_ERR, DESYNC) are detected, and the Error Flag are cleared by writing to the Error bit in SPIFLG register, the corresponding Error flag in SPIBUF does not get cleared. Software needs to read the SPIBUF until it becomes empty before proceeding. This ensures that all the older status bits in SPIBUF are cleared before starting the next transfer." end="0" id="DLENERRFLG" rwaccess="" width="1"></bitfield>
  </register>
  
  
  <register acronym="SPIPC0" description="SPI / MibSPI Pin Control Register 0 (SPIPC0) - SPIFUN Note: Duplicate Control Bits for SIMO0 &amp; SOMI0 Bit 24 is not physically implemented. it is a mirror of Bit11. Any write to Bit 24 will be reflected on Bit11 and when Bit 24 &amp; Bit 11 simultaneously written, the value of Bit11 will control the SOMI pin. Read value of Bit 24 always reflects the Bit 11 value. This is true for the Bit 24 &amp; Bit 11 of all of SPIPC0 to SPIPC9 registers. Same is true for SIMO pin with Bit16 &amp; Bit 10 of SPIPC0 to SPIPC9 registers." id="SPIPC0" offset="0x14" width="32">
    
  <bitfield begin="31" description="Slave out, master in function. Determines whether the SPISOMIx pins are to be used as a general-purpose I/O pin or as a SPI / MibSPI functional pin. 0=SPISOMIx pin is a GPIO 1=SPISOMIx pin is a SPI / MibSPI functional pin" end="24" id="SOMIFUN" rwaccess="RW" width="8"></bitfield>
    
  <bitfield begin="23" description="Slave in, master out function. Determines whether the SPISIMOx pin is to be used as a general-purpose I/O pin or as a SPI / MibSPI functional pin. 0=SPISIMOx pin is a GPIO 1=SPISIMOx pin is a SPI / MibSPI functional pin Note: Generic based bit implementation Register bits 31 to 24 and 23 to 16 of SPIPC0 to SPIPC9 are implemented depending upon the generic parameter NUM_PARLL_PINS which determines the number of SIMO/SOMI data lines to be supported. Only if 8 dataline support is selected at the time of logic synthesis, bits 31 to 16 are implemented. Un-implemented bits return ‘0’ upon read and are not writable." end="16" id="SIMOFUN" rwaccess="RW" width="8"></bitfield>
    
  <bitfield begin="15" description="Reserved. Reads return ‘0’ and writes have no effect." end="12" id="NU" rwaccess="R" width="4"></bitfield>
    
  <bitfield begin="11" description="Slave out, master in function. Determines whether the SPISOMI0 pin is to be used as a general-purpose I/O pin or as a SPI / MibSPI functional pin. 0=SPISOMI0 pin is a GPIO 1=SPISOMI0 pin is a SPI / MibSPI functional pin Note: Bit 11 or bit 24 can be used to set the function mode for pin SOMI0. If a 32 bit write is performed, bit 11 will have priority over bit 24." end="11" id="SOMIFUN0" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="10" description="Slave in, master out function. Determines whether the SPISIMO0 pin is to be used as a general-purpose I/O pin, or as a SPI / MibSPI functional pin. 0=SPISIMO0 pin is a GPIO 1=SPISIMO0 pin is a SPI / MibSPI functional pin Note: Bit 10 or bit 16 can be used to set the function mode for pin SIMO0. If a 32 bit write is performed, bit 10 will have priority over bit 16." end="10" id="SIMOFUN0" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="9" description="SPI / MibSPI clock function. Determines whether the SPICLK pin is to be used as a general-purpose I/O pin, or as a SPI / MibSPI functional pin. 0=SPICLK pin is a GPIO 1=SPICLK pin is a SPI / MibSPI functional pin" end="9" id="CLKFUN" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="8" description="SPIENA function. Determines whether the SPIENA pin is to be used as a general-purpose I/O pin, or as a SPI / MibSPI functional pin. 0=SPIENA pin is a GPIO 1=SPIENA pin is a SPI / MibSPI functional pin" end="8" id="ENAFUN" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="7" description="SPISCS[7:0] function. Determines whether the SPISCSx pins are to be used as a general-purpose I/O pins or as SPI functional pins. If the slave SPISCSx pins are in functional mode and receive an inactive high signal, the slave SPI will place it is output in high-z and disable shifting. 0=SPISCSx pin is a GPIO 1=SPISCSx pin is a SPI functional pin Note: Effect of NUM_CS_PINS generic on ChipSelect bits. Actual number of bits implemented in SCSFUN[7:0] will depend upon the NUM_CS_PINS generic set during synthesis. Unimplemented bits will be read-only and will read ‘0’ always." end="0" id="SCSFUN" rwaccess="RW" width="8"></bitfield>
  </register>
  
  
  <register acronym="SPIPC1" description="SPI / MibSPI Pin Control Register 1 (SPIPC1) - SPIDIR" id="SPIPC1" offset="0x18" width="32">
    
  <bitfield begin="31" description="SPISOMIx direction. Controls the direction of the SPISOMIx pin when it is used as a general-purpose I/O pin. If the SPISOMIx pin is used as a SPI / MibSPI functional pin, the I/O direction is determined by the MASTER bit. 0=SPISOMIx pin is an input 1=SPISOMIx pin is an output" end="24" id="SOMIDIR" rwaccess="RW" width="8"></bitfield>
    
  <bitfield begin="23" description="SPISIMOx direction. Controls the direction of the SPISIMOx pin when it is used as a general-purpose I/O pin. If the SPISIMOx pin is used as a SPI / MibSPI functional pin, the I/O direction is determined by the MASTER bit. 0=SPISIMOx pin is an input 1=SPISIMOx pin is an output" end="16" id="SIMODIR" rwaccess="RW" width="8"></bitfield>
    
  <bitfield begin="15" description="Reserved. Reads return ‘0’ and writes have no effect." end="12" id="NU" rwaccess="R" width="4"></bitfield>
    
  <bitfield begin="11" description="SPISOMI0 direction. Controls the direction of the SPISOMI0 pin when it is used as a general-purpose I/O pin. If the SPISOMI0 pin is used as a SPI / MibSPI functional pin, the I/O direction is determined by the MASTER bit. 0=SPISOMI0 pin is an input 1=SPISOMI0 pin is an output Note: Bit 11 or bit 24 can be used to set the direction for pin SOMI0. If a 32 bit write is performed, bit 11 will have priority over bit 24." end="11" id="SOMIDIR0" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="10" description="SPISIMO0 direction. Controls the direction of the SPISIMO0 pin when it is used as a general-purpose I/O pin. If the SPISIMO0 pin is used as a SPI / MibSPI functional pin, the I/O direction is determined by the MASTER bit. 0=SPISIMO0 pin is an input 1=SPISIMO0 pin is an output Note: Bit 10 or bit 16 can be used to set the direction for pin SIMO0. If a 32 bit write is performed, bit 10 will have priority over bit 16." end="10" id="SIMODIR0" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="9" description="SPICLK direction. Controls the direction of the SPICLK pin when it is used as a general-purpose I/O pin. In functional mode, the I/O direction is determined by the CLKMOD bit. 0=SPICLK pin is an input 1=SPICLK pin is an output" end="9" id="CLKDIR" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="8" description="SPIENA direction. Controls the direction of the SPIENA pin when it is used as a general-purpose I/O. If the SPIENA pin is used as a functional pin, then the I/O direction is determined by the CLKMOD bit (SPIGCR1.1). 0=SPIENA pin is an input 1=SPIENA pin is an output" end="8" id="ENADIR" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="7" description="SPISCS[7:0] direction. Controls the direction of the SPISCSx pins when they are used as a general-purpose I/O pin. Each pins could be configured independently from the others If the SPISCSx is used as a SPI functional pin, the I/O direction is determined by the CLKMOD bit (SPIGCR1.1). 0=SPISCSx pin is an input 1=SPISCSx pin is an output Note: Effect of NUM_CS_PINS generic on ChipSelect bits. Actual number of bits implemented in SCSDIR[7:0] will depend upon the NUM_CS_PINS generic set during synthesis. Unimplemented bits will be read-only and will read ‘0’ always." end="0" id="SCSDIR" rwaccess="RW" width="8"></bitfield>
  </register>
  
  
  <register acronym="SPIPC2" description="SPI / MibSPI Pin Control Register 2 (SPIPC2) - SPIDIN" id="SPIPC2" offset="0x1C" width="32">
    
  <bitfield begin="31" description="SPISOMIx data in. Reflects the value of the SPISOMIx pin. 0=Current value on SPISOMIx pin is logic 0. 1=Current value on SPISOMIx pin is logic 1" end="24" id="SOMIDIN" rwaccess="R" width="8"></bitfield>
    
  <bitfield begin="23" description="SPISIMOx data in. Reflects the value of the SPISIMOx pin. 0=Current value on SPISIMOx pin is logic 0. 1=Current value on SPISIMOx pin is logic 1" end="16" id="SIMODIN" rwaccess="R" width="8"></bitfield>
    
  <bitfield begin="15" description="Reserved. Reads return ‘0’ and writes have no effect." end="12" id="NU" rwaccess="R" width="4"></bitfield>
    
  <bitfield begin="11" description="SPISOMI0 data in. Reflects the value of the SPISOMI0 pin. 0=Current value on SPISOMI0 pin is logic 0. 1=Current value on SPISOMI0 pin is logic 1 Note: Bit 11 or bit 24 can be used to set the direction for pin SOMI0. If a 32 bit write is performed, bit 11 will have priority over bit 24." end="11" id="SOMIDIN0" rwaccess="R" width="1"></bitfield>
    
  <bitfield begin="10" description="SPISIMO0 data in. Reflects the value of the SPISIMO0 pin. 0=Current value on SPISIMO0 pin is logic 0. 1=Current value on SPISIMO0 pin is logic 1. Note: Bit 10 or bit 16 can be used to set the direction for pin SIMO0. If a 32 bit write is performed, bit 10 will have priority over bit 16." end="10" id="SIMODIN0" rwaccess="R" width="1"></bitfield>
    
  <bitfield begin="9" description="Clock data in. Reflects the value of the SPICLK pin. 0=Current value on SPICLK pin is logic 0. 1=Current value on SPICLK pin is logic 1" end="9" id="CLKDIN" rwaccess="R" width="1"></bitfield>
    
  <bitfield begin="8" description="SPIENA data in. Reflects the value of the SPIENA pin. 0=Current value on SPIENA pin is logic 0. 1=Current value on SPIENA pin is logic 1" end="8" id="ENADIN" rwaccess="R" width="1"></bitfield>
    
  <bitfield begin="7" description="SPISCS[7:0] data in. Reflects the value of the SPISCSx pins. 0=Current value on SPISCSx pin is logic 0. 1=Current value on SPISCSx pin is logic 1 Note: Effect of NUM_CS_PINS generic on ChipSelect bits. Actual number of bits implemented in SCSDIN[7:0] will depend upon the NUM_CS_PINS generic set during synthesis. Unimplemented bits will read ‘0’ always." end="0" id="SCSDIN" rwaccess="R" width="8"></bitfield>
  </register>
  
  
  <register acronym="SPIPC3" description="SPI / MibSPI Pin Control Register 3 (SPIPC3) - SPIDOUT" id="SPIPC3" offset="0x20" width="32">
    
  <bitfield begin="31" description="SPISOMIx dataout write. Only active when the SPISOMIx pin is configured as a general-purpose I/O pin and configured as an output pin. The value of this bit indicates the value sent to the pin. 0=Current value on SPISOMIx pin is logic 0. 1=Current value on SPISOMIx pin is logic 1" end="24" id="SOMIDOUT" rwaccess="RW" width="8"></bitfield>
    
  <bitfield begin="23" description="SPISIMOx dataout write. Only active when the SPISIMOx pin is configured as a general-purpose I/O pin and configured as an output pin. The value of this bit indicates the value sent to the pin. 0=Current value on SPISIMOx pin is logic 0. 1=Current value on SPISIMOx pin is logic 1" end="16" id="SIMODOUT" rwaccess="RW" width="8"></bitfield>
    
  <bitfield begin="15" description="Reserved. Reads return ‘0’ and writes have no effect." end="12" id="NU" rwaccess="R" width="4"></bitfield>
    
  <bitfield begin="11" description="SPISOMI0 dataout write. Only active when the SPISOMI0 pin is configured as a general-purpose I/O pin and configured as an output pin. The value of this bit indicates the value sent to the pin. 0=Current value on SPISOMI0 pin is logic 0. 1=Current value on SPISOMI0 pin is logic 1. Note: Bit 11 or bit 24 can be used to set the direction for pin SOMI0. If a 32 bit write is performed, bit 11 will have priority over bit 24." end="11" id="SOMIDOUT0" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="10" description="SPISIMO0 dataout write. Only active when the SPISIMO0 pin is configured as a general-purpose I/O pin and configured as an output pin. The value of this bit indicates the value sent to the pin. 0=Current value on SPISIMO0 pin is logic 0. 1=Current value on SPISIMO0 pin is logic 1. Note: Bit 10 or bit 16 can be used to set the direction for pin SIMO0. If a 32 bit write is performed, bit 10 will have priority over bit 16." end="10" id="SIMODOUT0" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="9" description="SPICLK dataout write. Only active when the SPICLK pin is configured as a general-purpose I/O pin and configured as an output pin. The value of this bit indicates the value sent to the pin. 0=Current value on SPICLK pin is logic 0. 1=Current value on SPICLK pin is logic 1" end="9" id="CLKDOUT" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="8" description="SPIENA dataout write. Only active when the SPIENA pin is configured as a general-purpose I/O pin and configured as an output pin. The value of this bit indicates the value sent to the pin. 0=Current value on SPIENA pin is logic 0. 1=Current value on SPIENA pin is logic 1" end="8" id="ENADOUT" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="7" description="SPISCS[7:0] dataout write. Only active when the SPISCSx pins are configured as a general-purpose I/O pins and configured as an output pins. The value of these bit indicates the value sent to the pins. 0=Current value on SPISCSx pin is logic 0. 1=Current value on SPISCSx pin is logic 1 Note: Effect of NUM_CS_PINS generic on ChipSelect bits. Actual number of bits implemented in SCSDOUT[7:0] will depend upon the NUM_CS_PINS generic set during synthesis. Unimplemented bits will be read-only and will read ‘0’ always." end="0" id="SCSDOUT" rwaccess="RW" width="8"></bitfield>
  </register>
  
  
  <register acronym="SPIPC4" description="SPI / MibSPI Pin Control Register 4 (SPIPC4) - SPIDSET" id="SPIPC4" offset="0x24" width="32">
    
  <bitfield begin="31" description="SPISOMIx dataout set. Only active when the SPISOMIx pin is configured as a general-purpose output pin. A value of ‘1’ written to this bit sets the corresponding SPISOMIDOUTx bit to ‘1’. Write: 0= Has no effect 1= Logic 1 placed on SPISOMIx pin if it is in General Purpose O/P mode Read: 0= Current value on SIMODOUTx is 0. 1= Current value on SOMIDOUTx is 1." end="24" id="SOMISET" rwaccess="RW" width="8"></bitfield>
    
  <bitfield begin="23" description="SPISIMOx dataout set. Only active when the SPISIMOx pin is configured as a general-purpose output pin. A value of ‘1’ written to this bit sets the corresponding SPISIMODOUTx bit to ‘1’. Write: 0= Has no effect 1= Logic 1 placed on SPISIMOx pin if it is in General Purpose O/P mode Read: 0= Current value on SIMODOUTx is 0. 1= Current value on SIMODOUTx is 1" end="16" id="SIMOSET" rwaccess="RW" width="8"></bitfield>
    
  <bitfield begin="15" description="Reserved. Reads return ‘0’ and writes have no effect." end="12" id="NU" rwaccess="R" width="4"></bitfield>
    
  <bitfield begin="11" description="SPISOMI0 dataout set. Only active when the SPISOMI0 pin is configured as a general-purpose output pin. A value of ‘1’ written to this bit sets the corresponding SPISOMIDOUT bit to ‘1’. Write: 0= Has no effect 1= Logic 1 placed on SPISOMI0 pin if it is in General Purpose O/P mode Read: 0= Current value on SOMIDOUT0 is 0. 1= Current value on SOMIDOUT0 is 1. Note: Bit 11 or bit 24 can be used to set the direction for pin SOMI0. If a 32 bit write is performed, bit 11 will have priority over bit 24." end="11" id="SOMISET0" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="10" description="SPISIMO0 dataout set. Only active when the SPISIMO0 pin is configured as a general-purpose output pin. A value of ‘1’ written to this bit sets the corresponding SPISIMODOUT bit to ‘1’. Write: 0= Has no effect 1= Logic 1 placed on SPISIMO0 pin if it is in General Purpose O/P mode Read: 0= Current value on SIMODOUT0 is 0. 1= Current value on SIMODOUT0 is 1. Note: Bit 10 or bit 16 can be used to set the direction for pin SIMO0. If a 32 bit write is performed, bit 10 will have priority over bit 16." end="10" id="SIMOSET0" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="9" description="SPICLK dataout set. Only active when the SPICLK pin is configured as a general-purpose output pin. A value of ‘1’ written to this bit sets the corresponding CLKDOUT bit to ‘1’. Write: 0= Has no effect 1= Logic 1 placed on SPICLK pin if it is in General Purpose O/P mode Read: 0= Current value on CLKDOUT pin is logic 0. 1= Current value on CLKDOUT pin is logic 1" end="9" id="CLKSET" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="8" description="SPIENA dataout set. Only active when the SPIENA pin is configured as a general-purpose output pin. A value of ‘1’ written to this bit sets the corresponding ENABLEDOUT bit to ‘1’. Write: 0= Has no effect 1= Logic 1 placed on SPIENA pin if it is in General Purpose O/P mode Read: 0= Current value on ENADOUT is 0. 1= Current value on ENADOUT is 1" end="8" id="ENASET" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="7" description="SPISCS[7:0] dataout set. Only active when the SPISCSx pins are configured as a general-purpose output pins. A value of ‘1’ written to these bits set the corresponding SCSDOUT bit to ‘1’. Write: 0= Has no effect 1= Logic 1 placed on SPISCSx pin if it is in General Purpose O/P mode Read: 0= Current value on SCSDOUTx is 0. 1= Current value on SCSDOUTx is 1. Note: Effect of NUM_CS_PINS generic on ChipSelect bits. Actual number of bits implemented in SCSSET[7:0] will depend upon the NUM_CS_PINS generic set during synthesis. Unimplemented bits will be read-only and will read ‘0’ always. Note: Register Read Read of SPIPC4 register gives out contents of the SPIPC3 register." end="0" id="SCSSET" rwaccess="RW" width="8"></bitfield>
  </register>
  
  
  <register acronym="SPIPC5" description="SPI / MibSPI Pin Control Register 5 (SPIPC5) - SPIDCLR" id="SPIPC5" offset="0x28" width="32">
    
  <bitfield begin="31" description="SPISOMIx dataout clear. Only active when the SPISOMIx pin is configured as a general-purpose output pin. A value of ‘1’ written to this bit clears the corresponding SPISOMIDOUTx bit to ‘0’. Write: 0= Has no effect 1= Logic 0 placed on SPISOMIx pin if it is in General Purpose O/P mode Read: 0= Current value on SOMIDOUTx is 0. 1= Current value on SOMIDOUTx is 1." end="24" id="SOMICLR" rwaccess="RW" width="8"></bitfield>
    
  <bitfield begin="23" description="SPISIMOx dataout clear. Only active when the SPISIMOx pin is configured as a general-purpose output pin. A value of ‘1’ written to this bit clears the corresponding SPISIMODOUTx bit to ‘0’. Write: 0= Has no effect 1= Logic 0 placed on SPISIMOx pin if it is in General Purpose O/P mode Read: 0=Current value on SIMODOUTx is 0. 1=Current value on SIMODOUTx is 1." end="16" id="SIMOCLR" rwaccess="RW" width="8"></bitfield>
    
  <bitfield begin="15" description="Reserved. Reads return ‘0’ and writes have no effect." end="12" id="NU" rwaccess="R" width="4"></bitfield>
    
  <bitfield begin="11" description="SPISOMI0 dataout clear. Only active when the SPISOMI0 pin is configured as a general-purpose output pin. A value of ‘1’ written to this bit clears the corresponding SPISOMIDOUT bit to ‘0’. Write: 0= Has no effect 1= Logic 0 placed on SPISOMI0 pin if it is in General Purpose O/P mode Read: 0= Current value on SOMIDOUT0 is 0. 1= Current value on SOMIDOUT0 is 1. Note: Bit 11 or bit 24 can be used to set the direction for pin SOMI0. If a 32 bit write is performed, bit 11 will have priority over bit 24." end="11" id="SOMICLR0" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="10" description="SPISIMO0 dataout clear. Only active when the SPISIMO0 pin is configured as a general-purpose output pin. A value of ‘1’ written to this bit clears the corresponding SIMODOUT0 bit to ‘0’. Write: 0= Has no effect 1= Logic 0 placed on SPISIMO0 pin if it is in General Purpose O/P mode Read: 0= Current value on SIMODOUT0 is 0. 1= Current value on SIMODOUT0 is 1. Note: Bit 10 or bit 16 can be used to set the direction for pin SIMO0. If a 32 bit write is performed, bit 10 will have priority over bit 16." end="10" id="SIMOCLR0" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="9" description="SPICLK dataout clear. Only active when the SPICLK pin is configured as a general-purpose output pin. A value of ‘1’ written to this bit clears the corresponding CLKDOUT bit to ‘0’. Write: 0= Has no effect 1= Logic 0 placed on SPICLK pin if it is in General Purpose O/P mode Read: 0= Current value on CLKDOUT is 0. 1= Current value on CLKDOUT is 1." end="9" id="CLKCLR" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="8" description="SPIENA dataout clear. Only active when the SPIENA pin is configured as a general-purpose output pin. A value of ‘1’ written to this bit clears the corresponding ENABLEDOUT bit to ‘0’. Write: 0= Has no effect 1= Logic 0 placed on SPIENA pin if it is in General Purpose O/P mode Read: 0= Current value on ENADOUT is 0. 1= Current value on ENADOUT is 1." end="8" id="ENACLR" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="7" description="SPISCS[7:0] dataout clear. Only active when the SPISCSx pins are configured as a general-purpose output pins. A value of ‘1’ written to this bit clears the corresponding SCSDOUT bit to ‘0.. Write: 0= Has no effect 1= Logic 0 placed on SPISCSx pin if it is in General Purpose O/P mode Read: 0= Current value on SCSDOUTx is 0. 1= Current value on SCSDOUTx is 1 Note: Effect of NUM_CS_PINS generic on ChipSelect bits. Actual number of bits implemented in SCSCLR[7:0] will depend upon the NUM_CS_PINS generic set during synthesis. Unimplemented bits will be read-only and will read ‘0’ always. Note: Register Read Read of SPIPC5 register gives out contents of the SPIPC3 register." end="0" id="SCSCLR" rwaccess="RW" width="8"></bitfield>
  </register>
  
  
  <register acronym="SPIPC6" description="SPI / MibSPI Pin Control Register 6 (SPIPC6) - SPIPDR" id="SPIPC6" offset="0x2C" width="32">
    
  <bitfield begin="31" description="SPISOMIx Open drain enable Enables Open drain capability for the pin SOMIx if the following conditions are met. SOMIDIRx = 1 (SPISOMI0 pin configured in GPIO mode as output pin) SOMIDOUTx = 1 0 = Output value on SPISOMIx pin is logic ‘1’ 1 = Output pin SPISOMIx is Tri-stated" end="24" id="SOMIPDR" rwaccess="RW" width="8"></bitfield>
    
  <bitfield begin="23" description="SPISIMOx Open drain enable Enables Open drain capability for the pin SPISIMOx if the following conditions are met. SIMODIRx = 1 (SPISIMOx pin configured in GPIO mode as output pin) SIMODOUTx = 1 0 = Output value on SPISIMOx pin is logic ‘1’ 1 = Output pin SPISIMOx is Tri-stated" end="16" id="SIMOPDR" rwaccess="RW" width="8"></bitfield>
    
  <bitfield begin="15" description="Reserved. Reads return ‘0’ and writes have no effect." end="12" id="NU" rwaccess="R" width="4"></bitfield>
    
  <bitfield begin="11" description="SPISOMI0 Open drain enable Enables Open drain capability for the pin SPISOMI if the following conditions are met. SOMIDIR0 = 1 (SPISOMI0 pin configured in GPIO mode as output pin) SOMIDOUT0 = 1 0 = Output value on SPISOMI0 pin is logic ‘1’ 1 = Output pin SPISOMI0 is Tri-stated Note: Bit 11 or bit 24 can be used to set the direction for pin SPISOMI0. If a 32 bit write is performed, bit 11 will have priority over bit 24." end="11" id="SOMIPDR0" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="10" description="SPISIMO0 Open drain enable Enables Open drain capability for the pin SPISIMO0 if the following conditions are met. SIMODIR0 = 1 (SPISIMO pin configured in GPIO mode as output pin) SIMODOUT0 = 1 0 = Output value on SPISIMO0 pin is logic ‘1’ 1 = Output pin SPISIMO0 is Tri-stated Note: Bit 10 or bit 16 can be used to set the direction for pin SPISIMO0. If a 32 bit write is performed, bit 10 will have priority over bit 16." end="10" id="SIMOPDR0" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="9" description="SPICLK Open drain enable Enables Open drain capability for the pin CLK if the following conditions are met. CLKDIR = 1 (SPICLK pin configured in GPIO mode as output pin) CLKDOUT = 1 0 = Output value on SPICLK pin is logic ‘1’ 1 = Output pin SPICLK is Tri-stated" end="9" id="CLKPDR" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="8" description="SPIENA Open drain enable Enables Open drain capability for the pin SPIENA if the following conditions are met. ENABLEDIR = 1 (SPIENA pin configured in GPIO mode as output pin) ENABLEDOUT = 1 0 = Output value on SPIENA pin is logic ‘1’ 1 = Output pin SPIENA is Tri-stated" end="8" id="ENAPDR" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="7" description="SPISCSx Open drain enable Enables Open drain capability for the pin SPISCSx if the following conditions are met. SCSDIRx = 1 (SPISCS pin configured in GPIO mode as output pin) SCSDOUTx = 1 0 = Output value on SPISCSx pin is logic ‘1’ 1 = Output pin SPISCSx is Tri-stated Note: Effect of NUM_CS_PINS generic on ChipSelect bits. Actual number of bits implemented in SCSPDR[7:0] will depend upon the NUM_CS_PINS generic set during synthesis. Unimplemented bits will be read-only and will read ‘0’ always." end="0" id="SCSPDR" rwaccess="RW" width="8"></bitfield>
  </register>
  
  
  <register acronym="SPIDAT0" description="SPI / MibSPI Transmit Data Register 0 Note: Accessibility of SPIDAT0 The SPIDAT0 register is not accessible in Multibuffer Mode of MibSPI. It is only accessible in compatibility mode." id="SPIDAT0" offset="0x38" width="32">
    
  <bitfield begin="31" description="Reserved. Reads return ‘0’ and writes have no effect." end="16" id="NU" rwaccess="R" width="16"></bitfield>
    
  <bitfield begin="15" description="SPI / MibSPI Transmit Data. When written, these bits will be copied to the Shift Register if it is empty. If the Shift Register is not empty, the TXBUF will hold the written values. SPIEN (SPICGR1.24) must be set to 1 before this register can be written to. Writing a 0 to the SPIEN register forces the lower 16 bits of the SPIDAT0 register to 0x00. When this register is read, contents of internal buffer register TXBUF which holds the latest written data will be returned. As the data is shifted out from either the MSB or the LSB of Transmit Shift Register depending upon SHIFTDIR bit (SPIFMTx.20). Simultaneously, the received bit will be shifted into the Receive Shift Register either through LSB or MSB depending upon SHIFTDIR bit. This allows the concurrent transmission and reception of data. Note: Irrespective of the character length, the Transmit data should be right justified before writing to SPIDAT0 register. The default Data Format Control register for SPIDAT0 is SPIFMT0. However it is possible to reprogram the DFSEL[1:0] fields of SPIDAT1 prior to using SPIDAT0, to select a different SPIFMTx register." end="0" id="TXDATA" rwaccess="RW" width="16"></bitfield>
  </register>
  
  
  <register acronym="SPIDAT1" description="SPI / MibSPI Transmit Data Register 1 When this register is read, contents of internal buffer register TXBUF which holds the latest written data will be returned." id="SPIDAT1" offset="0x3C" width="32">
    
  <bitfield begin="31" description="Reserved. Reads return ‘0’ and writes have no effect." end="29" id="NU2" rwaccess="R" width="3"></bitfield>
    
  <bitfield begin="28" description="Chip select hold mode. In SPI or compatibility mode MibSPI, the CSHOLD bit is supported in master mode only. In slave mode, this bit is ignored. CSHOLD defines the behavior of the chip select line at the end of a data transfer. 1 =The chip select signal is held active at the end of a transfer until a control field with new data and control information is loaded into SPIDAT1. If the new chip select information equals the previous one, the active chip select signal is extended until the end of transfer with CSHOLD cleared or until the chip select information changes. 0 =The chip select signal is deactivated at the end of a transfer after the T2CDELAY time has passed. If two consecutive transfers are dedicated to the same chip select this chip select signal will be deactivated for atleast 2VCLK cycles before it is activated again." end="28" id="CSHOLD" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="27" description="Reserved. Reads return ‘0’ and writes have no effect." end="27" id="NU1" rwaccess="R" width="1"></bitfield>
    
  <bitfield begin="26" description="Enable the delay counter at the end of the current transaction. WDELAY bit is supported in Master mode only. In Slave mode, this bit will be ignored. 1 = After a transaction, WDELAY of the corresponding data format will be loaded into the delay counter. No transaction will be performed until the WDELAY counter overflows. The SPISCS pins will be de-activated for atleast (WDELAY + 2) * VCLK_Period duration. 0 = No delay will be inserted. However, SPISCS pins will still be de-activated for atleast for 2VCLK cycles if CSHOLD = ‘0’. In SPI or Compatibility mode of MibSPI, the duration for which the SPISCS pin remaining de-activated will also depend upon time taken to supply a new data after completing the shifting operation. If the internal buffer - TXBUF is already full, then the SPISCS will be deasserted for atleast 2 VCLK cycles(if WDEL = ‘0’)." end="26" id="WDEL" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="25" description="DFSEL1 DFSEL0 Description 0 0 Data word format 0 is selected 0 1 Data word format 1 is selected 1 0 Data word format 2 is selected 1 1 Data word format 3 is selected" end="24" id="DFSEL" rwaccess="RW" width="2"></bitfield>
    
  <bitfield begin="23" description="Chip select number. CSNR defines the chip select that shall be activated during the data transfer. The value of CSNR[7:0] will be driven on SPISCS[7:0] lines during the transfer. Note: Effect of NUM_CS_PINS generic on CSNR bits. Actual number of bits implemented in CSNR[7:0] will depend upon the NUM_CS_PINS generic set during synthesis. Unimplemented bits will be read-only and will read ‘0’ always. Note: Preselecting a Format Register. Writing to just the Control Field (using byte writes) does not initiate any SPI transfer in Master mode. This feature can be used to setup SPICLK Phase or Polarity before actually starting the transfer by just updating the DFSEL fields in the control field to select the required Phase/Polarity combination." end="16" id="CSNR" rwaccess="RW" width="8"></bitfield>
    
  <bitfield begin="15" description="SPI / MibSPI Transmit Data. When written, these bits will be copied to the Shift Register if it is empty. If the Shift Register is not empty, the TXBUF will hold the written values. SPIEN must be set to 1 before this register can be written to. Writing a 0 to the SPIEN register forces the lower 16 bits of the SPIDAT1 register to 0x00. Write to this register ONLY when using the automatic Slave Chip Select feature. See section 3, Operation Modes, on page 14. A write to this register will drive the contents of CSNR[7:0] into the respective pins in SPISCS[7:0] if those are configured as functional pins. When this register is read, contents of internal buffer register TXBUF which holds the latest written data will be returned. Irrespective of the character length, the Transmit data should be right justified before writing to SPIDAT1 register." end="0" id="TXDATA" rwaccess="RW" width="16"></bitfield>
  </register>
  
  
  <register acronym="SPIBUF" description="SPI / MibSPI Receive Buffer Register" id="SPIBUF" offset="0x40" width="32">
    
  <bitfield begin="31" description="Receive data buffer empty. When host reads the SPIBUF field or the whole SPIBUF register this will automatically set the RXEMPTY flag. When a data transfer is completed, the received data is copied into SPIBUF, the RXEMPTY flag is cleared. 1 =No data received since last reading of SPIBUF register. 0 =A new Data is received and copied into SPIBUF field. This flag gets set to ‘1’ under following conditions: oReading RXDATA portion of the SPIBUF register. oWriting ‘1’ to clear the RXINTFLG bit in SPIFLG register. Write-Clearing the RXINTFLG bit before reading the SPIBUF indicates the received data is being ignored. Conversely, RXINTFLG can be cleared by reading the RXDATA portion of the SPIBUF register. So, reading the full of SPIBUF register itself clears the Receiver Full Interrupt Flag." end="31" id="RXEMPTY" rwaccess="" width="1"></bitfield>
    
  <bitfield begin="30" description="Receive data buffer overrun. When a data transfer is completed and the received data is copied into the RXBUF while it is already full, RXOVR is set. Refer to Figure 1 for a view of internal logic diagram. An Overrun always occurs to the RXBUF, and SPIBUF contents never get Overwritten until after it is read by the VBUSP Master. If enabled, RXOVRN interrupt gets generated when RXBUF is Overwritten, and reading SPIFLG or SPIVECTx register shows the RXOVRN condition. However, two read operations to the SPIBUF register are required to reach the Overrun buffer. 1 =A receive data overrun condition occurred since last time reading the data field. 0 =No receive data overrun condition occurred since last time reading the data field. This bit is cleared to ‘0’ under the following conditions: o RXDATA portion of the SPIBUF register is read. o OVRNINTFLG bit in SPIFLG register is write-cleared. When an Overrun occurs, the SPIBUF contents will not be overwritten. Only the RXBUF contents are overwritten. When the SPIBUF is read out , the RXBUF contents get copied to the SPIBUF if RXBUF is full. So, the first data read out will be intact when an Overrun occurs. Note: A special condition under which RXOVR flag gets set. If both SPIBUF &amp; RXBUF are already full and while another buffer receive is underway, if any errors like TIMEOUT, BITERR &amp; DLEN_ERR occur, then RXOVR in RXBUF &amp; SPIFLG registers will be set to indicate that the status flags are getting overwritten by the new transfer. This overrun should be treated like a normal Receiver Overrun." end="30" id="RXOVR" rwaccess="" width="1"></bitfield>
    
  <bitfield begin="29" description="Transmit data buffer full. This flag is a read-only flag. Writing into SPIDAT0 or SPIDAT1 field while TX Shift Register is full will automatically set the TXFULL flag. Once the data is copied to the Shift Register the TXFULL flag will be cleared. Writing to SPIDAT0/SPIDAT1 register when both TXBUF &amp; the TX Shift Register are empty does not set the TXFULL flag. 1 =Transmit buffer is full, SPIDAT0/SPIDAT1 is not ready to accept a new data. 0 =Transmit buffer is empty, SPIDAT0/SPIDAT1 is ready to accept a new data." end="29" id="TXFULL" rwaccess="R" width="1"></bitfield>
    
  <bitfield begin="28" description="Mismatch of internal transmit data and transmitted data. 1 =A bit error occurred. The SPI / MibSPI samples the signal of the transmit pin (master: SIMO, slave: SOMI) at the receive point (half clock cycle after transmit point). If the sampled value differs from the transmitted value a bit error is detected and the flag BITERR is set. A possible reason for a bit error can be noise, a to high bit rate / capacitive load or another master/slave trying to transmit at the same time. 0 =No bit error occurred. This flag is cleared to ‘0’ when RXDATA portion of the SPIBUF register is read." end="28" id="BITERR" rwaccess="" width="1"></bitfield>
    
  <bitfield begin="27" description="De-synchronization of slave device. De-synchronization monitor is active in master mode only. 1 =A slave device is de-synchronized. The master monitors the ENA signal coming from the slave device and sets the DESYNC flag if ENA is deactivated before the last reception point or after the last bit is transmitted plus tT2EDELAY (see Section 8.21). If DESYNCENA is set an interrupt is asserted. De-synchronization can occur if a slave device misses a clock edge coming from the master. 0 =No slave de-synchronization detected. This bit is valid in Master mode only. This flag is cleared to ‘0’ when RXDATA portion of the SPIBUF register is read. Note: Possible inconsistency of Desync flag in SPI/Compatibility mode MibSPI Due to the nature of this Error, under some circumstances it is possible for Desync error detected for the previous buffer to be visible in the current buffer. This is due to the fact that Receive Completion flag/interrupt will be generated when the buffer transfer is completed. But Desync will be detected after the buffer transfer is completed. So, if VBUS master reads the received data quickly when an RXINT is detected, then the status flag may not reflect the correct Desync condition. This inconsistency in Desync flag is valid only in SPI or Compatibility mode of MibSPI. In Multibuffer mode, Desync flag is always guaranteed to be for the current buffer." end="27" id="DESYNC" rwaccess="" width="1"></bitfield>
    
  <bitfield begin="26" description="Calculated parity differs from received parity bit. 1 =A parity error occurred. If the parity generator is enabled (can be selected individually for each buffer) an even or odd parity bit is added at the end of a data word (see Section 8.23). During reception of the data word the parity generator calculates the reference parity and compares it to the received parity bit. In the event of a mismatch the PARITYERR flag is set. 0 =No parity error detected. This flag is cleared to ‘0’ when RXDATA portion of the SPIBUF register is read." end="26" id="PARITYERR" rwaccess="" width="1"></bitfield>
    
  <bitfield begin="25" description="Time-out due to non-activation of ENA pin. 1 =An ENA signal time-out occurred. The SPI / MibSPI generates a time-out because the slave hasn’t responded in time by activating the ENA signal after the chip select signal has been activated. If a time-out condition is detected the corresponding chip select is deactivated immediately and the TIMEOUT flag is set. In addition the TIMOUT flag in the status field of the corresponding buffer and in the SPIFLG register is set. 0 =No ENA-pin time-out occurred. This flag is cleared to ‘0’ when RXDATA portion of the SPIBUF register is read. This bit is valid in Master mode only." end="25" id="TIMEOUT" rwaccess="" width="1"></bitfield>
    
  <bitfield begin="24" description="Data Length Error flag. 1 = A Data Length Error has occured. 0 = No Data Length Error has occured. This flag is cleared to ‘0’ when RXDATA portion of the SPIBUF register is read." end="24" id="DLENERR" rwaccess="" width="1"></bitfield>
    
  <bitfield begin="23" description="Last Chip select number. LCSNR in the status field is a copy of CSNR in the corresponding control field. It defines the chip select that has been activated during the last data transfer from the corresponding buffer. This is the copy of CSNR bits from SPIDAT1 latched at the end of a transfer. Note: Effect of NUM_CS_PINS generic on LCSNR bits. Actual number of bits implemented in LCSNR[7:0] will depend upon the NUM_CS_PINS generic set during synthesis. Unimplemented bits will read ‘0’ always" end="16" id="LCSNR" rwaccess="R" width="8"></bitfield>
    
  <bitfield begin="15" description="SPI Receive Data. This is the received data, transferred from the Receive Shift-Register at the end of a transfer completion. Irrespective of the programmed character length &amp; the direction of shifting, the received data is stored right-justified in the register." end="0" id="RXDATA" rwaccess="R" width="16"></bitfield>
  </register>
  
  
  <register acronym="SPIEMU" description="SPI / MibSPI Emulation Register Note: All the fields ot SPIEMU register are Read-Only. Read operation on this register under any mode will not have any impact on the status of this or any other registers." id="SPIEMU" offset="0x44" width="32">
    
  <bitfield begin="31" description="Receive data buffer empty. 1 = No data received since last reading of SPIBUF register. 0 = A new Data is received and copied into SPIBUF field." end="31" id="RXEMPTY" rwaccess="R" width="1"></bitfield>
    
  <bitfield begin="30" description="Receive data buffer overrun. 1 =A receive data overrun condition occurred since last time reading the data field. 0 =No receive data overrun condition occurred since last time reading the data field." end="30" id="RXOVR" rwaccess="R" width="1"></bitfield>
    
  <bitfield begin="29" description="Transmit data buffer full. 1 =Transmit buffer is full, SPIDAT0/SPIDAT1 is not ready to accept a new data. 0 =Transmit buffer is empty, SPIDAT0/SPIDAT1 is ready to accept a new data." end="29" id="TXFULL" rwaccess="R" width="1"></bitfield>
    
  <bitfield begin="28" description="Mismatch of internal transmit data and transmitted data. 1 =A bit error occurred. The SPI / MibSPI samples the signal of the transmit pin (master: SIMO, slave: SOMI) at the receive point (half clock cycle after transmit point). If the sampled value differs from the transmitted value a bit error is detected and the flag BITERR is set. A possible reason for a bit error can be noise, a to high bit rate / capacitive load or another master/slave trying to transmit at the same time. 0 =No bit error occurred." end="28" id="BITERR" rwaccess="R" width="1"></bitfield>
    
  <bitfield begin="27" description="De-synchronization of slave device. De-synchronization monitor is active in master mode only. 1 =A slave device is de-synchronized. The master monitors the ENA signal coming from the slave device and sets the DESYNC flag if ENA is deactivated before the last reception point or after the last bit is transmitted plus tT2EDELAY (see Section 8.21). If DESYNCENA is set an interrupt is asserted. De-synchronization can occur if a slave device misses a clock edge coming from the master. 0 =No slave de-synchronization detected. This bit is valid in Master mode only." end="27" id="DESYNC" rwaccess="R" width="1"></bitfield>
    
  <bitfield begin="26" description="Calculated parity differs from received parity bit. 1 =A parity error occurred. If the parity generator is enabled (can be selected individually for each buffer) an even or odd parity bit is added at the end of a data word (see Section 8.23). During reception of the data word the parity generator calculates the reference parity and compares it to the received parity bit. In the event of a mismatch the PARITYERR flag is set. 0 =No parity error detected." end="26" id="PARITYERR" rwaccess="R" width="1"></bitfield>
    
  <bitfield begin="25" description="Time-out due to non-activation of ENA pin. 1 =An ENA signal time-out occurred. The SPI / MibSPI generates a time-out because the slave hasn’t responded in time by activating the ENA signal after the chip select signal has been activated. If a time-out condition is detected the corresponding chip select is deactivated immediately and the TIMEOUT flag is set. In addition the TIMOUT flag in the status field of the corresponding buffer and in the SPIFLG register is set. 0 =No ENA-pin time-out occurred. This bit is valid in Master mode only." end="25" id="TIMEOUT" rwaccess="R" width="1"></bitfield>
    
  <bitfield begin="24" description="Data Length Error flag. 1 = A Data Length Error has occured. 0 = No Data Length Error has occured." end="24" id="DLENERR" rwaccess="R" width="1"></bitfield>
    
  <bitfield begin="23" description="Last Chip select number. LCSNR in the status field is a copy of CSNR in the corresponding control field. It defines the chip select that has been activated during the last data transfer from the corresponding buffer. This is the copy of CSNR bits from SPIDAT1 latched at the end of a transfer. Note: Effect of NUM_CS_PINS generic on LCSNR bits. Actual number of bits implemented in LCSNR[7:0] will depend upon the NUM_CS_PINS generic set during synthesis. Unimplemented bits will read ‘0’ always." end="16" id="LCSNR" rwaccess="R" width="8"></bitfield>
    
  <bitfield begin="15" description="SPI Receive Data. SPI / MibSPI emulation is a mirror of the SPIBUF register. The only difference between SPIEMU and SPIBUF is that a read from SPIEMU does not clear any of the status flags." end="0" id="RXDATA" rwaccess="R" width="16"></bitfield>
  </register>
  
  
  <register acronym="SPIDELAY" description="SPI / MibSPI Delay Register" id="SPIDELAY" offset="0x48" width="32">
    
  <bitfield begin="31" description="Chip-select-active-to-transmit-start-delay. C2TDELAY is used in master mode only. It defines a setup time for the slave device that delays the data transmission from the chip select active edge by a multiple of VBUSPCLK cycles. ChipSelect-active-to-transmission delays between 2 to 257 VBUSPCLK cycles can be achieved. If Phase = ‘1’, the delay between SCS fall-edge to the first edge of SPICLK will have an additional 0.5 SPICLK Period delay. This delay is as per the SPI protocol." end="24" id="C2TDELAY" rwaccess="RW" width="8"></bitfield>
    
  <bitfield begin="23" description="Transmit-end-to-chip-select-inactive-delay. T2CDELAY is used in master mode only. It defines a hold time for the slave device that delays the chip select deactivation by a multiple of VBUSPCLK cycles after the last bit is transferred. T2CDELAY can be configured between 2 and 256 VBUSPCLK cycles. If Phase = ‘0’, then between the last edge of SPICLK and rise-edge of SCS, there will be an additional delay of 0.5 SPICLK period. This is as per the SPI protocol Both C2TDELAY and T2CDELAY counters do not have any dependancy on SPIENA pin value. Even if the SPIENA pin is asserted by the Slave, Master will continue to delay the start of SPICLK until the C2TDELAY counter overflows. Similarly, even if the SPIENA pin is deasserted by the Slave, Master will continue to hold the SPISCS pins active until the T2CDELAY counter overflows. This way, it is guaranteed that the setup/hold times of the SPISCS pins is determined by the Delay timers alone. To achieve better throughput, it should be ensured that these two timers are kept at the minimum possible values." end="16" id="T2CDELAY" rwaccess="RW" width="8"></bitfield>
    
  <bitfield begin="15" description="Transmit-data-finished-to-ENA-pin-inactive-time-out. T2EDELAY is used in master mode only. It defines a time-out value as a multiple of SPI clock before the ENAble signal has to become inactive and after the CS becomes inactive. The SPI clock depends on which data format is selected. If the slave device is missing one or more clock edges, it is becoming de-synchronized. Although the master has finished the data transfer the slave is still waiting for the missed clock pulses and the ENA signal isn’t disabled. The T2EDELAY defines a time-out value that triggers the DESYNC flag, if the ENA signal isn’t deactivated in time. DESYNC flag is set to indicate that the Slave device did not deassert its SPIENA pin in time to acknowledge that it has received all the bits of the sent character. If T2CDELAY is programmed a non-zero value, then T2EDELAY will start only after the T2CDELAY completes. This should be taken into consideration to determine an optimum value of T2EDELAY. Note: Zero T2EDELAY If T2EDELAY is not programmed or programmed to ‘0’, then the Master SPI/MibSPI does not wait for SPIENA pin to be deasserted. It ignores the state of the SPIENA pin after the transmission is completed." end="8" id="T2EDELAY" rwaccess="RW" width="8"></bitfield>
    
  <bitfield begin="7" description="Chip-select-active-to-ENA-signal-active-time-out C2EDELAY is utilized only in master mode and it applies only if the addressed slave generates an ENA signal as a hardware handshake response. C2EDELAY defines the maximum time between the SPI / MibSPI activating the chip select signal and the addressed slave responding by activating the ENA signal. C2EDELAY defines a time-out value as a multiple of SPI clocks. The SPI clock depends on whether data format 0 or data format 1 is selected. If the slave device is not responding with the ENA signal before the time-out value is reached, the TIMEOUT flag in SPIFLG register is set and an interrupt is asserted if enabled. If a time-out occurs the MibSPI clears the transmit request of the timed-out buffer, sets the TIMEOUT flag for the current buffer and continues with the transfer of the next buffer in the sequence that is enabled. If C2TDELAY is programmed a non-zero value, then C2EDELAY will start only after the C2TDELAY completes. This should be taken into consideration to determine an optimum value of C2EDELAY. Note: Zero C2EDELAY If C2EDELAY is not programmed or programmed to ‘0’, then the Master SPI/MibSPI waits until the SPIENA pin to asserted before it can start the transfer. If the SPIENA pin is not asserted due to a malfunctioning Slave, the Master will wait forever. This might cause hang-up situation. it is recommended to program to C2EDELAY to a suitable value whenever SPIENA pin is used as functional." end="0" id="C2EDELAY" rwaccess="RW" width="8"></bitfield>
  </register>
  
  
  <register acronym="SPIDEF" description="SPI / MibSPI Default Chip select Register" id="SPIDEF" offset="0x4C" width="32">
    
  <bitfield begin="31" description="Reserved. Reads return ‘0’ and writes have no effect." end="8" id="NU" rwaccess="R" width="24"></bitfield>
    
  <bitfield begin="7" description="Chip select default pattern. Master mode behavior. The CSDEFx bits are output to the chip select pins when no transmission are currently performed. It allows the user to set a chip select pattern which deselects all the SPI slaves. 1 =If CSDEFx is set to “1” the corresponding chip select is set to “1” while SPI/MibSPI is IDLE. 0 =If CSDEFx is set to “0” the corresponding chip select is set to “0” while SPI/MibSPI is IDLE. Note: Effect of NUM_CS_PINS generic on CSDEF bits. Actual number of bits implemented in CSDEF[7:0] will depend upon the NUM_CS_PINS generic set during synthesis. Unimplemented bits will be treated as reserved, read-only and will read ‘0’ always." end="0" id="CSDEF0" rwaccess="RW" width="8"></bitfield>
  </register>
  
  
  <register acronym="SPIFMT0" description="SPI / MibSPI Data Format Register 0" id="SPIFMT0" offset="0x50" width="32">
    
  <bitfield begin="31" description="Delay in between transmissions for data format x (x= 0,1,2,3). Idle time that will be applied at the end of the current transmission if the bit WDEL is set in the current buffer. The delay to be applied is equal to: WDELAY * PVBUSPCLK + 2 * PVBUSPCLK. PVBUSPCLK -> Period of VBUSPCLK." end="24" id="WDELAY" rwaccess="RW" width="8"></bitfield>
    
  <bitfield begin="23" description="Parity polarity: even or odd. PARPOLx can be modified in privilege mode only. It can be used for data format x (x= 0,1,2,3). 1 =An odd parity flag is added at the end of the transmit data stream. 0 =An even parity flag is added at the end of the transmit data stream." end="23" id="PARPOL" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="22" description="Parity enable for data format x. 1= A parity is transmitted at the end of each transmit data stream. At the end of a transfer the parity generator compares the received parity bit with the locally calculated parity flag. If the parity bits do not match the RXERR flag is set in the corresponding control field. The parity type (even or odd) can be selected via the PARPOL bit. 0= No parity generation/ verification is performed for this data format. If an Uncorrectable Error Flag is set in a Slave mode MibSPI, then wrong parity bit will be transmitted to indicate to the master that there has been some issue with the data parity. The SOMI pin will be forced to transmit all ‘0’s. And parity bit will be transmitted as ‘1’ if even parity is selected and as ‘0’ if odd parity is selected(using the PARPOLx bit of this register). This behavior will be irrespective of an UPE on either TXRAM or RXRAM." end="22" id="PARITYENA" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="21" description="Master waits for ENA signal from slave for data format x. WAITENA is considered in master mode only. In slave mode this bit has no meaning. WAITENA enables a flexible SPI network where slaves with ENA signal and slaves without ENA signal can be mixed. WAITENA defines for each buffer whether the addressed slave generates the ENA signal or does not. 1= Before the SPI / MibSPI starts the data transfer it waits for the ENA signal to become low. If the ENA signal is not pulled down by the addressed slave before the internal time-out counter (C2EDELAY) overflows, then the Master aborts the transfer and sets the TIMEOUT error flag. 0= The SPI / MibSPI does not wait for the ENA signal from the slaves and directly starts the transfer." end="21" id="WAITENA" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="20" description="Shift direction for data format x. With bit SHIFTDIRx the shift direction for data format x (x=0,1,2,3) can be selected. 1 =Data format x shift direction: Least significant bit is shifted out first. 0 =Data format x shift direction: Most significant bit is shifted out first." end="20" id="SHIFTDIR" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="19" description="Half Duplex transfer mode enable for Data Format x. This bit controls the I/O function of SOMI/SIMO lines for a specific requirement where in the case of Master mode, TX pin - SIMO will act as an RX pin, and in the case of Slave mode, RX pin - SIMO will act as a TX pin. 0 = Normal Full Duplex transfer. 1 = If MASTER = ‘1’, SIMO pin will act as an RX pin (No TX possible) If MASTER = ‘0’, SIMO pin will act as a TX pin (No RX possible). For all normal operations, HDUPLEX_ENAx bits should always remain ‘0’. It is intended for the usage when the SIMO pin is used for both TX &amp; RX operations at different times." end="19" id="HDUPLEX_ENA" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="18" description="Disable Chipselect Timers for this format register. The C2TDELAY &amp; T2CDELAY timers are by default enabled for all the Data Format registers. Using this bit, these timers can be disabled for particular Data Format if not required. When a Master is handling multiple Slaves, with varied set-up hold requirement, the application can selectively choose to include or not include the ChipSelect Delay timers for any Slaves. 0 = Both C2TDELAY &amp; T2CDELAY counts are inserted for the ChipSelects. 1 = No C2TDELAY or T2CDELAY is inserted in the ChipSelect timings." end="18" id="DISCSTIMERS" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="17" description="SPI data format x clock polarity. POLARITYx defines the clock polarity of data format x. POLARITYx can be modified in privilege mode only. 1 =If POLARITYx is set to “1” the SPI clock signal is high-inactive, i.e. before and after data transfer the clock signal is high. 0 =If POLARITYx is set to “0” the SPI clock signal is low-inactive, i.e. before and after data transfer the clock signal is low." end="17" id="POLARITY" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="16" description="SPI Data format x clock delay. PHASEx defines the clock delay of data format x. PHASEx can be modified in privilege mode only. 1 =If PHASEx is set to “1” the SPI clock signal is delayed by a half SPI clock cycle versus the transmit / receive data stream. The first transmit bit has to output prior to the first clock edge. Master and slave receive the first bit with the first edge 0 =If PHASEx is set to “0” the SPI clock signal is not delayed versus the transmit / receive data stream. The first data bit is transmitted with the first clock edge and the first bit is received with the second (inverse) clock edge Note: Restriction on SPICLK Phase/Polarity change in Slave Mode In Slave mode if Phase and/or Polarity of SPICLK has to be changed, the following sequence should be used. oClear the GCR1.SPIEN bit to ‘0’. oSet the required Phase/Polarity values in SPIFMTx registers. oSet the GCR1.SPIEN bit back to ‘1’. The setting of GCR1.SPIEN bit in Slave SPI/MibSPI to ‘1’ should be done only after the Polarity of the incoming SPICLK signal changes (if POLARITYx bit was changed in the configuration)." end="16" id="PHASE" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="15" description="SPI data format x prescaler. PRESCALEx can be modified in privilege mode only. PRESCALEx determines the bit transfer rate of data format x if the SPI is the network master. PRESCALEx is directly derived from VBUSPCLK. If the SPI / MibSPI is configured as slave, PRESCALEx DOES NOT NEED to be configured. The clock rate for data format x can be calculated as  BRFormat = VBUSPCLCK/(PRESCALEx+1) When PRESCALEx is set to zero (0), the SPI clock rate defaults to VBUSPCLK/2. Any write to this field will update EPRESCALE_FMTx field of EPRESCALEy (y=1,2) registers with EPRESCALE_FMTx(11:8) bits rounded off to ‘000’. Any write to EPRESCALE_FMTx field of the EXTENDED_PRESCALEy (y=1,2) register will cause its lower 8bits to be reflected in this field as well." end="8" id="PRESCALE" rwaccess="RW" width="8"></bitfield>
    
  <bitfield begin="7" description="Reserved. Reads return ‘0’ and writes have no effect." end="5" id="NU" rwaccess="R" width="3"></bitfield>
    
  <bitfield begin="4" description="SPI data format x data word length. CHARLENx defines the word length of data format x. Legal values are 0x02 (data word length = 2 bit) to 0x10 (data word length = 16). Illegal values, such as 0x00 or 0x1F are not detected and their effect is indeterminate." end="0" id="CHARLEN" rwaccess="RW" width="5"></bitfield>
  </register>
  
  
  <register acronym="SPIFMT1" description="SPI / MibSPI Data Format Register 1" id="SPIFMT1" offset="0x54" width="32">
    
  <bitfield begin="31" description="Delay in between transmissions for data format x (x= 0,1,2,3). Idle time that will be applied at the end of the current transmission if the bit WDEL is set in the current buffer. The delay to be applied is equal to: WDELAY * PVBUSPCLK + 2 * PVBUSPCLK. PVBUSPCLK -> Period of VBUSPCLK." end="24" id="WDELAY" rwaccess="RW" width="8"></bitfield>
    
  <bitfield begin="23" description="Parity polarity: even or odd. PARPOLx can be modified in privilege mode only. It can be used for data format x (x= 0,1,2,3). 1 =An odd parity flag is added at the end of the transmit data stream. 0 =An even parity flag is added at the end of the transmit data stream." end="23" id="PARPOL" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="22" description="Parity enable for data format x. 1= A parity is transmitted at the end of each transmit data stream. At the end of a transfer the parity generator compares the received parity bit with the locally calculated parity flag. If the parity bits do not match the RXERR flag is set in the corresponding control field. The parity type (even or odd) can be selected via the PARPOL bit. 0= No parity generation/ verification is performed for this data format. If an Uncorrectable Error Flag is set in a Slave mode MibSPI, then wrong parity bit will be transmitted to indicate to the master that there has been some issue with the data parity. The SOMI pin will be forced to transmit all ‘0’s. And parity bit will be transmitted as ‘1’ if even parity is selected and as ‘0’ if odd parity is selected(using the PARPOLx bit of this register). This behavior will be irrespective of an UPE on either TXRAM or RXRAM." end="22" id="PARITYENA" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="21" description="Master waits for ENA signal from slave for data format x. WAITENA is considered in master mode only. In slave mode this bit has no meaning. WAITENA enables a flexible SPI network where slaves with ENA signal and slaves without ENA signal can be mixed. WAITENA defines for each buffer whether the addressed slave generates the ENA signal or does not. 1= Before the SPI / MibSPI starts the data transfer it waits for the ENA signal to become low. If the ENA signal is not pulled down by the addressed slave before the internal time-out counter (C2EDELAY) overflows, then the Master aborts the transfer and sets the TIMEOUT error flag. 0= The SPI / MibSPI does not wait for the ENA signal from the slaves and directly starts the transfer." end="21" id="WAITENA" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="20" description="Shift direction for data format x. With bit SHIFTDIRx the shift direction for data format x (x=0,1,2,3) can be selected. 1 =Data format x shift direction: Least significant bit is shifted out first. 0 =Data format x shift direction: Most significant bit is shifted out first." end="20" id="SHIFTDIR" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="19" description="Half Duplex transfer mode enable for Data Format x. This bit controls the I/O function of SOMI/SIMO lines for a specific requirement where in the case of Master mode, TX pin - SIMO will act as an RX pin, and in the case of Slave mode, RX pin - SIMO will act as a TX pin. 0 = Normal Full Duplex transfer. 1 = If MASTER = ‘1’, SIMO pin will act as an RX pin (No TX possible) If MASTER = ‘0’, SIMO pin will act as a TX pin (No RX possible). For all normal operations, HDUPLEX_ENAx bits should always remain ‘0’. It is intended for the usage when the SIMO pin is used for both TX &amp; RX operations at different times." end="19" id="HDUPLEX_ENA" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="18" description="Disable Chipselect Timers for this format register. The C2TDELAY &amp; T2CDELAY timers are by default enabled for all the Data Format registers. Using this bit, these timers can be disabled for particular Data Format if not required. When a Master is handling multiple Slaves, with varied set-up hold requirement, the application can selectively choose to include or not include the ChipSelect Delay timers for any Slaves. 0 = Both C2TDELAY &amp; T2CDELAY counts are inserted for the ChipSelects. 1 = No C2TDELAY or T2CDELAY is inserted in the ChipSelect timings." end="18" id="DISCSTIMERS" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="17" description="SPI data format x clock polarity. POLARITYx defines the clock polarity of data format x. POLARITYx can be modified in privilege mode only. 1 =If POLARITYx is set to “1” the SPI clock signal is high-inactive, i.e. before and after data transfer the clock signal is high. 0 =If POLARITYx is set to “0” the SPI clock signal is low-inactive, i.e. before and after data transfer the clock signal is low." end="17" id="POLARITY" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="16" description="SPI Data format x clock delay. PHASEx defines the clock delay of data format x. PHASEx can be modified in privilege mode only. 1 =If PHASEx is set to “1” the SPI clock signal is delayed by a half SPI clock cycle versus the transmit / receive data stream. The first transmit bit has to output prior to the first clock edge. Master and slave receive the first bit with the first edge 0 =If PHASEx is set to “0” the SPI clock signal is not delayed versus the transmit / receive data stream. The first data bit is transmitted with the first clock edge and the first bit is received with the second (inverse) clock edge Note: Restriction on SPICLK Phase/Polarity change in Slave Mode In Slave mode if Phase and/or Polarity of SPICLK has to be changed, the following sequence should be used. oClear the GCR1.SPIEN bit to ‘0’. oSet the required Phase/Polarity values in SPIFMTx registers. oSet the GCR1.SPIEN bit back to ‘1’. The setting of GCR1.SPIEN bit in Slave SPI/MibSPI to ‘1’ should be done only after the Polarity of the incoming SPICLK signal changes (if POLARITYx bit was changed in the configuration)." end="16" id="PHASE" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="15" description="SPI data format x prescaler. PRESCALEx can be modified in privilege mode only. PRESCALEx determines the bit transfer rate of data format x if the SPI is the network master. PRESCALEx is directly derived from VBUSPCLK. If the SPI / MibSPI is configured as slave, PRESCALEx DOES NOT NEED to be configured. The clock rate for data format x can be calculated as  BRFormat = VBUSPCLCK/(PRESCALEx+1) When PRESCALEx is set to zero (0), the SPI clock rate defaults to VBUSPCLK/2. Any write to this field will update EPRESCALE_FMTx field of EPRESCALEy (y=1,2) registers with EPRESCALE_FMTx(11:8) bits rounded off to ‘000’. Any write to EPRESCALE_FMTx field of the EXTENDED_PRESCALEy (y=1,2) register will cause its lower 8bits to be reflected in this field as well." end="8" id="PRESCALE" rwaccess="RW" width="8"></bitfield>
    
  <bitfield begin="7" description="Reserved. Reads return ‘0’ and writes have no effect." end="5" id="NU" rwaccess="R" width="3"></bitfield>
    
  <bitfield begin="4" description="SPI data format x data word length. CHARLENx defines the word length of data format x. Legal values are 0x02 (data word length = 2 bit) to 0x10 (data word length = 16). Illegal values, such as 0x00 or 0x1F are not detected and their effect is indeterminate." end="0" id="CHARLEN" rwaccess="RW" width="5"></bitfield>
  </register>
  
  
  <register acronym="SPIFMT2" description="SPI / MibSPI Data Format Register 2" id="SPIFMT2" offset="0x58" width="32">
    
  <bitfield begin="31" description="Delay in between transmissions for data format x (x= 0,1,2,3). Idle time that will be applied at the end of the current transmission if the bit WDEL is set in the current buffer. The delay to be applied is equal to: WDELAY * PVBUSPCLK + 2 * PVBUSPCLK. PVBUSPCLK -> Period of VBUSPCLK." end="24" id="WDELAY" rwaccess="RW" width="8"></bitfield>
    
  <bitfield begin="23" description="Parity polarity: even or odd. PARPOLx can be modified in privilege mode only. It can be used for data format x (x= 0,1,2,3). 1 =An odd parity flag is added at the end of the transmit data stream. 0 =An even parity flag is added at the end of the transmit data stream." end="23" id="PARPOL" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="22" description="Parity enable for data format x. 1= A parity is transmitted at the end of each transmit data stream. At the end of a transfer the parity generator compares the received parity bit with the locally calculated parity flag. If the parity bits do not match the RXERR flag is set in the corresponding control field. The parity type (even or odd) can be selected via the PARPOL bit. 0= No parity generation/ verification is performed for this data format. If an Uncorrectable Error Flag is set in a Slave mode MibSPI, then wrong parity bit will be transmitted to indicate to the master that there has been some issue with the data parity. The SOMI pin will be forced to transmit all ‘0’s. And parity bit will be transmitted as ‘1’ if even parity is selected and as ‘0’ if odd parity is selected(using the PARPOLx bit of this register). This behavior will be irrespective of an UPE on either TXRAM or RXRAM." end="22" id="PARITYENA" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="21" description="Master waits for ENA signal from slave for data format x. WAITENA is considered in master mode only. In slave mode this bit has no meaning. WAITENA enables a flexible SPI network where slaves with ENA signal and slaves without ENA signal can be mixed. WAITENA defines for each buffer whether the addressed slave generates the ENA signal or does not. 1= Before the SPI / MibSPI starts the data transfer it waits for the ENA signal to become low. If the ENA signal is not pulled down by the addressed slave before the internal time-out counter (C2EDELAY) overflows, then the Master aborts the transfer and sets the TIMEOUT error flag. 0= The SPI / MibSPI does not wait for the ENA signal from the slaves and directly starts the transfer." end="21" id="WAITENA" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="20" description="Shift direction for data format x. With bit SHIFTDIRx the shift direction for data format x (x=0,1,2,3) can be selected. 1 =Data format x shift direction: Least significant bit is shifted out first. 0 =Data format x shift direction: Most significant bit is shifted out first." end="20" id="SHIFTDIR" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="19" description="Half Duplex transfer mode enable for Data Format x. This bit controls the I/O function of SOMI/SIMO lines for a specific requirement where in the case of Master mode, TX pin - SIMO will act as an RX pin, and in the case of Slave mode, RX pin - SIMO will act as a TX pin. 0 = Normal Full Duplex transfer. 1 = If MASTER = ‘1’, SIMO pin will act as an RX pin (No TX possible) If MASTER = ‘0’, SIMO pin will act as a TX pin (No RX possible). For all normal operations, HDUPLEX_ENAx bits should always remain ‘0’. It is intended for the usage when the SIMO pin is used for both TX &amp; RX operations at different times." end="19" id="HDUPLEX_ENA" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="18" description="Disable Chipselect Timers for this format register. The C2TDELAY &amp; T2CDELAY timers are by default enabled for all the Data Format registers. Using this bit, these timers can be disabled for particular Data Format if not required. When a Master is handling multiple Slaves, with varied set-up hold requirement, the application can selectively choose to include or not include the ChipSelect Delay timers for any Slaves. 0 = Both C2TDELAY &amp; T2CDELAY counts are inserted for the ChipSelects. 1 = No C2TDELAY or T2CDELAY is inserted in the ChipSelect timings." end="18" id="DISCSTIMERS" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="17" description="SPI data format x clock polarity. POLARITYx defines the clock polarity of data format x. POLARITYx can be modified in privilege mode only. 1 =If POLARITYx is set to “1” the SPI clock signal is high-inactive, i.e. before and after data transfer the clock signal is high. 0 =If POLARITYx is set to “0” the SPI clock signal is low-inactive, i.e. before and after data transfer the clock signal is low." end="17" id="POLARITY" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="16" description="SPI Data format x clock delay. PHASEx defines the clock delay of data format x. PHASEx can be modified in privilege mode only. 1 =If PHASEx is set to “1” the SPI clock signal is delayed by a half SPI clock cycle versus the transmit / receive data stream. The first transmit bit has to output prior to the first clock edge. Master and slave receive the first bit with the first edge 0 =If PHASEx is set to “0” the SPI clock signal is not delayed versus the transmit / receive data stream. The first data bit is transmitted with the first clock edge and the first bit is received with the second (inverse) clock edge Note: Restriction on SPICLK Phase/Polarity change in Slave Mode In Slave mode if Phase and/or Polarity of SPICLK has to be changed, the following sequence should be used. oClear the GCR1.SPIEN bit to ‘0’. oSet the required Phase/Polarity values in SPIFMTx registers. oSet the GCR1.SPIEN bit back to ‘1’. The setting of GCR1.SPIEN bit in Slave SPI/MibSPI to ‘1’ should be done only after the Polarity of the incoming SPICLK signal changes (if POLARITYx bit was changed in the configuration)." end="16" id="PHASE" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="15" description="SPI data format x prescaler. PRESCALEx can be modified in privilege mode only. PRESCALEx determines the bit transfer rate of data format x if the SPI is the network master. PRESCALEx is directly derived from VBUSPCLK. If the SPI / MibSPI is configured as slave, PRESCALEx DOES NOT NEED to be configured. The clock rate for data format x can be calculated as  BRFormat = VBUSPCLCK/(PRESCALEx+1) When PRESCALEx is set to zero (0), the SPI clock rate defaults to VBUSPCLK/2. Any write to this field will update EPRESCALE_FMTx field of EPRESCALEy (y=1,2) registers with EPRESCALE_FMTx(11:8) bits rounded off to ‘000’. Any write to EPRESCALE_FMTx field of the EXTENDED_PRESCALEy (y=1,2) register will cause its lower 8bits to be reflected in this field as well." end="8" id="PRESCALE" rwaccess="RW" width="8"></bitfield>
    
  <bitfield begin="7" description="Reserved. Reads return ‘0’ and writes have no effect." end="5" id="NU" rwaccess="R" width="3"></bitfield>
    
  <bitfield begin="4" description="SPI data format x data word length. CHARLENx defines the word length of data format x. Legal values are 0x02 (data word length = 2 bit) to 0x10 (data word length = 16). Illegal values, such as 0x00 or 0x1F are not detected and their effect is indeterminate." end="0" id="CHARLEN" rwaccess="RW" width="5"></bitfield>
  </register>
  
  
  <register acronym="SPIFMT3" description="SPI / MibSPI Data Format Register 3" id="SPIFMT3" offset="0x5C" width="32">
    
  <bitfield begin="31" description="Delay in between transmissions for data format x (x= 0,1,2,3). Idle time that will be applied at the end of the current transmission if the bit WDEL is set in the current buffer. The delay to be applied is equal to: WDELAY * PVBUSPCLK + 2 * PVBUSPCLK. PVBUSPCLK -> Period of VBUSPCLK." end="24" id="WDELAY" rwaccess="RW" width="8"></bitfield>
    
  <bitfield begin="23" description="Parity polarity: even or odd. PARPOLx can be modified in privilege mode only. It can be used for data format x (x= 0,1,2,3). 1 =An odd parity flag is added at the end of the transmit data stream. 0 =An even parity flag is added at the end of the transmit data stream." end="23" id="PARPOL" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="22" description="Parity enable for data format x. 1= A parity is transmitted at the end of each transmit data stream. At the end of a transfer the parity generator compares the received parity bit with the locally calculated parity flag. If the parity bits do not match the RXERR flag is set in the corresponding control field. The parity type (even or odd) can be selected via the PARPOL bit. 0= No parity generation/ verification is performed for this data format. If an Uncorrectable Error Flag is set in a Slave mode MibSPI, then wrong parity bit will be transmitted to indicate to the master that there has been some issue with the data parity. The SOMI pin will be forced to transmit all ‘0’s. And parity bit will be transmitted as ‘1’ if even parity is selected and as ‘0’ if odd parity is selected(using the PARPOLx bit of this register). This behavior will be irrespective of an UPE on either TXRAM or RXRAM." end="22" id="PARITYENA" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="21" description="Master waits for ENA signal from slave for data format x. WAITENA is considered in master mode only. In slave mode this bit has no meaning. WAITENA enables a flexible SPI network where slaves with ENA signal and slaves without ENA signal can be mixed. WAITENA defines for each buffer whether the addressed slave generates the ENA signal or does not. 1= Before the SPI / MibSPI starts the data transfer it waits for the ENA signal to become low. If the ENA signal is not pulled down by the addressed slave before the internal time-out counter (C2EDELAY) overflows, then the Master aborts the transfer and sets the TIMEOUT error flag. 0= The SPI / MibSPI does not wait for the ENA signal from the slaves and directly starts the transfer." end="21" id="WAITENA" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="20" description="Shift direction for data format x. With bit SHIFTDIRx the shift direction for data format x (x=0,1,2,3) can be selected. 1 =Data format x shift direction: Least significant bit is shifted out first. 0 =Data format x shift direction: Most significant bit is shifted out first." end="20" id="SHIFTDIR" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="19" description="Half Duplex transfer mode enable for Data Format x. This bit controls the I/O function of SOMI/SIMO lines for a specific requirement where in the case of Master mode, TX pin - SIMO will act as an RX pin, and in the case of Slave mode, RX pin - SIMO will act as a TX pin. 0 = Normal Full Duplex transfer. 1 = If MASTER = ‘1’, SIMO pin will act as an RX pin (No TX possible) If MASTER = ‘0’, SIMO pin will act as a TX pin (No RX possible). For all normal operations, HDUPLEX_ENAx bits should always remain ‘0’. It is intended for the usage when the SIMO pin is used for both TX &amp; RX operations at different times." end="19" id="HDUPLEX_ENA" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="18" description="Disable Chipselect Timers for this format register. The C2TDELAY &amp; T2CDELAY timers are by default enabled for all the Data Format registers. Using this bit, these timers can be disabled for particular Data Format if not required. When a Master is handling multiple Slaves, with varied set-up hold requirement, the application can selectively choose to include or not include the ChipSelect Delay timers for any Slaves. 0 = Both C2TDELAY &amp; T2CDELAY counts are inserted for the ChipSelects. 1 = No C2TDELAY or T2CDELAY is inserted in the ChipSelect timings." end="18" id="DISCSTIMERS" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="17" description="SPI data format x clock polarity. POLARITYx defines the clock polarity of data format x. POLARITYx can be modified in privilege mode only. 1 =If POLARITYx is set to “1” the SPI clock signal is high-inactive, i.e. before and after data transfer the clock signal is high. 0 =If POLARITYx is set to “0” the SPI clock signal is low-inactive, i.e. before and after data transfer the clock signal is low." end="17" id="POLARITY" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="16" description="SPI Data format x clock delay. PHASEx defines the clock delay of data format x. PHASEx can be modified in privilege mode only. 1 =If PHASEx is set to “1” the SPI clock signal is delayed by a half SPI clock cycle versus the transmit / receive data stream. The first transmit bit has to output prior to the first clock edge. Master and slave receive the first bit with the first edge 0 =If PHASEx is set to “0” the SPI clock signal is not delayed versus the transmit / receive data stream. The first data bit is transmitted with the first clock edge and the first bit is received with the second (inverse) clock edge Note: Restriction on SPICLK Phase/Polarity change in Slave Mode In Slave mode if Phase and/or Polarity of SPICLK has to be changed, the following sequence should be used. oClear the GCR1.SPIEN bit to ‘0’. oSet the required Phase/Polarity values in SPIFMTx registers. oSet the GCR1.SPIEN bit back to ‘1’. The setting of GCR1.SPIEN bit in Slave SPI/MibSPI to ‘1’ should be done only after the Polarity of the incoming SPICLK signal changes (if POLARITYx bit was changed in the configuration)." end="16" id="PHASE" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="15" description="SPI data format x prescaler. PRESCALEx can be modified in privilege mode only. PRESCALEx determines the bit transfer rate of data format x if the SPI is the network master. PRESCALEx is directly derived from VBUSPCLK. If the SPI / MibSPI is configured as slave, PRESCALEx DOES NOT NEED to be configured. The clock rate for data format x can be calculated as  BRFormat = VBUSPCLCK/(PRESCALEx+1) When PRESCALEx is set to zero (0), the SPI clock rate defaults to VBUSPCLK/2. Any write to this field will update EPRESCALE_FMTx field of EPRESCALEy (y=1,2) registers with EPRESCALE_FMTx(11:8) bits rounded off to ‘000’. Any write to EPRESCALE_FMTx field of the EXTENDED_PRESCALEy (y=1,2) register will cause its lower 8bits to be reflected in this field as well." end="8" id="PRESCALE" rwaccess="RW" width="8"></bitfield>
    
  <bitfield begin="7" description="Reserved. Reads return ‘0’ and writes have no effect." end="5" id="NU" rwaccess="R" width="3"></bitfield>
    
  <bitfield begin="4" description="SPI data format x data word length. CHARLENx defines the word length of data format x. Legal values are 0x02 (data word length = 2 bit) to 0x10 (data word length = 16). Illegal values, such as 0x00 or 0x1F are not detected and their effect is indeterminate." end="0" id="CHARLEN" rwaccess="RW" width="5"></bitfield>
  </register>
  
  
  <register acronym="TGINTVECT0" description="SPI Interrupt Vector Register 0 / MibSPI Transfer Group Interrupt Vector Register 0" id="TGINTVECT0" offset="0x60" width="32">
    
  <bitfield begin="31" description="Reserved. Reads return ‘0’ and writes have no effect." end="6" id="NU" rwaccess="R" width="26"></bitfield>
    
  <bitfield begin="5" description="Interrupt vector for interrupt line INT0. INTVECT0 returns the vector of the pending interrupt at interrupt line INT0. If more than one interrupts are pending, INTVECT0 always references the highest priority interrupt source first. The vectors generated are different for SPI / Compatibility mode of MibSPI and Multibuffer mode of MibSPI. INTVECT0 field just reflects the status of SPIFLG register in a vectorized format. So, any updates to SPIFLG will automatically reflect in the Vector value in this register. SPI / Compatibility mode - MibSPI The interrupts available for SPI or Compatibility mode - MibSPI, in the descending order of their priorities are as given below. Transmission Error Interrupt Receive Buffer Overrun Interrupt Receive Buffer Full Interrupt Transmit Buffer Empty Interrupt Vectors for each of these interrupts will be reflected on the INTVECT0 bits, when they occur. Reading the vectors for the “Receive Buffer Overrun” &amp; “Receive Buffer Full” interrupts will automatically clear the respective flags in the SPIFLG register. On reading the INTVECT0 bits, the vector of the next highest priority interrupt (if any) will be then reflected on the INTVECT0 bits. If two or more interrupts occur simultaneously, the vector for the higest priority interrupt will be reflected on the INTVECT0 bits. Reading the Vector register when “Transmitter Empty” is indicated does not clear the TXINTFLG in SPIFLG register. Writing a new data to SPIDATx register clears the “Transmitter Empty” interrupt. INTVECT0[4:0] Description 00000b no interrupt pending 10001b Error interrupt pending. Refer to Least Significant (LS) Byte of SPIFLG to determine more details about the type of error. 10011b Pending interrupt is “Receive Buffer Overrun Interrupt” 10010b Pending interrupt is “Receive Buffer Full Interrupt” 10100b Pending interrupt is “Transmit Buffer Empty Interrupt” All other bit combinations Reserved Note: Exception for clearing of RXINT If both SPIBUF and RXBUF (internal buffer) are full, then, reading TGINTVECT0 register (while it shows 10010) does not clear the RXINTFLG in SPIFLG register. In this case, only way to clear the Interrupt is to read the SPIBUF again until there’s no more unread RX data." end="1" id="INTVECT0" rwaccess="R" width="5"></bitfield>
    
  <bitfield begin="0" description="“Transfer suspended” or “transfer finished” interrupt.(MibSPI only) The SUSPEND0 flag is updated depending on the type of interrupt reflected by the VECTOR value field. 1 =The interrupt type is a “transfer suspended” interrupt. I.e. the transfer group referenced by INTVECT0 has asserted an interrupt, because the buffer to be transferred next is in “suspend to wait” mode. 0 =The interrupt type is a “transfer finished” interrupt. I.e. the buffer array referenced by INTVECT0 has asserted an interrupt, because all of the data from the whole transfer group has been transferred. Note: Special case for SUSPEND interrupt When there’s a “transfer suspended” interrupt (SUSPEND0 bit is set to ‘1’), reading the TGINTVECT0 register does not clear the “TG Suspended” interrupt. The SUSPEND condition should be resolved first before the interrupt can be cleared. The SUSPEND condition can be cleared by writing a new data to that TXRAM location and/or reading the data from that RXRAM location depending upon the SUSPEND criteria programmed in the “BUFMODE” field of that TXRAM location. The SUSPEND0 bit always returns value ‘0’ in SPI / Compatibility mode MibSPI. When there is an RXOVRN or any Error interrupt in Multibuffer mode, SUSPEND0 bit stays ‘0’. Refer to Section 6.2 on page 77 &amp; Section 6.3 on page 77 for more details and notes on better handling of interrupts. Note: Reading Error Vector Reading an Error Vector in the TGINTVECT0 register will NOT clear the Error flags in the SPIFLG register. The Error Flags in SPIFLG need to be write-cleared after servicing them suitably. If “TG Completed” interrupt occurs for a TG and after a while “TG Suspended” flag too gets set for the same TG, then the TGINTVECT0 register will show “TG Completed” interrupt giving it higher priority than the “TG Suspended” interrrupt." end="0" id="SUSPEND0" rwaccess="R" width="1"></bitfield>
  </register>
  
  
  <register acronym="TGINTVECT1" description="SPI Interrupt Vector Register 1 / MibSPI Transfer Group Interrupt Vector Register 1" id="TGINTVECT1" offset="0x64" width="32">
    
  <bitfield begin="31" description="Reserved. Reads return ‘0’ and writes have no effect." end="6" id="NU" rwaccess="R" width="26"></bitfield>
    
  <bitfield begin="5" description="Interrupt vector for interrupt line INT1. INTVECT1 returns the vector of the pending interrupt at interrupt line INT0. If more than one interrupt is pending, INTVECT1 always references the highest priority interrupt source first. The vectors generated are different for SPI / Compatibility mode of MibSPI and Multibuffer mode of MibSPI. INTVECT1 field just reflects the status of SPIFLG register in a vectorized format. So, any updates to SPIFLG will automatically reflect in the Vector value in this register. SPI / Compatibility mode - MibSPI The interrupts available for SPI / Compatibility mode - MibSPI, in the descending order of their priorities are as given below. Transmission Error Interrupt Receive Buffer Overrun Interrupt Receive Buffer Full Interrupt Transmit Buffer Empty Interrupt Vectors for each of these interrupts will be reflected on the INTVECT1 bits, when they occur. Reading the vectors for the “Receive Buffer Overrun” &amp; “Receive Buffer Full” interrupts will automatically clear the respective flags in the SPIFLG register. On reading the INTVECT1 bits, the vector of the next highest priority interrupt (if any) will then be reflected on the INTVECT1 bits. If two or more interrupts occur simultaneously, the vector for the higest priority interrupt will be reflected on the INTVECT1 bits. Reading the Vector register when “Transmitter Empty” is indicated does not clear the TXINTFLG in SPIFLG register. Writing a new data to SPIDATx register clears the “Transmitter Empty” interrupt. 00000b no interrupt pending 10001b Error interrupt pending. Refer to LS Byte of SPIFLG to determine more details about the type of error. 10011b Pending interrupt is “Receive Buffer Overrun Interrupt” 10010b Pending interrupt is “Receive Buiffer Full Interrupt” 10100b Pending interrupt is “Transmit Buffer Empty Interrupt” All other bit combinations Reserved Note: Exception for clearing of RXINT If both SPIBUF and RXBUF (internal buffer) are full, then, reading TGINTVECT1 register (while it shows 10010) does not clear the RXINTFLG in SPIFLG register. In this case, only way to clear the Interrupt is to read out the SPIBUF again until there’s no more unread RX data." end="1" id="INTVECT1" rwaccess="R" width="5"></bitfield>
    
  <bitfield begin="0" description="“Transfer suspended” or “transfer finished” interrupt.(MibSPI Only) The SUSPEND1 flag is updated depending on the type of interrupt reflected by the VECTOR value field. 1 =The interrupt type is a “transfer suspended” interrupt. I.e. the transfer group referenced by INTVECT1 has asserted an interrupt, because the buffer to be transferred next is in “suspend to wait” mode. 0 =The interrupt type is a “transfer finished” interrupt. I.e. the buffer array referenced by INTVECT1 has asserted an interrupt, because all data from the whole transfer group has been transferred. Note: Special case for SUSPEND interrupt When there’s a “transfer suspended” interrupt(SUSPEND1 bit is set to ‘1’), reading the TGINTVECT1 register does not clear the “TG Suspended” interrupt. The SUSPEND condition should be resolved first before the interrupt can be cleared. This condition can be cleared by writing a new data to that TXRAM location and/or reading the data from that RXRAM location depending upon the SUSPEND criteria programmed in the “BUFMODE” field of that TXRAM location. The SUSPEND1 bit always returns value ‘0’ in SPI / Compatibility mode MibSPI. Even while there is an RXOVRN or any Error interrupt in Multibuffer mode, SUSPEND1 bit stays ‘0’. Refer to Section 6.2 on page 77 &amp; Section 6.3 on page 77 for more details and notes on better handling of interrupts. Note: Reading Error Vector Reading an Error Vector in the TGINTVECT1 register will NOT clear the Error flags in the SPIFLG register. The Error Flags in SPIFLG need to be write-cleared after servicing them suitably. If “TG Completed” interrupt occurs for a TG and after a while “TG Suspended” flag too gets set for the same TG, then the TGINTVECT1 register will show “TG Completed” interrupt giving it higher priority than the “TG Suspended” interrrupt." end="0" id="SUSPEND1" rwaccess="R" width="1"></bitfield>
  </register>
  
  
  <register acronym="SPIPC9" description="SPI/MibSPI Pin Control Register 9 (SPIPC9) - SPISRSEL" id="SPIPC9" offset="0x68" width="32">
    
  <bitfield begin="31" description="Each of these 7 bits controls the slew rate for the corresponding SPISOMIx pin. 0 =Normal Buffer Select. 1 =Slow Buffer Select." end="24" id="SOMISRS7" rwaccess="RW" width="8"></bitfield>
    
  <bitfield begin="23" description="Each of these 7 bits controls the slew rate for the corresponding SPISIMOx pin. 0 =Normal Buffer Select. 1 =Slow Buffer Select." end="16" id="SIMOSRS7" rwaccess="RW" width="8"></bitfield>
    
  <bitfield begin="15" description="Reserved. Reads return ‘0’ and writes have no effect." end="12" id="NU" rwaccess="R" width="4"></bitfield>
    
  <bitfield begin="11" description="This bit controls the slew rate for SPISOMI0 pin. 0 =Normal Buffer Select. 1 =Slow Buffer Select. Note: Bit 11 or bit 24 can be used to control the slew rate for SPISOMI0. If a 32 bit write is performed, bit 11 will have priority over bit 24." end="11" id="SOMISRS0" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="10" description="This bit controls the slew rate for SPISIMO0 pin. 0 =Normal Buffer Select. 1 =Slow Buffer Select. Note: Bit 10 or bit 16 can be used to control the slew rate for SPISIMO0. If a 32 bit write is performed, bit 10 will have priority over bit 16." end="10" id="SIMOSRS0" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="9" description="This bit controls the slew rate for SPICLK pin. 0 =Normal Buffer Select. 1 =Slow Buffer Select." end="9" id="CLKSRS" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="8" description="This bit controls the slew rate for SPIENA pin. 0 =Fast Buffer Select. 1 =Slow Buffer Select." end="8" id="ENASRS" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="7" description="Each of these 7 bits controls the slew rate for the corresponding SPISCSx pin. 0 =Normal Buffer Select. 1 =Slow Buffer Select. Note: Effect of NUM_CS_PINS generic on ChipSelect bits. Actual number of bits implemented in SCSSRS[7:0] will depend upon the NUM_CS_PINS generic set during synthesis. Unimplemented bits will be read-only and will read ‘0’ always." end="0" id="SCSSRS" rwaccess="RW" width="8"></bitfield>
  </register>
  
  
  <register acronym="SPIPMCTRL" description="SPI/MibSPI Parallel/Modulo Mode Control Register" id="SPIPMCTRL" offset="0x6C" width="32">
    
  <bitfield begin="31" description="Reserved. Reads return ‘0’ and writes have no effect." end="31" id="NU4" rwaccess="R" width="1"></bitfield>
    
  <bitfield begin="30" description="High Speed Modulo Mode control bit for Data Format 3. Controls whether the PMODE3 bits will result in Modulo Format data transfer or not. Refer to Section 3.26 for details about the HSM Mode. 0 = Normal mode - Normal Parallel mode if PMODE3 bits are non-zero. 1 = High Speed Modulo Mode. Data transfer will happen in Modulo Format if PMODE3 bits are non-zero" end="30" id="HSM_MODE3" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="29" description="Modulo mode SPICLK Polarity for Data Format 3 Determines the Polarity of the SPICLK in Modulo mode only. If MODULO MODE[2:0] bits are “000”, this bit will be ignored. 0 = Normal SPICLK in all the modes. 1 = Polarity of the SPICLK will be inverted if Modulo mode is selected" end="29" id="MODCLKPOL3" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="28" description="These bits determine whether the SPI/MibSPI operates with 1, 2, 4, 5, or 6 data lines (if Modulo Option is supported by the module) for Data Format 3.000 = Normal single dataline mode - Default (PMODE should be set to “00”) 001 = 2-data line Mode (PMODE should be set to “00”) 010 = 3-data line mode (PMODE should be set to “00”) 011 = 4-data line mode (PMODE should be set to “00”) 100 = 5-data line mode (PMODE should be set to “00”) 101 = 6-data line mode (PMODE should be set to “01”) 110 = Reserved 111 = Reserved" end="26" id="MMODE3" rwaccess="RW" width="3"></bitfield>
    
  <bitfield begin="25" description="Parallel mode bits determine whether the SPI/MibSPI operates with 1, 2 ,4 or 8 data lines for Data Format 3. 00 = normal operation / 1-data line (MMODE should be set to “000”) 01 = 2-data line mode (MMODE should be set to “000”) 10 = 4-data line mode (MMODE should be set to “000”) 11 = 8-data line mode (MMODE should be set to “000”)" end="24" id="PMODE3" rwaccess="RW" width="2"></bitfield>
    
  <bitfield begin="23" description="Reserved. Reads return ‘0’ and writes have no effect." end="23" id="NU3" rwaccess="R" width="1"></bitfield>
    
  <bitfield begin="22" description="High Speed Modulo Mode control bit for Data Format 2. Controls whether the PMODE2 bits will result in Modulo Format data transfer or not. Refer to Section 3.26 for details about the HSM Mode. 0 = Normal mode - Normal Parallel mode if PMODE2 bits are non-zero. 1 = High Speed Modulo Mode. Data transfer will happen in Modulo Format if PMODE2 bits are non-zero" end="22" id="HSM_MODE2" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="21" description="Modulo mode SPICLK Polarity for Data Format 2. Determines the Polarity of the SPICLK in Modulo mode only. If MMODE[2:0] bits are “000”, this bit will be ignored. 0 = Normal SPICLK in all the modes. 1 = Polarity of the SPICLK will be inverted if Modulo mode is selected" end="21" id="MODCLKPOL2" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="20" description="These bits determine whether the SPI/MibSPI operates with 1, 2, 4, 5, or 6 data lines (if Modulo Option is supported by the module) for Data Format 2. 000 = 1-data line Mode - Default (PMODE should be set to “00”) 001 = 2-data line Mode (PMODE should be set to “00”) 010 = 3-data line mode (PMODE should be set to “00”) 011 = 4-data line mode (PMODE should be set to “00”) 100 = 5-data line mode (PMODE should be set to “00”) 101 = 6-data line mode (PMODE should be set to “01”) 110 = Reserved 111 = Reserved" end="18" id="MMODE2" rwaccess="RW" width="3"></bitfield>
    
  <bitfield begin="17" description="Parallel mode bits determine whether the SPI/MibSPI operates with 1, 2 ,4 or 8 data lines for Data Format 2. 00 = normal operation / 1-data line (MMODE should be set to “000”) 01 = 2-data line mode (MMODE should be set to “000”)10 = 4-data line mode (MMODE should be set to “000”) 11 = 8-data line mode (MMODE should be set to “000”)" end="16" id="PMODE2" rwaccess="RW" width="2"></bitfield>
    
  <bitfield begin="15" description="Reserved. Reads return ‘0’ and writes have no effect." end="15" id="NU2" rwaccess="R" width="1"></bitfield>
    
  <bitfield begin="14" description="High Speed Modulo Mode control bit for Data Format 1. Controls whether the PMODE1 bits will result in Modulo Format data transfer or not. Refer to Section 3.26 for details about the HSM Mode. 0 = Normal mode - Normal Parallel mode if PMODE1 bits are non-zero. 1 = High Speed Modulo Mode. Data transfer will happen in Modulo Format if PMODE1 bits are non-zero." end="14" id="HSM_MODE1" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="13" description="Modulo mode SPICLK Polarity for Data Format 1. Determines the Polarity of the SPICLK in Modulo mode only. If MMODE[2:0] bits are “000”, this bit will be ignored. 0 = Normal SPICLK in all the modes. 1 = Polarity of the SPICLK will be inverted if Modulo mode is selected." end="13" id="MODCLKPOL1" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="12" description="These bits determine whether the SPI/MibSPI operates with 1, 2, 4, 5, or 6 data lines (if Modulo Option is supported by the module) for Data Format 1. 000 = 1-data line Mode - Default (PMODE should be set to “00”) 001 = 2-data line Mode (PMODE should be set to “00”) 010 = 3-data line mode (PMODE should be set to “00”) 011 = 4-data line mode (PMODE should be set to “00”) 100 = 5-data line mode (PMODE should be set to “00”) 101 = 6-data line mode (PMODE should be set to “01”) 110 = Reserved 111 = Reserved" end="10" id="MMODE1" rwaccess="RW" width="3"></bitfield>
    
  <bitfield begin="9" description="Parallel mode bits determine whether the SPI/MibSPI operates with 1, 2 ,4 or 8 data lines for Data Format 1. 00 = normal operation / 1-data line (MMODE should be set to “000”) 01 = 2-data line mode (MMODE should be set to “000”) 10 = 4-data line mode (MMODE should be set to “000”) 11 = 8-data line mode (MMODE should be set to “000”)" end="8" id="PMODE1" rwaccess="RW" width="2"></bitfield>
    
  <bitfield begin="7" description="Reserved. Reads return ‘0’ and writes have no effect." end="7" id="NU1" rwaccess="R" width="1"></bitfield>
    
  <bitfield begin="6" description="High Speed Modulo Mode control bit for Data Format 0. Controls whether the PMODE0 bits will result in Modulo Format data transfer or not. Refer to Section 3.26 for details about the HSM Mode. 0 = Normal mode - Normal Parallel mode if PMODE0 bits are non-zero. 1 = High Speed Modulo Mode. Data transfer will happen in Modulo Format if PMODE0 bits are non-zero." end="6" id="HSM_MODE0" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="5" description="Modulo mode SPICLK Polarity for Data Format 0. Determines the Polarity of the SPICLK in Modulo mode only. If MMODE[2:0] bits are “000”, this bit will be ignored. 0 = Normal SPICLK in all the modes. 1 = Polarity of the SPICLK will be inverted if Modulo mode is selected." end="5" id="MODCLKPOL0" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="4" description="These bits determine whether the SPI/MibSPI operates with 1, 2, 4, 5, or 6 data lines (if Modulo Option is supported by the module) for Data Format 0. 000 = 1-data line Mode - Default (PMODE should be set to “00”) 001 = 2-data line Mode (PMODE should be set to “00”) 010 = 3-data line mode (PMODE should be set to “00”) 011 = 4-data line mode (PMODE should be set to “00”) 100 = 5-data line mode (PMODE should be set to “00”) 101 = 6-data line mode (PMODE should be set to “01”) 110 = Reserved 111 = Reserved" end="2" id="MMODE0" rwaccess="RW" width="3"></bitfield>
    
  <bitfield begin="1" description="Parallel mode bits determine whether the SPI/MibSPI operates with 1, 2 ,4 or 8 data lines for Data Format 0. 00 = normal operation / 1-data line (MMODE should be set to “000”) 01 = 2-data line mode (MMODE should be set to “000”) 10 = 4-data line mode (MMODE should be set to “000”) 11 = 8-data line mode (MMODE should be set to “000”)" end="0" id="PMODE0" rwaccess="RW" width="2"></bitfield>
  </register>
  
  
  <register acronym="MIBSPIE" description="MibSPI Enable Register" id="MIBSPIE" offset="0x70" width="32">
    
  <bitfield begin="31" description="Reserved. Reads return ‘0’ and writes have no effect." end="17" id="NU3" rwaccess="R" width="15"></bitfield>
    
  <bitfield begin="16" description="Receive RAM Access control Bit. During normal operating mode of MibSPI, the Receive Data/Status portion of Multibuffer RAM is read-only. To enable testing of Data Integrity checks of Receive RAM, a special read/write access control is provided through this bit. 0 = The RX portion of Multibuffer RAM is not writable by the CPU. That is, portion of Multibuffer RAM, addressed by an offset of 0x200-0x3FF is write protected. 1 = The whole of Multibuffer RAM is fully accessible for read/write by the CPU." end="16" id="RXRAMACCESS" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="15" description="Reserved.Reads return ‘0’ and writes have no effect" end="12" id="NU2" rwaccess="R" width="4"></bitfield>
    
  <bitfield begin="11" description="Enables the support for 256 buffers. By default MibSPI supports up to 128 buffers for both TX and RX. It is also possible to extend the support to 256 buffers as a parameterized implementation. This field can be used to enable/disable the support for Extended Buffers. This Enable field is implemented only if “EXTENDED_BUF” parameter is set to ‘1’. If the parameter is set to ‘0’, this field is read-only and reads the disable value. Write (Privilege mode only) 1010 - Enable the Extended Buffer mode - up to 256 buffers can be used 0101 - Disable the Extended Buffer mode - MibSPI supports only 128 buffers All other values - writes are ignored and the values are not updated into this field. The state of the feature remains unchanged. Read (both privilege and user modes) 1010 - Extended Buffer mode is enabled - up to 256 buffers can be used 0101 - Extended Buffer mode is disabled - MibSPI supports only 128 buffers" end="8" id="EXTENDED_BUF_ENA" rwaccess="RW" width="4"></bitfield>
    
  <bitfield begin="7" description="Reserved. Reads return ‘0’ and writes have no effect." end="1" id="NU1" rwaccess="R" width="7"></bitfield>
    
  <bitfield begin="0" description="Multibuffer mode Enable. After power-up or reset MSPIENA remains cleared, which means that the MibSPI runs in compatibility mode by default. If Multibuffer mode is desired, this register should be configured first after configuring the SPIGCR0 register. Unless MSPIENA is set to ‘1’, the Multibuffer mode registers are not writable. Refer to Section 3.3 for the grouping of registers into Compatibility mode and Multibuffer mode. 1 =The MibSPI is configured to run in MibSPI mode (Multibuffer mode). In this mode the additional features are available. 0 =The MibSPI runs in compatibility mode, i.e. in this mode the MibSPI is fully code compliant to the standard TMS470 Platform SPI. No Multibuffer feature is supported" end="0" id="MSPIENA" rwaccess="RW" width="1"></bitfield>
  </register>
  
  
  <register acronym="TGITENST" description="MibSPI Transfer Group Interrupt Enable Set Register" id="TGITENST" offset="0x74" width="32">
    
  <bitfield begin="31" description="Transfer group interrupt set (enable) when transfer finished. Write: 1 = Enables the “The Transfer group x completed “ interrupt Interrupt gets generated when Transfer Group x gets completed. 0 = Has no effect. Read: 1 = “The Transfer group x completed “ interrupt is enabled Interrupt gets generated when Transfer Group x gets completed. 0 = “The Transfer group x completed” interrupt is disabled Interrupt does not get generated when Transfer Group x gets completed" end="16" id="SETINTENRDY" rwaccess="RW" width="16"></bitfield>
    
  <bitfield begin="15" description="Transfer group interrupt set (enable) when transfer suspended Write: 1 = Enables the “The Transfer group x suspended “ interrupt Interrupt gets generated when Transfer Group x gets suspended. 0 = Has no effect. Read: 1 = “The Transfer group x suspended “ interrupt is enabled Interrupt gets generated when Transfer Group x gets suspended. 0 = “The Transfer group x suspended” interrupt is disabled Interrupt does not get generated when Transfer Group x gets suspended" end="0" id="SETINTENSUS" rwaccess="RW" width="16"></bitfield>
  </register>
  
  
  <register acronym="TGITENCR" description="MibSPI Transfer Group Interrupt Enable Clear Register" id="TGITENCR" offset="0x78" width="32">
    
  <bitfield begin="31" description="Transfer group interrupt clear (disable) when transfer finished. Write: 1 = Disables the “The Transfer group x completed “ interrupt Interrupt does not get generated when Transfer Group x gets completed. 0 = Has no effect. Read: 1 = “The Transfer group x completed “ interrupt is enabled Interrupt gets generated when Transfer Group x gets completed. 0 = “The Transfer group x completed” interrupt is disabled Interrupt does not get generated when Transfer Group x gets completed" end="16" id="CLRINTENRDY" rwaccess="RW" width="16"></bitfield>
    
  <bitfield begin="15" description="Transfer group interrupt clear (disable) when transfer suspended Write: 1 = Disables the “The Transfer group x suspended “ interrupt Interrupt does not get generated when Transfer Group x gets suspended. 0 = Has no effect. Read: 1 = “The Transfer group x suspended “ interrupt is enabled Interrupt gets generated when Transfer Group x gets suspended. 0 = “The Transfer group x suspended” interrupt is disabled Interrupt does not get generated when Transfer Group x gets suspended" end="0" id="CLRINTENSUS" rwaccess="RW" width="16"></bitfield>
  </register>
  
  
  <register acronym="TGITLVST" description="MibSPI Transfer Group Interrupt Level Set Register" id="TGITLVST" offset="0x7C" width="32">
    
  <bitfield begin="31" description="Transfer group completed” Interrupt Level set register Write: 1 = Sets the “The Transfer group x completed “ interrupt to line INT1 0 = Has no effect. Read: 1 = “The Transfer group x completed “ interrupt is set to line INT1 0 = “The Transfer group x completed “ interrupt is set to line INT0" end="16" id="SETINTLVLRDY" rwaccess="RW" width="16"></bitfield>
    
  <bitfield begin="15" description="Transfer group suspended” interrupt Level set rigester Write: 1 = Sets the “The Transfer group x suspended “ interrupt to line INT1 0 = Has no effect. Read: 1 = “The Transfer group x suspended “ interrupt is set to line INT1 0 = “The Transfer group x suspended “ interrupt is set to line INT0" end="0" id="SETINTLVLSUS" rwaccess="RW" width="16"></bitfield>
  </register>
  
  
  <register acronym="TGITLVCR" description="MibSPI Transfer Group Interrupt Level Clear Register" id="TGITLVCR" offset="0x80" width="32">
    
  <bitfield begin="31" description="Transfer group completed” Interrupt Level clear register Write: 1 = Sets the “The Transfer group x completed “ interrupt to line INT0 0 = Has no effect. Read: 1 = “The Transfer group x completed “ interrupt is set to line INT1 0 = “The Transfer group x completed “ interrupt is set to line INT0" end="16" id="CLRINTLVLRDY" rwaccess="RW" width="16"></bitfield>
    
  <bitfield begin="15" description="Transfer group suspended” interrupt Level clear register Write: 1 = Sets the “The Transfer group x suspended “ interrupt to line INT0 0 = Has no effect. Read: 1 = “The Transfer group x suspended “ interrupt is set to line INT1 0 = “The Transfer group x suspended “ interrupt is set to line INT0" end="0" id="CLRINTLVLSUS" rwaccess="RW" width="16"></bitfield>
  </register>
  
  
  <register acronym="TGINTFLAG" description="Transfer Group Interrupt Flag Register" id="TGINTFLAG" offset="0x84" width="32">
    
  <bitfield begin="31" description="Transfer group interrupt flag for “transfer finished” interrupt. Read: 1 =A “transfer finished” interrupt from transfer group x occurred. No matter whether the interrupt is enabled or disabled (INTENRDYx = don’t care) or whether the interrupt is mapped to line INT0 or INT1, INTFLGRDYx is set right after the transfer from transfer group x is finished. 0 =No “transfer finished” interrupt occurred since last clearing of the flag INTFLGRDYx. Write: 1 = Clears the corresponding bit flag. 0 = Has no effect." end="16" id="INTFLGRDY" rwaccess="R" width="16"></bitfield>
    
  <bitfield begin="15" description="Transfer group interrupt flag for “transfer suspend” interrupt. Read: 1 =A “transfer suspended” interrupt from transfer group x occurred. No matter whether the interrupt is enabled or disabled (INTENSUSx = don’t care) or whether the interrupt is mapped to line INT0 or INT1, INTFLGSUSx is set right after the transfer from transfer group x is suspended. 0 =No ”transfer suspended” interrupt occurred since last clearing of the flag INTFLGSUSx. Note: Read Clear Behavior Reading the interrupt vector registers TGINTVECT0 or TGINTVECT1 automatically clears the interrupt flag bit INTFLGRDYx referenced by the vector number given by INTVECT0/INTVECT1 bits, if SUSPEND0/SUPEND1 bit in the Vector registers is ‘0’." end="0" id="INTFLGSUS" rwaccess="R" width="16"></bitfield>
  </register>
  
  
  <register acronym="TICKCNT" description="Tick Count Register" id="TICKCNT" offset="0x90" width="32">
    
  <bitfield begin="31" description="Tick counter enable. 1 =The MibSPI internal tick counter is enabled and is clocked by the clock source selected by CLKCTRL[1:0]. When the tick counter is enabled it starts down-counting from its current value. When TICKENA goes from “0” to “1” the tick counter is automatically loaded with the TICKVALUE. 0 =The MibSPI internal tick counter is disabled. The counter value remains unchanged. Note: When the tick counter is disabled the trigger signal is forced low." end="31" id="TICKENA" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="30" description="Re-load tick counter. RELOAD is a set-only bit, i.e. writing a “1” to it automatically reloads the Tick Counter with the value stored in TICKVALUE. Reading RELOAD always returns a “0”. Note: When the tick counter is reloaded by the RELOAD bit, the trigger signal is not toggled." end="30" id="RELOAD" rwaccess="R" width="1"></bitfield>
    
  <bitfield begin="29" description="Tick counter clock source control. CLKCTRL[1:0] defines the clock source that is used to clock the MibSPI internal tick counter.CLKCTRL[1:0] Description 00b SPICLK of Data word format 0 is selected as clock source of tick counter 01b SPICLK of Data word format 1 is selected as clock source of tick counter 10b SPICLK of Data word format 2 is selected as clock source of tick counter 11b SPICLK of Data word format 3 is selected as clock source of tick counter" end="28" id="CLKCTRL" rwaccess="RW" width="2"></bitfield>
    
  <bitfield begin="27" description="Reserved.Reads return ‘0’ and writes have no effect" end="16" id="NU" rwaccess="R" width="12"></bitfield>
    
  <bitfield begin="15" description="Initial value for tick counter. TICKVALUE stores the initial value for the tick counter. The tick counter is loaded with TICKVALUE every time an under-flow condition occurs and every time the RELOAD flag is set by the host" end="0" id="TICKVALUE" rwaccess="RW" width="16"></bitfield>
  </register>
  
  
  <register acronym="LTGPEND" description="Last Transfer Group End Pointer" id="LTGPEND" offset="0x94" width="32">
    
  <bitfield begin="31" description="Reserved.Reads return ‘0’ and writes have no effect" end="29" id="NU3" rwaccess="R" width="3"></bitfield>
    
  <bitfield begin="28" description="Transfer Group currently being serviced by the Sequencer. Read-Only field indicating the current Transfer Group that is being serviced. This field can generally be used for code debug purpose. Read Value:TG IN SERVICE[4:0] Description 00000b No Transfer Group is being serviced by the Sequencer 00001b Transfer Group0 is being serviced by the Sequencer ... ... 10000b Transfer Group15 is being serviced by the Sequencer 10001b - 11111b Invalid values" end="24" id="TGINSERVICE" rwaccess="R" width="5"></bitfield>
    
  <bitfield begin="23" description="Reserved.Reads return ‘0’ and writes have no effect" end="16" id="NU2" rwaccess="R" width="8"></bitfield>
    
  <bitfield begin="15" description="Last Transfer Group End Pointer Usually the transfer group end address (PEND) is inherently defined by the start value of the starting pointer of the subsequent transfer group (PSTART). The transfer group ends at the buffer one before the next transfer group starts (PEND[x]=PSTART[x+1] - 1). For a full configuration of MibSPI, the 15th transfer group has no subsequent transfer group, i.e. no end address is inherently defined. Therefore LPEND has to be programmed to specify explicitly the end address of the 15th transfer group. Number of Transfer Groups implemented in a MibSPI can vary from one MibSPI to another since it is a generic parameter based implementation. If in a MibSPI, only 4 Transfer Groups are implemented, then the PEND of the 4th TG is defined by LPEND values defined in this LTGPEND register." end="8" id="LPEND" rwaccess="RW" width="8"></bitfield>
    
  <bitfield begin="7" description="Reserved.Reads return ‘0’ and writes have no effect" end="0" id="NU1" rwaccess="R" width="8"></bitfield>
  </register>
  
  
  <register acronym="TG0CTRL" description="MibSPI Transfer Group Control Register The number of transfer groups is scalable by design up to a maximum of 16. Depending on the implementation the number of transfer groups and hence the number of transfer group control register may vary. Each transfer group can be configured via one dedicated control register. The register description below shows one exemplary control register(x) which is identical for all transfer groups. E.g. the control register for transfer group 2 is named “TG2CTRL” and is located at address base0+98h+4*2." id="TG0CTRL" offset="0x98" width="32">
    
  <bitfield begin="31" description="Transfer Group Enable. 1 =The corresponding transfer group is enabled. If the correct event (TRIGEVTx) occurs at the selected source (TRIGSRCx) a group transfer is initiated if no higher priority transfer group is in active transfer mode or if one or more higher priority Transfer Groups are in transfer suspend mode. If higher priority Transfer Groups (TG) are in transfer mode, then the newly enabled TG will wait till all of the higher priority TG transfers are completed. 0 =The corresponding transfer group is disabled. Disabling a transfer group while a transfer is ongoing, will finish the ongoing buffer transfer but not the whole group transfer" end="31" id="TGENA" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="30" description="Single transfer for this Transfer Group group. 1 =A transfer from the corresponding transfer group will be performed only once (= one shot) after a valid trigger event at the selected trigger source. After the transfer is finished the TGENAx control bit will be cleared by the MibSPI and therefore no additional transfer can be triggered before the host enables the transfer group again. This oneshot mode ensures that after one group transfer the host has enough time to read the received data and to provide new transmit data. 0 =The corresponding transfer group initiates a transfer every time a trigger event occurs and TGENA is set." end="30" id="ONESHOT" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="29" description="transfer group Pointer Reset mode. With PRST, the way of resolving trigger events during an ongoing transfer from the concerned transfer group can be configured. This bit is meaningful only for Level Triggered Transfer Groups. Edge triggered TGs cannot be re-started before their completion by another edge. PRST bit will have no effect on this behavior. 1 =The corresponding transfer group pointer (PCURRENTx) will be reset to the start address (PSTARTx) when a valid trigger event occurs at the selected trigger source while a transfer from the same transfer group is ongoing. I.e. every trigger event resets PCURRENTx no matter whether the concerned transfer group is in transfer mode or not. The trigger events have priority over the ongoing transfer. 0 =If a trigger event occurs during a transfer from the concerned transfer group, the event is ignored and is not stored internally. The transfer group transfer has priority over additional trigger events." end="29" id="PRST" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="28" description="Transfer group triggered. This bit is read-only. 1 =The transfer group has been triggered and is either currently in service or waiting for servicing. 0 =The corresponding transfer group has not been triggered or is no more waiting for service. Use the “TG IN SERVICE” field in LTGPEND register to determine the exact Transfer Group being currently serviced" end="28" id="TGTD" rwaccess="R" width="1"></bitfield>
    
  <bitfield begin="27" description="Reserved.Reads return ‘0’ and writes have no effect" end="24" id="NU" rwaccess="R" width="4"></bitfield>
    
  <bitfield begin="23" description="Type of trigger event. After reset, the trigger event types of all transfer groups are set to inactive TypesTRIGEVTx[3:0] Type Description 0000b never 0001b rising edge A rising edge (0 to 1) at the selected trigger source (TRIGSRCx) initiates a transfer from the corresponding transfer group 0010b falling edge A falling edge (1 to 0) at the selected trigger source (TRIGSRCx) initiates a transfer from the corresponding transfer group 0011b both edges Rising and falling edges at the selected trigger source (TRIGSRCx) initiates a transfer from the corresponding transfer group 0100b reserved 0101b high-active Repetitive group transfer while trigger is high: While the selected trigger source (TRIGSRCx) is at a logic high level (1) the group transfer is continued and at the end of one group transfer restarted at the beginning. If ONESHOTx is set the transfer is performed only once. If the logic level changes to low (0) during an ongoing group transfer, the whole group transfer will be stopped. 0110b low-active Repetitive group transfer while trigger is low: While the selected trigger source (TRIGSRCx) is at a logic low level (0) the group transfer is continued and at the end of one restarted at the beginning. If ONESHOTx is set the transfer is performed only once. If the logic level changes to high (1) during an ongoing group transfer, the whole group transfer will be stopped. 0111b always A repetitive group transfer will be performed. Setting ONESHOTx allows a software controlled single transfer modea a. By setting the TRIGSRC to 0000b, the TRIGEVT to ALWAYS (0111b) the ONESHOT bit to 1. This allows a software control trigger on this Transfer Group. Then by setting the TGENA bit, the Transfer Group is immediately triggered. . If ONESHOTx is cleared a continuous mode for this Transfer Group is selected.1xxxb reserved" end="20" id="TRIGEVT" rwaccess="RW" width="4"></bitfield>
    
  <bitfield begin="19" description="Trigger source. After reset the trigger sources of all transfer groups are disabled. Table 22. Trigger SourcesTRIGSRCx[3:0] Type Description 0000b disabled 0001b EXT0 MibSPI external trigger source 0. Source has to be defined individually for each Microcontroller derivative (e.g. HET I/O channel, event pin, etc.). 0010b EXT1 MibSPI external trigger source 1. Source has to be defined individually for each Microcontroller derivative (e.g. HET I/O channel, event pin, etc.). 0011b EXT2 MibSPI external trigger source 2. Source has to be defined individually for each Microcontroller derivative (e.g. HET I/O channel, event pin, etc.). 0100b EXT3 MibSPI external trigger source 3. Source has to be defined individually for each Microcontroller derivative (e.g. HET I/O channel, event pin, etc.). ... ... ... 1110b EXT13 MibSPI external trigger source 13. Source has to be defined individually for each Microcontroller derivative (e.g. HET I/O channel, event pin, etc.). 1111b TICK MibSPI internal periodic event trigger. The tick counter can initiate periodic group transfers." end="16" id="TRIGSRC" rwaccess="RW" width="4"></bitfield>
    
  <bitfield begin="15" description="transfer group start address. PSTARTx stores the start address of the corresponding transfer group. The corresponding end address is inherently defined by the subsequent transfer groups start address minus one (PENDx[TGx] = PSTARTx[TGx+1]-1). PSTARTx is copied into PCURRENTx when: o the transfer group is enabled o the end of the transfer group is reached during a transfer o a trigger event occurs while PRST is set to 1" end="8" id="PSTART" rwaccess="RW" width="8"></bitfield>
    
  <bitfield begin="7" description="transfer group pointer to current buffer. PCURRENT is read-only. PCURRENTx stores the address (0...127/255) of the buffer that is currently transferred or that will be transferred after a trigger event occurs (if PRSTx=0) or after the transfer group resumes from suspend to wait mode. If the transfer group switches mode from active transfer mode to “suspend to wait”, PCURRENTx keeps the address of the currently Suspended buffer. After the transfer group resumes from “suspend to wait” mode the next buffer will be transferred. I.e. no buffer data is multiply transferred or not at all transferred due to “suspend to wait” mode." end="0" id="PCURRENT" rwaccess="R" width="8"></bitfield>
  </register>
  
  
  <register acronym="TG1CTRL" description="MibSPI Transfer Group Control Register" id="TG1CTRL" offset="0x9C" width="32">
    
  <bitfield begin="31" description="Transfer Group Enable. 1 =The corresponding transfer group is enabled. If the correct event (TRIGEVTx) occurs at the selected source (TRIGSRCx) a group transfer is initiated if no higher priority transfer group is in active transfer mode or if one or more higher priority Transfer Groups are in transfer suspend mode. If higher priority Transfer Groups (TG) are in transfer mode, then the newly enabled TG will wait till all of the higher priority TG transfers are completed. 0 =The corresponding transfer group is disabled. Disabling a transfer group while a transfer is ongoing, will finish the ongoing buffer transfer but not the whole group transfer" end="31" id="TGENA" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="30" description="Single transfer for this Transfer Group group. 1 =A transfer from the corresponding transfer group will be performed only once (= one shot) after a valid trigger event at the selected trigger source. After the transfer is finished the TGENAx control bit will be cleared by the MibSPI and therefore no additional transfer can be triggered before the host enables the transfer group again. This oneshot mode ensures that after one group transfer the host has enough time to read the received data and to provide new transmit data. 0 =The corresponding transfer group initiates a transfer every time a trigger event occurs and TGENA is set." end="30" id="ONESHOT" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="29" description="transfer group Pointer Reset mode. With PRST, the way of resolving trigger events during an ongoing transfer from the concerned transfer group can be configured. This bit is meaningful only for Level Triggered Transfer Groups. Edge triggered TGs cannot be re-started before their completion by another edge. PRST bit will have no effect on this behavior. 1 =The corresponding transfer group pointer (PCURRENTx) will be reset to the start address (PSTARTx) when a valid trigger event occurs at the selected trigger source while a transfer from the same transfer group is ongoing. I.e. every trigger event resets PCURRENTx no matter whether the concerned transfer group is in transfer mode or not. The trigger events have priority over the ongoing transfer. 0 =If a trigger event occurs during a transfer from the concerned transfer group, the event is ignored and is not stored internally. The transfer group transfer has priority over additional trigger events." end="29" id="PRST" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="28" description="Transfer group triggered. This bit is read-only. 1 =The transfer group has been triggered and is either currently in service or waiting for servicing. 0 =The corresponding transfer group has not been triggered or is no more waiting for service. Use the “TG IN SERVICE” field in LTGPEND register to determine the exact Transfer Group being currently serviced" end="28" id="TGTD" rwaccess="R" width="1"></bitfield>
    
  <bitfield begin="27" description="Reserved.Reads return ‘0’ and writes have no effect" end="24" id="NU" rwaccess="R" width="4"></bitfield>
    
  <bitfield begin="23" description="Type of trigger event. After reset, the trigger event types of all transfer groups are set to inactive TypesTRIGEVTx[3:0] Type Description 0000b never 0001b rising edge A rising edge (0 to 1) at the selected trigger source (TRIGSRCx) initiates a transfer from the corresponding transfer group 0010b falling edge A falling edge (1 to 0) at the selected trigger source (TRIGSRCx) initiates a transfer from the corresponding transfer group 0011b both edges Rising and falling edges at the selected trigger source (TRIGSRCx) initiates a transfer from the corresponding transfer group 0100b reserved 0101b high-active Repetitive group transfer while trigger is high: While the selected trigger source (TRIGSRCx) is at a logic high level (1) the group transfer is continued and at the end of one group transfer restarted at the beginning. If ONESHOTx is set the transfer is performed only once. If the logic level changes to low (0) during an ongoing group transfer, the whole group transfer will be stopped. 0110b low-active Repetitive group transfer while trigger is low: While the selected trigger source (TRIGSRCx) is at a logic low level (0) the group transfer is continued and at the end of one restarted at the beginning. If ONESHOTx is set the transfer is performed only once. If the logic level changes to high (1) during an ongoing group transfer, the whole group transfer will be stopped. 0111b always A repetitive group transfer will be performed. Setting ONESHOTx allows a software controlled single transfer modea a. By setting the TRIGSRC to 0000b, the TRIGEVT to ALWAYS (0111b) the ONESHOT bit to 1. This allows a software control trigger on this Transfer Group. Then by setting the TGENA bit, the Transfer Group is immediately triggered. . If ONESHOTx is cleared a continuous mode for this Transfer Group is selected.1xxxb reserved" end="20" id="TRIGEVT" rwaccess="RW" width="4"></bitfield>
    
  <bitfield begin="19" description="Trigger source. After reset the trigger sources of all transfer groups are disabled. Table 22. Trigger SourcesTRIGSRCx[3:0] Type Description 0000b disabled 0001b EXT0 MibSPI external trigger source 0. Source has to be defined individually for each Microcontroller derivative (e.g. HET I/O channel, event pin, etc.). 0010b EXT1 MibSPI external trigger source 1. Source has to be defined individually for each Microcontroller derivative (e.g. HET I/O channel, event pin, etc.). 0011b EXT2 MibSPI external trigger source 2. Source has to be defined individually for each Microcontroller derivative (e.g. HET I/O channel, event pin, etc.). 0100b EXT3 MibSPI external trigger source 3. Source has to be defined individually for each Microcontroller derivative (e.g. HET I/O channel, event pin, etc.). ... ... ... 1110b EXT13 MibSPI external trigger source 13. Source has to be defined individually for each Microcontroller derivative (e.g. HET I/O channel, event pin, etc.). 1111b TICK MibSPI internal periodic event trigger. The tick counter can initiate periodic group transfers." end="16" id="TRIGSRC" rwaccess="RW" width="4"></bitfield>
    
  <bitfield begin="15" description="transfer group start address. PSTARTx stores the start address of the corresponding transfer group. The corresponding end address is inherently defined by the subsequent transfer groups start address minus one (PENDx[TGx] = PSTARTx[TGx+1]-1). PSTARTx is copied into PCURRENTx when: o the transfer group is enabled o the end of the transfer group is reached during a transfer o a trigger event occurs while PRST is set to 1" end="8" id="PSTART" rwaccess="RW" width="8"></bitfield>
    
  <bitfield begin="7" description="transfer group pointer to current buffer. PCURRENT is read-only. PCURRENTx stores the address (0...127/255) of the buffer that is currently transferred or that will be transferred after a trigger event occurs (if PRSTx=0) or after the transfer group resumes from suspend to wait mode. If the transfer group switches mode from active transfer mode to “suspend to wait”, PCURRENTx keeps the address of the currently Suspended buffer. After the transfer group resumes from “suspend to wait” mode the next buffer will be transferred. I.e. no buffer data is multiply transferred or not at all transferred due to “suspend to wait” mode." end="0" id="PCURRENT" rwaccess="R" width="8"></bitfield>
  </register>
  
  
  <register acronym="TG2CTRL" description="MibSPI Transfer Group Control Register" id="TG2CTRL" offset="0xA0" width="32">
    
  <bitfield begin="31" description="Transfer Group Enable. 1 =The corresponding transfer group is enabled. If the correct event (TRIGEVTx) occurs at the selected source (TRIGSRCx) a group transfer is initiated if no higher priority transfer group is in active transfer mode or if one or more higher priority Transfer Groups are in transfer suspend mode. If higher priority Transfer Groups (TG) are in transfer mode, then the newly enabled TG will wait till all of the higher priority TG transfers are completed. 0 =The corresponding transfer group is disabled. Disabling a transfer group while a transfer is ongoing, will finish the ongoing buffer transfer but not the whole group transfer" end="31" id="TGENA" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="30" description="Single transfer for this Transfer Group group. 1 =A transfer from the corresponding transfer group will be performed only once (= one shot) after a valid trigger event at the selected trigger source. After the transfer is finished the TGENAx control bit will be cleared by the MibSPI and therefore no additional transfer can be triggered before the host enables the transfer group again. This oneshot mode ensures that after one group transfer the host has enough time to read the received data and to provide new transmit data. 0 =The corresponding transfer group initiates a transfer every time a trigger event occurs and TGENA is set." end="30" id="ONESHOT" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="29" description="transfer group Pointer Reset mode. With PRST, the way of resolving trigger events during an ongoing transfer from the concerned transfer group can be configured. This bit is meaningful only for Level Triggered Transfer Groups. Edge triggered TGs cannot be re-started before their completion by another edge. PRST bit will have no effect on this behavior. 1 =The corresponding transfer group pointer (PCURRENTx) will be reset to the start address (PSTARTx) when a valid trigger event occurs at the selected trigger source while a transfer from the same transfer group is ongoing. I.e. every trigger event resets PCURRENTx no matter whether the concerned transfer group is in transfer mode or not. The trigger events have priority over the ongoing transfer. 0 =If a trigger event occurs during a transfer from the concerned transfer group, the event is ignored and is not stored internally. The transfer group transfer has priority over additional trigger events." end="29" id="PRST" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="28" description="Transfer group triggered. This bit is read-only. 1 =The transfer group has been triggered and is either currently in service or waiting for servicing. 0 =The corresponding transfer group has not been triggered or is no more waiting for service. Use the “TG IN SERVICE” field in LTGPEND register to determine the exact Transfer Group being currently serviced" end="28" id="TGTD" rwaccess="R" width="1"></bitfield>
    
  <bitfield begin="27" description="Reserved.Reads return ‘0’ and writes have no effect" end="24" id="NU" rwaccess="R" width="4"></bitfield>
    
  <bitfield begin="23" description="Type of trigger event. After reset, the trigger event types of all transfer groups are set to inactive TypesTRIGEVTx[3:0] Type Description 0000b never 0001b rising edge A rising edge (0 to 1) at the selected trigger source (TRIGSRCx) initiates a transfer from the corresponding transfer group 0010b falling edge A falling edge (1 to 0) at the selected trigger source (TRIGSRCx) initiates a transfer from the corresponding transfer group 0011b both edges Rising and falling edges at the selected trigger source (TRIGSRCx) initiates a transfer from the corresponding transfer group 0100b reserved 0101b high-active Repetitive group transfer while trigger is high: While the selected trigger source (TRIGSRCx) is at a logic high level (1) the group transfer is continued and at the end of one group transfer restarted at the beginning. If ONESHOTx is set the transfer is performed only once. If the logic level changes to low (0) during an ongoing group transfer, the whole group transfer will be stopped. 0110b low-active Repetitive group transfer while trigger is low: While the selected trigger source (TRIGSRCx) is at a logic low level (0) the group transfer is continued and at the end of one restarted at the beginning. If ONESHOTx is set the transfer is performed only once. If the logic level changes to high (1) during an ongoing group transfer, the whole group transfer will be stopped. 0111b always A repetitive group transfer will be performed. Setting ONESHOTx allows a software controlled single transfer modea a. By setting the TRIGSRC to 0000b, the TRIGEVT to ALWAYS (0111b) the ONESHOT bit to 1. This allows a software control trigger on this Transfer Group. Then by setting the TGENA bit, the Transfer Group is immediately triggered. . If ONESHOTx is cleared a continuous mode for this Transfer Group is selected.1xxxb reserved" end="20" id="TRIGEVT" rwaccess="RW" width="4"></bitfield>
    
  <bitfield begin="19" description="Trigger source. After reset the trigger sources of all transfer groups are disabled. Table 22. Trigger SourcesTRIGSRCx[3:0] Type Description 0000b disabled 0001b EXT0 MibSPI external trigger source 0. Source has to be defined individually for each Microcontroller derivative (e.g. HET I/O channel, event pin, etc.). 0010b EXT1 MibSPI external trigger source 1. Source has to be defined individually for each Microcontroller derivative (e.g. HET I/O channel, event pin, etc.). 0011b EXT2 MibSPI external trigger source 2. Source has to be defined individually for each Microcontroller derivative (e.g. HET I/O channel, event pin, etc.). 0100b EXT3 MibSPI external trigger source 3. Source has to be defined individually for each Microcontroller derivative (e.g. HET I/O channel, event pin, etc.). ... ... ... 1110b EXT13 MibSPI external trigger source 13. Source has to be defined individually for each Microcontroller derivative (e.g. HET I/O channel, event pin, etc.). 1111b TICK MibSPI internal periodic event trigger. The tick counter can initiate periodic group transfers." end="16" id="TRIGSRC" rwaccess="RW" width="4"></bitfield>
    
  <bitfield begin="15" description="transfer group start address. PSTARTx stores the start address of the corresponding transfer group. The corresponding end address is inherently defined by the subsequent transfer groups start address minus one (PENDx[TGx] = PSTARTx[TGx+1]-1). PSTARTx is copied into PCURRENTx when: o the transfer group is enabled o the end of the transfer group is reached during a transfer o a trigger event occurs while PRST is set to 1" end="8" id="PSTART" rwaccess="RW" width="8"></bitfield>
    
  <bitfield begin="7" description="transfer group pointer to current buffer. PCURRENT is read-only. PCURRENTx stores the address (0...127/255) of the buffer that is currently transferred or that will be transferred after a trigger event occurs (if PRSTx=0) or after the transfer group resumes from suspend to wait mode. If the transfer group switches mode from active transfer mode to “suspend to wait”, PCURRENTx keeps the address of the currently Suspended buffer. After the transfer group resumes from “suspend to wait” mode the next buffer will be transferred. I.e. no buffer data is multiply transferred or not at all transferred due to “suspend to wait” mode." end="0" id="PCURRENT" rwaccess="R" width="8"></bitfield>
  </register>
  
  
  <register acronym="TG3CTRL" description="MibSPI Transfer Group Control Register" id="TG3CTRL" offset="0xA4" width="32">
    
  <bitfield begin="31" description="Transfer Group Enable. 1 =The corresponding transfer group is enabled. If the correct event (TRIGEVTx) occurs at the selected source (TRIGSRCx) a group transfer is initiated if no higher priority transfer group is in active transfer mode or if one or more higher priority Transfer Groups are in transfer suspend mode. If higher priority Transfer Groups (TG) are in transfer mode, then the newly enabled TG will wait till all of the higher priority TG transfers are completed. 0 =The corresponding transfer group is disabled. Disabling a transfer group while a transfer is ongoing, will finish the ongoing buffer transfer but not the whole group transfer" end="31" id="TGENA" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="30" description="Single transfer for this Transfer Group group. 1 =A transfer from the corresponding transfer group will be performed only once (= one shot) after a valid trigger event at the selected trigger source. After the transfer is finished the TGENAx control bit will be cleared by the MibSPI and therefore no additional transfer can be triggered before the host enables the transfer group again. This oneshot mode ensures that after one group transfer the host has enough time to read the received data and to provide new transmit data. 0 =The corresponding transfer group initiates a transfer every time a trigger event occurs and TGENA is set." end="30" id="ONESHOT" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="29" description="transfer group Pointer Reset mode. With PRST, the way of resolving trigger events during an ongoing transfer from the concerned transfer group can be configured. This bit is meaningful only for Level Triggered Transfer Groups. Edge triggered TGs cannot be re-started before their completion by another edge. PRST bit will have no effect on this behavior. 1 =The corresponding transfer group pointer (PCURRENTx) will be reset to the start address (PSTARTx) when a valid trigger event occurs at the selected trigger source while a transfer from the same transfer group is ongoing. I.e. every trigger event resets PCURRENTx no matter whether the concerned transfer group is in transfer mode or not. The trigger events have priority over the ongoing transfer. 0 =If a trigger event occurs during a transfer from the concerned transfer group, the event is ignored and is not stored internally. The transfer group transfer has priority over additional trigger events." end="29" id="PRST" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="28" description="Transfer group triggered. This bit is read-only. 1 =The transfer group has been triggered and is either currently in service or waiting for servicing. 0 =The corresponding transfer group has not been triggered or is no more waiting for service. Use the “TG IN SERVICE” field in LTGPEND register to determine the exact Transfer Group being currently serviced" end="28" id="TGTD" rwaccess="R" width="1"></bitfield>
    
  <bitfield begin="27" description="Reserved.Reads return ‘0’ and writes have no effect" end="24" id="NU" rwaccess="R" width="4"></bitfield>
    
  <bitfield begin="23" description="Type of trigger event. After reset, the trigger event types of all transfer groups are set to inactive TypesTRIGEVTx[3:0] Type Description 0000b never 0001b rising edge A rising edge (0 to 1) at the selected trigger source (TRIGSRCx) initiates a transfer from the corresponding transfer group 0010b falling edge A falling edge (1 to 0) at the selected trigger source (TRIGSRCx) initiates a transfer from the corresponding transfer group 0011b both edges Rising and falling edges at the selected trigger source (TRIGSRCx) initiates a transfer from the corresponding transfer group 0100b reserved 0101b high-active Repetitive group transfer while trigger is high: While the selected trigger source (TRIGSRCx) is at a logic high level (1) the group transfer is continued and at the end of one group transfer restarted at the beginning. If ONESHOTx is set the transfer is performed only once. If the logic level changes to low (0) during an ongoing group transfer, the whole group transfer will be stopped. 0110b low-active Repetitive group transfer while trigger is low: While the selected trigger source (TRIGSRCx) is at a logic low level (0) the group transfer is continued and at the end of one restarted at the beginning. If ONESHOTx is set the transfer is performed only once. If the logic level changes to high (1) during an ongoing group transfer, the whole group transfer will be stopped. 0111b always A repetitive group transfer will be performed. Setting ONESHOTx allows a software controlled single transfer modea a. By setting the TRIGSRC to 0000b, the TRIGEVT to ALWAYS (0111b) the ONESHOT bit to 1. This allows a software control trigger on this Transfer Group. Then by setting the TGENA bit, the Transfer Group is immediately triggered. . If ONESHOTx is cleared a continuous mode for this Transfer Group is selected.1xxxb reserved" end="20" id="TRIGEVT" rwaccess="RW" width="4"></bitfield>
    
  <bitfield begin="19" description="Trigger source. After reset the trigger sources of all transfer groups are disabled. Table 22. Trigger SourcesTRIGSRCx[3:0] Type Description 0000b disabled 0001b EXT0 MibSPI external trigger source 0. Source has to be defined individually for each Microcontroller derivative (e.g. HET I/O channel, event pin, etc.). 0010b EXT1 MibSPI external trigger source 1. Source has to be defined individually for each Microcontroller derivative (e.g. HET I/O channel, event pin, etc.). 0011b EXT2 MibSPI external trigger source 2. Source has to be defined individually for each Microcontroller derivative (e.g. HET I/O channel, event pin, etc.). 0100b EXT3 MibSPI external trigger source 3. Source has to be defined individually for each Microcontroller derivative (e.g. HET I/O channel, event pin, etc.). ... ... ... 1110b EXT13 MibSPI external trigger source 13. Source has to be defined individually for each Microcontroller derivative (e.g. HET I/O channel, event pin, etc.). 1111b TICK MibSPI internal periodic event trigger. The tick counter can initiate periodic group transfers." end="16" id="TRIGSRC" rwaccess="RW" width="4"></bitfield>
    
  <bitfield begin="15" description="transfer group start address. PSTARTx stores the start address of the corresponding transfer group. The corresponding end address is inherently defined by the subsequent transfer groups start address minus one (PENDx[TGx] = PSTARTx[TGx+1]-1). PSTARTx is copied into PCURRENTx when: o the transfer group is enabled o the end of the transfer group is reached during a transfer o a trigger event occurs while PRST is set to 1" end="8" id="PSTART" rwaccess="RW" width="8"></bitfield>
    
  <bitfield begin="7" description="transfer group pointer to current buffer. PCURRENT is read-only. PCURRENTx stores the address (0...127/255) of the buffer that is currently transferred or that will be transferred after a trigger event occurs (if PRSTx=0) or after the transfer group resumes from suspend to wait mode. If the transfer group switches mode from active transfer mode to “suspend to wait”, PCURRENTx keeps the address of the currently Suspended buffer. After the transfer group resumes from “suspend to wait” mode the next buffer will be transferred. I.e. no buffer data is multiply transferred or not at all transferred due to “suspend to wait” mode." end="0" id="PCURRENT" rwaccess="R" width="8"></bitfield>
  </register>
  
  
  <register acronym="TG4CTRL" description="MibSPI Transfer Group Control Register" id="TG4CTRL" offset="0xA8" width="32">
    
  <bitfield begin="31" description="Transfer Group Enable. 1 =The corresponding transfer group is enabled. If the correct event (TRIGEVTx) occurs at the selected source (TRIGSRCx) a group transfer is initiated if no higher priority transfer group is in active transfer mode or if one or more higher priority Transfer Groups are in transfer suspend mode. If higher priority Transfer Groups (TG) are in transfer mode, then the newly enabled TG will wait till all of the higher priority TG transfers are completed. 0 =The corresponding transfer group is disabled. Disabling a transfer group while a transfer is ongoing, will finish the ongoing buffer transfer but not the whole group transfer" end="31" id="TGENA" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="30" description="Single transfer for this Transfer Group group. 1 =A transfer from the corresponding transfer group will be performed only once (= one shot) after a valid trigger event at the selected trigger source. After the transfer is finished the TGENAx control bit will be cleared by the MibSPI and therefore no additional transfer can be triggered before the host enables the transfer group again. This oneshot mode ensures that after one group transfer the host has enough time to read the received data and to provide new transmit data. 0 =The corresponding transfer group initiates a transfer every time a trigger event occurs and TGENA is set." end="30" id="ONESHOT" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="29" description="transfer group Pointer Reset mode. With PRST, the way of resolving trigger events during an ongoing transfer from the concerned transfer group can be configured. This bit is meaningful only for Level Triggered Transfer Groups. Edge triggered TGs cannot be re-started before their completion by another edge. PRST bit will have no effect on this behavior. 1 =The corresponding transfer group pointer (PCURRENTx) will be reset to the start address (PSTARTx) when a valid trigger event occurs at the selected trigger source while a transfer from the same transfer group is ongoing. I.e. every trigger event resets PCURRENTx no matter whether the concerned transfer group is in transfer mode or not. The trigger events have priority over the ongoing transfer. 0 =If a trigger event occurs during a transfer from the concerned transfer group, the event is ignored and is not stored internally. The transfer group transfer has priority over additional trigger events." end="29" id="PRST" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="28" description="Transfer group triggered. This bit is read-only. 1 =The transfer group has been triggered and is either currently in service or waiting for servicing. 0 =The corresponding transfer group has not been triggered or is no more waiting for service. Use the “TG IN SERVICE” field in LTGPEND register to determine the exact Transfer Group being currently serviced" end="28" id="TGTD" rwaccess="R" width="1"></bitfield>
    
  <bitfield begin="27" description="Reserved.Reads return ‘0’ and writes have no effect" end="24" id="NU" rwaccess="R" width="4"></bitfield>
    
  <bitfield begin="23" description="Type of trigger event. After reset, the trigger event types of all transfer groups are set to inactive TypesTRIGEVTx[3:0] Type Description 0000b never 0001b rising edge A rising edge (0 to 1) at the selected trigger source (TRIGSRCx) initiates a transfer from the corresponding transfer group 0010b falling edge A falling edge (1 to 0) at the selected trigger source (TRIGSRCx) initiates a transfer from the corresponding transfer group 0011b both edges Rising and falling edges at the selected trigger source (TRIGSRCx) initiates a transfer from the corresponding transfer group 0100b reserved 0101b high-active Repetitive group transfer while trigger is high: While the selected trigger source (TRIGSRCx) is at a logic high level (1) the group transfer is continued and at the end of one group transfer restarted at the beginning. If ONESHOTx is set the transfer is performed only once. If the logic level changes to low (0) during an ongoing group transfer, the whole group transfer will be stopped. 0110b low-active Repetitive group transfer while trigger is low: While the selected trigger source (TRIGSRCx) is at a logic low level (0) the group transfer is continued and at the end of one restarted at the beginning. If ONESHOTx is set the transfer is performed only once. If the logic level changes to high (1) during an ongoing group transfer, the whole group transfer will be stopped. 0111b always A repetitive group transfer will be performed. Setting ONESHOTx allows a software controlled single transfer modea a. By setting the TRIGSRC to 0000b, the TRIGEVT to ALWAYS (0111b) the ONESHOT bit to 1. This allows a software control trigger on this Transfer Group. Then by setting the TGENA bit, the Transfer Group is immediately triggered. . If ONESHOTx is cleared a continuous mode for this Transfer Group is selected.1xxxb reserved" end="20" id="TRIGEVT" rwaccess="RW" width="4"></bitfield>
    
  <bitfield begin="19" description="Trigger source. After reset the trigger sources of all transfer groups are disabled. Table 22. Trigger SourcesTRIGSRCx[3:0] Type Description 0000b disabled 0001b EXT0 MibSPI external trigger source 0. Source has to be defined individually for each Microcontroller derivative (e.g. HET I/O channel, event pin, etc.). 0010b EXT1 MibSPI external trigger source 1. Source has to be defined individually for each Microcontroller derivative (e.g. HET I/O channel, event pin, etc.). 0011b EXT2 MibSPI external trigger source 2. Source has to be defined individually for each Microcontroller derivative (e.g. HET I/O channel, event pin, etc.). 0100b EXT3 MibSPI external trigger source 3. Source has to be defined individually for each Microcontroller derivative (e.g. HET I/O channel, event pin, etc.). ... ... ... 1110b EXT13 MibSPI external trigger source 13. Source has to be defined individually for each Microcontroller derivative (e.g. HET I/O channel, event pin, etc.). 1111b TICK MibSPI internal periodic event trigger. The tick counter can initiate periodic group transfers." end="16" id="TRIGSRC" rwaccess="RW" width="4"></bitfield>
    
  <bitfield begin="15" description="transfer group start address. PSTARTx stores the start address of the corresponding transfer group. The corresponding end address is inherently defined by the subsequent transfer groups start address minus one (PENDx[TGx] = PSTARTx[TGx+1]-1). PSTARTx is copied into PCURRENTx when: o the transfer group is enabled o the end of the transfer group is reached during a transfer o a trigger event occurs while PRST is set to 1" end="8" id="PSTART" rwaccess="RW" width="8"></bitfield>
    
  <bitfield begin="7" description="transfer group pointer to current buffer. PCURRENT is read-only. PCURRENTx stores the address (0...127/255) of the buffer that is currently transferred or that will be transferred after a trigger event occurs (if PRSTx=0) or after the transfer group resumes from suspend to wait mode. If the transfer group switches mode from active transfer mode to “suspend to wait”, PCURRENTx keeps the address of the currently Suspended buffer. After the transfer group resumes from “suspend to wait” mode the next buffer will be transferred. I.e. no buffer data is multiply transferred or not at all transferred due to “suspend to wait” mode." end="0" id="PCURRENT" rwaccess="R" width="8"></bitfield>
  </register>
  
  
  <register acronym="TG5CTRL" description="MibSPI Transfer Group Control Register" id="TG5CTRL" offset="0xAC" width="32">
    
  <bitfield begin="31" description="Transfer Group Enable. 1 =The corresponding transfer group is enabled. If the correct event (TRIGEVTx) occurs at the selected source (TRIGSRCx) a group transfer is initiated if no higher priority transfer group is in active transfer mode or if one or more higher priority Transfer Groups are in transfer suspend mode. If higher priority Transfer Groups (TG) are in transfer mode, then the newly enabled TG will wait till all of the higher priority TG transfers are completed. 0 =The corresponding transfer group is disabled. Disabling a transfer group while a transfer is ongoing, will finish the ongoing buffer transfer but not the whole group transfer" end="31" id="TGENA" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="30" description="Single transfer for this Transfer Group group. 1 =A transfer from the corresponding transfer group will be performed only once (= one shot) after a valid trigger event at the selected trigger source. After the transfer is finished the TGENAx control bit will be cleared by the MibSPI and therefore no additional transfer can be triggered before the host enables the transfer group again. This oneshot mode ensures that after one group transfer the host has enough time to read the received data and to provide new transmit data. 0 =The corresponding transfer group initiates a transfer every time a trigger event occurs and TGENA is set." end="30" id="ONESHOT" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="29" description="transfer group Pointer Reset mode. With PRST, the way of resolving trigger events during an ongoing transfer from the concerned transfer group can be configured. This bit is meaningful only for Level Triggered Transfer Groups. Edge triggered TGs cannot be re-started before their completion by another edge. PRST bit will have no effect on this behavior. 1 =The corresponding transfer group pointer (PCURRENTx) will be reset to the start address (PSTARTx) when a valid trigger event occurs at the selected trigger source while a transfer from the same transfer group is ongoing. I.e. every trigger event resets PCURRENTx no matter whether the concerned transfer group is in transfer mode or not. The trigger events have priority over the ongoing transfer. 0 =If a trigger event occurs during a transfer from the concerned transfer group, the event is ignored and is not stored internally. The transfer group transfer has priority over additional trigger events." end="29" id="PRST" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="28" description="Transfer group triggered. This bit is read-only. 1 =The transfer group has been triggered and is either currently in service or waiting for servicing. 0 =The corresponding transfer group has not been triggered or is no more waiting for service. Use the “TG IN SERVICE” field in LTGPEND register to determine the exact Transfer Group being currently serviced" end="28" id="TGTD" rwaccess="R" width="1"></bitfield>
    
  <bitfield begin="27" description="Reserved.Reads return ‘0’ and writes have no effect" end="24" id="NU" rwaccess="R" width="4"></bitfield>
    
  <bitfield begin="23" description="Type of trigger event. After reset, the trigger event types of all transfer groups are set to inactive TypesTRIGEVTx[3:0] Type Description 0000b never 0001b rising edge A rising edge (0 to 1) at the selected trigger source (TRIGSRCx) initiates a transfer from the corresponding transfer group 0010b falling edge A falling edge (1 to 0) at the selected trigger source (TRIGSRCx) initiates a transfer from the corresponding transfer group 0011b both edges Rising and falling edges at the selected trigger source (TRIGSRCx) initiates a transfer from the corresponding transfer group 0100b reserved 0101b high-active Repetitive group transfer while trigger is high: While the selected trigger source (TRIGSRCx) is at a logic high level (1) the group transfer is continued and at the end of one group transfer restarted at the beginning. If ONESHOTx is set the transfer is performed only once. If the logic level changes to low (0) during an ongoing group transfer, the whole group transfer will be stopped. 0110b low-active Repetitive group transfer while trigger is low: While the selected trigger source (TRIGSRCx) is at a logic low level (0) the group transfer is continued and at the end of one restarted at the beginning. If ONESHOTx is set the transfer is performed only once. If the logic level changes to high (1) during an ongoing group transfer, the whole group transfer will be stopped. 0111b always A repetitive group transfer will be performed. Setting ONESHOTx allows a software controlled single transfer modea a. By setting the TRIGSRC to 0000b, the TRIGEVT to ALWAYS (0111b) the ONESHOT bit to 1. This allows a software control trigger on this Transfer Group. Then by setting the TGENA bit, the Transfer Group is immediately triggered. . If ONESHOTx is cleared a continuous mode for this Transfer Group is selected.1xxxb reserved" end="20" id="TRIGEVT" rwaccess="RW" width="4"></bitfield>
    
  <bitfield begin="19" description="Trigger source. After reset the trigger sources of all transfer groups are disabled. Table 22. Trigger SourcesTRIGSRCx[3:0] Type Description 0000b disabled 0001b EXT0 MibSPI external trigger source 0. Source has to be defined individually for each Microcontroller derivative (e.g. HET I/O channel, event pin, etc.). 0010b EXT1 MibSPI external trigger source 1. Source has to be defined individually for each Microcontroller derivative (e.g. HET I/O channel, event pin, etc.). 0011b EXT2 MibSPI external trigger source 2. Source has to be defined individually for each Microcontroller derivative (e.g. HET I/O channel, event pin, etc.). 0100b EXT3 MibSPI external trigger source 3. Source has to be defined individually for each Microcontroller derivative (e.g. HET I/O channel, event pin, etc.). ... ... ... 1110b EXT13 MibSPI external trigger source 13. Source has to be defined individually for each Microcontroller derivative (e.g. HET I/O channel, event pin, etc.). 1111b TICK MibSPI internal periodic event trigger. The tick counter can initiate periodic group transfers." end="16" id="TRIGSRC" rwaccess="RW" width="4"></bitfield>
    
  <bitfield begin="15" description="transfer group start address. PSTARTx stores the start address of the corresponding transfer group. The corresponding end address is inherently defined by the subsequent transfer groups start address minus one (PENDx[TGx] = PSTARTx[TGx+1]-1). PSTARTx is copied into PCURRENTx when: o the transfer group is enabled o the end of the transfer group is reached during a transfer o a trigger event occurs while PRST is set to 1" end="8" id="PSTART" rwaccess="RW" width="8"></bitfield>
    
  <bitfield begin="7" description="transfer group pointer to current buffer. PCURRENT is read-only. PCURRENTx stores the address (0...127/255) of the buffer that is currently transferred or that will be transferred after a trigger event occurs (if PRSTx=0) or after the transfer group resumes from suspend to wait mode. If the transfer group switches mode from active transfer mode to “suspend to wait”, PCURRENTx keeps the address of the currently Suspended buffer. After the transfer group resumes from “suspend to wait” mode the next buffer will be transferred. I.e. no buffer data is multiply transferred or not at all transferred due to “suspend to wait” mode." end="0" id="PCURRENT" rwaccess="R" width="8"></bitfield>
  </register>
  
  
  <register acronym="TG6CTRL" description="MibSPI Transfer Group Control Register" id="TG6CTRL" offset="0xB0" width="32">
    
  <bitfield begin="31" description="Transfer Group Enable. 1 =The corresponding transfer group is enabled. If the correct event (TRIGEVTx) occurs at the selected source (TRIGSRCx) a group transfer is initiated if no higher priority transfer group is in active transfer mode or if one or more higher priority Transfer Groups are in transfer suspend mode. If higher priority Transfer Groups (TG) are in transfer mode, then the newly enabled TG will wait till all of the higher priority TG transfers are completed. 0 =The corresponding transfer group is disabled. Disabling a transfer group while a transfer is ongoing, will finish the ongoing buffer transfer but not the whole group transfer" end="31" id="TGENA" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="30" description="Single transfer for this Transfer Group group. 1 =A transfer from the corresponding transfer group will be performed only once (= one shot) after a valid trigger event at the selected trigger source. After the transfer is finished the TGENAx control bit will be cleared by the MibSPI and therefore no additional transfer can be triggered before the host enables the transfer group again. This oneshot mode ensures that after one group transfer the host has enough time to read the received data and to provide new transmit data. 0 =The corresponding transfer group initiates a transfer every time a trigger event occurs and TGENA is set." end="30" id="ONESHOT" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="29" description="transfer group Pointer Reset mode. With PRST, the way of resolving trigger events during an ongoing transfer from the concerned transfer group can be configured. This bit is meaningful only for Level Triggered Transfer Groups. Edge triggered TGs cannot be re-started before their completion by another edge. PRST bit will have no effect on this behavior. 1 =The corresponding transfer group pointer (PCURRENTx) will be reset to the start address (PSTARTx) when a valid trigger event occurs at the selected trigger source while a transfer from the same transfer group is ongoing. I.e. every trigger event resets PCURRENTx no matter whether the concerned transfer group is in transfer mode or not. The trigger events have priority over the ongoing transfer. 0 =If a trigger event occurs during a transfer from the concerned transfer group, the event is ignored and is not stored internally. The transfer group transfer has priority over additional trigger events." end="29" id="PRST" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="28" description="Transfer group triggered. This bit is read-only. 1 =The transfer group has been triggered and is either currently in service or waiting for servicing. 0 =The corresponding transfer group has not been triggered or is no more waiting for service. Use the “TG IN SERVICE” field in LTGPEND register to determine the exact Transfer Group being currently serviced" end="28" id="TGTD" rwaccess="R" width="1"></bitfield>
    
  <bitfield begin="27" description="Reserved.Reads return ‘0’ and writes have no effect" end="24" id="NU" rwaccess="R" width="4"></bitfield>
    
  <bitfield begin="23" description="Type of trigger event. After reset, the trigger event types of all transfer groups are set to inactive TypesTRIGEVTx[3:0] Type Description 0000b never 0001b rising edge A rising edge (0 to 1) at the selected trigger source (TRIGSRCx) initiates a transfer from the corresponding transfer group 0010b falling edge A falling edge (1 to 0) at the selected trigger source (TRIGSRCx) initiates a transfer from the corresponding transfer group 0011b both edges Rising and falling edges at the selected trigger source (TRIGSRCx) initiates a transfer from the corresponding transfer group 0100b reserved 0101b high-active Repetitive group transfer while trigger is high: While the selected trigger source (TRIGSRCx) is at a logic high level (1) the group transfer is continued and at the end of one group transfer restarted at the beginning. If ONESHOTx is set the transfer is performed only once. If the logic level changes to low (0) during an ongoing group transfer, the whole group transfer will be stopped. 0110b low-active Repetitive group transfer while trigger is low: While the selected trigger source (TRIGSRCx) is at a logic low level (0) the group transfer is continued and at the end of one restarted at the beginning. If ONESHOTx is set the transfer is performed only once. If the logic level changes to high (1) during an ongoing group transfer, the whole group transfer will be stopped. 0111b always A repetitive group transfer will be performed. Setting ONESHOTx allows a software controlled single transfer modea a. By setting the TRIGSRC to 0000b, the TRIGEVT to ALWAYS (0111b) the ONESHOT bit to 1. This allows a software control trigger on this Transfer Group. Then by setting the TGENA bit, the Transfer Group is immediately triggered. . If ONESHOTx is cleared a continuous mode for this Transfer Group is selected.1xxxb reserved" end="20" id="TRIGEVT" rwaccess="RW" width="4"></bitfield>
    
  <bitfield begin="19" description="Trigger source. After reset the trigger sources of all transfer groups are disabled. Table 22. Trigger SourcesTRIGSRCx[3:0] Type Description 0000b disabled 0001b EXT0 MibSPI external trigger source 0. Source has to be defined individually for each Microcontroller derivative (e.g. HET I/O channel, event pin, etc.). 0010b EXT1 MibSPI external trigger source 1. Source has to be defined individually for each Microcontroller derivative (e.g. HET I/O channel, event pin, etc.). 0011b EXT2 MibSPI external trigger source 2. Source has to be defined individually for each Microcontroller derivative (e.g. HET I/O channel, event pin, etc.). 0100b EXT3 MibSPI external trigger source 3. Source has to be defined individually for each Microcontroller derivative (e.g. HET I/O channel, event pin, etc.). ... ... ... 1110b EXT13 MibSPI external trigger source 13. Source has to be defined individually for each Microcontroller derivative (e.g. HET I/O channel, event pin, etc.). 1111b TICK MibSPI internal periodic event trigger. The tick counter can initiate periodic group transfers." end="16" id="TRIGSRC" rwaccess="RW" width="4"></bitfield>
    
  <bitfield begin="15" description="transfer group start address. PSTARTx stores the start address of the corresponding transfer group. The corresponding end address is inherently defined by the subsequent transfer groups start address minus one (PENDx[TGx] = PSTARTx[TGx+1]-1). PSTARTx is copied into PCURRENTx when: o the transfer group is enabled o the end of the transfer group is reached during a transfer o a trigger event occurs while PRST is set to 1" end="8" id="PSTART" rwaccess="RW" width="8"></bitfield>
    
  <bitfield begin="7" description="transfer group pointer to current buffer. PCURRENT is read-only. PCURRENTx stores the address (0...127/255) of the buffer that is currently transferred or that will be transferred after a trigger event occurs (if PRSTx=0) or after the transfer group resumes from suspend to wait mode. If the transfer group switches mode from active transfer mode to “suspend to wait”, PCURRENTx keeps the address of the currently Suspended buffer. After the transfer group resumes from “suspend to wait” mode the next buffer will be transferred. I.e. no buffer data is multiply transferred or not at all transferred due to “suspend to wait” mode." end="0" id="PCURRENT" rwaccess="R" width="8"></bitfield>
  </register>
  
  
  <register acronym="TG7CTRL" description="MibSPI Transfer Group Control Register" id="TG7CTRL" offset="0xB4" width="32">
    
  <bitfield begin="31" description="Transfer Group Enable. 1 =The corresponding transfer group is enabled. If the correct event (TRIGEVTx) occurs at the selected source (TRIGSRCx) a group transfer is initiated if no higher priority transfer group is in active transfer mode or if one or more higher priority Transfer Groups are in transfer suspend mode. If higher priority Transfer Groups (TG) are in transfer mode, then the newly enabled TG will wait till all of the higher priority TG transfers are completed. 0 =The corresponding transfer group is disabled. Disabling a transfer group while a transfer is ongoing, will finish the ongoing buffer transfer but not the whole group transfer" end="31" id="TGENA" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="30" description="Single transfer for this Transfer Group group. 1 =A transfer from the corresponding transfer group will be performed only once (= one shot) after a valid trigger event at the selected trigger source. After the transfer is finished the TGENAx control bit will be cleared by the MibSPI and therefore no additional transfer can be triggered before the host enables the transfer group again. This oneshot mode ensures that after one group transfer the host has enough time to read the received data and to provide new transmit data. 0 =The corresponding transfer group initiates a transfer every time a trigger event occurs and TGENA is set." end="30" id="ONESHOT" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="29" description="transfer group Pointer Reset mode. With PRST, the way of resolving trigger events during an ongoing transfer from the concerned transfer group can be configured. This bit is meaningful only for Level Triggered Transfer Groups. Edge triggered TGs cannot be re-started before their completion by another edge. PRST bit will have no effect on this behavior. 1 =The corresponding transfer group pointer (PCURRENTx) will be reset to the start address (PSTARTx) when a valid trigger event occurs at the selected trigger source while a transfer from the same transfer group is ongoing. I.e. every trigger event resets PCURRENTx no matter whether the concerned transfer group is in transfer mode or not. The trigger events have priority over the ongoing transfer. 0 =If a trigger event occurs during a transfer from the concerned transfer group, the event is ignored and is not stored internally. The transfer group transfer has priority over additional trigger events." end="29" id="PRST" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="28" description="Transfer group triggered. This bit is read-only. 1 =The transfer group has been triggered and is either currently in service or waiting for servicing. 0 =The corresponding transfer group has not been triggered or is no more waiting for service. Use the “TG IN SERVICE” field in LTGPEND register to determine the exact Transfer Group being currently serviced" end="28" id="TGTD" rwaccess="R" width="1"></bitfield>
    
  <bitfield begin="27" description="Reserved.Reads return ‘0’ and writes have no effect" end="24" id="NU" rwaccess="R" width="4"></bitfield>
    
  <bitfield begin="23" description="Type of trigger event. After reset, the trigger event types of all transfer groups are set to inactive TypesTRIGEVTx[3:0] Type Description 0000b never 0001b rising edge A rising edge (0 to 1) at the selected trigger source (TRIGSRCx) initiates a transfer from the corresponding transfer group 0010b falling edge A falling edge (1 to 0) at the selected trigger source (TRIGSRCx) initiates a transfer from the corresponding transfer group 0011b both edges Rising and falling edges at the selected trigger source (TRIGSRCx) initiates a transfer from the corresponding transfer group 0100b reserved 0101b high-active Repetitive group transfer while trigger is high: While the selected trigger source (TRIGSRCx) is at a logic high level (1) the group transfer is continued and at the end of one group transfer restarted at the beginning. If ONESHOTx is set the transfer is performed only once. If the logic level changes to low (0) during an ongoing group transfer, the whole group transfer will be stopped. 0110b low-active Repetitive group transfer while trigger is low: While the selected trigger source (TRIGSRCx) is at a logic low level (0) the group transfer is continued and at the end of one restarted at the beginning. If ONESHOTx is set the transfer is performed only once. If the logic level changes to high (1) during an ongoing group transfer, the whole group transfer will be stopped. 0111b always A repetitive group transfer will be performed. Setting ONESHOTx allows a software controlled single transfer modea a. By setting the TRIGSRC to 0000b, the TRIGEVT to ALWAYS (0111b) the ONESHOT bit to 1. This allows a software control trigger on this Transfer Group. Then by setting the TGENA bit, the Transfer Group is immediately triggered. . If ONESHOTx is cleared a continuous mode for this Transfer Group is selected.1xxxb reserved" end="20" id="TRIGEVT" rwaccess="RW" width="4"></bitfield>
    
  <bitfield begin="19" description="Trigger source. After reset the trigger sources of all transfer groups are disabled. Table 22. Trigger SourcesTRIGSRCx[3:0] Type Description 0000b disabled 0001b EXT0 MibSPI external trigger source 0. Source has to be defined individually for each Microcontroller derivative (e.g. HET I/O channel, event pin, etc.). 0010b EXT1 MibSPI external trigger source 1. Source has to be defined individually for each Microcontroller derivative (e.g. HET I/O channel, event pin, etc.). 0011b EXT2 MibSPI external trigger source 2. Source has to be defined individually for each Microcontroller derivative (e.g. HET I/O channel, event pin, etc.). 0100b EXT3 MibSPI external trigger source 3. Source has to be defined individually for each Microcontroller derivative (e.g. HET I/O channel, event pin, etc.). ... ... ... 1110b EXT13 MibSPI external trigger source 13. Source has to be defined individually for each Microcontroller derivative (e.g. HET I/O channel, event pin, etc.). 1111b TICK MibSPI internal periodic event trigger. The tick counter can initiate periodic group transfers." end="16" id="TRIGSRC" rwaccess="RW" width="4"></bitfield>
    
  <bitfield begin="15" description="transfer group start address. PSTARTx stores the start address of the corresponding transfer group. The corresponding end address is inherently defined by the subsequent transfer groups start address minus one (PENDx[TGx] = PSTARTx[TGx+1]-1). PSTARTx is copied into PCURRENTx when: o the transfer group is enabled o the end of the transfer group is reached during a transfer o a trigger event occurs while PRST is set to 1" end="8" id="PSTART" rwaccess="RW" width="8"></bitfield>
    
  <bitfield begin="7" description="transfer group pointer to current buffer. PCURRENT is read-only. PCURRENTx stores the address (0...127/255) of the buffer that is currently transferred or that will be transferred after a trigger event occurs (if PRSTx=0) or after the transfer group resumes from suspend to wait mode. If the transfer group switches mode from active transfer mode to “suspend to wait”, PCURRENTx keeps the address of the currently Suspended buffer. After the transfer group resumes from “suspend to wait” mode the next buffer will be transferred. I.e. no buffer data is multiply transferred or not at all transferred due to “suspend to wait” mode." end="0" id="PCURRENT" rwaccess="R" width="8"></bitfield>
  </register>
  
  
  <register acronym="DMA0CTRL" description="MibSPI DMA Channel Control Register" id="DMA0CTRL" offset="0xD8" width="32">
    
  <bitfield begin="31" description="Auto-disable of DMA channel after ICOUNT+1 transfers. 1 =ONESHOTx allows a block transfer of defined length (ICOUNTx+1) mainly controlled by the MibSPI and not by the DMA controller. After ICOUNTx +1 transfers the enable bits RXDMAENAx and TXDMAENAx are automatically cleared by the MibSPI, hence no more DMA requests are generated. In conjunction with NOBRKx, a burst transfer can be initiated without any other transfer through another buffer. 0 =The length of the block transfer is fully controlled by the DMA controller. The enable bits RXDMAENAx and TXDMAENAx are not modified by the MibSPI." end="31" id="ONESHOT" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="30" description="Buffer utilized for DMA transfer. BUFIDx defines the buffer that is utilized for the DMA transfer. In order to synchronize the transfer with the DMA controller with the NOBRK condition the “suspend to wait until...” modes must be used (for more details refer to Section 8.53.1)." end="24" id="BUFID" rwaccess="RW" width="7"></bitfield>
    
  <bitfield begin="23" description="Receive data DMA Request Map Each MibSPI DMA channel can be linked to two physical DMA Request lines of the DMA controller. One request line for receive data and the other for request line for transmit data. RXDMA_MAPx[3:0] defines the number of the physical DMA Request line that is connected to the receive path of the MibSPI DMA channel. If RXDMAENAx and TXDMAENAx are both set to ‘1’, then RXDMA_MAPx[3:0] shall differ from TXDMA_MAPx[3:0] and shall differ from any other used physical DMA Request line. Otherwise unexpected interference may occur." end="20" id="RXDMA_MAP" rwaccess="RW" width="4"></bitfield>
    
  <bitfield begin="19" description="Transmit data DMA channel Each MibSPI DMA channel can be linked to two physical DMA Request lines of the DMA controller. ne request line for receive data and the other for request line for transmit data. TXDMA_MAPx[3:0] defines the number of the physical DMA Request line that is connected to the transmit path of the MibSPI DMA channel. If RXDMAENAx and TXDMAENAx are both set then TXDMA_MAPx[3:0] shall differ from RXDMA_MAPx[3:0] and shall differ from any other used physical DMA Request line. Otherwise unexpected interference may occur." end="16" id="TXDMA_MAP" rwaccess="RW" width="4"></bitfield>
    
  <bitfield begin="15" description="Receive data DMA channel enable. 1 =The physical DMA Request line for the receive path is enabled. The first DMA request pulse is generated after the first transfer from the referenced buffer (BUFIDx) is finished. The concerned buffer should be configured in the mode “skip until RXEMPTY is set” or “suspend to wait until RXEMPTY is set” in order to ensure synchronization between DMA controller and MibSPI sequencer. 0 =No DMA request upon new receive data." end="15" id="RXDMAENA" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="14" description="Transmit data DMA channel enable. 1 =The physical DMA Request line for the transmit path is enabled. The first DMA request pulse is generated right after setting TXDMAENAx to load the first transmit data. The concerned buffer should be configured in the mode “skip until TXFULL is set” or “suspend to wait until TXFULL is set” in order to ensure synchronization between DMA controller and MibSPI sequencer. 0 =No DMA request upon new transmit data" end="14" id="TXDMAENA" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="13" description="Non-interleaved DMA block transfer(Master mode only). 1 =NOBRKx ensures that ICOUNTx+1 data transfers are performed from the buffer referenced by BUFIDx without a data transfer from any other buffer. The sequencer remains at the DMA buffer until ICOUNTx+1 transfers have been processed. E.g: this can be used to generate a burst transfer to one device without disabling the chip select signal in-between (the concerned buffer has to be configured with CSHOLD=1). Another example would be to have a defined block data transfer in slave mode, synchronous to the master SPI. Triggering of higher priority transfer groups or enabling of higher priority DMA channels will not interrupt NOBRK block transfer. 0 =The DMA transfers through the buffer referenced by BUFIDx are interleaved by data transfers from other active buffers or transfer groups. Every time the sequencer checks the DMA buffer, it performs one transfer and then steps to the next buffer" end="13" id="NOBRK" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="12" description="Initial Count of DMA transfers ICOUNTx[4:0] is used to preset the transfer counter COUNTx[4:0]. Every time COUNTx[4:0] hits zero it is reloaded with ICOUNTx[4:0]. The real number of transfer equals ICOUNTx[4:0] plus one. If ONESHOTx is set, ICOUNTx[4:0] defines the number of DMA transfers that are performed before the MibSPI automatically disables the DMA channels. If NOBRKx is set, ICOUNTx[4:0] defines the number of DMA transfers that are performed in one sequence without a transfer from any other buffer" end="8" id="ICOUNT" rwaccess="RW" width="5"></bitfield>
    
  <bitfield begin="7" description="Extended bit of BUFIDx field when Extended Buffer feature is implemented. This bit represents the 8th bit of BUFID field such that any buffers between 127-255 can be configured as DMA capable buffers" end="7" id="BUFID7" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="6" description="The 17th bit of COUNT field of DMAxCOUNT register. This bit is useful only when ICOUNTx in DMAxCOUNT register is programmed to be 0xFFFF. During all other values, this bit remains to be ‘0’." end="6" id="COUNTBIT17" rwaccess="R" width="1"></bitfield>
    
  <bitfield begin="5" description="Actual number of remaining DMA transfer COUNTx[5:0] is a read-only bit field. It comprises the actual number of DMA transfers that remain, until the DMA channel is disabled if ONESHOTx is set." end="0" id="COUNT" rwaccess="R" width="6"></bitfield>
  </register>
  
  
  <register acronym="DMA1CTRL" description="MibSPI DMA Channel Control Register" id="DMA1CTRL" offset="0xDC" width="32">
    
  <bitfield begin="31" description="Auto-disable of DMA channel after ICOUNT+1 transfers. 1 =ONESHOTx allows a block transfer of defined length (ICOUNTx+1) mainly controlled by the MibSPI and not by the DMA controller. After ICOUNTx +1 transfers the enable bits RXDMAENAx and TXDMAENAx are automatically cleared by the MibSPI, hence no more DMA requests are generated. In conjunction with NOBRKx, a burst transfer can be initiated without any other transfer through another buffer. 0 =The length of the block transfer is fully controlled by the DMA controller. The enable bits RXDMAENAx and TXDMAENAx are not modified by the MibSPI." end="31" id="ONESHOT" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="30" description="Buffer utilized for DMA transfer. BUFIDx defines the buffer that is utilized for the DMA transfer. In order to synchronize the transfer with the DMA controller with the NOBRK condition the “suspend to wait until...” modes must be used (for more details refer to Section 8.53.1)." end="24" id="BUFID" rwaccess="RW" width="7"></bitfield>
    
  <bitfield begin="23" description="Receive data DMA Request Map Each MibSPI DMA channel can be linked to two physical DMA Request lines of the DMA controller. One request line for receive data and the other for request line for transmit data. RXDMA_MAPx[3:0] defines the number of the physical DMA Request line that is connected to the receive path of the MibSPI DMA channel. If RXDMAENAx and TXDMAENAx are both set to ‘1’, then RXDMA_MAPx[3:0] shall differ from TXDMA_MAPx[3:0] and shall differ from any other used physical DMA Request line. Otherwise unexpected interference may occur." end="20" id="RXDMA_MAP" rwaccess="RW" width="4"></bitfield>
    
  <bitfield begin="19" description="Transmit data DMA channel Each MibSPI DMA channel can be linked to two physical DMA Request lines of the DMA controller. ne request line for receive data and the other for request line for transmit data. TXDMA_MAPx[3:0] defines the number of the physical DMA Request line that is connected to the transmit path of the MibSPI DMA channel. If RXDMAENAx and TXDMAENAx are both set then TXDMA_MAPx[3:0] shall differ from RXDMA_MAPx[3:0] and shall differ from any other used physical DMA Request line. Otherwise unexpected interference may occur." end="16" id="TXDMA_MAP" rwaccess="RW" width="4"></bitfield>
    
  <bitfield begin="15" description="Receive data DMA channel enable. 1 =The physical DMA Request line for the receive path is enabled. The first DMA request pulse is generated after the first transfer from the referenced buffer (BUFIDx) is finished. The concerned buffer should be configured in the mode “skip until RXEMPTY is set” or “suspend to wait until RXEMPTY is set” in order to ensure synchronization between DMA controller and MibSPI sequencer. 0 =No DMA request upon new receive data." end="15" id="RXDMAENA" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="14" description="Transmit data DMA channel enable. 1 =The physical DMA Request line for the transmit path is enabled. The first DMA request pulse is generated right after setting TXDMAENAx to load the first transmit data. The concerned buffer should be configured in the mode “skip until TXFULL is set” or “suspend to wait until TXFULL is set” in order to ensure synchronization between DMA controller and MibSPI sequencer. 0 =No DMA request upon new transmit data" end="14" id="TXDMAENA" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="13" description="Non-interleaved DMA block transfer(Master mode only). 1 =NOBRKx ensures that ICOUNTx+1 data transfers are performed from the buffer referenced by BUFIDx without a data transfer from any other buffer. The sequencer remains at the DMA buffer until ICOUNTx+1 transfers have been processed. E.g: this can be used to generate a burst transfer to one device without disabling the chip select signal in-between (the concerned buffer has to be configured with CSHOLD=1). Another example would be to have a defined block data transfer in slave mode, synchronous to the master SPI. Triggering of higher priority transfer groups or enabling of higher priority DMA channels will not interrupt NOBRK block transfer. 0 =The DMA transfers through the buffer referenced by BUFIDx are interleaved by data transfers from other active buffers or transfer groups. Every time the sequencer checks the DMA buffer, it performs one transfer and then steps to the next buffer" end="13" id="NOBRK" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="12" description="Initial Count of DMA transfers ICOUNTx[4:0] is used to preset the transfer counter COUNTx[4:0]. Every time COUNTx[4:0] hits zero it is reloaded with ICOUNTx[4:0]. The real number of transfer equals ICOUNTx[4:0] plus one. If ONESHOTx is set, ICOUNTx[4:0] defines the number of DMA transfers that are performed before the MibSPI automatically disables the DMA channels. If NOBRKx is set, ICOUNTx[4:0] defines the number of DMA transfers that are performed in one sequence without a transfer from any other buffer" end="8" id="ICOUNT" rwaccess="RW" width="5"></bitfield>
    
  <bitfield begin="7" description="Extended bit of BUFIDx field when Extended Buffer feature is implemented. This bit represents the 8th bit of BUFID field such that any buffers between 127-255 can be configured as DMA capable buffers" end="7" id="BUFID7" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="6" description="The 17th bit of COUNT field of DMAxCOUNT register. This bit is useful only when ICOUNTx in DMAxCOUNT register is programmed to be 0xFFFF. During all other values, this bit remains to be ‘0’." end="6" id="COUNTBIT17" rwaccess="R" width="1"></bitfield>
    
  <bitfield begin="5" description="Actual number of remaining DMA transfer COUNTx[5:0] is a read-only bit field. It comprises the actual number of DMA transfers that remain, until the DMA channel is disabled if ONESHOTx is set." end="0" id="COUNT" rwaccess="R" width="6"></bitfield>
  </register>
  
  
  <register acronym="DMA2CTRL" description="MibSPI DMA Channel Control Register" id="DMA2CTRL" offset="0xE0" width="32">
    
  <bitfield begin="31" description="Auto-disable of DMA channel after ICOUNT+1 transfers. 1 =ONESHOTx allows a block transfer of defined length (ICOUNTx+1) mainly controlled by the MibSPI and not by the DMA controller. After ICOUNTx +1 transfers the enable bits RXDMAENAx and TXDMAENAx are automatically cleared by the MibSPI, hence no more DMA requests are generated. In conjunction with NOBRKx, a burst transfer can be initiated without any other transfer through another buffer. 0 =The length of the block transfer is fully controlled by the DMA controller. The enable bits RXDMAENAx and TXDMAENAx are not modified by the MibSPI." end="31" id="ONESHOT" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="30" description="Buffer utilized for DMA transfer. BUFIDx defines the buffer that is utilized for the DMA transfer. In order to synchronize the transfer with the DMA controller with the NOBRK condition the “suspend to wait until...” modes must be used (for more details refer to Section 8.53.1)." end="24" id="BUFID" rwaccess="RW" width="7"></bitfield>
    
  <bitfield begin="23" description="Receive data DMA Request Map Each MibSPI DMA channel can be linked to two physical DMA Request lines of the DMA controller. One request line for receive data and the other for request line for transmit data. RXDMA_MAPx[3:0] defines the number of the physical DMA Request line that is connected to the receive path of the MibSPI DMA channel. If RXDMAENAx and TXDMAENAx are both set to ‘1’, then RXDMA_MAPx[3:0] shall differ from TXDMA_MAPx[3:0] and shall differ from any other used physical DMA Request line. Otherwise unexpected interference may occur." end="20" id="RXDMA_MAP" rwaccess="RW" width="4"></bitfield>
    
  <bitfield begin="19" description="Transmit data DMA channel Each MibSPI DMA channel can be linked to two physical DMA Request lines of the DMA controller. ne request line for receive data and the other for request line for transmit data. TXDMA_MAPx[3:0] defines the number of the physical DMA Request line that is connected to the transmit path of the MibSPI DMA channel. If RXDMAENAx and TXDMAENAx are both set then TXDMA_MAPx[3:0] shall differ from RXDMA_MAPx[3:0] and shall differ from any other used physical DMA Request line. Otherwise unexpected interference may occur." end="16" id="TXDMA_MAP" rwaccess="RW" width="4"></bitfield>
    
  <bitfield begin="15" description="Receive data DMA channel enable. 1 =The physical DMA Request line for the receive path is enabled. The first DMA request pulse is generated after the first transfer from the referenced buffer (BUFIDx) is finished. The concerned buffer should be configured in the mode “skip until RXEMPTY is set” or “suspend to wait until RXEMPTY is set” in order to ensure synchronization between DMA controller and MibSPI sequencer. 0 =No DMA request upon new receive data." end="15" id="RXDMAENA" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="14" description="Transmit data DMA channel enable. 1 =The physical DMA Request line for the transmit path is enabled. The first DMA request pulse is generated right after setting TXDMAENAx to load the first transmit data. The concerned buffer should be configured in the mode “skip until TXFULL is set” or “suspend to wait until TXFULL is set” in order to ensure synchronization between DMA controller and MibSPI sequencer. 0 =No DMA request upon new transmit data" end="14" id="TXDMAENA" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="13" description="Non-interleaved DMA block transfer(Master mode only). 1 =NOBRKx ensures that ICOUNTx+1 data transfers are performed from the buffer referenced by BUFIDx without a data transfer from any other buffer. The sequencer remains at the DMA buffer until ICOUNTx+1 transfers have been processed. E.g: this can be used to generate a burst transfer to one device without disabling the chip select signal in-between (the concerned buffer has to be configured with CSHOLD=1). Another example would be to have a defined block data transfer in slave mode, synchronous to the master SPI. Triggering of higher priority transfer groups or enabling of higher priority DMA channels will not interrupt NOBRK block transfer. 0 =The DMA transfers through the buffer referenced by BUFIDx are interleaved by data transfers from other active buffers or transfer groups. Every time the sequencer checks the DMA buffer, it performs one transfer and then steps to the next buffer" end="13" id="NOBRK" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="12" description="Initial Count of DMA transfers ICOUNTx[4:0] is used to preset the transfer counter COUNTx[4:0]. Every time COUNTx[4:0] hits zero it is reloaded with ICOUNTx[4:0]. The real number of transfer equals ICOUNTx[4:0] plus one. If ONESHOTx is set, ICOUNTx[4:0] defines the number of DMA transfers that are performed before the MibSPI automatically disables the DMA channels. If NOBRKx is set, ICOUNTx[4:0] defines the number of DMA transfers that are performed in one sequence without a transfer from any other buffer" end="8" id="ICOUNT" rwaccess="RW" width="5"></bitfield>
    
  <bitfield begin="7" description="Extended bit of BUFIDx field when Extended Buffer feature is implemented. This bit represents the 8th bit of BUFID field such that any buffers between 127-255 can be configured as DMA capable buffers" end="7" id="BUFID7" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="6" description="The 17th bit of COUNT field of DMAxCOUNT register. This bit is useful only when ICOUNTx in DMAxCOUNT register is programmed to be 0xFFFF. During all other values, this bit remains to be ‘0’." end="6" id="COUNTBIT17" rwaccess="R" width="1"></bitfield>
    
  <bitfield begin="5" description="Actual number of remaining DMA transfer COUNTx[5:0] is a read-only bit field. It comprises the actual number of DMA transfers that remain, until the DMA channel is disabled if ONESHOTx is set." end="0" id="COUNT" rwaccess="R" width="6"></bitfield>
  </register>
  
  
  <register acronym="DMA3CTRL" description="MibSPI DMA Channel Control Register" id="DMA3CTRL" offset="0xE4" width="32">
    
  <bitfield begin="31" description="Auto-disable of DMA channel after ICOUNT+1 transfers. 1 =ONESHOTx allows a block transfer of defined length (ICOUNTx+1) mainly controlled by the MibSPI and not by the DMA controller. After ICOUNTx +1 transfers the enable bits RXDMAENAx and TXDMAENAx are automatically cleared by the MibSPI, hence no more DMA requests are generated. In conjunction with NOBRKx, a burst transfer can be initiated without any other transfer through another buffer. 0 =The length of the block transfer is fully controlled by the DMA controller. The enable bits RXDMAENAx and TXDMAENAx are not modified by the MibSPI." end="31" id="ONESHOT" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="30" description="Buffer utilized for DMA transfer. BUFIDx defines the buffer that is utilized for the DMA transfer. In order to synchronize the transfer with the DMA controller with the NOBRK condition the “suspend to wait until...” modes must be used (for more details refer to Section 8.53.1)." end="24" id="BUFID" rwaccess="RW" width="7"></bitfield>
    
  <bitfield begin="23" description="Receive data DMA Request Map Each MibSPI DMA channel can be linked to two physical DMA Request lines of the DMA controller. One request line for receive data and the other for request line for transmit data. RXDMA_MAPx[3:0] defines the number of the physical DMA Request line that is connected to the receive path of the MibSPI DMA channel. If RXDMAENAx and TXDMAENAx are both set to ‘1’, then RXDMA_MAPx[3:0] shall differ from TXDMA_MAPx[3:0] and shall differ from any other used physical DMA Request line. Otherwise unexpected interference may occur." end="20" id="RXDMA_MAP" rwaccess="RW" width="4"></bitfield>
    
  <bitfield begin="19" description="Transmit data DMA channel Each MibSPI DMA channel can be linked to two physical DMA Request lines of the DMA controller. ne request line for receive data and the other for request line for transmit data. TXDMA_MAPx[3:0] defines the number of the physical DMA Request line that is connected to the transmit path of the MibSPI DMA channel. If RXDMAENAx and TXDMAENAx are both set then TXDMA_MAPx[3:0] shall differ from RXDMA_MAPx[3:0] and shall differ from any other used physical DMA Request line. Otherwise unexpected interference may occur." end="16" id="TXDMA_MAP" rwaccess="RW" width="4"></bitfield>
    
  <bitfield begin="15" description="Receive data DMA channel enable. 1 =The physical DMA Request line for the receive path is enabled. The first DMA request pulse is generated after the first transfer from the referenced buffer (BUFIDx) is finished. The concerned buffer should be configured in the mode “skip until RXEMPTY is set” or “suspend to wait until RXEMPTY is set” in order to ensure synchronization between DMA controller and MibSPI sequencer. 0 =No DMA request upon new receive data." end="15" id="RXDMAENA" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="14" description="Transmit data DMA channel enable. 1 =The physical DMA Request line for the transmit path is enabled. The first DMA request pulse is generated right after setting TXDMAENAx to load the first transmit data. The concerned buffer should be configured in the mode “skip until TXFULL is set” or “suspend to wait until TXFULL is set” in order to ensure synchronization between DMA controller and MibSPI sequencer. 0 =No DMA request upon new transmit data" end="14" id="TXDMAENA" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="13" description="Non-interleaved DMA block transfer(Master mode only). 1 =NOBRKx ensures that ICOUNTx+1 data transfers are performed from the buffer referenced by BUFIDx without a data transfer from any other buffer. The sequencer remains at the DMA buffer until ICOUNTx+1 transfers have been processed. E.g: this can be used to generate a burst transfer to one device without disabling the chip select signal in-between (the concerned buffer has to be configured with CSHOLD=1). Another example would be to have a defined block data transfer in slave mode, synchronous to the master SPI. Triggering of higher priority transfer groups or enabling of higher priority DMA channels will not interrupt NOBRK block transfer. 0 =The DMA transfers through the buffer referenced by BUFIDx are interleaved by data transfers from other active buffers or transfer groups. Every time the sequencer checks the DMA buffer, it performs one transfer and then steps to the next buffer" end="13" id="NOBRK" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="12" description="Initial Count of DMA transfers ICOUNTx[4:0] is used to preset the transfer counter COUNTx[4:0]. Every time COUNTx[4:0] hits zero it is reloaded with ICOUNTx[4:0]. The real number of transfer equals ICOUNTx[4:0] plus one. If ONESHOTx is set, ICOUNTx[4:0] defines the number of DMA transfers that are performed before the MibSPI automatically disables the DMA channels. If NOBRKx is set, ICOUNTx[4:0] defines the number of DMA transfers that are performed in one sequence without a transfer from any other buffer" end="8" id="ICOUNT" rwaccess="RW" width="5"></bitfield>
    
  <bitfield begin="7" description="Extended bit of BUFIDx field when Extended Buffer feature is implemented. This bit represents the 8th bit of BUFID field such that any buffers between 127-255 can be configured as DMA capable buffers" end="7" id="BUFID7" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="6" description="The 17th bit of COUNT field of DMAxCOUNT register. This bit is useful only when ICOUNTx in DMAxCOUNT register is programmed to be 0xFFFF. During all other values, this bit remains to be ‘0’." end="6" id="COUNTBIT17" rwaccess="R" width="1"></bitfield>
    
  <bitfield begin="5" description="Actual number of remaining DMA transfer COUNTx[5:0] is a read-only bit field. It comprises the actual number of DMA transfers that remain, until the DMA channel is disabled if ONESHOTx is set." end="0" id="COUNT" rwaccess="R" width="6"></bitfield>
  </register>
  
  
  <register acronym="DMA4CTRL" description="MibSPI DMA Channel Control Register" id="DMA4CTRL" offset="0xE8" width="32">
    
  <bitfield begin="31" description="Auto-disable of DMA channel after ICOUNT+1 transfers. 1 =ONESHOTx allows a block transfer of defined length (ICOUNTx+1) mainly controlled by the MibSPI and not by the DMA controller. After ICOUNTx +1 transfers the enable bits RXDMAENAx and TXDMAENAx are automatically cleared by the MibSPI, hence no more DMA requests are generated. In conjunction with NOBRKx, a burst transfer can be initiated without any other transfer through another buffer. 0 =The length of the block transfer is fully controlled by the DMA controller. The enable bits RXDMAENAx and TXDMAENAx are not modified by the MibSPI." end="31" id="ONESHOT" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="30" description="Buffer utilized for DMA transfer. BUFIDx defines the buffer that is utilized for the DMA transfer. In order to synchronize the transfer with the DMA controller with the NOBRK condition the “suspend to wait until...” modes must be used (for more details refer to Section 8.53.1)." end="24" id="BUFID" rwaccess="RW" width="7"></bitfield>
    
  <bitfield begin="23" description="Receive data DMA Request Map Each MibSPI DMA channel can be linked to two physical DMA Request lines of the DMA controller. One request line for receive data and the other for request line for transmit data. RXDMA_MAPx[3:0] defines the number of the physical DMA Request line that is connected to the receive path of the MibSPI DMA channel. If RXDMAENAx and TXDMAENAx are both set to ‘1’, then RXDMA_MAPx[3:0] shall differ from TXDMA_MAPx[3:0] and shall differ from any other used physical DMA Request line. Otherwise unexpected interference may occur." end="20" id="RXDMA_MAP" rwaccess="RW" width="4"></bitfield>
    
  <bitfield begin="19" description="Transmit data DMA channel Each MibSPI DMA channel can be linked to two physical DMA Request lines of the DMA controller. ne request line for receive data and the other for request line for transmit data. TXDMA_MAPx[3:0] defines the number of the physical DMA Request line that is connected to the transmit path of the MibSPI DMA channel. If RXDMAENAx and TXDMAENAx are both set then TXDMA_MAPx[3:0] shall differ from RXDMA_MAPx[3:0] and shall differ from any other used physical DMA Request line. Otherwise unexpected interference may occur." end="16" id="TXDMA_MAP" rwaccess="RW" width="4"></bitfield>
    
  <bitfield begin="15" description="Receive data DMA channel enable. 1 =The physical DMA Request line for the receive path is enabled. The first DMA request pulse is generated after the first transfer from the referenced buffer (BUFIDx) is finished. The concerned buffer should be configured in the mode “skip until RXEMPTY is set” or “suspend to wait until RXEMPTY is set” in order to ensure synchronization between DMA controller and MibSPI sequencer. 0 =No DMA request upon new receive data." end="15" id="RXDMAENA" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="14" description="Transmit data DMA channel enable. 1 =The physical DMA Request line for the transmit path is enabled. The first DMA request pulse is generated right after setting TXDMAENAx to load the first transmit data. The concerned buffer should be configured in the mode “skip until TXFULL is set” or “suspend to wait until TXFULL is set” in order to ensure synchronization between DMA controller and MibSPI sequencer. 0 =No DMA request upon new transmit data" end="14" id="TXDMAENA" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="13" description="Non-interleaved DMA block transfer(Master mode only). 1 =NOBRKx ensures that ICOUNTx+1 data transfers are performed from the buffer referenced by BUFIDx without a data transfer from any other buffer. The sequencer remains at the DMA buffer until ICOUNTx+1 transfers have been processed. E.g: this can be used to generate a burst transfer to one device without disabling the chip select signal in-between (the concerned buffer has to be configured with CSHOLD=1). Another example would be to have a defined block data transfer in slave mode, synchronous to the master SPI. Triggering of higher priority transfer groups or enabling of higher priority DMA channels will not interrupt NOBRK block transfer. 0 =The DMA transfers through the buffer referenced by BUFIDx are interleaved by data transfers from other active buffers or transfer groups. Every time the sequencer checks the DMA buffer, it performs one transfer and then steps to the next buffer" end="13" id="NOBRK" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="12" description="Initial Count of DMA transfers ICOUNTx[4:0] is used to preset the transfer counter COUNTx[4:0]. Every time COUNTx[4:0] hits zero it is reloaded with ICOUNTx[4:0]. The real number of transfer equals ICOUNTx[4:0] plus one. If ONESHOTx is set, ICOUNTx[4:0] defines the number of DMA transfers that are performed before the MibSPI automatically disables the DMA channels. If NOBRKx is set, ICOUNTx[4:0] defines the number of DMA transfers that are performed in one sequence without a transfer from any other buffer" end="8" id="ICOUNT" rwaccess="RW" width="5"></bitfield>
    
  <bitfield begin="7" description="Extended bit of BUFIDx field when Extended Buffer feature is implemented. This bit represents the 8th bit of BUFID field such that any buffers between 127-255 can be configured as DMA capable buffers" end="7" id="BUFID7" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="6" description="The 17th bit of COUNT field of DMAxCOUNT register. This bit is useful only when ICOUNTx in DMAxCOUNT register is programmed to be 0xFFFF. During all other values, this bit remains to be ‘0’." end="6" id="COUNTBIT17" rwaccess="R" width="1"></bitfield>
    
  <bitfield begin="5" description="Actual number of remaining DMA transfer COUNTx[5:0] is a read-only bit field. It comprises the actual number of DMA transfers that remain, until the DMA channel is disabled if ONESHOTx is set." end="0" id="COUNT" rwaccess="R" width="6"></bitfield>
  </register>
  
  
  <register acronym="ICOUNT0" description="MibSPI DMAxCOUNT" id="ICOUNT0" offset="0xF8" width="32">
    
  <bitfield begin="31" description="Initial Number of DMA transfers. ICOUNTx is used to preset the transfer counter COUNTx. Every time COUNTx hits zero it is reloaded with ICOUNTx. The real number of transfer equals ICOUNTx plus one. If ONESHOTx is set, ICOUNTx defines the number of DMA transfers that are performed before the MibSPI automatically disables the DMA channels. If NOBRKx is set, ICOUNTx defines the number of DMA transfers that are performed in one sequence without a transfer from any other buffer" end="16" id="ICOUNT" rwaccess="RW" width="16"></bitfield>
    
  <bitfield begin="15" description="Actual number of remaining DMA transfer COUNTx is a read-only bit field. It comprises the actual number of DMA transfers that remain, until the DMA channel is disabled if ONESHOTx is set. Since the real COUNTx is always ICLOUNTx +1, the 17th bit of COUNTx is available on DMAxCTRL(6) bit." end="0" id="COUNT" rwaccess="R" width="16"></bitfield>
  </register>
  
  
  <register acronym="ICOUNT1" description="MibSPI DMAxCOUNT" id="ICOUNT1" offset="0xFC" width="32">
    
  <bitfield begin="31" description="Initial Number of DMA transfers. ICOUNTx is used to preset the transfer counter COUNTx. Every time COUNTx hits zero it is reloaded with ICOUNTx. The real number of transfer equals ICOUNTx plus one. If ONESHOTx is set, ICOUNTx defines the number of DMA transfers that are performed before the MibSPI automatically disables the DMA channels. If NOBRKx is set, ICOUNTx defines the number of DMA transfers that are performed in one sequence without a transfer from any other buffer" end="16" id="ICOUNT" rwaccess="RW" width="16"></bitfield>
    
  <bitfield begin="15" description="Actual number of remaining DMA transfer COUNTx is a read-only bit field. It comprises the actual number of DMA transfers that remain, until the DMA channel is disabled if ONESHOTx is set. Since the real COUNTx is always ICLOUNTx +1, the 17th bit of COUNTx is available on DMAxCTRL(6) bit." end="0" id="COUNT" rwaccess="R" width="16"></bitfield>
  </register>
  
  
  <register acronym="ICOUNT2" description="MibSPI DMAxCOUNT" id="ICOUNT2" offset="0x100" width="16">
    
  <bitfield begin="15" description="Actual number of remaining DMA transfer COUNTx is a read-only bit field. It comprises the actual number of DMA transfers that remain, until the DMA channel is disabled if ONESHOTx is set. Since the real COUNTx is always ICLOUNTx +1, the 17th bit of COUNTx is available on DMAxCTRL(6) bit." end="0" id="COUNT" rwaccess="R" width="16"></bitfield>
  </register>
  
  
  <register acronym="ICOUNT3" description="MibSPI DMAxCOUNT" id="ICOUNT3" offset="0x104" width="32">
    
  <bitfield begin="31" description="Initial Number of DMA transfers. ICOUNTx is used to preset the transfer counter COUNTx. Every time COUNTx hits zero it is reloaded with ICOUNTx. The real number of transfer equals ICOUNTx plus one. If ONESHOTx is set, ICOUNTx defines the number of DMA transfers that are performed before the MibSPI automatically disables the DMA channels. If NOBRKx is set, ICOUNTx defines the number of DMA transfers that are performed in one sequence without a transfer from any other buffer" end="16" id="ICOUNT" rwaccess="RW" width="16"></bitfield>
    
  <bitfield begin="15" description="Actual number of remaining DMA transfer COUNTx is a read-only bit field. It comprises the actual number of DMA transfers that remain, until the DMA channel is disabled if ONESHOTx is set. Since the real COUNTx is always ICLOUNTx +1, the 17th bit of COUNTx is available on DMAxCTRL(6) bit." end="0" id="COUNT" rwaccess="R" width="16"></bitfield>
  </register>
  
  
  <register acronym="ICOUNT4" description="MibSPI DMAxCOUNT" id="ICOUNT4" offset="0x108" width="32">
    
  <bitfield begin="31" description="Initial Number of DMA transfers. ICOUNTx is used to preset the transfer counter COUNTx. Every time COUNTx hits zero it is reloaded with ICOUNTx. The real number of transfer equals ICOUNTx plus one. If ONESHOTx is set, ICOUNTx defines the number of DMA transfers that are performed before the MibSPI automatically disables the DMA channels. If NOBRKx is set, ICOUNTx defines the number of DMA transfers that are performed in one sequence without a transfer from any other buffer" end="16" id="ICOUNT" rwaccess="RW" width="16"></bitfield>
    
  <bitfield begin="15" description="Actual number of remaining DMA transfer COUNTx is a read-only bit field. It comprises the actual number of DMA transfers that remain, until the DMA channel is disabled if ONESHOTx is set. Since the real COUNTx is always ICLOUNTx +1, the 17th bit of COUNTx is available on DMAxCTRL(6) bit." end="0" id="COUNT" rwaccess="R" width="16"></bitfield>
  </register>
  
  
  <register acronym="DMACNTLEN" description="DMA LARGE COUNT register" id="DMACNTLEN" offset="0x118" width="32">
    
  <bitfield begin="31" description="Reserved.Reads return ‘0’ and writes have no effect." end="1" id="NU" rwaccess="R" width="31"></bitfield>
    
  <bitfield begin="0" description="0: Writes to the DMAxCTRL register will modify the ICOUNT value. Reading ICOUNT and COUNT can be done from the DMAxCTRL register. The DMAxCOUNT register should not be used since any write to this register will be overwritten by a subsequent write to DMAxCTRL register to set the TXDMAENA or RXDMAENA bits. 1: Writes to the DMAxCTRL register will not modify the ICOUNT value. The ICOUNT value must be written to in the DMAxCOUNT register before the RXDMAENA or TXDMAENA bits are set in the DMAxCTRL register. The DMAxCOUNT register should be used for reading COUNT or ICOUNT." end="0" id="LARGE_COUNT" rwaccess="RW" width="1"></bitfield>
  </register>
  
  
  <register acronym="PAR_ECC_CTRL" description="Parity/ECC Control Register" id="PAR_ECC_CTRL" offset="0x120" width="32">
    
  <bitfield begin="31" description="Reserved.Reads return ‘0’ and writes have no effect." end="28" id="NU4" rwaccess="R" width="4"></bitfield>
    
  <bitfield begin="27" description="Single Bit Error Event Enable This bit controls the generation of Error signaling (on MIBSPI_SBERR port) whenever a Single Bit Errors (SBE) is detected on TXRAM/RXRAM. This signal can be used to generate interrupt if required. Write: 0101 - Disable Error Event indication upon detection of SBE on TXRAM/RXRAM 1010 - Enable Error Event upon detection of SBE on TXRAM/RXRAM All other values - writes are ignored and the values are not updated into this field. The state of the feature remains unchanged. Read: Returns the current value of the field" end="24" id="SBE_EVT_EN" rwaccess="RW" width="4"></bitfield>
    
  <bitfield begin="23" description="Reserved.Reads return ‘0’ and writes have no effect." end="20" id="NU3" rwaccess="R" width="4"></bitfield>
    
  <bitfield begin="19" description="Error Detection And Correction Mode These bits determine whether Single Bit Errors (SBE) detected by the SECDED block will be corrected or not. Write: 0101 - Disable correction of SBE detected by the SECDED block 1010 - Enable correction of SBE detected by the SECDED block All other values - writes are ignored and the values are not updated into this field. The state of the feature remains unchanged. Read: Returns the current value of the field" end="16" id="EDAC_MODE" rwaccess="RW" width="4"></bitfield>
    
  <bitfield begin="15" description="Reserved.Reads return ‘0’ and writes have no effect." end="9" id="NU2" rwaccess="R" width="7"></bitfield>
    
  <bitfield begin="8" description="Parity/ECC memory Test Enable. This bit, maps the parity/ecc bits corresponding to Multibuffer RAM locations into the peripheral RAM frame to make them accessible by the CPU. User and privilege mode (read): 0 = parity/ecc bits are not memory mapped 1 = parity/ecc bits are memory mapped Privilege mode (write): 0 = disable memory mapping of Parity/ECC locations 1 = enable memory mapping of Parity/ECC locations" end="8" id="PTESTEN" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="7" description="Reserved.Reads return ‘0’ and writes have no effect." end="4" id="NU1" rwaccess="R" width="4"></bitfield>
    
  <bitfield begin="3" description="Error Detection Enable These bits enable Parity/ECC Error Detection. Write: 0101: Disables Parity/ECC Error Detection Logic(default) Others : Enables Parity/ECC Error Detection Logic. Read: Returns the current value of this field" end="0" id="EDEN" rwaccess="RW" width="4"></bitfield>
  </register>
  
  
  <register acronym="PAR_ECC_STAT" description="Parity/ECC Status Register" id="PAR_ECC_STAT" offset="0x124" width="32">
    
  <bitfield begin="31" description="Reserved.Reads return ‘0’ and writes have no effect." end="10" id="NU2" rwaccess="R" width="22"></bitfield>
    
  <bitfield begin="9" description="Single Bit Error in RXRAM. This flag indicates if a single bit ECC Error ocurred on reading RXRAM Read: 0 = No error occured. 1 = Single bit error is detected in RXRAM and the address is captured in SBERRADDR1 register. Write: 0 = No effect. 1 = Clears the bit." end="9" id="SBE_FLG1" rwaccess="R" width="1"></bitfield>
    
  <bitfield begin="8" description="Single Bit Error in TXRAM. This flag indicates if a single bit ECC Error ocurred on reading TXRAM Read: 0 = No error occured. 1 = Single bit error is detected in TXRAM and the address is captured in SBERRADDR0 register. Write: 0 = No effect. 1 = Clears the bit." end="8" id="SBE_FLG0" rwaccess="R" width="1"></bitfield>
    
  <bitfield begin="7" description="Reserved.Reads return ‘0’ and writes have no effect." end="2" id="NU1" rwaccess="R" width="6"></bitfield>
    
  <bitfield begin="1" description="Uncorrectable Parity or double bit ECC error detection flag This flag indicates if a Parity or double bit ECC error ocurred on reading RXRAM When this bit is read: 0 = No error occured. 1 = Error detected and the address is captured in UERRADDR1 register. When write to this bit with: 0 = No effect. 1 = Clears the bit" end="1" id="UERR_FLG1" rwaccess="R" width="1"></bitfield>
    
  <bitfield begin="0" description="Uncorrectable Parity or double bit ECC error detection flag This flag indicates if a Parity or ECC error ocurred on reading TXRAM When this bit is read: 0 = No error occured. 1 = Error detected and the address is captured in UERRADDR0 register. When write to this bit with: 0 = No effect. 1 = Clears the bit." end="0" id="UERR_FLG0" rwaccess="R" width="1"></bitfield>
  </register>
  
  
  <register acronym="UERRADDR1" description="Uncorrectable Parity or double bit ECC error Address Register - RXRAM" id="UERRADDR1" offset="0x128" width="32">
    
  <bitfield begin="31" description="Reserved.Reads return ‘0’ and writes have no effect." end="11" id="NU" rwaccess="R" width="21"></bitfield>
    
  <bitfield begin="10" description="Uncorrectable Parity or double bit ECC error address This register holds the address of the RAM location if a parity or double bit ECC error is detected when reading the MibSPI (Receive) RXRAM. The address captured is byte alligned when RAM Parity Check is supported. This error address is frozen from being updated until it is read by the VBUS host. Reading this register clears its contents to the default value The default value is 0x400 if Extended Buffer feature is enabled, else it is 0x200 Writes to this register are ignored" end="0" id="UERRADDR1" rwaccess="R" width="11"></bitfield>
  </register>
  
  
  <register acronym="UERRADDR0" description="Uncorrectable Parity or double bit ECC error address register - TXRAM" id="UERRADDR0" offset="0x12C" width="32">
    
  <bitfield begin="31" description="Reserved.Reads return ‘0’ and writes have no effect." end="11" id="NU" rwaccess="R" width="21"></bitfield>
    
  <bitfield begin="10" description="Uncorrectable Parity or double bit ECC error address This register holds the address when a parity error is generated while reading the MibSPI (Transmit) TXRAM. The TXRAM can be read either by CPU or by the MibSPI Sequencer FSM logic for transmission. The address captured is byte alligned. This error address is frozen from being updated until it is read by the VBUSP host. Reading this register clears its contents to the default value of 0x000. Writes to this register are ignored." end="0" id="UERRADDR0" rwaccess="R" width="11"></bitfield>
  </register>
  
  
  <register acronym="RXOVRN_BUF_ADDR" description="Receive RAM Overrun Buffer Address Register" id="RXOVRN_BUF_ADDR" offset="0x130" width="32">
    
  <bitfield begin="31" description="Reserved.Reads return ‘0’ and writes have no effect." end="11" id="NU" rwaccess="R" width="21"></bitfield>
    
  <bitfield begin="10" description="Address of the RAM location of RXRAM for which an Overwrite occured. This address value will show only the offset address of the RAM location in the Multibuffer RAM address space. Refer to the device Spec for the actual absolute address of RXRAM. Content of this register are valid only when any of the TGINTVECT0 or TGINTVECT1 and SPIFLG registers show an RXOVRN error vector while in Multibuffer mode. If there are multiple Overrun errors, then this register holds address of first overrun address until it is read." end="0" id="RXOVRN_BUF_ADDR" rwaccess="R" width="11"></bitfield>
  </register>
  
  
  <register acronym="IOLPBKTSTCR" description="SPI/MibSPI IO Loopback Test Control Register This register controls test mode for I/O pins. It also controls whether loop-back should be digital or analog ones in this test mode. In addition it contains control bits to induce some of the error condition into the module. These are to be used for test purpose only. All the control/status bits in this register are valid only when IO LPBK TST ENA field is set to “1010”." id="IOLPBKTSTCR" offset="0x134" width="32">
    
  <bitfield begin="31" description="Reserved. Reads return ‘0’ and writes have no effect." end="25" id="NU4" rwaccess="R" width="7"></bitfield>
    
  <bitfield begin="24" description="Bit indicating a failure on SPISCS pin compare during analog loopback during IO Loopback Test mode. Read 1 = A comparison between the internal CSNR field and the analog looped back value of SPISCS[7:0] pins failed. A stuck-at fault is detected on one of the SPISCS[7:0]. Comparison is done only on the pins which are configured as functional and during transfer operation. 0 = No miscompares on any of the 8 chipselect pin value comparison with the internal Chipselect number CSNR during transfers. Write 1 = Clear this Flag bit. 0 = No effect." end="24" id="SCSFAILFLG" rwaccess="" width="1"></bitfield>
    
  <bitfield begin="23" description="Reserved. Reads return ‘0’ and writes have no effect." end="21" id="NU3" rwaccess="R" width="3"></bitfield>
    
  <bitfield begin="20" description="Controls inducing of BITERR during IO Loopback Test mode. 1 = The value of incoming data from the loopback Transmit pin is flipped. 0 = No affect on BIT ERROR." end="20" id="CTRLBITERR" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="19" description="Controls inducing of DESYNC Error during IO Loopback Test mode. 1 = Forces the incoming SPIENA pin (if functional) to remain ‘0’ even after the transfer complete. This forcing will be retained until the Kernel reaches IDLE state. 0 = No affect on DESYNC Error." end="19" id="CTRLDESYNC" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="18" description="Controls inducing of Parity Error during IO Loopback Test mode. 1 = Flips the Parity Polarity signal being used for transmit parity generation logic 0 = No affect on Parity Error" end="18" id="CTRLPARERR" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="17" description="Controls inducing of TIMEOUT Error during IO LoopbacK Test mode. 1 = Forces the incoming SPIENA pin (if functional) to remain ‘1’ when transmission is initiated. The forcing will be retained until the Kernel reaches IDLE state. 0 = No affect on TIMEOUT Error." end="17" id="CTRLTIMEOUT" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="16" description="Controls inducing of Data Length Error during IO Loopback Test mode. 1 = When in Master mode, forces the SPIENA pin(if functional) to ‘1’ when the module starts Shifting the data. When in Slave mode, forces the incoming SPISCS pin(if functional) to ‘1’ when the module starts shifting the data.. 0 = No affect on Data Length Error." end="16" id="CTRLDLENERR" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="15" description="Reserved. Reads return ‘0’ and writes have no effect." end="12" id="NU2" rwaccess="R" width="4"></bitfield>
    
  <bitfield begin="11" description="Module I/O Loopback Test Enable Key User and Privileged mode reads. Write access only in Privileged mode. Write: 1010 = I/O DFT is enabled All other values = I/O DFT is disabled Read: 1010 = I/O DFT is enabled All other values = I/O DFT is disabled" end="8" id="IOLPBKTSTENA" rwaccess="RW" width="4"></bitfield>
    
  <bitfield begin="7" description="Reserved. Reads return ‘0’ and writes have no effect." end="6" id="NU1" rwaccess="R" width="2"></bitfield>
    
  <bitfield begin="5" description="Inject Error on ChipSelect Pin. The value in this field is decoded to find out the ChipSelect pin on which to inject an error. During the analog loopback of IO Loopback Test mode if CTRL SCS PIN ERR bit is set to ‘1’, then the chipselect pin selected by this field is forced to the opposite of its original CSNR bit. 000 - Select SPISCS[0] for injecting error 001 - Select SPISCS[1] for injecting error . 111 - Select SPISCS[7] for injecting error" end="3" id="ERRSCSPIN" rwaccess="RW" width="3"></bitfield>
    
  <bitfield begin="2" description="Control bit to enable the injection of an error on SPISCS[7:0] pins. Individual pins of SPISCS[7:0] can be choosen using ERR SCS PIN. 1 = Enable the error inducing logic to the SPISCS pins. 0 = Disable the error inducing logic." end="2" id="CTRLSCSPINERR" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="1" description="Module IO Loopback Type (Analog/Digital). User and Privileged mode reads. Write access only in Privileged mode. Write/Read : 1 = Analog loopback is enabled in module I/O DFT mode when IOLPBKTSTENA = 1010) 0 = Digital loopback is enabled in module I/O DFT mode when IOLPBKTSTENA = 1010" end="1" id="LPBKTYPE" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="0" description="Module Analog loopback through Receive Pin Enable. User and Privileged mode reads. Write only in privileged mode: Write/Read : 1 = Analog loopback through receive pin 0 = Analog loopback through transmit pin. This bit is valid only when LPBK TYPE = ‘1’ which chooses Analog loopback mode." end="0" id="RXPENA" rwaccess="RW" width="1"></bitfield>
  </register>
  
  
  <register acronym="EXTENDED_PRESCALE1" description="SPI/MibSPI Extended Prescale Register 1 (EXTENDED_PRESCALE1 for SPIFMT0 and SPIFMT1) This register provides an extended Prescale values for SPICLK generation to be able to interface with much slower SPI Slaves. This is an extension of SPIFMT0 and SPIFMT1 registers. For example, EPRESCALE_FMT1(7:0) of EXTENDED_PRESCALE1 and PRESCALE1(7:0) of SPIFMT1 register will always reflect the same contents. Similarly EPRESCALE_FMT0(7:0) and PRESCALE0(7:0) of SPIFMT0 reflect the same contents." id="EXTENDED_PRESCALE1" offset="0x138" width="32">
    
  <bitfield begin="31" description="Reserved. Reads return ‘0’ and writes have no effect." end="27" id="NU2" rwaccess="R" width="5"></bitfield>
    
  <bitfield begin="26" description="Extended Prescale value for SPIFMT1. EPRESCALE_FMT1 can be modified in privilege mode only. EPRESCALE_FMT1 determines the bit transfer rate of Data Format 1 if the SPI/MibSPI is the network master. If the SPI / MibSPI is configured as slave, this field DOES NOT NEED to be configured. These EPRESCALE_FMT1(7:0) bits and PRESCALE1(7:0) bits of SPIFMT1 register will point to the same physically implemented register. Refer to Figure 56 for a graphical representation of the implementation. Write : This register field should be written if a SPICLK prescaler of more VBUSPCLK/256 is required. This field provides a prescaler of up to VBUSPCLK/2048 for SPICLK. Writing to this register field will also get reflected in SPIFMT1(15:8). Read : Reading this field will reflect the PRESCALE value based on the last written register field i.e., EXTENDED_PRESCALE1(26:16) or SPIFMT1(15:8) register. Note: If Extended Prescaler is required, it should be ensured that EXTENDED_PRESCALE1 register is programmed after SPIFMT1 register is programmed. This is to ensure that the final SPICLK prescale value is controlled by EXTENDED_PRESCALE1 register when a prescale of more 256 is intended on SPICLK. BRFormatx = VBUSPCLK/(EXTENDEDPRESCALEy+1) When EPRESCALE_FMTy (y=1,2) is set to zero(0), the SPI clock rate defaults to VBUSPCLK/2." end="16" id="EPRESCLAE_FMT1" rwaccess="RW" width="11"></bitfield>
    
  <bitfield begin="15" description="Reserved. Reads return ‘0’ and writes have no effect." end="11" id="NU1" rwaccess="R" width="5"></bitfield>
    
  <bitfield begin="10" description="EPRESCALE_FMT0 can be modified in privilege mode only. EPRESCALE_FMT0 determines the bit transfer rate of Data Format 0 if the SPI is the network master. If the SPI / MibSPI is configured as slave, this field DOES NOT NEED to be configured. These EPRESCALE_FMT0(7:0) bits and PRESCALE0(7:0) bits of SPIFMT0 register will point to the same physically implemented register. Refer to Figure 56 for a graphical representation of the implementation. Write : This register field should be written if a SPICLK prescaler of more VBUSPCLK/256 is required. This field provides a prescaler of up to VBUSPCLK/2048 for SPICLK. Writing to this register field will also get reflected in SPIFMT0(15:8). Read : Reading this field will reflect the PRESCALE value based on the last written register field i.e., EPRESCALE0(26:16) or SPIFMT0(15:8) register. Note: If Extended Prescaler is required, it should be ensured that EXTENDED_PRESCALE1 register is programmed after SPIFMT0 register is programmed. This is to ensure that the final SPICLK prescale value is controlled by EXTENDED_PRESCALE1 register when a prescale of more 256 is intended on SPICLK." end="0" id="EPRESCLAE_FMT0" rwaccess="RW" width="11"></bitfield>
  </register>
  
  
  <register acronym="EXTENDED_PRESCALE2" description="SPI/MibSPI Extended Prescale Register 2 (EXTENDED_PRESCALE2 for SPIFMT2 and SPIFMT3) This register provides an extended Prescale values for SPICLK generation to be able to interface with much slower SPI Slaves. This register is an extension of SPIFMT2 and SPIFMT3 registers. For example, EPRESCALE_FMT2(7:0) of EXTENDED_PRESCALE2 and PRESCALE2(7:0) of SPIFMT2 register will always reflect the same contents. Similarly EPRESCALE_FMT3(7:0) and PRESCALE3(7:0) of SPIFMT3 reflect the same contents." id="EXTENDED_PRESCALE2" offset="0x13C" width="32">
    
  <bitfield begin="31" description="Reserved. Reads return ‘0’ and writes have no effect." end="27" id="NU4" rwaccess="R" width="5"></bitfield>
    
  <bitfield begin="26" description="EPRESCALE_FMT3 can be modified in privilege mode only. EPRESCALE_FMT3 determines the bit transfer rate of Data Format 3 if the SPI is the network master. If the SPI / MibSPI is configured as slave, this field DOES NOT NEED to be configured. These EPRESCALE_FMT3(7:0) bits and PRESCALE3(7:0) bits of SPIFMT3 register will point to the same physically implemented register. Refer to Figure 56 for a graphical representation of the implementation. Write : This register field should be written if a SPICLK prescaler of more VBUSPCLK/256 is required. This field provides a prescaler of up to VBUSPCLK/2048 for SPICLK. Writing to this register field will also get reflected in SPIFMT3(15:8). Read : Reading this field will reflect the PRESCALE value based on the last written register field i.e., EPRESCALE3(26:16) or SPIFMT3(15:8) register. Note: If Extended Prescaler is required, it should be ensured that EXTENDED_PRESCALE2 register is programmed after SPIFMT3 register is programmed. This is to ensure that the final SPICLK prescale value is controlled by EXTENDED_PRESCALE2 register when a prescale of more 256 is intended on SPICLK." end="16" id="EPRESCLAE_FMT3" rwaccess="RW" width="11"></bitfield>
    
  <bitfield begin="15" description="Reserved. Reads return ‘0’ and writes have no effect." end="11" id="NU3" rwaccess="R" width="5"></bitfield>
    
  <bitfield begin="10" description="EPRESCALE_FMT2 can be modified in privilege mode only. EPRESCALE_FMT2 determines the bit transfer rate of Data Format 2 if the SPI is the network master. If the SPI / MibSPI is configured as slave, this field DOES NOT NEED to be configured. These EPRESCALE_FMT2(7:0) bits and PRESCALE2(7:0) bits of SPIFMT2 register will point to the same physically implemented register. Refer to Figure 56 for a graphical representation of the implementation. Write : This register field should be written if a SPICLK prescaler of more VBUSPCLK/256 is required. This field provides a prescaler of up to VBUSPCLK/2048 for SPICLK. Writing to this register field will also get reflected in SPIFMT3(15:8). Read : Reading this field will reflect the PRESCALE value based on the last written register field i.e., EXTENDED_PRESCALE2(26:16) or SPIFMT2(15:8) register. Note: If Extended Prescaler is required, it should be ensured that EXTENDED_PRESCALE2 register is programmed after SPIFMT2 register is programmed. This is to ensure that the final SPICLK prescale value is controlled by EXTENDED_PRESCALE2 register when a prescale of more 256 is intended on SPICLK." end="0" id="EPRESCLAE_FMT2" rwaccess="RW" width="11"></bitfield>
  </register>
  
  
  <register acronym="ECCDIAG_CTRL" description="ECC Diagnostic Control register" id="ECCDIAG_CTRL" offset="0x140" width="32">
    
  <bitfield begin="31" description="Reserved. Reads return ‘0’ and writes have no effect." end="4" id="NU" rwaccess="R" width="28"></bitfield>
    
  <bitfield begin="3" description="ECC Diagnostic mode Enable Key bits. 0101 : Diagnostic mode is enabled. Writes and reads from ECC bits allowed from the ECC address space. Refer to Section 9 for details on ECC/Parity address space. Others : Diagnostic mode is disabled. No writes to ECC bits are ignored, reads return ‘0’." end="0" id="ECCDIAG_EN" rwaccess="RW" width="4"></bitfield>
  </register>
  
  
  <register acronym="ECCDIAG_STAT" description="ECC Diagnostic Status register" id="ECCDIAG_STAT" offset="0x144" width="32">
    
  <bitfield begin="31" description="Reserved. Reads return ‘0’ and writes have no effect." end="18" id="NU2" rwaccess="R" width="14"></bitfield>
    
  <bitfield begin="17" description="Double bit error flag for RXRAM 1 - A double bit Error is detected for RXRAM bank during diagnostic mode tests. 0 - No error. A write ‘1’ to this bit will clear the bit." end="17" id="DEFLG1" rwaccess="R" width="1"></bitfield>
    
  <bitfield begin="16" description="Double bit error flag for TXRAM 1 - A double bit Error is detected for TXRAM bank during diagnostic mode tests. 0 - No error. A write ‘1’ to this bit will clear the bit." end="16" id="DEFLG0" rwaccess="R" width="1"></bitfield>
    
  <bitfield begin="15" description="Reserved. Reads return ‘0’ and writes have no effect." end="2" id="NU1" rwaccess="R" width="14"></bitfield>
    
  <bitfield begin="1" description="Single bit error flag for RXRAM 1 - A Single bit Error is detected for RXRAM bank during diagnostic mode tests. 0 - No error. A write ‘1’ to this bit will clear the bit." end="1" id="SEFLG1" rwaccess="R" width="1"></bitfield>
    
  <bitfield begin="0" description="Single bit error flag for TXRAM 1 - A Single bit Error is detected for TXRAM bank during diagnostic mode tests. 0 - No error. A write ‘1’ to this bit will clear the bit." end="0" id="SEFLG0" rwaccess="R" width="1"></bitfield>
  </register>
  
  
  <register acronym="SBERRADDR1" description="Single Bit Error Address Register - RXRAM" id="SBERRADDR1" offset="0x148" width="32">
    
  <bitfield begin="31" description="Reserved.Reads return ‘0’ and writes have no effect." end="11" id="NU1" rwaccess="R" width="21"></bitfield>
    
  <bitfield begin="10" description="Single Bit ECC Error Address This register holds the address of the RAM location when a single bit error is generated by SECDED block while reading the MibSPI (Receive) RXRAM. This error address is frozen from being updated until it is read by the VBUS host. Reading this register clears its contents to the default value The default value is 0x400 if Extended Buffer feature is enabled, else it is 0x200 Writes to this register are ignored." end="0" id="SBERRADDR1" rwaccess="R" width="11"></bitfield>
  </register>
  
  
  <register acronym="SBERRADDR0" description="Single Bit ECC Error Address Register - TXRAM" id="SBERRADDR0" offset="0x14C" width="32">
    
  <bitfield begin="31" description="Reserved.Reads return ‘0’ and writes have no effect." end="11" id="NU2" rwaccess="R" width="21"></bitfield>
    
  <bitfield begin="10" description="Single Bit ECC Error Address This register holds the address when a single bit error is generated from SECDED block while reading the MibSPI (Transmit) TXRAM. The TXRAM can be read either by CPU or by the MibSPI Sequencer logic for transmission. This error address is frozen from being updated until it is read by the VBUSP host. Reading this register clears its contents to the default value of 0x000. Writes to this register are ignored." end="0" id="SBERRADDR0" rwaccess="R" width="11"></bitfield>
  </register>
  
  
  <register acronym="SPIREV" description="SPI / MibSPI Revision ID Register" id="SPIREV" offset="0x1FC" width="32">
    
  <bitfield begin="31" description="Identification Scheme Used to distinguish different ID schemes. Reads 0x01" end="30" id="SCHEME" rwaccess="R" width="2"></bitfield>
    
  <bitfield begin="29" description="Reserved.Reads return ‘0’ and writes have no effect." end="28" id="NU" rwaccess="R" width="2"></bitfield>
    
  <bitfield begin="27" description="Indicates functionally equivalent module family Reads 0xA05" end="16" id="FUNC" rwaccess="R" width="12"></bitfield>
    
  <bitfield begin="15" description="RTL version number Read value will provide an approximate RTL revision number. The design release version can be obtained from the device specification" end="11" id="RTL" rwaccess="R" width="5"></bitfield>
    
  <bitfield begin="10" description="Major Revision number Reads 0x3" end="8" id="MAJOR" rwaccess="R" width="3"></bitfield>
    
  <bitfield begin="7" description="Indicates device specific implementation Reads 0x0" end="6" id="CUSTOM" rwaccess="R" width="2"></bitfield>
    
  <bitfield begin="5" description="Minor Revision number Reads 0x8" end="0" id="MINOR" rwaccess="R" width="6"></bitfield>
  </register>
</module>
