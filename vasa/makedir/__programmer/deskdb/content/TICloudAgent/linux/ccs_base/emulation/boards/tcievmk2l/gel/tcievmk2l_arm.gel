/******************************************************************************
 * Copyright (c) 2016 Texas Instruments Incorporated - http://www.ti.com
 * 
 *  Redistribution and use in source and binary forms, with or without 
 *  modification, are permitted provided that the following conditions 
 *
 *  are met:
 *
 *    Redistributions of source code must retain the above copyright 
 *    notice, this list of conditions and the following disclaimer.
 *
 *
 *    Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the     
 *    documentation and/or other materials provided with the   
 *
 *    distribution.
 *
 *
 *    Neither the name of Texas Instruments Incorporated nor the names of
 *    its contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
 *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
 *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
 *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
 *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
 *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
 *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 * 
 *****************************************************************************
 *
 *  Filename: 		evmtci6630k2l_arm.gel
 *  Description:	Utility GEL for use with the TCI6630k2l EVM. This GEL has 
 *					functions that initialize the chip PLL's and the DDR3A  interfaces. 
 *						
 *					It also includes general utilities that are useful for EVM development
 *	                  
 *	            	More functions will be added as needed. 
 *	  
 *	Author: Texas instruments                 
 *	Revision History: 
 *                    v1.0 - Initial Revision: Includes functions for Core PLL Init, DDR1066,DDR1600
 *                    v1.1 - Functions for DDR1333, Enable all PSC, Set Tetris PLL
 *					  v1.2 - Function for DFE PLL Setup
 *                    v1.3 - Modified Ethernet PHY setup function to use MDIO
 *                    v1.4 - Added initialization support for ARM
 *		              v1.5 - Inserted  SetupPhy0 and SetupPhy1 to target connect MDIO
 *			               - Added enterNonSecureMode for SMP mode in Target Connect and reset
 * ---------------------------------------------------------------------------*/

#define GEL_VERSION         1.5

// Timeout definitions
int _GEL_Global_Timeout1 = 0;

#define TIMEOUT_ID 10
// Global timeout value
#define GTIMEOUT 2000
//*****************************************************
// Power definitions
#define PSC_BASE            0x02350000
#define PSC_PTCMD           *( unsigned int* )( PSC_BASE+0x120 )
#define PSC_PTSTAT          *( unsigned int* )( PSC_BASE+0x128 )
#define PSC_PDCTL_BASE      ( PSC_BASE+0x300 )
#define PSC_MDSTAT_BASE     ( PSC_BASE+0x800 )
#define PSC_MDCTL_BASE      ( PSC_BASE+0xA00 )
// Modules on power domain 0
// Always on
// Modules on power domain 1
#define LPSC_DEBUG     (5)
#define LPSC_TETB      (6)
// Modules on power domain 2
#define LPSC_PA        (7)
#define LPSC_SGMII     (8)
#define LPSC_SA        (9)
// Modules on power domain 3 
#define LPSC_PCIE_0      (10)      
// Modules on power domain 4
#define LPSC_PCIE_1      (11)      
// Modules on power domain 5
#define LPSC_DFE_PD2       (12)
// Modules on power domain 6
#define LPSC_SR     (13)
// Modules on power domain 7
#define LPSC_MSMCRAM   (14)
// Modules on power domain 8
#define LPSC_GEM_0   (15)
// Modules on power domain 9
#define LPSC_GEM_1   (16)
// Modules on power domain 10
#define LPSC_GEM_2   (17)
// Modules on power domain 11
#define LPSC_GEM_3   (18)
// Modules on power domain 16
#define LPSC_DDR3_0      (23)
// Modules on power domain 17
#define LPSC_TAC       (25)
#define LPSC_RAC_0       (26)
// Modules on power domain 18
#define LPSC_DFE_PD0       (27)
// Modules on power domain 19
#define LPSC_FFTCA_FFTC_0 (28)
// Modules on power domain 21
#define LPSC_OSR      (34)
// Modules on power domain 22
#define LPSC_TCP3D_0      (35)
// Modules on power domain 23
#define LPSC_TCP3D_1      (37)
// Modules on power domain 24
#define LPSC_VCP_0      (39)
#define LPSC_VCP_1      (40)
#define LPSC_VCP_2      (41)
#define LPSC_VCP_3      (42)
// Modules on power domain 26
#define LPSC_BCP     (47)
// Modules on power domain 27
#define LPSC_DFE_PD1       (48)
// Modules on power domain 28
#define LPSC_FFTCA_FFTC_1      (49)
// Modules on power domain 29
#define LPSC_IQN_AIL 		(50)
// Modules on power domain 31
#define LPSC_ARM    (52)
// Power domains definitions
#define PD0         (0)     // Power Domain-0
#define PD1         (1)     // Power Domain-1
#define PD2         (2)     // Power Domain-2
#define PD3         (3)     // Power Domain-3
#define PD4         (4)     // Power Domain-4
#define PD5         (5)     // Power Domain-5
#define PD6         (6)     // Power Domain-6
#define PD7         (7)     // Power Domain-7
#define PD8         (8)     // Power Domain-8
#define PD9         (9)     // Power Domain-9
#define PD10        (10)    // Power Domain-10
#define PD11        (11)    // Power Domain-11
#define PD12        (12)    // Power Domain-12
#define PD13        (13)    // Power Domain-13
#define PD14        (14)    // Power Domain-14
#define PD15        (15)    // Power Domain-15
#define PD16        (16)    // Power Domain-16
#define PD17        (17)    // Power Domain-17
#define PD18        (18)    // Power Domain-18
#define PD19        (19)    // Power Domain-19
#define PD20        (20)    // Power Domain-20
#define PD21        (21)    // Power Domain-21
#define PD22        (22)    // Power Domain-22
#define PD23        (23)    // Power Domain-23
#define PD24        (24)    // Power Domain-24
#define PD25        (25)    // Power Domain-25
#define PD26        (26)    // Power Domain-26
#define PD27        (27)    // Power Domain-27
#define PD28        (28)    // Power Domain-28
#define PD29        (29)    // Power Domain-29
#define PD30        (30)    // Power Domain-30
#define PD31        (31)    // Power Domain-31
#define PSC_SYNCRESET (0x1)
#define PSC_DISABLE   (0x2)
#define PSC_ENABLE    (0x3)
#define CHIP_LEVEL_REG              0x02620000

/******************* PLL registers **********************************/
/*Boot cfg registers*/
#define KICK0                       *(unsigned int*)(CHIP_LEVEL_REG + 0x0038)
#define KICK1                       *(unsigned int*)(CHIP_LEVEL_REG + 0x003C)
#define KICK0_UNLOCK                (0x83E70B13)
#define KICK1_UNLOCK                (0x95A4F1E0)
#define KICK_LOCK                   0
#define TINPSEL                     *(unsigned int*)(CHIP_LEVEL_REG + 0x0300)
#define TOUTPSEL                    *(unsigned int*)(CHIP_LEVEL_REG + 0x0304)
#define MAINPLLCTL0                 *(unsigned int*)(CHIP_LEVEL_REG + 0x0350) //0x0328)
#define MAINPLLCTL1                 *(unsigned int*)(CHIP_LEVEL_REG + 0x0354) //0x032C)
#define MAIN_PLLD_OFFSET            0
#define MAIN_PLLD_MASK              0xFFFFFFC0
#define MAIN_PLLM_OFFSET            12
#define MAIN_PLLM_MASK              0xFFF80FFF
#define MAIN_BWADJ0_OFFSET          24
#define MAIN_BWADJ0_MASK            0x00FFFFFF
#define MAIN_ENSAT_OFFSET           6
#define MAIN_ENSAT_MASK             0xFFFFFFBF
#define MAIN_BWADJ1_OFFSET          0
#define MAIN_BWADJ1_MASK            0xFFFFFFF0
#define OBSCLKCTL                   *(unsigned int*)(CHIP_LEVEL_REG + 0x0C80)

/* PA PLL Registers */
#define BYPASS_BIT_SHIFT 23
#define CLKF_BIT_SHIFT   6
#define CLKD_BIT_SHIFT   0
#define DEVSTAT    (*((unsigned int *) 0x02620020))
#define PAPLLCTL0                 *(unsigned int*)(CHIP_LEVEL_REG + 0x0358) 
#define PAPLLCTL1                 *(unsigned int*)(CHIP_LEVEL_REG + 0x035C) 
#define PASSCLKSEL_MASK    (1 << 17)    /* Tells the configuration of the PASSCLKSEL pin */
#define PA_PLL_BYPASS_MASK (1 << BYPASS_BIT_SHIFT)    /* Tells whether the PA PLL is in BYPASS mode or not */
#define PA_PLL_CLKOD_MASK  (0x00780000) /* Tells the output divider value for the PA PLL */
#define PA_PLL_CLKF_MASK   (0x0007FFC0) /* Tells the multiplier value for the PA PLL */
#define PA_PLL_CLKR_MASK   (0x0000003F) /* Tells the divider value for the PA PLL */
#define PA_PLL_RESET_MASK  (0x00004000)
#define CHIP_MISC1                  *(unsigned int*)(CHIP_LEVEL_REG + 0x0C7C)
#define ARMPLL_ENABLE_OFFSET        13
#define DDR3APLLCTL0  			*(unsigned int*)(CHIP_LEVEL_REG + 0x0360)
#define DDR3APLLCTL1  			*(unsigned int*)(CHIP_LEVEL_REG + 0x0364)
#define DFEPLLCTL0                  (unsigned int*)(CHIP_LEVEL_REG + 0x378)
#define DFEPLLCTL1                  (unsigned int*)(CHIP_LEVEL_REG + 0x37C)
#define DFE_CLKDIV_CTL              (unsigned int*)(CHIP_LEVEL_REG + 0x6E8)
#define DFE_CLKSYNC_CTL             (unsigned int*)(CHIP_LEVEL_REG + 0x6EC)
//******************************************************
// PLL 1 definitions (DSP and ARM clock and subsystems)
#define PLL1_BASE                   0x02310000
#define PLL1_PLLCTL                 (*(unsigned int*)(PLL1_BASE + 0x100))   // PLL1 Control
#define PLL1_SECCTL                 (*(unsigned int*)(PLL1_BASE + 0x108))   // PLL1 Secondary Control
#define PLL1_PLLM                   (*(unsigned int*)(PLL1_BASE + 0x110))   // PLL1 Multiplier
#define PLL1_DIV1                   (*(unsigned int*)(PLL1_BASE + 0x118))   // DIV1 divider
#define PLL1_DIV2                   (*(unsigned int*)(PLL1_BASE + 0x11C))   // DIV2 divider
#define PLL1_DIV3                   (*(unsigned int*)(PLL1_BASE + 0x120))   // DIV3 divider
#define PLL1_CMD                    (*(unsigned int*)(PLL1_BASE + 0x138))   // CMD control
#define PLL1_STAT                   (*(unsigned int*)(PLL1_BASE + 0x13C))   // STAT control
#define PLL1_ALNCTL                 (*(unsigned int*)(PLL1_BASE + 0x140))   // ALNCTL control
#define PLL1_DCHANGE                (*(unsigned int*)(PLL1_BASE + 0x144))   // DCHANGE status
#define PLL1_CKEN                   (*(unsigned int*)(PLL1_BASE + 0x148))   // CKEN control
#define PLL1_CKSTAT                 (*(unsigned int*)(PLL1_BASE + 0x14C))   // CKSTAT status
#define PLL1_SYSTAT                 (*(unsigned int*)(PLL1_BASE + 0x150))   // SYSTAT status
#define PLL1_DIV4                   (*(unsigned int*)(PLL1_BASE + 0x160))   // DIV4 divider
#define PLL1_DIV5                   (*(unsigned int*)(PLL1_BASE + 0x164))   // DIV5 divider
#define PLL1_DIV6                   (*(unsigned int*)(PLL1_BASE + 0x168))   // DIV6 divider
#define PLL1_DIV7                   (*(unsigned int*)(PLL1_BASE + 0x16C))   // DIV7 divider
#define PLL1_DIV8                   (*(unsigned int*)(PLL1_BASE + 0x170))   // DIV8 divider
#define PLL1_DIV9                   (*(unsigned int*)(PLL1_BASE + 0x174))   // DIV9 divider
#define PLL1_DIV10                  (*(unsigned int*)(PLL1_BASE + 0x178))   // DIV10 divider
#define PLL1_DIV11                  (*(unsigned int*)(PLL1_BASE + 0x17C))   // DIV11 divider
#define PLL1_DIV12                  (*(unsigned int*)(PLL1_BASE + 0x180))   // DIV12 divider
#define PLL1_DIV13                  (*(unsigned int*)(PLL1_BASE + 0x184))   // DIV13 divider
#define PLL1_DIV14                  (*(unsigned int*)(PLL1_BASE + 0x188))   // DIV14 divider
#define PLL1_DIV15                  (*(unsigned int*)(PLL1_BASE + 0x18C))   // DIV15 divider
#define PLL1_DIV16                  (*(unsigned int*)(PLL1_BASE + 0x190))   // DIV16 divider
#define PLLPWRDN_OFFSET             1
#define PLLPWRDN_MASK               0xFFFFFFFD
#define PLLRST_OFFSET               3
#define PLLRST_MASK                 0xFFFFFFF7
#define PLLENSRC_OFFSET             5
#define PLLENSRC_MASK               0xFFFFFFDF
#define PLLEN_OFFSET                0
#define PLLEN_MASK                  0xFFFFFFFE
#define OUTPUT_DIVIDE_OFFSET        19
#define OUTPUT_DIVIDE_MASK          0xFF87FFFF    
#define BYPASS_OFFSET               23
#define BYPASS_MASK                 0xFF7FFFFF
#define PLLM_OFFSET                 0
#define PLLM_MASK                   0xFFFFFFC0
#define GOSET_OFFSET                0
#define GOSET_MASK                  0xFFFFFFFE
#define GOSTAT_OFFSET               0
#define GOSTAT_MASK                 0xFFFFFFFE
#define OUTPUT_DIVIDE_OFFSET        19
#define OUTPUT_DIVIDE_MASK          0xFF87FFFF   
// ARMPLL definitions
#define SEC_PLLCTL0_PLLM_OFFSET     6
#define SEC_PLLCTL0_PLLM_MASK       0xFFFF003F
#define SEC_PLLCTL0_BWADJ_OFFSET    24
#define SEC_PLLCTL0_BWADJ_MASK      0x00FFFFFF
#define SEC_PLLCTL0_OD_OFFSET       19
#define SEC_PLLCTL0_OD_MASK         0xFF87FFFF
#define SEC_PLLCTL0_BYPASS_OFFSET   23
#define SEC_PLLCTL0_BYPASS_MASK     0xFF7FFFFF
#define SEC_PLLCTL1_RESET_OFFSET    14
#define SEC_PLLCTL1_RESET_MASK      0xFFFFBFFF
#define SEC_PLLCTL1_PWRDWN_OFFSET   15
#define SEC_PLLCTL1_PWRDWN_MASK     0xFFFF7FFF
#define SEC_PLLCTL1_ENSTAT_OFFSET   6
#define SEC_PLLCTL1_ENSTAT_MASK     0xFFFFFFBF
/*----------------DDR3A Register definition---------------------*/
#define DDR3A_BASE_ADDR (0x21010000)
#define DDR3A_STATUS   (*(int*)(DDR3A_BASE_ADDR + 0x00000004))
#define DDR3A_SDCFG    (*(int*)(DDR3A_BASE_ADDR + 0x00000008))
#define DDR3A_SDRFC    (*(int*)(DDR3A_BASE_ADDR + 0x00000010))
#define DDR3A_SDTIM1   (*(int*)(DDR3A_BASE_ADDR + 0x00000018))
#define DDR3A_SDTIM2   (*(int*)(DDR3A_BASE_ADDR + 0x0000001C))
#define DDR3A_SDTIM3   (*(int*)(DDR3A_BASE_ADDR + 0x00000020))
#define DDR3A_SDTIM4   (*(int*)(DDR3A_BASE_ADDR + 0x00000028))
#define DDR3A_ZQCFG    (*(int*)(DDR3A_BASE_ADDR + 0x000000C8))
#define DDR3A_TMPALRT  (*(int*)(DDR3A_BASE_ADDR + 0x000000CC))
#define DDR3A_DDRPHYC  (*(int*)(DDR3A_BASE_ADDR + 0x000000E4))
#define DDR3A_PHY_CFG_BASE (0x02329000)
#define DDR3A_PIR    (*(int*)(DDR3A_PHY_CFG_BASE + 0x00000004))
#define DDR3A_PGCR0  (*(int*)(DDR3A_PHY_CFG_BASE + 0x00000008))
#define DDR3A_PGCR1  (*(int*)(DDR3A_PHY_CFG_BASE + 0x0000000C))
#define DDR3A_PGCR2  (*(int*)(DDR3A_PHY_CFG_BASE + 0x0000008C))
#define DDR3A_PGSR0  (*(int*)(DDR3A_PHY_CFG_BASE + 0x00000010))
#define DDR3A_PGSR1  (*(int*)(DDR3A_PHY_CFG_BASE + 0x00000014))
#define DDR3A_PLLCR  (*(int*)(DDR3A_PHY_CFG_BASE + 0x00000018))
#define DDR3A_PTR0   (*(int*)(DDR3A_PHY_CFG_BASE + 0x0000001C))
#define DDR3A_PTR1   (*(int*)(DDR3A_PHY_CFG_BASE + 0x00000020))
#define DDR3A_PTR2   (*(int*)(DDR3A_PHY_CFG_BASE + 0x00000024))
#define DDR3A_PTR3   (*(int*)(DDR3A_PHY_CFG_BASE + 0x00000028))
#define DDR3A_PTR4   (*(int*)(DDR3A_PHY_CFG_BASE + 0x0000002C))
#define DDR3A_DSGCR  (*(int*)(DDR3A_PHY_CFG_BASE + 0x00000040))
#define DDR3A_DCR    (*(int*)(DDR3A_PHY_CFG_BASE + 0x00000044))
#define DDR3A_MR0    (*(int*)(DDR3A_PHY_CFG_BASE + 0x00000054))
#define DDR3A_MR1    (*(int*)(DDR3A_PHY_CFG_BASE + 0x00000058))
#define DDR3A_MR2    (*(int*)(DDR3A_PHY_CFG_BASE + 0x0000005C))
#define DDR3A_DTCR   (*(int*)(DDR3A_PHY_CFG_BASE + 0x00000068))
#define DDR3A_DTPR0  (*(int*)(DDR3A_PHY_CFG_BASE + 0x00000048))
#define DDR3A_DTPR1  (*(int*)(DDR3A_PHY_CFG_BASE + 0x0000004C))
#define DDR3A_DTPR2  (*(int*)(DDR3A_PHY_CFG_BASE + 0x00000050))
#define DDR3A_ZQ0CR1  (*(int*)(DDR3A_PHY_CFG_BASE + 0x00000184))
#define DDR3A_ZQ1CR1  (*(int*)(DDR3A_PHY_CFG_BASE + 0x00000194))
#define DDR3A_ZQ2CR1  (*(int*)(DDR3A_PHY_CFG_BASE + 0x000001A4))
#define DDR3A_ZQ3CR1  (*(int*)(DDR3A_PHY_CFG_BASE + 0x000001B4))
#define DDR3A_DATX8_8 (*(int*)(DDR3A_PHY_CFG_BASE + 0x000003C0))
#define DDR3_TEST_START_ADDRESS (*(int*)(0x80000000))
#define IODDRM_MASK            0x00000180  
#define ZCKSEL_MASK            0x01800000
#define CL_MASK				   0x00000072
#define WR_MASK				   0x00000E00
#define BL_MASK				   0x00000003
#define RRMODE_MASK            0x00040000
#define UDIMM_MASK             0x20000000
#define BYTEMASK_MASK          0x0000FC00
#define MPRDQ_MASK             0x00000080
#define PDQ_MASK               0x00000070
#define NOSRA_MASK             0x08000000
#define ECC_MASK               0x00000001
#define RRMODE_MASK            0x00040000
#define DDR3A_DX0GSR0 (*(int*)(DDR3A_PHY_CFG_BASE + 0x000001C4)) //0x71
#define DDR3A_DX1GSR0 (*(int*)(DDR3A_PHY_CFG_BASE + 0x00000204)) //0x81
#define DDR3A_DX2GSR0 (*(int*)(DDR3A_PHY_CFG_BASE + 0x00000244)) //0x91
#define DDR3A_DX3GSR0 (*(int*)(DDR3A_PHY_CFG_BASE + 0x00000284)) //0xA1
#define DDR3A_DX4GSR0 (*(int*)(DDR3A_PHY_CFG_BASE + 0x000002C4)) //0xB1
#define DDR3A_DX5GSR0 (*(int*)(DDR3A_PHY_CFG_BASE + 0x00000304)) //0xC1
#define DDR3A_DX6GSR0 (*(int*)(DDR3A_PHY_CFG_BASE + 0x00000344)) //0xD1
#define DDR3A_DX7GSR0 (*(int*)(DDR3A_PHY_CFG_BASE + 0x00000384)) //0xE1
#define DDR3A_DX8GSR0 (*(int*)(DDR3A_PHY_CFG_BASE + 0x000003C4)) //0xF1
#define DDR3A_TEST_START_ADDRESS (0x80000000)
#define DDR3A_TEST_END_ADDRESS   (DDR3A_TEST_START_ADDRESS + (4 * 100))
#define DDR3A_BASE_ADDRESS        0x80000000
#define TETRIS_BASE                 0x01E80000
#define TETRIS_CPU0_PTCMD           *(unsigned int*)(TETRIS_BASE + 0x0400)
#define TETRIS_CPU0_PDSTAT          *(unsigned int*)(TETRIS_BASE + 0x0404)
#define TETRIS_CPU0_PDCTL           *(unsigned int*)(TETRIS_BASE + 0x0408)
#define TETRIS_CPU1_PTCMD           *(unsigned int*)(TETRIS_BASE + 0x040C)
#define TETRIS_CPU1_PDSTAT          *(unsigned int*)(TETRIS_BASE + 0x0410)
#define TETRIS_CPU1_PDCTL           *(unsigned int*)(TETRIS_BASE + 0x0414)
#define SECPLLCTL0                  *(unsigned int*)(CHIP_LEVEL_REG + 0x0370)
#define SECPLLCTL1                  *(unsigned int*)(CHIP_LEVEL_REG + 0x0374)
unsigned int read_val;

#define GICD_BASE_ADDRESS       0x02561000
#define GICC_BASE_ADDRESS       0x02562000
#define GICD_GROUP_OFFSET       0x80
#define GICC_PMR_OFFSET         0x4

#define RW32(X)                         *(unsigned int *)(X)

#define NUM_CPUS                        2
#define VBUSP_REGS                      0x01E80000
#define PD_BASE                         (VBUSP_REGS + 0x400)
#define PD_CMD(CPUID)           (PD_BASE + 0xC*CPUID)
#define PD_STAT(CPUID)          (PD_BASE + 0x4 + 0xC*CPUID)
#define PD_CTL(CPUID)           (PD_BASE + 0x8 + 0xC*CPUID)

/************ Change A15 security mode to non-secure mode ***************/
hotmenu enterNonSecureMode()
{
        int i;
        int status;

        Disable_MMU();
        Disable_Caches();

        GEL_TextOut("Enabling non-secure access to cp10 and cp11\n");
        status = REG_CTXA15_CP15_C1_NSACR;
        status |= 0x00000C00;
        status &= 0x7FFFFFFF;
        REG_CTXA15_CP15_C1_NSACR = status;
        GEL_TextOut("Enabled non-secure access to cp10 and cp11\n");

        GEL_TextOut("Enabling SMP bit in ACTLR\n");
        status = REG_CTXA15_CP15_C1_ACTLR;
        status |= 0x40;
        REG_CTXA15_CP15_C1_ACTLR = status;
        GEL_TextOut("Enabled SMP bit in ACTLR\n");

        GEL_TextOut("Entering NonSecure Mode\n");
        status = REG_CTXA15_CP15_C1_SCR;
        status |= 0x1;
        REG_CTXA15_CP15_C1_SCR = status;
        GEL_TextOut("Entered NonSecure Mode\n");

        // Ensure MMU and Caches are disabled after changing security mode
        Disable_MMU();
        Disable_Caches();
}
#define MMU_ON 0x1
#define MMU_OFF ~MMU_ON

hotmenu Disable_MMU()
{
    int status;

        GEL_TextOut("Disabling MMU\n");
    status = REG_CTXA15_CP15_C1_SCTLR;
    status &= MMU_OFF;
    REG_CTXA15_CP15_C1_SCTLR = status;
}

#define ICACHE_ON 0x1000
#define ICACHE_OFF ~ICACHE_ON
#define DCACHE_ON 0x4
#define DCACHE_OFF ~DCACHE_ON

hotmenu Disable_Caches()
{
    int status, i, j;
        int level; // indicating cache level
        int ccsidr, lineLength, numWays, numSets, input, baseinput, shift, incFactor;

        GEL_TextOut("Disabling Caches\n");
        status = REG_CTXA15_CP15_C1_SCTLR;
    status &= DCACHE_OFF;
    status &= ICACHE_OFF;
    REG_CTXA15_CP15_C1_SCTLR = status;

        // invalidate entire instruction cache
        GEL_TextOut("Invalidate Instruction Caches\n");
        REG_CTXA15_CP15_C7_ICIALLU = 1;

        return;
        level = 0;
        // invalidate L1D and L2 cache
        while (level < 2) {
                REG_CTXA15_CP15_C0_CSSELR = (level & 0x7) << 1; // select current cache level in csselr
                ccsidr = REG_CTXA15_CP15_C0_CCSIDR;                             // read the new ccsidr
                lineLength = (ccsidr & 0x7) + 4;
                numWays = (ccsidr >> 3) & 0x3ff;
                numSets = (ccsidr >> 13) & 0x7fff;
                GEL_TextOut("numWays %d\n",,,,, numWays);
                GEL_TextOut("numSets %d\n",,,,, numSets);
                GEL_TextOut("lineLength %d\n",,,,, lineLength);
                numSets = numSets << lineLength;
                incFactor = 1 << lineLength;
                if (level == 0) {
                        shift = 31;
                }
                else {
                        shift = 28;
                }
                //shift = 32 - log2(numWays);
                for (i = 0; i <= numWays; i++) {
                        baseinput = (level << 1) | (i << shift);
                        for (j = 0; j <= numSets; j += incFactor) {
                                input = baseinput | j;
                                REG_CTXA15_CP15_C7_DCCISW = input;
                        }
                }
                level++;
        }
}
hotmenu PowerOnCpu()
{
        int i;

        for (i = 1; i < NUM_CPUS; i++) {
                /* Wakeup CPU */
                RW32(PD_CTL(i)) = 0x0;
                /* Start transition */
                RW32(PD_CMD(i)) = 0x1;
                /* Wait for CPU wakeup transition to complete */
                while(PD_STAT(i) & (0x70000));
        }
}

/****************************************************************************
 *
 * NAME
 *      OnTargetConnect
 *
 * PURPOSE:
 *      Setup almost everything ready for a new debug session:
 *      DSP modules and EVM board modules, at target connection.
 *      Do nothing if target is in realtime mode.
 *      This routine is called when you connect to the target board.
 *
 *      IMPORTANT: this routine won't attempt to connect to the target
 *      if the target is not in real-time mode and that the dsp boot
 *      mode switches are not set in emulation boot mode.
 *
 * USAGE
 *      This routine is a callback routine and called by CCS only.
 *
 * RETURN VALUE
 *      NONE
 *
 * REFERENCE
 *
 ****************************************************************************/
OnTargetConnect()
{
	/*------------------------------------------------------*/
	/* GEL_Reset() is used to deal with the worst case      */
	/* senario of unknown target state.  If for some reason */
	/* a reset is not desired upon target connection,       */
	/* GEL_Reset() may be removed and replaced with         */
	/* something "less brutal" like a cache initialization  */
	/* function.                                            */
	/*------------------------------------------------------*/
	GEL_Reset();
	//xmc_setup();
	//ddr3_setup();

	GEL_TextOut("\nConnecting Target...\n");

	// Check if target is not in real-time mode. If it is in stop mode,
	// initialize everything. In real-time mode, do nothing to connect
	// unobtrusively...
	if (!GEL_IsInRealtimeMode())
	{
		
		enterNonSecureMode();
		// Validates if emulation boot mode
		if (DEVSTAT & 0x0000000E)
		{
			GEL_TextOut("No initialization performed since bootmode = %x \n",,,,,(DEVSTAT >> 1 ) & 0xF);
			GEL_TextOut("You can manually initialize with GlobalDefaultSetup\n");
		}
		else
		{
			// Comment the following line at production application test
			// when the application need to initialize everything, but not the
			// GEL file.
			Global_Default_Setup_Silent();
		}
	} else {
		GEL_TextOut("No initialization performed in real time mode\n");
	}

        /* Setup memory map with SH1 shareability attribute */
        GEL_MapOn();
        GEL_MapAddStr(0x0000000, 0, 0xFFFFFFFF, "R|W|AS4", 0);

}

/*--------------------------------------------------------------*/
/* OnReset()                                                    */
/* This function is called by CCS when you do Debug->Resest.    */
/* The goal is to put the C6x into a known good state with      */
/* respect to cache, edma and interrupts.                       */
/*--------------------------------------------------------------*/
OnReset( int nErrorCode )
{

	enterNonSecureMode();

}

/*--------------------------------------------------------------*/
/* xmc_setup()                                                  */
/* XMC MPAX register setting to access DDR3 config space        */
/*--------------------------------------------------------------*/

#define XMC_BASE_ADDR (0x08000000)
#define XMPAX2_L     (*(int*)(XMC_BASE_ADDR + 0x00000010))
#define XMPAX2_H     (*(int*)(XMC_BASE_ADDR + 0x00000014))

xmc_setup()
{
	/* mapping for ddr emif registers XMPAX*2 */

	XMPAX2_L =  0x121010FF;  /* replacement addr + perm */
	XMPAX2_H =  0x2101000B;    /* base addr + seg size (64KB)*/	//"1B"-->"B" by xj
	GEL_TextOut("XMC setup complete.\n");
}

/****************************************************************************
 *
 * NAME
 *      Global_Default_Setup_Silent
 *
 * PURPOSE:
 *      Setup almost everything ready for a new debug session:
 *      DSP modules and EVM board modules.
 *
 * USAGE
 *      This routine can be called as:
 *
 *      Global_Default_Setup_Silent()
 *
 * RETURN VALUE
 *      NONE
 *
 * REFERENCE
 *
 ****************************************************************************/
Global_Default_Setup_Silent()
{
    float gel_ver = GEL_VERSION;
    int coreId = REG_CTXA15_CP15_C0_MPIDR & 0x3;

    GEL_TextOut( "TCI6630k2l GEL file Ver is %f \n",,,,, (float) (gel_ver/1.0));

    GEL_Reset();

    // Only core 0 can set these
    if (coreId == 0) {
        // Setup main PLL DSP @ 983 MHz
        Set_Pll1(3); // call Set_Pll1 with index = 3 -> 122.88 MHz to 983.04 MHz operation

        // Setup ARM PLL index = 1 -> 125 MHz to 1000 MHz operation
        Set_Tetris_Pll(1);

        // Setup all Power Domains on
        Set_Psc_All_On();

        // Setup PA PLL
        PaPllConfig();

        GEL_TextOut("DDR begin\n");
        xmc_setup();
        ddr3A_64bit_DDR1600_setup(0);
        GEL_TextOut("DDR done\n");

        /* Wake-up cores */
        PowerOnCpu();
        GEL_TextOut( "Entering A15 non secure mode .. \n");
        enterNonSecureMode();
        GEL_TextOut( "A15 non secure mode entered \n");

        GEL_TextOut("setupPhy begin\n");
        SetupPhy0();
        SetupPhy1();
        GEL_TextOut("setupPhy done\n");
    }
}


/****************************************************************************
 *
 * NAME
 *      Set_PSC_State
 *
 * PURPOSE:
 *      Set a new power state for the specified domain id in a power controler
 *      domain. Wait for the power transition to complete.
 *
 * USAGE
 *      This routine can be called as:
 *
 *      Set_PSC_State(unsigned int pd,unsigned int id,unsigned int state)
 *
 *      pd    - (i) power domain.
 *
 *      id    - (i) module id to use for module in the specified power domain
 *
 *      state - (i) new state value to set
 *                  0 = RESET
 *                  1 = SYNC RESET
 *                  2 = DISABLE
 *                  3 = ENABLE
 *
 * RETURN VALUE
 *      0 if ok, !=0 for error
 *
 * REFERENCE
 *
 ****************************************************************************/
Set_PSC_State(unsigned int pd,unsigned int id,unsigned int state)
{
	unsigned int* mdctl;
	unsigned int* mdstat;
	unsigned int* pdctl;
	int ret=0;
        int coreId = REG_CTXA15_CP15_C0_MPIDR & 0x3;

	// Only core0 can set PSC
	if (coreId == 0)
	{
		mdctl = ( unsigned int* )(PSC_MDCTL_BASE + ( 4 * id ));
		mdstat = ( unsigned int* )( PSC_MDSTAT_BASE + ( 4 * id ));
		pdctl = ( unsigned int* )(PSC_PDCTL_BASE + ( 4 * pd ));

		// If state is already set, do nothing
		if ( ( *mdstat & 0x1f ) == state )
		{
			return(0);
		}

		// Wait for GOSTAT to clear
		Set_Timeout(GTIMEOUT);
		while( Get_Timeout() && (PSC_PTSTAT & (0x1 << pd)) != 0 );

		// Check if we got timeout error while waiting
		if (!Get_Timeout())
		{
			GEL_TextOut( "Set_PSC_State... Timeout Error #01 pd=%d, md=%d!\n",,2,,,pd,id);
			ret=1;
		}
		else
		{
			// Set power domain control
			*pdctl = (*pdctl) | 0x00000001;

			// Set MDCTL NEXT to new state
			*mdctl = ((*mdctl) & ~(0x1f)) | state;

			// Start power transition by setting PTCMD GO to 1
			PSC_PTCMD = (PSC_PTCMD) | (0x1<<pd);

			// Wait for PTSTAT GOSTAT to clear
			Set_Timeout(GTIMEOUT);
			while( Get_Timeout() && (PSC_PTSTAT & (0x1 << pd)) != 0 );

			// Check if we got timeout error while waiting
			if (!Get_Timeout())
			{
				GEL_TextOut( "Set_PSC_State... Timeout Error #02 pd=%d, md=%d!\n",,2,,,pd,id);
				ret=2;
			}
			else
			{
				// Verify state changed
				Set_Timeout(GTIMEOUT);
				while(Get_Timeout() && ( *mdstat & 0x1f ) != state );

				// Check if we got timeout error while waiting
				if (!Get_Timeout())
				{
					GEL_TextOut( "Set_PSC_State... Timeout Error #03 pd=%d, md=%d!\n",,2,,,pd,id);
					ret=3;
				}
			}
		}

		// Kill the currently running timeout
		Kill_Timeout();
	}
	else
	{
		GEL_TextOut("DSP core #%d cannot set PSC.\n",,2,,,DNUM);
	}

	return(ret);
}

/****************************************************************************
 *
 * NAME
 *      Set_Timeout
 *
 * PURPOSE:
 *      Starts a timeout period of msec. The running timeout period can be
 *      query with Get_Timeout. To kill a running timeout before the end,
 *      call Kill_Timeout. Only one timeout period can be used at any time.
 *      A timeout period can be used to measure a period of time while doing
 *      anything else. Not accurate, sets timer at least as big as desired.
 *
 * USAGE
 *      This routine can be called as:
 *
 *      Set_Timeout(msec)
 *
 *      msec - (i) timeout period in msec (not very precise < sec range)
 *
 * RETURN VALUE
 *      NONE
 *
 * REFERENCE
 *
 ****************************************************************************/
Set_Timeout(msec)
{
	// Cancel the current timer if not already expired
	GEL_CancelTimer(TIMEOUT_ID);

	// Starts the timeout period
	_GEL_Global_Timeout1=1;

	// Setup a callback routine with specified timeout
	GEL_SetTimer(msec, TIMEOUT_ID, "_Timeout_Callback()");
}

/****************************************************************************
 *
 * NAME
 *      Get_Timeout
 *
 * PURPOSE:
 *      Query the running state of a timeout period started by Set_Timeout.
 *      (see Set_Timeout for more info).
 *
 * USAGE
 *      This routine can be called as:
 *
 *      Get_Timeout()
 *
 * RETURN VALUE
 *      0:expired, 1:running
 *
 * REFERENCE
 *
 ****************************************************************************/
Get_Timeout()
{
	if (!_GEL_Global_Timeout1)
	{
		// Cancel the current timer
		GEL_CancelTimer(TIMEOUT_ID);
	}

	// Return the global timeout status 1=running, 0=expired
	return _GEL_Global_Timeout1;
}

/****************************************************************************
 *
 * NAME
 *      Kill_Timeout
 *
 * PURPOSE:
 *      Cancel a running timeout period before it expires
 *      (see Set_Timeout for more info).
 *
 * USAGE
 *      This routine can be called as:
 *
 *      Kill_Timeout()
 *
 * RETURN VALUE
 *      NONE
 *
 * REFERENCE
 *
 ****************************************************************************/
Kill_Timeout()
{
	// Cancel the current timer
	GEL_CancelTimer(TIMEOUT_ID);

	// The timeout period is expired
	_GEL_Global_Timeout1=0;
}

/****************************************************************************
 *
 * NAME
 *      _Timeout_Callback
 *
 * PURPOSE:
 *      Internal Callback function used by Set_timeout
 *      (see Set_Timeout for more info).
 *
 * USAGE
 *      This routine must not be called by itself.
 *
 * RETURN VALUE
 *      NONE
 *
 * REFERENCE
 *
 ****************************************************************************/
_Timeout_Callback()
{
	// The timeout period is expired
	_GEL_Global_Timeout1=0;
}


/****************************************************************************
 *
 * NAME
 *      Set_Psc_All_On
 *
 * PURPOSE:
 *      Enable all PSC modules and DSP power domains on ALWAYSON, and wait
 *      for these power transitions to complete.
 *
 * USAGE
 *      This routine can be called as:
 *
 *      Set_Psc_All_On()
 *
 * RETURN VALUE
 *      NONE
 *
 * REFERENCE
 *
 ****************************************************************************/
hotmenu Set_Psc_All_On( )
{
	unsigned int i=0;
        int coreId = REG_CTXA15_CP15_C0_MPIDR & 0x3;

	// Only core0 can set PSC
	if (coreId == 0)
	{
		GEL_TextOut( "Power on all PSC modules and DSP domains... \n");

		Set_PSC_State(PD1, LPSC_DEBUG, PSC_ENABLE);	
		Set_PSC_State(PD1, LPSC_TETB, PSC_ENABLE);	
		Set_PSC_State(PD2, LPSC_PA, PSC_ENABLE);	
		Set_PSC_State(PD2, LPSC_SGMII, PSC_ENABLE);	
		Set_PSC_State(PD2, LPSC_SA, PSC_ENABLE);	
		Set_PSC_State(PD3, LPSC_PCIE_0, PSC_ENABLE);	
		Set_PSC_State(PD4, LPSC_PCIE_1, PSC_ENABLE);	
		Set_PSC_State(PD5, LPSC_DFE_PD2, PSC_ENABLE);	
		Set_PSC_State(PD6, LPSC_SR, PSC_ENABLE);	
		Set_PSC_State(PD7, LPSC_MSMCRAM, PSC_ENABLE);	
		Set_PSC_State(PD8, LPSC_GEM_0, PSC_ENABLE);	
		Set_PSC_State(PD9, LPSC_GEM_1, PSC_ENABLE);	
		Set_PSC_State(PD10, LPSC_GEM_2, PSC_ENABLE);	
		Set_PSC_State(PD11, LPSC_GEM_3, PSC_ENABLE);	
		Set_PSC_State(PD16, LPSC_DDR3_0, PSC_ENABLE);	
		Set_PSC_State(PD17, LPSC_TAC, PSC_ENABLE);	
		Set_PSC_State(PD17, LPSC_RAC_0, PSC_ENABLE);	
		Set_PSC_State(PD18, LPSC_DFE_PD0, PSC_ENABLE);	
		Set_PSC_State(PD19, LPSC_FFTCA_FFTC_0, PSC_ENABLE);	
		Set_PSC_State(PD21, LPSC_OSR, PSC_ENABLE);	
		Set_PSC_State(PD22, LPSC_TCP3D_0, PSC_ENABLE);	
		Set_PSC_State(PD23, LPSC_TCP3D_1, PSC_ENABLE);	
		Set_PSC_State(PD24, LPSC_VCP_0, PSC_ENABLE);	
		Set_PSC_State(PD24, LPSC_VCP_1, PSC_ENABLE);	
		Set_PSC_State(PD24, LPSC_VCP_2, PSC_ENABLE);	
		Set_PSC_State(PD24, LPSC_VCP_3, PSC_ENABLE);	
		Set_PSC_State(PD26, LPSC_BCP, PSC_ENABLE);	
		Set_PSC_State(PD27, LPSC_DFE_PD1, PSC_ENABLE);	
		Set_PSC_State(PD28, LPSC_FFTCA_FFTC_1, PSC_ENABLE);	
		Set_PSC_State(PD29, LPSC_IQN_AIL, PSC_ENABLE);	
		Set_PSC_State(PD31, LPSC_ARM, PSC_ENABLE);	
		GEL_TextOut( "Power on all PSC modules and DSP domains... Done.\n" );
	}
	else
	{
		GEL_TextOut("DSP core #%d cannot set PSC.\n",,2,,,DNUM);
	}
}


//********************************************************************************************************************************
//********************************************************************************************************************************
/*
   Set_Pll1() - This function executes the main PLL initialization 
   sequence needed to get the main PLL up after coming out of an initial power up 
   before it is locked or after it is already locked.

   Index value determines multiplier, divier used and clock reference assumed for 
   output display. 
 */
Set_Pll1(int index)
{
	int i, TEMP;
	unsigned int BYPASS_val;     
	unsigned int BWADJ_val;     
	unsigned int OD_val;            

	float CLKIN_val;
	unsigned int PLLM_val;
	unsigned int PLLD_val;
	unsigned int PLLDIV3_val; //example value for SYSCLK2 (from 6614 spec) Default /2 - Fast Peripherals, (L2, MSMC, DDR3 EMIF, EDMA0...)
	unsigned int PLLDIV4_val; //example value for SYSCLK3 (from 6614 spec) Default /3 - Switch Fabric
	unsigned int PLLDIV7_val; //example value for SYSCLK6 (from 6614 spec) Defualt /6 - Slow Peripherals (UART, SPI, I2C, GPIO...)

	unsigned int debug_info_on;
	unsigned int delay;

	if(index == 1){            // 122.88 MHz -> 614.4 MHz
		CLKIN_val   = 122.88;       // setup CLKIN to 122.88 MHz
		PLLM_val    = 10;           // setup PLLM (PLL multiplier) to x10
		PLLD_val    = 1;            // setup PLLD (reference divider) to /1
		OD_val      = 2;            // setup OD to a fixed /2
	}
	else if(index == 2){            // 122.88MHz -> 737.28 MHz
		CLKIN_val   = 122.88;       // setup CLKIN to 122.88 MHz
		PLLM_val    = 12;           // setup PLLM (PLL multiplier) to x12
		PLLD_val    = 1;            // setup PLLD (reference divider) to /1
		OD_val      = 2;            // setup OD to a fixed /2
	}

	else if(index == 3){            // 122.88MHz -> 983.04 MHz
		CLKIN_val   = 122.88;       // setup CLKIN to 122.88 MHz
		PLLM_val    = 16;           // setup PLLM (PLL multiplier) to x12
		PLLD_val    = 1;            // setup PLLD (reference divider) to /1
		OD_val      = 2;            // setup OD to a fixed /2
	}

	else if(index == 4){            // 122.88 MHz -> 1.2 GHz
		CLKIN_val   = 122.88;          // setup CLKIN to 122.88 MHz
		PLLM_val    = 20;           // setup PLLM (PLL multiplier) to x20
		PLLD_val    = 1;            // setup PLLD (reference divider) to /1
		OD_val      = 2;            // setup OD to a fixed /2
	}
	else if(index == 5){            // 122.88 MHz -> 1.35 GHz
		CLKIN_val   = 122.88;          // setup CLKIN to 122.88 MHz
		PLLM_val    = 22;           // setup PLLM (PLL multiplier) to x22
		PLLD_val    = 1;            // setup PLLD (reference divider) to /1
		OD_val      = 2;            // setup OD to a fixed /2
	}




	PLLDIV3_val = 3;            // setup PLL output divider 3 to /3
	PLLDIV4_val = 5;            // setup PLL output divider 4 to /3
	PLLDIV7_val = 6;            // setup PLL output divider 7 to /6

	BYPASS_val      = PLL1_SECCTL & ~BYPASS_MASK;   // get value of the BYPASS field
	BWADJ_val       = (PLLM_val) >> 1;              // setup BWADJ to be 1/2 the value of PLLM


	debug_info_on   = 1;
	delay           = 1000; // fix this!

	/* Step 1: Unlock Boot Config Registers */
	KICK0 = KICK0_UNLOCK;
	KICK1 = KICK1_UNLOCK;

	/* Step 2: Check if SECCTL bypass is low or high indicating what state the Main PLL is currently in. if 
       the Main PLL is in bypass still (not yet setup) execute the following steps.  */

	if(BYPASS_val != 0x00000000){ // PLL bypass enabled - Execute PLL setup for PLL fresh out of power on reset
		if(debug_info_on){
			GEL_TextOut("Detected PLL bypass enabled: SECCTL[BYPASS] = %x\n",,,,, BYPASS_val);
		}
		/* Step 2a: Set MAINPLLCTL1[ENSAT] = 1 - This enables proper biasing of PLL analog circuitry */            
		MAINPLLCTL1 |= (1 << MAIN_ENSAT_OFFSET); 
		if(debug_info_on){
			GEL_TextOut("(2a) MAINPLLCTL1 = %x\n",,,,, MAINPLLCTL1);
		}        

		/* Step 2b: Set PLLCTL[PLLEN] = 0 This enables bypass in PLL controller MUX */        
		PLL1_PLLCTL &= ~(1 << PLLEN_OFFSET);        
		if(debug_info_on){    
			GEL_TextOut("(2b) PLLCTL = %x\n",,,,, PLL1_PLLCTL);
		}    

		/* Step 2c: Set PLLCTL[PLLENSRC] = 0 - This enables PLLEN to control PLL controller MUX */    
		PLL1_PLLCTL &= ~(1 << PLLENSRC_OFFSET);
		if(debug_info_on){    
			GEL_TextOut("(2c) PLLCTL = %x\n",,,,, PLL1_PLLCTL);
		}    

		/* Step 2d: Wait 4 reference clock cycles (slowest of ALTCORE or SYSCLK) to make sure 
           that the PLL controller MUX switches properly to bypass. */
		if(debug_info_on){    
			GEL_TextOut("(2d) Delay...\n",,,,,);
		}        
		for(i = 0; i < delay; i++); // this delay is much more than required         

		/* Step 2e: Set SECCTL[BYPASS] = 1 - enables bypass in PLL MUX */    
		PLL1_SECCTL |= (1 << BYPASS_OFFSET);        
		if(debug_info_on){    
			GEL_TextOut("(2e) SECCTL = %x\n",,,,, PLL1_SECCTL);
		}    

		/* Step 2f: Set PLLCTL[PLLPWRDN] = 1 - power down the PLL */        
		PLL1_PLLCTL |= (1 << PLLPWRDN_OFFSET);
		if(debug_info_on){    
			GEL_TextOut("(2f) PLLCTL = %x\n",,,,, PLL1_PLLCTL);
		}    

		/* Step 2g: Wait for at least 5us for the PLL to power down */
		if(debug_info_on){    
			GEL_TextOut("(2g) Delay...\n",,,,,);
		}    
		for(i = 0; i < delay; i++); // this delay is much more than required 

		/* Step 2h: Set PLLCTL[PLLPWRDN] = 0 - Power the PLL back up */    
		PLL1_PLLCTL &= ~(1 << PLLPWRDN_OFFSET);
		if(debug_info_on){    
			GEL_TextOut("(2h) PLLCTL = %x\n",,,,, PLL1_PLLCTL);
		}            

	}
	else{ // PLL bypass disabled - Execute PLL setup for PLL that has previously been locked (skip to Step 3)
		if(debug_info_on){    
			GEL_TextOut("Detected PLL bypass disabled: SECCTL[BYPASS] = %x\n",,,,, BYPASS_val);
		}

		/* Step 3a: Set PLLCTL[PLLEN] = 0 This enables bypass in PLL controller MUX */        
		PLL1_PLLCTL &= ~(1 << PLLEN_OFFSET);        
		if(debug_info_on){    
			GEL_TextOut("(3a) PLLCTL = %x\n",,,,, PLL1_PLLCTL);
		}    

		/* Step 3b: Set PLLCTL[PLLENSRC] = 0 - This enables PLLEN to control PLL controller MUX */    
		PLL1_PLLCTL &= ~(1 << PLLENSRC_OFFSET);
		if(debug_info_on){    
			GEL_TextOut("(3b) PLLCTL = %x\n",,,,, PLL1_PLLCTL);
		}

		/* Step 3c: Wait 4 reference clock cycles (slowest of ALTCORE or SYSCLK) to make sure 
           that the PLL controller MUX switches properly to bypass. */
		if(debug_info_on){    
			GEL_TextOut("(3c) Delay...\n",,,,,);
		}        
		for(i = 0; i < delay; i++); // this delay is much more than required       

	}


	/* Step 4: Programming PLLM[5:0] in the PLLM register of the PLL controller and
       programming PLLM[12:6] in the MAINPLLCTL0 register */        
	PLL1_PLLM &= PLLM_MASK;             // clear the PLLM[5:0] bit field
	PLL1_PLLM |= ~PLLM_MASK & (PLLM_val - 1);   // set the PLLM[5:0] bit field to the 6 LSB of PLLM_val

	if(debug_info_on){
		GEL_TextOut("(4)PLLM[PLLM] = %x\n",,,,, PLL1_PLLM);
	}    

	MAINPLLCTL0 &= MAIN_PLLM_MASK;      // clear the PLLM[12:6] bit field
	MAINPLLCTL0 |= ~MAIN_PLLM_MASK & (( (PLLM_val - 1) >> 6) << MAIN_PLLM_OFFSET);  // set the PLLM[12:6] bit field to the 7 MSB of PLL_val

	if(debug_info_on){
		GEL_TextOut("MAINPLLCTL0 = %x\n",,,,, MAINPLLCTL0);
	}

	/* Step 5: Programming BWADJ[7:0] in the MAINPLLCTL0 register and BWADJ[11:8] in MAINPLLCTL1 register */            
	MAINPLLCTL0 &= MAIN_BWADJ0_MASK;    // clear the MAIN_BWADJ0 bit field
	MAINPLLCTL0 |= ~MAIN_BWADJ0_MASK & ((BWADJ_val - 1) << MAIN_BWADJ0_OFFSET); // set the MAIN_BWADJ[7:0] bit field to the 8 LSB of BWADJ_val

	if(debug_info_on){
		GEL_TextOut("(5) MAINPLLCTL0 = %x\n",,,,, MAINPLLCTL0);
	}

	MAINPLLCTL1 &= MAIN_BWADJ1_MASK;    // clear the MAIN_BWADJ1 bit field
	MAINPLLCTL1 |= ~MAIN_BWADJ1_MASK & (( (BWADJ_val - 1) >> 8) << MAIN_BWADJ1_OFFSET); // set the MAIN_BWADJ[11:8] bit field to the 4 MSB of BWADJ_val

	if(debug_info_on){
		GEL_TextOut("(5) MAINPLLCTL1 = %x\n",,,,, MAINPLLCTL1);
	}

	/* Step 6: Programming PLLD[5:0] in the MAINPLLCTL0 register */            
	MAINPLLCTL0 &= MAIN_PLLD_MASK;      // clear the PLLD bit field
	MAINPLLCTL0 |= ~MAIN_PLLD_MASK & (PLLD_val - 1);    // set the PLLD[5:0] bit field of PLLD to PLLD_val

	if(debug_info_on){
		GEL_TextOut("(6) MAINPLLCTL0 = %x\n",,,,, MAINPLLCTL0);
	}

	/* Step 7: Programming OD[3:0] in the SECCTL register */            
	PLL1_SECCTL &= OUTPUT_DIVIDE_MASK;  // clear the OD bit field
	PLL1_SECCTL |= ~OUTPUT_DIVIDE_MASK & (OD_val - 1) << OUTPUT_DIVIDE_OFFSET;  // set the OD[3:0] bit field of PLLD to OD_val    

	if(debug_info_on){
		GEL_TextOut("(7) SECCTL = %x\n",,,,, PLL1_SECCTL);
	}

	/* Step 8: Following steps are needed to change the default output dividers */            

	/* Step 8a: Check that the GOSTAT bit in PLLSTAT is cleared to show that no GO
       operation is currently in progress*/
	if(debug_info_on){    
		GEL_TextOut("(8a) Delay...\n",,,,,);
	}    
	while((PLL1_STAT) & 0x00000001);

	/* Step 8b: Program the RATIO field in PLLDIVn to the desired new divide-down rate.
       If RATIO field is changed, the PLL controller will flag the change in the
       corresponding bit of DCHANGE*/
	PLL1_DIV3 = (PLLDIV3_val-1) | 0x8000;  //Set PLLDIV3
	PLL1_DIV4 = (PLLDIV4_val-1) | 0x8000;  //Set PLLDIV4
	PLL1_DIV7 = (PLLDIV7_val-1) | 0x8000;  //Set PLLDIV7

	if(debug_info_on){
		GEL_TextOut("PLL1_DIV3 = %x\n",,,,, PLL1_DIV3);
		GEL_TextOut("PLL1_DIV4 = %x\n",,,,, PLL1_DIV4);
		GEL_TextOut("PLL1_DIV7 = %x\n",,,,, PLL1_DIV7);
	}

	/* Step 8c: Set GOSET bit in PLLCMD to initiate the GO operation to change the divide
       values and align the SYSCLKs as programmed */
	PLL1_CMD |= 0x00000001;

	/*Step 8d/e: Read the GOSTAT bit in PLLSTAT to make sure the bit returns to 0 to
      indicate that the GO operation has completed */
	if(debug_info_on){    
		GEL_TextOut("(8d/e) Delay...\n",,,,,);
	}    
	while((PLL1_STAT) & 0x00000001);

	/* Step 9: Set PLLCTL[PLLRST] = 1 - Assert PLL reset (Previously Step 3)*/        
	PLL1_PLLCTL |= (1 << PLLRST_OFFSET);

	/* Step 10: Wait for the at least 7us for the PLL reset properly (128 CLKIN1 cycles) */        
	if(debug_info_on){    
		GEL_TextOut("(10) Delay...\n",,,,,);
	}    
	for(i=0;i<delay;i++);

	/* Step 11: Set PLLCTL[PLLRST] = 0 - De-Assert PLL reset */        
	PLL1_PLLCTL &= ~(1 << PLLRST_OFFSET);

	/* Step 12: Wait for PLL to lock (2000 CLKIN1 cycles) */
	if(debug_info_on){    
		GEL_TextOut("(12) Delay...\n",,,,,);
	}    
	for(i=0;i<delay;i++);

	/* Step 13: In SECCTL, write BYPASS = 0 (enable PLL mux to switch to PLL mode) */
	PLL1_SECCTL &= ~(1 << BYPASS_OFFSET);        
	if(debug_info_on){    
		GEL_TextOut("(13) SECCTL = %x\n",,,,, PLL1_SECCTL);
	}    
	if(debug_info_on){    
		GEL_TextOut("(Delay...\n",,,,,);
	}    
	for(i=0;i<delay;i++);
	if(debug_info_on){    
		GEL_TextOut("(Delay...\n",,,,,);
	}    
	for(i=0;i<delay;i++);

	/* Step 14: In PLLCTL, write PLLEN = 1 to enable PLL mode */
	PLL1_PLLCTL |= (1 << PLLEN_OFFSET);        
	if(debug_info_on){    
		GEL_TextOut("(14) PLLCTL = %x\n",,,,, PLL1_PLLCTL);
	}    

	/* Step 15: Lock Boot Config Registers */
	KICK0 = 0x00000000;
	KICK1 = 0x00000000;

	GEL_TextOut("PLL has been configured (CLKIN * PLLM / PLLD / PLLOD = PLLOUT):\n",,,,,);
	GEL_TextOut("PLL has been configured (%f MHz * %d / %d / 2 = %f MHz)\n",,,,, CLKIN_val, PLLM_val, PLLD_val, (CLKIN_val * PLLM_val / PLLD_val / 2));
}

Set_Tetris_Pll(int index)
{

	unsigned int BWADJ_val;     
	unsigned int OD_val;            
	unsigned int PLLM_val;
	float CLKIN_val;
	int i;

	GEL_TextOut("Switching on ARM Core 0\n",,,,,);
	TETRIS_CPU0_PDCTL   = 0x00000000;
	TETRIS_CPU0_PTCMD   = 0x00000001;    

	GEL_TextOut("Switching on ARM Core 1\n",,,,,);
	TETRIS_CPU1_PDCTL   = 0x00000000;
	TETRIS_CPU1_PTCMD   = 0x00000001;    



	if(index == 1){              // 122.88 MHz -> 983 GHz
		CLKIN_val   = 122.88;          // setup CLKIN to 122.88 MHz
		PLLM_val    = 16;           // setup PLLM (PLL multiplier) to x20
		OD_val      = 2;            // setup OD to a fixed /2
	}
	else if(index == 2){            // 100 MHz -> 1.4 GHz
		CLKIN_val   = 125;          // setup CLKIN to 125 MHz
		PLLM_val    = 22;           // setup PLLM (PLL multiplier) to x28
		OD_val      = 2;            // setup OD to a fixed /2
	}
	else if(index == 3){            // 174.825MHz -> 1.4 GHz

		CLKIN_val   = 174.825;      // setup CLKIN to 174.825 MHz
		PLLM_val    = 16;           // setup PLLM (PLL multiplier) to x16
		OD_val      = 2;            // setup OD to a fixed /2
	}

	BWADJ_val       = (PLLM_val-1) >> 1;            // setup BWADJ to be 1/2 the value of PLLM

	/* Step 1: Unlock Boot Config Registers */
	KICK0 = KICK0_UNLOCK;
	KICK1 = KICK1_UNLOCK;

	//Step 1 : Assert SEC PLL Reset
	SECPLLCTL1 = ((1 << SEC_PLLCTL1_RESET_OFFSET) | (1 << SEC_PLLCTL1_ENSTAT_OFFSET));

	//Step 2 : Change CLKF/OD/BWADJ etc. for SEC PLL
	SECPLLCTL0 = ((BWADJ_val << SEC_PLLCTL0_BWADJ_OFFSET) |
			((OD_val-1) << SEC_PLLCTL0_OD_OFFSET)|
			((PLLM_val-1) << SEC_PLLCTL0_PLLM_OFFSET));

	//Step 3 : Make sure the resets are held for 5us
	for(i = 0; i < 200000; i++);

	//Step 4 : Remove SEC PLL reset
	SECPLLCTL1 = (1 << SEC_PLLCTL1_ENSTAT_OFFSET);

	//Step 5 : Wait for PLL to lock (4000 CLKIN1 cycles)
	for(i = 0; i < 4000; i++);

	//Step 6 : Get the PLL out of Bypass
	//SECPLLCTL0 &= ~(1 << SEC_PLLCTL0_BYPASS_OFFSET);
	CHIP_MISC1 |= (1 << ARMPLL_ENABLE_OFFSET); 


	//Step 6 : Lock Boot Config Registers
	KICK0 = 0x00000000;
	KICK1 = 0x00000000;

	GEL_TextOut("ARM PLL has been configured (%f MHz * %d / %d = %f MHz)\n",,,,, CLKIN_val, PLLM_val, OD_val, (CLKIN_val * PLLM_val)/OD_val);

}
/* Set the desired PA PLL configuration */
PaPllConfig()
{
	unsigned int passclksel = (DEVSTAT & PASSCLKSEL_MASK);
	unsigned int papllctl0val_orig = PAPLLCTL0;
	unsigned int papllctl1val_orig = PAPLLCTL1;
	unsigned int papllctl0val_final;
	unsigned int papllctl1val_final;
	unsigned int papllclkf = 204; //31; // 204; 20 (if PASSREFCLK == 100mhz) Multiply by clkf + 1
	unsigned int papllclkd = 11;  //11;   1 (if PASSREFCLK == 100mhz) Divide by clkd + 1
	unsigned int i = 0;

	if (passclksel != PASSCLKSEL_MASK) GEL_TextOut("WARNING: SYSCLK is the input to the PA PLL.\n");

	/* Unlock Chip Level Registers */
	KICK0 = KICK0_UNLOCK;
	KICK1 = KICK1_UNLOCK;

	// PAPLLCTL1 = PAPLLCTL1 | 0x00000040; //Set ENSAT = 1; Set PLL Select to 0 (for SYCLK0 as input of PASS)
	PAPLLCTL1 = PAPLLCTL1 | 0x00002040; //Set ENSAT = 1; Set PLL Select to 1 (for PA PLL as input of PASS)  

	/*in PAPLLCTL0, clear bypass bit to set the PA PLL in Bypass Mode*/
	//PAPLLCTL0 &= ~(1<<BYPASS_BIT_SHIFT); // Not setting Bypass bit
	PAPLLCTL0 |=  (1<<BYPASS_BIT_SHIFT); // Actually setting bypass bit

	/*Wait 4 cycles for the slowest of PLLOUT or reference clock source (CLKIN)*/
	for(i=0;i<100;i++);

	/*In PAPLLCTL1, write PLL reset bit to put the PLL in reset*/
	PAPLLCTL1 |= PA_PLL_RESET_MASK;

	/* Program the multiplier value */
	PAPLLCTL0 &= (~PA_PLL_CLKF_MASK);          //clear multiplier value
	PAPLLCTL0 &= (~PA_PLL_CLKR_MASK);          //clear divider value
	PAPLLCTL0 |= (papllclkf<<CLKF_BIT_SHIFT);  // set PLLM
	PAPLLCTL0 |= (papllclkd<<CLKD_BIT_SHIFT);  // set PLLD


	PAPLLCTL0 &= 0x00FFFFFF;
	PAPLLCTL0 |= ((((papllclkf + 1)>>1)-1)<<24);

	PAPLLCTL1 &= ~(0x0000000F);
	PAPLLCTL1 |= (((((papllclkf + 1)>>1)-1) >> 8) & 0x0000000F);

	//PAPLLCTL1 = PAPLLCTL1 | 0x00002000;

	/*Wait for PLL to properly reset (128 CLKIN1 cycles) */
	for(i=0;i<1000;i++);

	/* take the PA PLL out of reset */
	PAPLLCTL1 &= (~PA_PLL_RESET_MASK);

	/*Wait for PLL to lock (2000 CLKIN1 cycles) */
	for(i=0;i<5000;i++);

	/* enable PLL mode */
	PAPLLCTL0 &= ~(1<<BYPASS_BIT_SHIFT); // actually setting PLL MODE

	for(i=0;i<4000;i++);

	/* Lock Chip Level Registers */
	KICK0 = KICK_LOCK;
	KICK1 = KICK_LOCK;

	papllctl0val_final = PAPLLCTL0;
	papllctl1val_final = PAPLLCTL1;

	GEL_TextOut("Completed PA PLL Setup\n");
	GEL_TextOut("PAPLLCTL0 - before: 0x%x\t after: 0x%x\n",,,,, papllctl0val_orig, papllctl0val_final);
	GEL_TextOut("PAPLLCTL1 - before: 0x%x\t after: 0x%x\n",,,,, papllctl1val_orig, papllctl1val_final);

	if ((papllctl0val_final != 0x09080500) || (papllctl1val_final != 0x00002040))
	{
		return 1;
	}

	return 0;

}

#define DFE_PLL_MULT_MASK     0x003F
#define DFE_PLL_MULT_SHIFT    6
#define DFE_PLL_ODIV_MASK     0xF
#define DFE_PLL_ODIV_SHIFT    19    
#define DFE_PLL_DIVMODE_MASK     0x3
#define DFE_PLL_DIVMODE_SHIFT    0  
#define DFE_PLL_BWADJ_SHIFT   24     
#define DFE_PLL_BWADJ_MASK    0x00FFFFFF    
#define DFE_PLL_BYPASS_SET 0x00800000
#define DFE_PLL_RESET_SET  0x00004000
#define DFE_PLL_PLLSEL_SET 0x00002000
#define DFE_PLL_PLLSEL_RESET 0xFFFFDFFF


dfepll_setup(unsigned int base, unsigned int clkr, 
		unsigned int clkf, unsigned int clkod,
		unsigned int divmode)
{
	unsigned int *dfepllctl0 = DFEPLLCTL0;
	unsigned int *dfepllctl1 = DFEPLLCTL1;
	unsigned int *dfe_clkdiv_ctl = DFE_CLKDIV_CTL;
	unsigned int *dfe_clksync_ctl = DFE_CLKSYNC_CTL;
	unsigned int i = 0;

	// check disallowed here. 
	if (clkod && ((clkod & 0x1) != 0x1)) return(0);
	// Check some unimplemented (yet) features.
	if (clkr) return(0);
	if (clkf > 63) return(0);

	/* Unlock Boot Config Registers */
	KICK0 = KICK0_UNLOCK;
	KICK1 = KICK1_UNLOCK;

	// Reset DFEPLLCTL0, DFEPLLCTL1, DFE_CLKDIV_CTL, DFE_CLKSYNC_CTL
	*dfepllctl0 = 0x098803C0;
	*dfepllctl1 = 0x00000040;
	*dfe_clkdiv_ctl = 0x00000000;
	*dfe_clksync_ctl = 0x00000000;

	// Step 1: Put PLL in bypass.
	*dfepllctl0 |= DFE_PLL_BYPASS_SET;

	// Step 2: Put PLL in reset.
	*dfepllctl1 |= DFE_PLL_RESET_SET;

	// Step 3: Program PLL clkf (CLKF)
	*dfepllctl0 &= ~(DFE_PLL_MULT_MASK << DFE_PLL_MULT_SHIFT);
	*dfepllctl0 |= ((clkf & DFE_PLL_MULT_MASK) << DFE_PLL_MULT_SHIFT);

	// Step 4: Set bwadj factor.
	*dfepllctl0 &= DFE_PLL_BWADJ_MASK;
	*dfepllctl0 |= (clkf/2) << DFE_PLL_BWADJ_SHIFT;

	// Step 5: set PLL post div (CLKOD)
	*dfepllctl0 &= ~(DFE_PLL_ODIV_MASK << DFE_PLL_ODIV_SHIFT);
	*dfepllctl0 |= ((clkod & DFE_PLL_ODIV_MASK) << DFE_PLL_ODIV_SHIFT);

	// Step 6: Wait for 5us based on refclk
	for(i=0;i<30000;i++);

	// Step 7: Set Divmode in DFE_CLKDIV_CTL
	*dfe_clkdiv_ctl &= ~(DFE_PLL_DIVMODE_MASK << DFE_PLL_DIVMODE_SHIFT);
	*dfe_clkdiv_ctl |= ((divmode & DFE_PLL_DIVMODE_MASK) << DFE_PLL_DIVMODE_SHIFT);

	// Step 8: Release PLL reset. But make sure reset is at least 5us.
	for(i=0;i<30000;i++);
	*dfepllctl1 &= ~DFE_PLL_RESET_SET;

	// Step 9: wait for PLL to lock. --// NEED TO UPDATE Wait for at least 500 * REFCLK cycles * (PLLD + 1) (PLL lock time)
	//waitfor(((*stat & DFE_PLL_LOCK_SET) == DFE_PLL_LOCK_SET), 1000);
	//if ((*stat & DFE_PLL_LOCK_SET) != DFE_PLL_LOCK_SET) return(FAIL);
	for(i=0;i<30000;i++);

	// Step 10: Disable PLL bypass
	*dfepllctl0 &= ~DFE_PLL_BYPASS_SET;

	for(i=0;i<10;i++);

	// Step 11: Program sync_en (DFECLKSYNC)
	*dfe_clksync_ctl = 0x00000001;

	for(i=0;i<100;i++);

	// Step 12: Set PLLSEL = 1

	*dfepllctl1 |= DFE_PLL_PLLSEL_SET;

	/* Lock Boot Config Registers */
	KICK0 = KICK_LOCK;
	KICK1 = KICK_LOCK;

	return(1);
}

//*************************************************************************************************
//*************************************************************************************************
//*************************************************************************************************
//*************************************************************************************************
//*************************************************************************************************
//*************************************************************************************************

//--------DDR3A Memory test----------------------

ddr3A_memory_test ()
{
	unsigned int index, value;

	GEL_TextOut( "DDR3A memory test... Started\n" );

	/* Write a pattern */
	for (index = DDR3A_TEST_START_ADDRESS; index < DDR3A_TEST_END_ADDRESS; index += 4) {
		*index = index;
	}

	/* Read and check the pattern */
	for (index = DDR3A_TEST_START_ADDRESS; index < DDR3A_TEST_END_ADDRESS; index += 4) {

		value = *index;

		if (value  != index) {
			GEL_TextOut( "DDR3A memory test... Failed\n" );
			return -1;
		}
	}

	/* Write a pattern for complementary values */
	for (index = DDR3A_TEST_START_ADDRESS; index < DDR3A_TEST_END_ADDRESS; index += 4) {
		*index = ~index;
	}

	/* Read and check the pattern */
	for (index = DDR3A_TEST_START_ADDRESS; index < DDR3A_TEST_END_ADDRESS; index += 4) {

		value = *index;

		if (value  != ~index) {
			GEL_TextOut( "DDR3A memory test... Failed\n" );
			return -1;
		}
	}

	GEL_TextOut( "DDR3A memory test... Passed\n" );
	return 0;

}

//---------------------------------------------------	


/****************************************************************************
 *
 * NAME
 *      Setup_Memory_Map
 *
 * PURPOSE:
 *      Setup the Memory Map for EVMC6678L.
 *      Defined memory location avoid debugger access outside these locations.
 *
 * USAGE
 *      This routine can be called as:
 *
 *      Setup_Memory_Map()
 *
 * RETURN VALUE
 *      NONE
 *
 * REFERENCE
 *      Based on TMS320C6678 datasheet.
 *
 ****************************************************************************/
hotmenu Setup_Memory_Map( )
{
	GEL_TextOut("Setup_Memory_Map...\n",,);

	GEL_MapOn( );
	GEL_MapReset( );

	GEL_MapAddStr( 0x00000000, 0, 0x21400000, "R|W|AS4", 0 );   // 
	GEL_MapAddStr( 0x21400000,0, 0x00000080, "R|W|AS4", 0 );   // Hyperlink Config (remote)	
	//GEL_MapAddStr( 0x21400080,0, 0x00000080, "R|W|AS4", 0 );   // Hyperlink Config (remote)
	GEL_MapAddStr( 0x21400200, 0, 0xdebffe00, "R|W|AS4", 0 );   // 
	GEL_TextOut( "Setup_Memory_Map... Done.\n" );
}
/*----------------------------------------------------- DDR3A : DDR1066, 64bit--------------------------------------------------------------------------*/
ddr3A_64bit_DDR1066_setup(int ECC_Enable)
{

	unsigned int multiplier = 15;
	unsigned int divider = 0;
	unsigned int OD_val = 6;

	int temp,i;
	int delay = 2000;

	KICK0 = 0x83E70B13;
	KICK1 = 0x95A4F1E0;


	// Poll for IDONE=1 in the PHY General Status Register 0 (address offset 0x010).
	do { 
		read_val = DDR3A_PGSR0;
	} while ((read_val&0x00000001) != 0x00000001);

	//	Clocks are enabled and frequency is stable---------------------------------------
	// DDR3A PLL setup	
	GEL_TextOut ( "DDR3 PLL Setup ... \n");
	// DDR3APLLCTL0 = DDR3APLLCTL0 & 0xFF7FFFFF;
	// Set ENSAT = 1
	DDR3APLLCTL1 |= 0x00000040;
	// Put the PLL in PLL Mode  
	DDR3APLLCTL0 |= 0x00800000;

	// Program the necessary multipliers/dividers and BW adjustments            
	// Set the divider values 
	DDR3APLLCTL0 &= ~(0x0000003F);
	DDR3APLLCTL0 |= (divider & 0x0000003F);

	// Program OD[3:0] in the SECCTL register            
	DDR3APLLCTL0 &= OUTPUT_DIVIDE_MASK;  // clear the OD bit field
	DDR3APLLCTL0 |= ~OUTPUT_DIVIDE_MASK & (OD_val - 1) << OUTPUT_DIVIDE_OFFSET;  // set the OD[3:0] bit field of PLLD to OD_val    
	// Set the Multipler values 
	DDR3APLLCTL0 &= ~(0x0007FFC0);
	DDR3APLLCTL0 |= ((multiplier << 6) & 0x0007FFC0 );
	temp = ((multiplier + 1) >> 1) - 1;
	DDR3APLLCTL0 &= ~(0xFF000000); 
	DDR3APLLCTL0 |= ((temp << 24) & 0xFF000000);
	DDR3APLLCTL1 &= ~(0x0000000F);
	DDR3APLLCTL1 |= ((temp >> 8) & 0x0000000F);

	// In PLL Controller, reset the PLL (bit 13 in DDR3APLLCTL1 register) 
	DDR3APLLCTL1 |= 0x00004000;
	for(i=0;i<delay;i++);
	// In DDR3PLLCTL1, write PLLRST = 0 to bring PLL out of reset 
	DDR3APLLCTL1 &= ~(0x00004000);
	for(i=0;i<delay;i++);

	// Put the PLL in PLL Mode  
	DDR3APLLCTL0 &= ~(0x00800000); // ReSet the Bit 23
	GEL_TextOut( "DDR3 PLL Setup complete, DDR3A clock now running at 533MHz.\n" );
	//DDR3A PLL setup complete ---------------------------------------


	/*------------------------------- ECO FIX -----------------------------------------*/
	/*
		// DDR3 write leveling ECO - Assert & release DDR PHY RESET after DDR PLL setup...
		DDR3APLLCTL1 = DDR3APLLCTL1 | 0x80000000;	//Assert DDR PHY reset after PLL enabled
		//for(i=0;i<delay;i++);						//delay 1000 cycles
		DDR3APLLCTL1 = DDR3APLLCTL1 & 0x7FFFFFFF;	//Release DDR PHY reset

		do {   // Poll IDONE after resetting PHY 
			read_val = DDR3A_PGSR0;	
		   } while ((read_val&0x00000001) != 0x00000001);
	 */
	/*------------------------- Start PHY Configuration -------------------------------*/

	//DDR3A_PGCR1 = 0x0280C487;

	// Program FRQSEL in the PLL Control Register (address offset 0x018).
	DDR3A_PLLCR = 0xDC000; //Set FRQSEL=11, for ctl_clk between 166-275MHz

	// Program WLSTEP=1, IODDRM=1, and ZCKSEL in the PHY General Configuration Register 1 (address offset 0x00C).

	DDR3A_PGCR1 |= (1 << 2); //WLSTEP = 1
	DDR3A_PGCR1 &= ~(IODDRM_MASK);
	DDR3A_PGCR1 |= (( 1 << 7) & IODDRM_MASK);
	DDR3A_PGCR1 &= ~(ZCKSEL_MASK);
	DDR3A_PGCR1 |= (( 1 << 23) & ZCKSEL_MASK);

	// Program PHY Timing Parameters Register 0-4 (address offset 0x01C - 0x02C).

	DDR3A_PTR0 = 0x42C21590;
	DDR3A_PTR1 = 0xD05612C0;	

	// Maintain default values of Phy Timing Parameters Register 2 in PUB

	DDR3A_PTR3 = 0x09041104;//0x18061A80; 
	DDR3A_PTR4 = 0x0855A068;//0x0AAE7100;

	// Program PDQ, MPRDQ, and BYTEMASK in the DRAM Configuration Register (address offset 0x044). 
	// All other fields must be left at their default values.

	DDR3A_DCR &= ~(PDQ_MASK); //PDQ = 0
	DDR3A_DCR &= ~(MPRDQ_MASK); //MPRDQ = 0
	DDR3A_DCR &= ~(BYTEMASK_MASK);
	DDR3A_DCR |= (( 1 << 10) & BYTEMASK_MASK);

	// Program DRAM Timing Parameters Register 0-2 (address offset 0x048 - 0x050). 

	DDR3A_DTPR0 = 0x6D147744;
	DDR3A_DTPR1 = 0x32845A80;	//Increase tWLO to 12
	DDR3A_DTPR2 = 0x50023600;

	// Program BL=0, CL, WR, and PD=1 in the Mode Register 0 (address offset 0x054). 
	// All other fields must be left at their default values.

	DDR3A_MR0 = 0x00001840;


	// Program DIC, RTT, and TDQS in the Mode Register 1 (address offset 0x058). 
	// All other fields must be left at their default values.

	DDR3A_MR1 = 0x00000006;

	// Program Mode Register 2 (address offset 0x05C).

	DDR3A_MR2 = 0x00000008;

	// Program DTMPR=1, DTEXD, DTEXG, RANKEN=1 or 3, and RFSHDT=7 in the Data Training Configuration Register (address offset 0x068). 
	// All other fields must be left at their default values.
	DDR3A_DTCR = 0x710035C7; //Single-rank	

	// Program tREFPRD=(5*tREFI/ddr_clk_period) in the PHY General Configuration Register 2 (address offset 0x08C). 
	//All other fields must be left at their default values.

	DDR3A_PGCR2 = 0x00F05159; //NOBUB = 0, FXDLAT = 0 	
	//DDR3A_PGCR2 = 0x00F83D09; //NOBUB = 0, FXDLAT = 1 

	//Set Impedence Register and DFIPU0=1 
	DDR3A_ZQ0CR1 = 0x0001005D; 
	DDR3A_ZQ1CR1 = 0x0001005B;
	DDR3A_ZQ2CR1 = 0x0001005B;


	// Re-trigger PHY initialization in DDR PHY through the VBUSP interface.
	// Program 0x00000033 to the PHY Initialization Register (address offset 0x004) to re-trigger PLL, ZCAL, and DCAL initialization.

	DDR3A_PIR = 0x00000033;

	// Poll for IDONE=1 in the PHY General Status Register 0 (address offset 0x010).
	do { 
		read_val = DDR3A_PGSR0;
	} while ((read_val&0x00000001) != 0x00000001);

	//---------------------------------------------------------------------------------------------------------					

	if(!ECC_Enable)
	{
		DDR3A_DATX8_8 = read_val & 0xFFFFFFFE; //Disable ECC byte lane
	}
	// Trigger DDR3 initialization and leveling/training in DDR PHY through the VBUSP interface.
	// If using a 16-bit wide DDR interface, program DXEN=0 in the DATX8 2-7 General Configuration Registers (address offsets 0x240, 0x280, 0x2C0, 0x300, 0x340, and 0x380) to disable the leveling/training for the upper byte lanes.
	// If using a 32-bit wide DDR interface, program DXEN=0 in the DATX8 4-7 General Configuration Registers (address offsets 0x2C0, 0x300, 0x340, and 0x380) to disable the leveling/training for the upper byte lanes.
	// If ECC is not required, program DXEN=0 in the DATX8 8 General Configuration Register (address offset 0x3C0) to disable the leveling/training for the ECC byte lane.
	// NOTE: Setup supports 64-bit by default,  ECC enable by default.

	// Program 0x0000XF81 to the PHY Initialization Register (address offset 0x004) to trigger DDR3 initialization and leveling/training sequences 

	DDR3A_PIR = 0x0000FF81; //WLADJ - ON
	//DDR3A_PIR = 0x00000781;  //WLADJ - OFF

	//---------------------------------------------------------------------------------------------------------					

	// Poll for IDONE=1 in the PHY General Status Register 0 (address offset 0x010).
	do {              
		read_val = DDR3A_PGSR0;
	} while ((read_val&0x00000001) != 0x00000001);

	/* End PHY Configuration */
	if(ECC_Enable)
	{
		//Enable ECC
		//0xB0000000: ECC_EN=1, ECC_VERIFY_EN=1, RMW_EN=1
		//0x50000000: ECC_EN=1, ECC_VERIFY_EN=0, RMW_EN=1
		DDR3A_ECC_CTRL = 0xB0000000;
		read_val = DDR3A_ECC_CTRL;
		if(read_val!=0xB0000000){
			GEL_TextOut("\nIncorrect data written to DDR3A_ECC_CTRL..");
		}
	}
	//---------------------------------------------------------------------------------------------------------					

	DDR3A_SDCFG    = 0x62004862;	//Single-Rank

	DDR3A_SDTIM1   = 0x0E4C6843;
	DDR3A_SDTIM2   = 0x00001CC6;
	DDR3A_SDTIM3   = 0x323DFF32;
	DDR3A_SDTIM4   = 0x533F08AF;

	DDR3A_ZQCFG    = 0x70073200;	//Single-rank

	// Program reg_initref_dis=0 in the SDRAM Refresh Control Register (address offset 0x10).
	DDR3A_SDRFC = 0x00001044;

	GEL_TextOut("DDR3A initialization complete \n");
	/* End  DDR3A EMIF Configuration */

}



/*----------------------------------------------------- DDR3A : DDR1333, 64bit--------------------------------------------------------------------------*/
ddr3A_64bit_DDR1333_setup(int ECC_Enable)	
{
	unsigned int multiplier = 19;
	unsigned int divider = 0;
	unsigned int OD_val = 6;

	int temp,i;
	int delay = 2000;

	KICK0 = 0x83E70B13;
	KICK1 = 0x95A4F1E0;


	// Poll for IDONE=1 in the PHY General Status Register 0 (address offset 0x010).
	do 
	{ 
		read_val = DDR3A_PGSR0;
	} while ((read_val&0x00000001) != 0x00000001);

	//Clocks are enabled and frequency is stable---------------------------------------
	//DDR3A PLL setup	
	GEL_TextOut ( "DDR3 PLL Setup ... \n");
	//DDR3APLLCTL0 = DDR3APLLCTL0 & 0xFF7FFFFF;
	//Set ENSAT = 1

	DDR3APLLCTL1 |= 0x00000040;
	// Put the PLL in PLL Mode  
	DDR3APLLCTL0 |= 0x00800000;

	//Program the necessary multipliers/dividers and BW adjustments            
	//Set the divider values 
	DDR3APLLCTL0 &= ~(0x0000003F);
	DDR3APLLCTL0 |= (divider & 0x0000003F);

	//Program OD[3:0] in the SECCTL register            
	DDR3APLLCTL0 &= OUTPUT_DIVIDE_MASK;  // clear the OD bit field
	DDR3APLLCTL0 |= ~OUTPUT_DIVIDE_MASK & (OD_val - 1) << OUTPUT_DIVIDE_OFFSET;  // set the OD[3:0] bit field of PLLD to OD_val    

	// Set the Multipler values 
	DDR3APLLCTL0 &= ~(0x0007FFC0);
	DDR3APLLCTL0 |= ((multiplier << 6) & 0x0007FFC0 );
	temp = ((multiplier + 1) >> 1) - 1;
	DDR3APLLCTL0 &= ~(0xFF000000); 
	DDR3APLLCTL0 |= ((temp << 24) & 0xFF000000);
	DDR3APLLCTL1 &= ~(0x0000000F);
	DDR3APLLCTL1 |= ((temp >> 8) & 0x0000000F);

	// In PLL Controller, reset the PLL (bit 13 in DDR3APLLCTL1 register) 
	DDR3APLLCTL1 |= 0x00004000;
	for(i=0;i<delay;i++);
	// In DDR3PLLCTL1, write PLLRST = 0 to bring PLL out of reset 
	DDR3APLLCTL1 &= ~(0x00004000);
	for(i=0;i<delay;i++);

	// Put the PLL in PLL Mode  
	DDR3APLLCTL0 &= ~(0x00800000); // ReSet the Bit 23
	GEL_TextOut( "Lammar DDR3 PLL Setup complete, DDR3A clock now running at 666.5MHz.\n" );



	/*------------------------------- ECO FIX -----------------------------------------*/
	/*
		// DDR3 write leveling ECO - Assert & release DDR PHY RESET after DDR PLL setup...
		DDR3APLLCTL1 = DDR3APLLCTL1 | 0x80000000;	//Assert DDR PHY reset after PLL enabled
		//for(i=0;i<delay;i++);						//delay 1000 cycles
		DDR3APLLCTL1 = DDR3APLLCTL1 & 0x7FFFFFFF;	//Release DDR PHY reset

		do 
		{  // Poll IDONE after resetting PHY 
			read_val = DDR3A_PGSR0;	
		} while ((read_val&0x00000001) != 0x00000001);
	 */



	/*------------------------- Start PHY Configuration -------------------------------*/

	//DDR3A_PGCR1 = 0x0280C487;

	// Program FRQSEL in the PLL Control Register (address offset 0x018).
	DDR3A_PLLCR = 0x0005C000; //Set FRQSEL=11, for ctl_clk between 166-275MHz

	// Program WLSTEP=1, IODDRM=1, and ZCKSEL in the PHY General Configuration Register 1 (address offset 0x00C).

	DDR3A_PGCR1 |= (1 << 2); //WLSTEP = 1
	DDR3A_PGCR1 &= ~(IODDRM_MASK);
	DDR3A_PGCR1 |= (( 1 << 7) & IODDRM_MASK);
	DDR3A_PGCR1 &= ~(ZCKSEL_MASK);
	DDR3A_PGCR1 |= (( 1 << 23) & ZCKSEL_MASK);

	// Program PHY Timing Parameters Register 0-4 (address offset 0x01C - 0x02C).

	DDR3A_PTR0 = 0x42C21590;
	DDR3A_PTR1 = 0xD05612C0;


	// Maintain default values of Phy Timing Parameters Register 2 in PUB

	DDR3A_PTR3 = 0x0B4515C2;
	DDR3A_PTR4 = 0x0A6E08B4;


	// Program PDQ, MPRDQ, and BYTEMASK in the DRAM Configuration Register (address offset 0x044). 
	// All other fields must be left at their default values.

	DDR3A_DCR &= ~(PDQ_MASK); //PDQ = 0
	DDR3A_DCR &= ~(MPRDQ_MASK); //MPRDQ = 0
	DDR3A_DCR &= ~(BYTEMASK_MASK);
	DDR3A_DCR |= (( 1 << 10) & BYTEMASK_MASK);

	// Program DRAM Timing Parameters Register 0-2 (address offset 0x048 - 0x050). 

	DDR3A_DTPR0 = 0x85589955;
	DDR3A_DTPR1 = 0x128573C1;
	DDR3A_DTPR2 = 0xD002C200;


	// Program BL=0, CL, WR, and PD=1 in the Mode Register 0 (address offset 0x054). 
	// All other fields must be left at their default values.

	DDR3A_MR0 = 0x00001A60; //00001A60




	// Program DIC, RTT, and TDQS in the Mode Register 1 (address offset 0x058). 
	// All other fields must be left at their default values.

	DDR3A_MR1 = 0x00000006;

	// Program Mode Register 2 (address offset 0x05C).

	DDR3A_MR2 = 0x00000010;

	// Program DTMPR=1, DTEXD, DTEXG, RANKEN=1 or 3, and RFSHDT=7 in the Data Training Configuration Register (address offset 0x068). 
	// All other fields must be left at their default values.
	DDR3A_DTCR = 0x710035C7; //Single-rank	

	// Program tREFPRD=(5*tREFI/ddr_clk_period) in the PHY General Configuration Register 2 (address offset 0x08C). 
	//All other fields must be left at their default values.

	DDR3A_PGCR2 = 0x00F065B8; //NOBUB = 0, FXDLAT = 0 	
	//DDR3A_PGCR2 = 0x00F83D09; //NOBUB = 0, FXDLAT = 1 

	//Set Impedence Register and DFIPU0=1 
	DDR3A_ZQ0CR1 = 0x0001005D; 
	DDR3A_ZQ1CR1 = 0x0001005B;
	DDR3A_ZQ2CR1 = 0x0001005B;


	// Re-trigger PHY initialization in DDR PHY through the VBUSP interface.
	// Program 0x00000033 to the PHY Initialization Register (address offset 0x004) to re-trigger PLL, ZCAL, and DCAL initialization.

	DDR3A_PIR = 0x00000033;

	// Poll for IDONE=1 in the PHY General Status Register 0 (address offset 0x010).
	do 
	{ 
		read_val = DDR3A_PGSR0;
	} while ((read_val&0x00000001) != 0x00000001);

	//---------------------------------------------------------------------------------------------------------					

	if(!ECC_Enable)
	{
		DDR3A_DATX8_8 = read_val & 0xFFFFFFFE; //Disable ECC byte lane
	}
	// Trigger DDR3 initialization and leveling/training in DDR PHY through the VBUSP interface.
	// If using a 16-bit wide DDR interface, program DXEN=0 in the DATX8 2-7 General Configuration Registers (address offsets 0x240, 0x280, 0x2C0, 0x300, 0x340, and 0x380) to disable the leveling/training for the upper byte lanes.
	// If using a 32-bit wide DDR interface, program DXEN=0 in the DATX8 4-7 General Configuration Registers (address offsets 0x2C0, 0x300, 0x340, and 0x380) to disable the leveling/training for the upper byte lanes.
	// If ECC is not required, program DXEN=0 in the DATX8 8 General Configuration Register (address offset 0x3C0) to disable the leveling/training for the ECC byte lane.
	// NOTE: Setup supports 64-bit by default,  ECC enable by default.

	// Program 0x0000XF81 to the PHY Initialization Register (address offset 0x004) to trigger DDR3 initialization and leveling/training sequences 

	DDR3A_PIR = 0x0000FF81; //WLADJ - ON
	//DDR3A_PIR = 0x00000781;  //WLADJ - OFF

	//---------------------------------------------------------------------------------------------------------					

	// Poll for IDONE=1 in the PHY General Status Register 0 (address offset 0x010).
	do {              
		read_val = DDR3A_PGSR0;
	} while ((read_val&0x00000001) != 0x00000001);

	/* End PHY Configuration */
	if(ECC_Enable)
	{
		//Enable ECC
		//0xB0000000: ECC_EN=1, ECC_VERIFY_EN=1, RMW_EN=1
		//0x50000000: ECC_EN=1, ECC_VERIFY_EN=0, RMW_EN=1
		DDR3A_ECC_CTRL = 0xB0000000;
		read_val = DDR3A_ECC_CTRL;
		if(read_val!=0xB0000000){
			GEL_TextOut("\nIncorrect data written to DDR3A_ECC_CTRL..");
		}
	}
	//---------------------------------------------------------------------------------------------------------					

	DDR3A_SDCFG    = 0x62008C62;	//62008C62
	//Single-Rank

	DDR3A_SDTIM1   = 0x125C8074;
	DDR3A_SDTIM2   = 0x00001D08;
	DDR3A_SDTIM3   = 0x32CDFF43;
	DDR3A_SDTIM4   = 0x543F0ADF;
	DDR3A_ZQCFG    = 0x70073200;	//Single-rank

	// Program reg_initref_dis=0 in the SDRAM Refresh Control Register (address offset 0x10).
	DDR3A_SDRFC = 0x00001457;

	GEL_TextOut("DDR3A initialization complete \n");
	/* End  DDR3A EMIF Configuration */

}	
/*----------------------------------------------------- DDR3A : DDR1600, 64bit--------------------------------------------------------------------------*/
ddr3A_64bit_DDR1600_setup(int ECC_Enable)
{
	unsigned int multiplier = 15;
	unsigned int divider = 0;
	unsigned int OD_val = 4;

	int temp,i;
	int delay = 2000;

	KICK0 = 0x83E70B13;
	KICK1 = 0x95A4F1E0;


	// Poll for IDONE=1 in the PHY General Status Register 0 (address offset 0x010).
	do { 
		read_val = DDR3A_PGSR0;
	} while ((read_val&0x00000001) != 0x00000001);

	//	Clocks are enabled and frequency is stable---------------------------------------
	// DDR3A PLL setup	
	GEL_TextOut ( "DDR3 PLL Setup ... \n");
	// DDR3APLLCTL0 = DDR3APLLCTL0 & 0xFF7FFFFF;
	// Set ENSAT = 1
	DDR3APLLCTL1 |= 0x00000040;
	// Put the PLL in PLL Mode  
	DDR3APLLCTL0 |= 0x00800000;

	// Program the necessary multipliers/dividers and BW adjustments            
	// Set the divider values 
	DDR3APLLCTL0 &= ~(0x0000003F);
	DDR3APLLCTL0 |= (divider & 0x0000003F);

	// Program OD[3:0] in the SECCTL register            
	DDR3APLLCTL0 &= OUTPUT_DIVIDE_MASK;  // clear the OD bit field
	DDR3APLLCTL0 |= ~OUTPUT_DIVIDE_MASK & (OD_val - 1) << OUTPUT_DIVIDE_OFFSET;  // set the OD[3:0] bit field of PLLD to OD_val    
	// Set the Multipler values 
	DDR3APLLCTL0 &= ~(0x0007FFC0);
	DDR3APLLCTL0 |= ((multiplier << 6) & 0x0007FFC0 );
	temp = ((multiplier + 1) >> 1) - 1;
	DDR3APLLCTL0 &= ~(0xFF000000); 
	DDR3APLLCTL0 |= ((temp << 24) & 0xFF000000);
	DDR3APLLCTL1 &= ~(0x0000000F);
	DDR3APLLCTL1 |= ((temp >> 8) & 0x0000000F);

	// In PLL Controller, reset the PLL (bit 13 in DDR3APLLCTL1 register) 
	DDR3APLLCTL1 |= 0x00004000;
	for(i=0;i<delay;i++);
	// In DDR3PLLCTL1, write PLLRST = 0 to bring PLL out of reset 
	DDR3APLLCTL1 &= ~(0x00004000);
	for(i=0;i<delay;i++);

	// Put the PLL in PLL Mode  
	DDR3APLLCTL0 &= ~(0x00800000); // ReSet the Bit 23
	GEL_TextOut( "DDR3 PLL Setup complete, DDR3A clock now running at 533MHz.\n" );
	//DDR3A PLL setup complete ---------------------------------------


	/*------------------------------- ECO FIX -----------------------------------------*/
	/*
		// DDR3 write leveling ECO - Assert & release DDR PHY RESET after DDR PLL setup...
		DDR3APLLCTL1 = DDR3APLLCTL1 | 0x80000000;	//Assert DDR PHY reset after PLL enabled
		//for(i=0;i<delay;i++);						//delay 1000 cycles
		DDR3APLLCTL1 = DDR3APLLCTL1 & 0x7FFFFFFF;	//Release DDR PHY reset

		do {   // Poll IDONE after resetting PHY 
			read_val = DDR3A_PGSR0;	
		   } while ((read_val&0x00000001) != 0x00000001);
	 */
	/*------------------------- Start PHY Configuration -------------------------------*/

	// Program FRQSEL in the PLL Control Register (address offset 0x018).
	DDR3A_PLLCR = 0x1C000; //Set FRQSEL=11, for ctl_clk between 166-275MHz

	// Program WLSTEP=1, IODDRM=1, and ZCKSEL in the PHY General Configuration Register 1 (address offset 0x00C).

	DDR3A_PGCR1 |= (1 << 2); //WLSTEP = 1
	DDR3A_PGCR1 &= ~(IODDRM_MASK);
	DDR3A_PGCR1 |= (( 1 << 7) & IODDRM_MASK);
	DDR3A_PGCR1 &= ~(ZCKSEL_MASK);
	DDR3A_PGCR1 |= (( 1 << 23) & ZCKSEL_MASK);

	// Program PHY Timing Parameters Register 0-4 (address offset 0x01C - 0x02C).

	DDR3A_PTR0 = 0x42C21590;
	DDR3A_PTR1 = 0xD05612C0;	

	// Maintain default values of Phy Timing Parameters Register 2 in PUB

	DDR3A_PTR3 = 0x0D861A80;//0x18061A80; 
	DDR3A_PTR4 = 0x0C827100;//0x0AAE7100;

	// Program PDQ, MPRDQ, and BYTEMASK in the DRAM Configuration Register (address offset 0x044). 
	// All other fields must be left at their default values.

	DDR3A_DCR &= ~(PDQ_MASK); //PDQ = 0
	DDR3A_DCR &= ~(MPRDQ_MASK); //MPRDQ = 0
	DDR3A_DCR &= ~(BYTEMASK_MASK);
	DDR3A_DCR |= (( 1 << 10) & BYTEMASK_MASK);

	// Program DRAM Timing Parameters Register 0-2 (address offset 0x048 - 0x050). 

	DDR3A_DTPR0 = 0x9D5CBB66;
	DDR3A_DTPR1 = 0x12868300;	//Increase tWLO to 12
	DDR3A_DTPR2 = 0x5002D200;

	// Program BL=0, CL, WR, and PD=1 in the Mode Register 0 (address offset 0x054). 
	// All other fields must be left at their default values.

	DDR3A_MR0 = 0x00001C70;


	// Program DIC, RTT, and TDQS in the Mode Register 1 (address offset 0x058). 
	// All other fields must be left at their default values.

	DDR3A_MR1 = 0x00000006;

	// Program Mode Register 2 (address offset 0x05C).

	DDR3A_MR2 = 0x00000018;

	// Program DTMPR=1, DTEXD, DTEXG, RANKEN=1 or 3, and RFSHDT=7 in the Data Training Configuration Register (address offset 0x068). 
	// All other fields must be left at their default values.
	DDR3A_DTCR = 0x710035C7; //Single-rank	

	// Program tREFPRD=(5*tREFI/ddr_clk_period) in the PHY General Configuration Register 2 (address offset 0x08C). 
	//All other fields must be left at their default values.

	DDR3A_PGCR2 = 0x00F07A12; //NOBUB = 0, FXDLAT = 0 	
	//DDR3A_PGCR2 = 0x00F83D09; //NOBUB = 0, FXDLAT = 1 

	//Set Impedence Register and DFIPU0=1 
	DDR3A_ZQ0CR1 = 0x0001005D; 
	DDR3A_ZQ1CR1 = 0x0001005B;
	DDR3A_ZQ2CR1 = 0x0001005B;


	// Re-trigger PHY initialization in DDR PHY through the VBUSP interface.
	// Program 0x00000033 to the PHY Initialization Register (address offset 0x004) to re-trigger PLL, ZCAL, and DCAL initialization.

	DDR3A_PIR = 0x00000033;

	// Poll for IDONE=1 in the PHY General Status Register 0 (address offset 0x010).
	do { 
		read_val = DDR3A_PGSR0;
	} while ((read_val&0x00000001) != 0x00000001);

	//---------------------------------------------------------------------------------------------------------					

	if(!ECC_Enable)
	{
		DDR3A_DATX8_8 = read_val & 0xFFFFFFFE; //Disable ECC byte lane
	}
	// Trigger DDR3 initialization and leveling/training in DDR PHY through the VBUSP interface.
	// If using a 16-bit wide DDR interface, program DXEN=0 in the DATX8 2-7 General Configuration Registers (address offsets 0x240, 0x280, 0x2C0, 0x300, 0x340, and 0x380) to disable the leveling/training for the upper byte lanes.
	// If using a 32-bit wide DDR interface, program DXEN=0 in the DATX8 4-7 General Configuration Registers (address offsets 0x2C0, 0x300, 0x340, and 0x380) to disable the leveling/training for the upper byte lanes.
	// If ECC is not required, program DXEN=0 in the DATX8 8 General Configuration Register (address offset 0x3C0) to disable the leveling/training for the ECC byte lane.
	// NOTE: Setup supports 64-bit by default,  ECC enable by default.

	// Program 0x0000XF81 to the PHY Initialization Register (address offset 0x004) to trigger DDR3 initialization and leveling/training sequences 

	DDR3A_PIR = 0x0000FF81; //WLADJ - ON
	//DDR3A_PIR = 0x00000781;  //WLADJ - OFF

	//---------------------------------------------------------------------------------------------------------					

	// Poll for IDONE=1 in the PHY General Status Register 0 (address offset 0x010).
	do {              
		read_val = DDR3A_PGSR0;
	} while ((read_val&0x00000001) != 0x00000001);

	/* End PHY Configuration */
	if(ECC_Enable)
	{
		//Enable ECC
		//0xB0000000: ECC_EN=1, ECC_VERIFY_EN=1, RMW_EN=1
		//0x50000000: ECC_EN=1, ECC_VERIFY_EN=0, RMW_EN=1
		DDR3A_ECC_CTRL = 0xB0000000;
		read_val = DDR3A_ECC_CTRL;
		if(read_val!=0xB0000000){
			GEL_TextOut("\nIncorrect data written to DDR3A_ECC_CTRL..");
		}
	}
	//---------------------------------------------------------------------------------------------------------					

	DDR3A_SDCFG    = 0x6200CE62;	//Single-Rank

	DDR3A_SDTIM1   = 0x166C9855;
	DDR3A_SDTIM2   = 0x00001D4A;
	DDR3A_SDTIM3   = 0x435DFF53;
	DDR3A_SDTIM4   = 0x543F0CFF;

	DDR3A_ZQCFG    = 0x70073200;	//Single-rank

	// Program reg_initref_dis=0 in the SDRAM Refresh Control Register (address offset 0x10).
	DDR3A_SDRFC = 0x00001869;

	GEL_TextOut("DDR3A initialization complete \n");
	/* End  DDR3A EMIF Configuration */

}




/*--------------------------------------------------------------*/
/* TCI66x MENU                                              */
/*--------------------------------------------------------------*/

menuitem "TCI66x Functions";

/****************************************************************************
 *
 * NAME
 *      Global_Default_Setup
 *
 * PURPOSE:
 *      Setup almost everything ready for a new debug session:
 *      DSP modules and EVM board modules.
 *
 * USAGE
 *      This routine can be called as:
 *
 *      Global_Default_Setup()
 *
 * RETURN VALUE
 *      NONE
 *
 * REFERENCE
 *
 ****************************************************************************/
hotmenu Global_Default_Setup()
{
	GEL_TextOut( "Global Default Setup...\n" );
	Global_Default_Setup_Silent();
	GEL_TextOut( "Global Default Setup... Done.\n" );
}

hotmenu Reset()
{
	GEL_Reset();
}

hotmenu InitXMC()
{
	xmc_setup();
}

hotmenu CORE_PLL_INIT_122_88MHZ_to_614_4MHz()
{
	Set_Pll1(1); // call Set_Pll1 with index = 1 -> 122.88 MHz to 614.4 MHz operation 
}

hotmenu CORE_PLL_INIT_122_88MHZ_to_737_28MHz()
{
	Set_Pll1(2); // call Set_Pll1 with index = 2 -> 122.88 MHz to 737.28 MHz operation 
}

hotmenu CORE_PLL_INIT_122_88MHZ_to_983_04MHz()
{
	Set_Pll1(3); // call Set_Pll1 with index = 3 -> 122.88 MHz to 983.04 MHz operation 
}

hotmenu CORE_PLL_INIT_122_88MHZ_to_1_2GHz()
{
	Set_Pll1(4); // call Set_Pll1 with index = 4 -> 122.88 MHz  to 1.2 GHz operation 
}


hotmenu CORE_PLL_INIT_122_88MHZ_to_1_3Gz()
{
	Set_Pll1(5); // call Set_Pll1 with index = 4 -> 122.88 MHz  to 1.2 GHz operation 
}

hotmenu TETRIS_POWERUP_AND_PLL_INIT_122MHZ_to_983MHz()
{
	Set_Tetris_Pll(1); // 122.88 MHz to 983 MHz operation 
}

hotmenu TETRIS_POWERUP_AND_PLL_INIT_100MHZ_to_1400MHz()
{
	Set_Tetris_Pll(2); // 100 MHz to 1.4 GHz operation 
}

hotmenu TETRIS_POWERUP_AND_PLL_INIT_175MHZ_to_1400MHz()
{
	Set_Tetris_Pll(3); // 175 MHz to 1.4 GHz operation 
}


hotmenu PA_PLL_Config()
{
	PaPllConfig();
}

hotmenu DFE_PLL_Init_122MHZ_to_245MHz()
{
	// DFE PLL REFCLK = 122.88 MHz
	// DFE PLL CLKR = 0x0 (Default: no prediv)
	// DFE PLL CLKF = 0x7(Default) or 0x5 (multiplier = n+1 = 8,or 6)
	// DFE PLL CLKOD = 0x0(Default) (postdiv = 1, no postdiv)
	// DFE PLL CLKOUT = 983.04 (Default) or 737.28MHz

	//DFECLKSYNC_CTL register DIVMODE configured to /4 (default) or /2, to support
	//DFE operating frequency of 245.76 (default), 368.64 or 491.52 MHz. Note 491.52 is
	//frequency is only supported for internal testing.

	//DFE Frequency PLL Configuration DFECLKSYNC Divider Mode
	//245.76 MHz x8 (983.04 MHz) /4
	//491.52 MHz x8 (983.04 MHz) /2
	//368.64 MHz x6 (737.28 MHz) /2

	dfepll_setup(CHIP_LEVEL_REG, 0, 8-1, 1-1, 0);    

	GEL_TextOut("DFE_CLK setup to 245.76Mh complete!\n",,,,,);
}

hotmenu InitDDR3A_64bit_DDR1066_NOECC()
{
	ddr3A_64bit_DDR1066_setup(0);
} 

hotmenu InitDDR3A_64bit_DDR1333_NOECC()
{
	ddr3A_64bit_DDR1333_setup(0);
} 
hotmenu InitDDR3A_64bit_DDR1600_NOECC()
{
	ddr3A_64bit_DDR1600_setup(0);
}   
///* Function to enable CORE PLL observation clock for PLL output *///
hotmenu ENABLE_CORE_PLL_OBSCLK()
{
	/* Unlock Chip Level Registers */
	KICK0 = KICK0_UNLOCK;
	KICK1 = KICK1_UNLOCK;

	/* set bit 1 to enable power to the CORE PLL observation clock, clear bit 0 to view the CORE PLL observation (output) clock */
	OBSCLKCTL |= (1 << 1);  /* set bit 1 to enable power to the observation clock */
	OBSCLKCTL &= ~(1 << 0); /* clear bit 0 to view the CORE PLL clock */ 

	/* Lock Chip Level Registers */
	KICK0 = 0x00000000;
	KICK1 = 0x00000000;

	GEL_TextOut("CORE PLL observation clock enabled and configured to show CORE PLL output\n");
}

/* Function to enable DDR PLL observation clock for PLL output */
hotmenu ENABLE_DDR_PLL_OBSCLK ()
{
	/* Unlock Chip Level Registers */
	KICK0 = KICK0_UNLOCK;
	KICK1 = KICK1_UNLOCK;

	/* set bit 1 to enable power to the CORE PLL observation clock, clear bit 0 to view the CORE PLL observation (output) clock */
	OBSCLKCTL |= (1 << 3);  /* set bit 3 to enable power to the observation clock */
	OBSCLKCTL |= (1 << 2);  /* set bit 2 to view the DDR PLL clock */ 

	/* Lock Chip Level Registers */
	//KICK0 = 0x00000000;
	// KICK1 = 0x00000000;

	GEL_TextOut("DDR PLL observation clock enabled and configured to show DDR PLL output\n");
}

hotmenu ENABLE_ARM_PLL_OBSCLK ()
{
	/* Unlock Chip Level Registers */
	KICK0 = KICK0_UNLOCK;
	KICK1 = KICK1_UNLOCK;

	/* set bit 1 to enable power to the CORE PLL observation clock, clear bit 0 to view the CORE PLL observation (output) clock */
	//OBSCLKCTL |= (1 << 3);  /* set bit 3 to enable power to the observation clock */
	OBSCLKCTL |= (1 << 6);  /* set bit 2 to view the DDR PLL clock */ 

	/* Lock Chip Level Registers */
	KICK0 = 0x00000000;
	KICK1 = 0x00000000;

	GEL_TextOut("DDR PLL observation clock enabled and configured to show DDR PLL output\n");
}

hotmenu ENABLE_PA_PLL_OBSCLK ()
{
	/* Unlock Chip Level Registers */
	KICK0 = KICK0_UNLOCK;
	KICK1 = KICK1_UNLOCK;

	/* set bit 1 to enable power to the CORE PLL observation clock, clear bit 0 to view the CORE PLL observation (output) clock */
	OBSCLKCTL |= (1 << 4);  /* set bit 3 to enable power to the observation clock */
	OBSCLKCTL |= (1 << 5);  /* set bit 2 to view the DDR PLL clock */ 

	/* Lock Chip Level Registers */
	KICK0 = 0x00000000;
	KICK1 = 0x00000000;

	GEL_TextOut("DDR PLL observation clock enabled and configured to show DDR PLL output\n");
}

hotmenu ddr3A_write_read_test()
{
	//int data_set[4];
	//= {0xAAAAAAAA, 0x55555555, 0xFFFFFFFF, 0x00000000};
	int coreId = REG_CTXA15_CP15_C0_MPIDR & 0x3;
	unsigned int write_data = 0xAAAAAAAA;
	unsigned int read_data = 0x0;
	unsigned int errors = 0;
	int dw;
	unsigned int i, mem_start, mem_size, mem_location;
	mem_start = DDR3A_BASE_ADDRESS + (coreId * 0x01000000);
	mem_size = 0x100;
	for(dw=0;dw<4;dw++)
	{
		if (dw == 0) write_data = 0xAAAAAAAA;
		if (dw == 1) write_data = 0x55555555;
		if (dw == 2) write_data = 0xFFFFFFFF;
		if (dw == 3) write_data = 0x00000000;
		mem_location = mem_start;
		GEL_TextOut( "Memory Test Write Core: %d, Mem Start: 0x%x, Mem Size: 0x%x, value: 0x%x ...\n",,2,,,coreId,mem_start,mem_size,write_data);
		for(i=0;i<mem_size;i++)
		{
			*( unsigned int* )(mem_location) = write_data;
			mem_location += 4;
		}
		mem_location = mem_start;
		GEL_TextOut( "Memory Test Read Core: %d, Mem Start: 0x%x, Mem Size: 0x%x ...\n",,2,,,coreId,mem_start,mem_size);
		for (i=0;i<mem_size;i++)
		{
			read_data = *( unsigned int* )(mem_location);
			if (read_data != write_data)
			{
				GEL_TextOut("DDR3 Data Error: DSP Core: %d, Mem Addr: 0x%x, read: 0x%x, expected: 0x%x \n",,2,,,coreId,(DDR3_BASE_ADDRESS + (i * 4)),read_data,write_data);
				errors++;
			}
			mem_location += 4;
		}
		if (errors == 0)
		{
			GEL_TextOut( "Memory Test Done, no errors found.\n" );
		}
		else
		{
			GEL_TextOut("Memory Test Done, %d errors were encounterd. \n",,2,,,errors);
		}
	}
	GEL_TextOut( "All Memory Test Completed on core: %d with %d errors.\n",,2,,,coreId,errors);

}

/****************************************************************************
 *				PHY Related Defines and Functions
 ****************************************************************************/

#define MDIO_VERSION_REG            (*(unsigned int *) (0x26200F00 + 0x00))
/* mdio_user_access_reg */
#define MDIO_USER_ACCESS_REG            (*(unsigned int *) (0x26200F00 + 0x80))
#define MDIO_USER_CONTROL_REG            (*(unsigned int *) (0x26200F00 + 0x04))
#define MDIO_USER_INT_MASK_REG            (*(unsigned int *) (0x26200F00 + 0x28))

/* shift and mask for MDIO_USER_ACCESS_REG */
#define CSL_MDIO_USER_ACCESS_REG_DATA_MASK (0x0000FFFFu)
#define CSL_MDIO_USER_ACCESS_REG_DATA_SHIFT (0x00000000u)
#define CSL_MDIO_USER_ACCESS_REG_DATA_RESETVAL (0x00000000u)

#define CSL_MDIO_USER_ACCESS_REG_PHYADR_MASK (0x001F0000u)
#define CSL_MDIO_USER_ACCESS_REG_PHYADR_SHIFT (0x00000010u)
#define CSL_MDIO_USER_ACCESS_REG_PHYADR_RESETVAL (0x00000000u)

#define CSL_MDIO_USER_ACCESS_REG_REGADR_MASK (0x03E00000u)
#define CSL_MDIO_USER_ACCESS_REG_REGADR_SHIFT (0x00000015u)
#define CSL_MDIO_USER_ACCESS_REG_REGADR_RESETVAL (0x00000000u)

#define CSL_MDIO_USER_ACCESS_REG_ACK_MASK (0x20000000u)
#define CSL_MDIO_USER_ACCESS_REG_ACK_SHIFT (0x0000001Du)
#define CSL_MDIO_USER_ACCESS_REG_ACK_RESETVAL (0x00000000u)

#define CSL_MDIO_USER_ACCESS_REG_WRITE_MASK (0x40000000u)
#define CSL_MDIO_USER_ACCESS_REG_WRITE_SHIFT (0x0000001Eu)
#define CSL_MDIO_USER_ACCESS_REG_WRITE_RESETVAL (0x00000000u)

#define CSL_MDIO_USER_ACCESS_REG_GO_MASK (0x80000000u)
#define CSL_MDIO_USER_ACCESS_REG_GO_SHIFT (0x0000001Fu)
#define CSL_MDIO_USER_ACCESS_REG_GO_RESETVAL (0x00000000u)

/*
#define CSL_FMK(PER_REG_FIELD, val)                                         \
    (((val) << CSL_##PER_REG_FIELD##_SHIFT) & CSL_##PER_REG_FIELD##_MASK)

#define CSL_FEXT(reg, PER_REG_FIELD)                                        \
    (((reg) & CSL_##PER_REG_FIELD##_MASK) >> CSL_##PER_REG_FIELD##_SHIFT)
#endif
 */

/* the Field MaKe macro */
#define CSL_FMK(SHIFT, MASK, val) 		(((val) << SHIFT) & MASK)

/* the Field EXTract macro */
#define CSL_FEXT(reg, SHIFT, MASK) 		(((reg) & MASK) >> SHIFT)


#define PHY_REG_PAGE_ADDR 22

phy_hwwrite(unsigned short phy_addr, unsigned short addr, unsigned short val)
{
	unsigned int retVal=1;
	unsigned int i, delay=2000;
	
	MDIO_USER_ACCESS_REG   =  CSL_FMK (CSL_MDIO_USER_ACCESS_REG_GO_SHIFT, CSL_MDIO_USER_ACCESS_REG_GO_MASK, 1u) |
			CSL_FMK (CSL_MDIO_USER_ACCESS_REG_WRITE_SHIFT, CSL_MDIO_USER_ACCESS_REG_WRITE_MASK, 1) |
			CSL_FMK (CSL_MDIO_USER_ACCESS_REG_REGADR_SHIFT, CSL_MDIO_USER_ACCESS_REG_REGADR_MASK, addr) |
			CSL_FMK (CSL_MDIO_USER_ACCESS_REG_PHYADR_SHIFT, CSL_MDIO_USER_ACCESS_REG_PHYADR_MASK, phy_addr) |
			CSL_FMK (CSL_MDIO_USER_ACCESS_REG_DATA_SHIFT, CSL_MDIO_USER_ACCESS_REG_DATA_MASK, val);

	
	while(1)
	{
		retVal=CSL_FEXT(MDIO_USER_ACCESS_REG, CSL_MDIO_USER_ACCESS_REG_GO_SHIFT, CSL_MDIO_USER_ACCESS_REG_GO_MASK);
		if(retVal == 0)
			break;

		for(i = 0; i < delay; i++); // this delay is much more than required   

	}
}

phy_hwread(unsigned short phy_addr, unsigned short addr, unsigned short *val)
{

	MDIO_USER_ACCESS_REG =  CSL_FMK (CSL_MDIO_USER_ACCESS_REG_GO_SHIFT, CSL_MDIO_USER_ACCESS_REG_GO_MASK, 1u) |
			CSL_FMK (CSL_MDIO_USER_ACCESS_REG_REGADR_SHIFT, CSL_MDIO_USER_ACCESS_REG_REGADR_MASK, addr) |
			CSL_FMK (CSL_MDIO_USER_ACCESS_REG_PHYADR_SHIFT, CSL_MDIO_USER_ACCESS_REG_PHYADR_MASK, phy_addr);

	PHYREG0_waitResultsAck(*val, ack);

	if(!ack)
		GEL_TextOut("Reg read error for PHY: %d\n",,,,, phy_addr);
}

#define PHYREG0_waitResultsAck( results, ack ) {                                        \
		results = CSL_FEXT( MDIO_USER_ACCESS_REG, CSL_MDIO_USER_ACCESS_REG_DATA_SHIFT, CSL_MDIO_USER_ACCESS_REG_DATA_MASK);        \
		ack = CSL_FEXT( MDIO_USER_ACCESS_REG, CSL_MDIO_USER_ACCESS_REG_ACK_SHIFT, CSL_MDIO_USER_ACCESS_REG_ACK_MASK); }

phy_miiread (unsigned short phyaddr, unsigned short page, unsigned int addr, unsigned short *val)
{
	phy_hwwrite(phyaddr, PHY_REG_PAGE_ADDR, page);
	phy_hwread(phyaddr, addr, val);
}

phy_miiwrite(unsigned short phyaddr, unsigned short page, unsigned short addr, unsigned short val)
{
	phy_hwwrite(phyaddr, PHY_REG_PAGE_ADDR, page);
	phy_hwwrite(phyaddr, addr, val);
}

setupPhy(unsigned short phyaddr)
{
	unsigned short val = 0;
	unsigned int delay = 0x40000;
	unsigned int i = 0;

	GEL_TextOut("Starting Setup for PHY: %d\n",,,,, phyaddr);

	/* PHY settings as per Release Note, Errata section 3.1 */
	phy_hwwrite(phyaddr, 22, 0x00ff);
	phy_hwwrite(phyaddr, 17, 0x214B);
	phy_hwwrite(phyaddr, 16, 0x2144);
	phy_hwwrite(phyaddr, 17, 0x0C28);
	phy_hwwrite(phyaddr, 16, 0x2146);
	phy_hwwrite(phyaddr, 17, 0xB233);
	phy_hwwrite(phyaddr, 16, 0x214D);
	phy_hwwrite(phyaddr, 17, 0xCC0C);
	phy_hwwrite(phyaddr, 16, 0x2159);
	phy_hwwrite(phyaddr, 22, 0x0000);


	/* Set SGMII to Copper mode Page 18, Reg 20.2:0 = 1  */
	phy_hwwrite(phyaddr, 22, 18);
	phy_hwwrite(phyaddr, 20, 0x1);
	/* PHY Reset Page 18, Reg 20.15 = 1  */
	phy_hwwrite(phyaddr, 20, 0x8201);
	phy_hwwrite(phyaddr, 22, 00);
	
	GEL_TextOut("Wait a moment for copper link up for PHY: %d\n",,,,, phyaddr);
	for(i = 0; i < delay; i++);
	//fix: need to add phy link register read code here
	GEL_TextOut("Configuration Completed for PHY: %d\n",,,,, phyaddr);
}

/****************************************************************************
 *
 * NAME
 *      SetupPhy
 *
 * PURPOSE:
 *      Setup Marvell 88e1514 default settings.
 *
 * USAGE
 *      This routine shall be called before using external network on Port 0
 *      Or Port 1 (RJ45 ports) with K2L evm.
 *
 * RETURN VALUE
 *      NONE
 *
 * REFERENCE
 *
 ****************************************************************************/
hotmenu SetupPhy0()
{
	MDIO_USER_CONTROL_REG = (1 << 30) | 0xFA;
	MDIO_USER_INT_MASK_REG = 0x00;
	setupPhy(0);
}

hotmenu SetupPhy1()
{
	MDIO_USER_CONTROL_REG = (1 << 30) | 0xFA;
	MDIO_USER_INT_MASK_REG = 0x00;
	setupPhy(1);
}

menuitem "DSP CLOCK Estimation";

#define TIMER_TSC             (1)    // The timer used for polling TSCH/TSCL  
#define TIMER_TSC_POLL_PERIOD (10)   // Every 10 seconds
unsigned int gPollPeriod = TIMER_TISC_POLL_PERIOD;
unsigned int gTSCL = 0;
unsigned int gTSCH = 0;              // Global var for holding previous read of TSCL/H
unsigned int gNumberPoll=0;          // Number of pulling */
unsigned int gLoopCount=0;



hotmenu dspEnableTsc()
{
	//GEL_TextOut( "dspEnableTsc - write a value to TSCL to enable it\n" );
	if( GEL_IsHalted() ) {
		TSCL = 0;  // A write to TSCL will enable TSC (timestamp counter)
		GEL_Run();
	} else {
		GEL_Halt();
		TSCL = 0;
		GEL_Run();
	}
}


hotmenu dspDumpTsc()
{
	unsigned int tscl, tsch;
	tscl = TSCL;  /* note: need to read TSCL first */
	tsch = TSCH;
	GEL_TextOut( "dspEnableTsc - TSCH=%x, TSCL=%x\n",,,,, tscl, tsch );
}


dspPollTsc()
{
	unsigned int tscl, tsch;
	unsigned long long tsc1, tsc2;

	if( gLoopCount <= gNumberPoll) { 
		//GEL_EnableRealtime();
		GEL_Halt();
		tscl = TSCL;            /* The read time can be considered as variations */
		tsch = TSCH;            /* The read won't cause variation */
		//GEL_DisableRealtime();
		GEL_Run();
		tsc2  = (((unsigned long long) tsch)<<32) +  tscl;
		tsc1  = (((unsigned long long)gTSCH)<<32) + gTSCL;
		gTSCL = tscl;
		gTSCH = tsch;

		//tsc1 = (tsc2-tsc1)/TIMER_TSC_POLL_PERIOD;
		tsc1 = (tsc2-tsc1)/gPollPeriod;

		GEL_TextOut( "dspPollTsc - [TSCH,TSCL] = [%x, %x], freq=%dhz, i=%d\n",,,,,
				gTSCH, gTSCL, (tsc1), gLoopCount);
	}

	if( gLoopCount>=gNumberPoll ) {
		dspCancelTscTimer();
	} else {  
		gLoopCount++;
	}
}


//
// To cancel the Timer - TIMER_TSC, after using it. Otherwise, it will continue running.
//
hotmenu dspCancelTscTimer()
{
	GEL_TextOut( "dspCancelTscTimer\n");
	GEL_CancelTimer( TIMER_TSC );
}


//
// To poll the DSP clock.
//
dialog dspPollDSPClockFreq(
		pollPeriod   "Polling period (sec) - the longer, the more accurate!",
		numberOfPoll "Number of Polls" )
{
	gPollPeriod = pollPeriod;

	GEL_TextOut( "dspPollDSPClockFreq with - pollPeriod=%dsec, numberOfPoll=%d\n"
			,,,,, gPollPeriod, numberOfPoll);

	gNumberPoll = numberOfPoll-1;
	gLoopCount  = 0;
	dspEnableTsc();

	// Get the initial value of TSC
	//GEL_EnableRealtime();
	GEL_Halt();
	gTSCL = TSCL;            /* The read time can be considered as variations */
	gTSCH = TSCH;            /* The read won't cause variation */
	//GEL_DisableRealtime();
	GEL_Run();

	GEL_SetTimer( gPollPeriod*1000, TIMER_TSC, "dspPollTsc()");

}

