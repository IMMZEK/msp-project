<?xml version="1.0" encoding="UTF-8" standalone="yes"?>


<module description="MSS_AES" id="MSS_AES">
  
  
  <register acronym="S_KEY2_6" description=" XTS second key / CBC-MAC third key (Read-returns0s)" id="S_KEY2_6" offset="0x0" width="32">
    
  <bitfield begin="31" description="key data" end="0" id="KEY" rwaccess="RW" width="32"></bitfield>
  </register>
  
  
  <register acronym="S_KEY2_7" description=" XTS second key (MSW for 256-bit key) / CBC-MAC third key (MSW)  (Read-returns0s)" id="S_KEY2_7" offset="0x4" width="32">
    
  <bitfield begin="31" description="key data" end="0" id="KEY" rwaccess="RW" width="32"></bitfield>
  </register>
  
  
  <register acronym="S_KEY2_4" description=" XTS / CCM second key / CBC-MAC third key (LSW)  (Read-returns0s)" id="S_KEY2_4" offset="0x8" width="32">
    
  <bitfield begin="31" description="key data" end="0" id="KEY" rwaccess="RW" width="32"></bitfield>
  </register>
  
  
  <register acronym="S_KEY2_5" description=" XTS second key (MSW for 192-bit key) / CBC-MAC third key  (Read-returns0s)" id="S_KEY2_5" offset="0xC" width="32">
    
  <bitfield begin="31" description="key data" end="0" id="KEY" rwaccess="RW" width="32"></bitfield>
  </register>
  
  
  <register acronym="S_KEY2_2" description=" XTS / CCM / CBC-MAC second key / Hash Key input (Read-returns0s)" id="S_KEY2_2" offset="0x10" width="32">
    
  <bitfield begin="31" description="key data" end="0" id="KEY" rwaccess="RW" width="32"></bitfield>
  </register>
  
  
  <register acronym="S_KEY2_3" description=" XTS second key (MSW for 128-bit key) + CCM/CBC-MAC second key (MSW) / Hash Key input (MSW)  (Read-returns0s)" id="S_KEY2_3" offset="0x14" width="32">
    
  <bitfield begin="31" description="key data" end="0" id="KEY" rwaccess="RW" width="32"></bitfield>
  </register>
  
  
  <register acronym="S_KEY2_0" description=" XTS / CCM / CBC-MAC second key (LSW) / Hash Key input (LSW)  (Read-returns0s)" id="S_KEY2_0" offset="0x18" width="32">
    
  <bitfield begin="31" description="key data" end="0" id="KEY" rwaccess="RW" width="32"></bitfield>
  </register>
  
  
  <register acronym="S_KEY2_1" description=" XTS / CCM / CBC-MAC second key / Hash Key input (Read-returns0s)" id="S_KEY2_1" offset="0x1C" width="32">
    
  <bitfield begin="31" description="key data" end="0" id="KEY" rwaccess="RW" width="32"></bitfield>
  </register>
  
  
  <register acronym="S_KEY1_6" description=" Key (LSW for 256-bit key)  (Read-returns0s)" id="S_KEY1_6" offset="0x20" width="32">
    
  <bitfield begin="31" description="key data" end="0" id="KEY" rwaccess="RW" width="32"></bitfield>
  </register>
  
  
  <register acronym="S_KEY1_7" description=" Key (MSW for 256-bit key) (Read-returns0s)" id="S_KEY1_7" offset="0x24" width="32">
    
  <bitfield begin="31" description="key data" end="0" id="KEY" rwaccess="RW" width="32"></bitfield>
  </register>
  
  
  <register acronym="S_KEY1_4" description=" Key (LSW for 192-bit key) (Read-returns0s)" id="S_KEY1_4" offset="0x28" width="32">
    
  <bitfield begin="31" description="key data" end="0" id="KEY" rwaccess="RW" width="32"></bitfield>
  </register>
  
  
  <register acronym="S_KEY1_5" description=" Key (MSW for 192-bit key) (Read-returns0s)" id="S_KEY1_5" offset="0x2C" width="32">
    
  <bitfield begin="31" description="key data" end="0" id="KEY" rwaccess="RW" width="32"></bitfield>
  </register>
  
  
  <register acronym="S_KEY1_2" description=" Key (Read-returns0s)" id="S_KEY1_2" offset="0x30" width="32">
    
  <bitfield begin="31" description="key data" end="0" id="KEY" rwaccess="RW" width="32"></bitfield>
  </register>
  
  
  <register acronym="S_KEY1_3" description=" Key (MSW for 128-bit key) (Read-returns0s)" id="S_KEY1_3" offset="0x34" width="32">
    
  <bitfield begin="31" description="key data" end="0" id="KEY" rwaccess="RW" width="32"></bitfield>
  </register>
  
  
  <register acronym="S_KEY1_0" description=" Key (LSW for 128-bit key) (Read-returns0s)" id="S_KEY1_0" offset="0x38" width="32">
    
  <bitfield begin="31" description="key data" end="0" id="KEY" rwaccess="RW" width="32"></bitfield>
  </register>
  
  
  <register acronym="S_KEY1_1" description=" Key (Read-returns0s)" id="S_KEY1_1" offset="0x3C" width="32">
    
  <bitfield begin="31" description="key data" end="0" id="KEY" rwaccess="RW" width="32"></bitfield>
  </register>
  
  
  <register acronym="S_IV_IN_0" description=" Initialization Vector input (LSW)" id="S_IV_IN_0" offset="0x40" width="32">
    
  <bitfield begin="31" description="IV data" end="0" id="DATA" rwaccess="RW" width="32"></bitfield>
  </register>
  
  
  <register acronym="S_IV_IN_1" description=" Initialization vector input" id="S_IV_IN_1" offset="0x44" width="32">
    
  <bitfield begin="31" description="IV data" end="0" id="DATA" rwaccess="RW" width="32"></bitfield>
  </register>
  
  
  <register acronym="S_IV_IN_2" description=" Initialization vector input " id="S_IV_IN_2" offset="0x48" width="32">
    
  <bitfield begin="31" description="IV data" end="0" id="DATA" rwaccess="RW" width="32"></bitfield>
  </register>
  
  
  <register acronym="S_IV_IN_3" description=" Initialization Vector input (MSW) " id="S_IV_IN_3" offset="0x4C" width="32">
    
  <bitfield begin="31" description="IV data" end="0" id="DATA" rwaccess="RW" width="32"></bitfield>
  </register>
  
  
  <register acronym="S_CTRL" description=" register determines the mode of operation of the AES Engine" id="S_CTRL" offset="0x50" width="32">
    
  <bitfield begin="31" description="If ‘1’@@ this read-only status bit indicates that the context data registers can be overwritten and the host is permitted to write the next context." end="31" id="CONTEXT_READY" rwaccess="R" width="1"></bitfield>
    
  <bitfield begin="30" description="If ‘1’@@ this read-only status bit indicates that an AES authentication TAG and/or IV block(s) is/are available for the host to retrieve. This bit is only asserted if the ‘save_context’ bit is set to ‘1’. The bit is mutual exclusive with the ‘context_ready’ bit." end="30" id="SAVE_CONTEXT_READY" rwaccess="R" width="1"></bitfield>
    
  <bitfield begin="29" description="This bit is used to indicate that an authentication TAG or result IV needs to be stored as a result context. If this bit is set@@ context output DMA and/or interrupt will be asserted if the operation is finished and related signals are enabled." end="29" id="SAVE_CONTEXT" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="28" description="reserved" end="25" id="RESERVED" rwaccess="R" width="4"></bitfield>
    
  <bitfield begin="24" description="Defines “M” that indicated the length of the authentication field for CCM operations; the authentication field length equals two times (the value of CCM-M plus one). Note that the AES Engine always returns a 128-bit authentication field@@ of which the M least significant bytes are valid. All values are supported." end="22" id="CCM_M" rwaccess="RW" width="3"></bitfield>
    
  <bitfield begin="21" description="Defines “L” that indicated the width of the length field for CCM operations; the length field in bytes equals the value of CMM-L plus one. Supported values for L are (programmed value): 2 (1)@@ 4 (3) and 8 (7)." end="19" id="CCM_L" rwaccess="RW" width="3"></bitfield>
    
  <bitfield begin="18" description="AES-CCM is selected@@ this is a combined mode@@ using AES for both authentication and encryption. No additional mode selection is required. 0 Other mode selected 1 ccm mode selected" end="18" id="CCM" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="17" description="AES-GCM mode is selected.this is a combined mode@@ using the Galois field multiplier GF(2^128) for authentication and AES-CTR mode for encryption@@ the bits specify the GCM mode. 0x0 No operation 0x1 GHASH with H loaded and Y0-encrypted forced to zero 0x2 GHASH with H loaded and Y0-encrypted calculated internally 0x3 Autonomous GHASH (both H and Y0-encrypted calculated internally)" end="16" id="GCM" rwaccess="RW" width="2"></bitfield>
    
  <bitfield begin="15" description="AES-CBC MAC is selected@@ the Direction bit must be set to ‘1’ for this mode. 0 Other mode selected 1 cbcmac mode selected" end="15" id="CBCMAC" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="14" description="AES f9 mode is selected@@ the AES key size must be set to 128-bit for this mode. 0 Other mode selected 1 f9 selected" end="14" id="F9" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="13" description="AES f8 mode is selected@@ the AES key size must be set to 128-bit for this mode. 0 Other mode selected 1 f8 selected" end="13" id="F8" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="12" description="AES-XTS operation is selected; the bits specify the XTS mode.01 = Previous/intermediate tweak value and ‘j’ loaded (value is loaded via IV@@ j is loaded via the AAD length register) 0x0 No operation 0x1 Previous/intermediate tweak value and ‘j’ loaded (value is loaded via IV@@ j is loaded via the AAD length register) 0x2 Key2@@ i and j loaded (i is loaded via IV@@ j is loaded via the AAD length register) 0x3 Key2 and i loaded@@ j=0 (i is loaded via IV)" end="11" id="XTS" rwaccess="RW" width="2"></bitfield>
    
  <bitfield begin="10" description="full block AES cipher feedback mode (CFB128) is selected. 0 other mode selected 1 cfb selected" end="10" id="CFB" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="9" description="AES integer counter mode (ICM) is selected@@ this is a counter mode with a 16-bit wide counter. 0 Other mode selected. 1 ICM mode selected" end="9" id="ICM" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="8" description="Specifies the counter width for AES-CTR mode 0x0 Counter is 32 bits 0x1 Counter is 64 bits 0x2 Counter is 128 bits 0x3 Counter is 192 bits" end="7" id="CTR_WIDTH" rwaccess="RW" width="2"></bitfield>
    
  <bitfield begin="6" description="Tthis bit must also be set for GCM and CCM@@ when encryption/decryption is required. 0 Other mode selected 1 Counter mode" end="6" id="CTR" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="5" description="ecb/cbc mode 0 ecb mode 1 cbc mode" end="5" id="MODE" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="4" description="key size 0x0 reserved 0x1 Key is 128 bits. 0x2 Key is 192 bits 0x3 Key is 256" end="3" id="KEY_SIZE" rwaccess="RW" width="2"></bitfield>
    
  <bitfield begin="2" description="If set to ‘1’ an encrypt operation is performed. If set to ‘0’ a decrypt operation is performed. Read 0 decryption is selected Read 1 Encryption is selected" end="2" id="DIRECTION" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="1" description="If ‘1’@@ this read-only status bit indicates that the 16-byte input buffer is empty@@ and the host is permitted to write the next block of data." end="1" id="INPUT_READY" rwaccess="R" width="1"></bitfield>
    
  <bitfield begin="0" description="If ‘1’@@ this read-only status bit indicates that an AES output block is available for the host to retrieve." end="0" id="OUTPUT_READY" rwaccess="R" width="1"></bitfield>
  </register>
  
  
  <register acronym="S_C_LENGTH_0" description=" Crypto data length registers (LSW and MSW) store the cryptographic data length in bytes for all modes. Once processing with this context is started@@ this length decrements to zero. Data lengths up to (2^61 – 1) bytes are allowed. For GCM@@ any value up to 2^36 - 32 bytes can be used. This is because a 32-bit counter mode is used; the maximum number of 128-bit blocks is 2^32 – 2@@ resulting in a maximum number of bytes of 2^36 - 32. A write to this register triggers the engine to start using this context. This is valid for all modes except GCM and CCM. Note that for the combined modes@@ this length does not include the authentication only data; the authentication length is specified in the AES_AUTH_LENGTH register below. All modes must have a length > 0. For the combined modes@@ it is allowed to have one of the lengths equal to zero. For the basic encryption modes (ECB/CBC/CTR/ICM/CFB128) it is allowed to program zero to the length field; in that case the length is assumed infinite. All data must be byte (8-bit) aligned; bit aligned data streams are not supported by the AES Engine. For a Host read operation@@ these registers return all-zeroes.  (Read-returns0s)" id="S_C_LENGTH_0" offset="0x54" width="32">
    
  <bitfield begin="31" description="Data length (LSW)" end="0" id="RESERVED" rwaccess="RW" width="32"></bitfield>
  </register>
  
  
  <register acronym="S_C_LENGTH_1" description=" Crypto data length registers (LSW and MSW) store the cryptographic data length in bytes for all modes. Once processing with this context is started@@ this length decrements to zero. Data lengths up to (2^61 – 1) bytes are allowed. For GCM@@ any value up to 2^36 - 32 bytes can be used. This is because a 32-bit counter mode is used; the maximum number of 128-bit blocks is 2^32 – 2@@ resulting in a maximum number of bytes of 2^36 - 32. A write to this register triggers the engine to start using this context. This is valid for all modes except GCM and CCM. Note that for the combined modes@@ this length does not include the authentication only data; the authentication length is specified in the AES_AUTH_LENGTH register below. All modes must have a length > 0. For the combined modes@@ it is allowed to have one of the lengths equal to zero. For the basic encryption modes (ECB/CBC/CTR/ICM/CFB128) it is allowed to program zero to the length field; in that case the length is assumed infinite. All data must be byte (8-bit) aligned; bit aligned data streams are not supported by the AES Engine. For a Host read operation@@ these registers return all-zeroes.  (Read-returns0s)" id="S_C_LENGTH_1" offset="0x58" width="32">
    
  <bitfield begin="31" description="reserved" end="29" id="RESERVED" rwaccess="R" width="3"></bitfield>
    
  <bitfield begin="28" description="Data length (MSW) length registers (LSW and MSW) store the cryptographic data length in bytes for all modes. Once processing with this context is started@@ this length decrements to zero. Data lengths up to (2^61 – 1) bytes are allowed. For GCM@@ any value up to 2^36 - 32 bytes can be used. This is because a 32-bit counter mode is used; the maximum number of 128-bit blocks is 2^32 – 2@@ resulting in a maximum number of bytes of 2^36 - 32. A write to this register triggers the engine to start using this context. This is valid for all modes except GCM and CCM. Note that for the combined modes@@ this length does not include the authentication only data; the authentication length is specified in the AES_AUTH_LENGTH register below. All modes must have a length > 0. For the combined modes@@ it is allowed to have one of the lengths equal to zero. For the basic encryption modes (ECB/CBC/CTR/ICM/CFB128) it is allowed to program zero to the length field; in that case the length is assumed infinite. All data must be byte (8-bit) aligned; bit aligned data streams are not supported by the AES Engine. For a Host read operation@@ these registers return all-zeroes." end="0" id="LENGTH" rwaccess="RW" width="29"></bitfield>
  </register>
  
  
  <register acronym="S_AUTH_LENGTH" description=" AAD data length. The authentication length register store the authentication data length in bytes for combined modes only (GCM or CCM) Supported AAD-lengths for CCM are from 0 to (2^16 - 2^8) bytes. For GCM any value up to (2^32 - 1) bytes can be used. Once processing with this context is started@@ this length decrements to zero. A write to this register triggers the engine to start using this context for GCM and CCM. For XTS this register is optionally used to load ‘j’. Loading of ‘j’ is only required if ‘j’ != 0. ‘j’ is a 28-bit value and must be written to bits [31-4] of this register. ‘j’ represents the sequential number of the 128-bit block inside the data unit. For the first block in a unit@@ this value is zero. It is not required to provide a ‘j’ for each new data block within a unit. Note that it is possible to start with a ‘j’ unequal to zero; refer to Table 4 for more details. For a Host read operation@@ these registers return all-zeroes.  (Read-returns0s)" id="S_AUTH_LENGTH" offset="0x5C" width="32">
    
  <bitfield begin="31" description="data" end="0" id="AUTH" rwaccess="RW" width="32"></bitfield>
  </register>
  
  
  <register acronym="S_DATA_IN_0" description=" Data register to read and write plaintext/ciphertext (MSW)" id="S_DATA_IN_0" offset="0x60" width="32">
    
  <bitfield begin="31" description="Data to encrypt/decrypt" end="0" id="DATA" rwaccess="RW" width="32"></bitfield>
  </register>
  
  
  <register acronym="S_DATA_IN_1" description=" Data register to read and write plaintext/ciphertext" id="S_DATA_IN_1" offset="0x64" width="32">
    
  <bitfield begin="31" description="Data to encrypt/decrypt" end="0" id="DATA" rwaccess="RW" width="32"></bitfield>
  </register>
  
  
  <register acronym="S_DATA_IN_2" description=" Data register to read and write plaintext/ciphertext" id="S_DATA_IN_2" offset="0x68" width="32">
    
  <bitfield begin="31" description="Data to encrypt/decrypt" end="0" id="DATA" rwaccess="RW" width="32"></bitfield>
  </register>
  
  
  <register acronym="S_DATA_IN_3" description=" Data register to read and write plaintext/ciphertext (LSW)" id="S_DATA_IN_3" offset="0x6C" width="32">
    
  <bitfield begin="31" description="Data to encrypt/decrypt" end="0" id="DATA" rwaccess="RW" width="32"></bitfield>
  </register>
  
  
  <register acronym="S_TAG_OUT_0" description=" " id="S_TAG_OUT_0" offset="0x70" width="32">
    
  <bitfield begin="31" description="Hash result (MSW)" end="0" id="HASH" rwaccess="RW" width="32"></bitfield>
  </register>
  
  
  <register acronym="S_TAG_OUT_1" description=" " id="S_TAG_OUT_1" offset="0x74" width="32">
    
  <bitfield begin="31" description="Hash result (MSW)" end="0" id="HASH" rwaccess="RW" width="32"></bitfield>
  </register>
  
  
  <register acronym="S_TAG_OUT_2" description=" " id="S_TAG_OUT_2" offset="0x78" width="32">
    
  <bitfield begin="31" description="Hash result (MSW)" end="0" id="HASH" rwaccess="RW" width="32"></bitfield>
  </register>
  
  
  <register acronym="S_TAG_OUT_3" description=" " id="S_TAG_OUT_3" offset="0x7C" width="32">
    
  <bitfield begin="31" description="Hash result (LSW)" end="0" id="HASH" rwaccess="RW" width="32"></bitfield>
  </register>
  
  
  <register acronym="S_REVISION" description=" Register AES_REVISION" id="S_REVISION" offset="0x80" width="32">
    
  <bitfield begin="31" description="Used to distinguish between old scheme and current. Read�0x0 Legacy ASP or WTBU scheme Read�0x1 Highlander 0.8 scheme" end="30" id="SCHEME" rwaccess="R" width="2"></bitfield>
    
  <bitfield begin="29" description="Reserved" end="28" id="RESERVED" rwaccess="R" width="2"></bitfield>
    
  <bitfield begin="27" description="Function indicates a software compatible module family. If there is no level of software compatibility a new Func number (and hence REVISION) should be assigned." end="16" id="FUNC" rwaccess="R" width="12"></bitfield>
    
  <bitfield begin="15" description="RTL Version (R)@@ maintained by IP design owner. RTL follows a numbering such as X.Y.R.Z which are explained in this table. R changes ONLY when: (1) PDS uploads occur which may have been due to spec changes (2) Bug fixes occur (3) Resets to '0' when X or Y changes. Design team has an internal 'Z' (customer invisible) number which increments on every drop that happens due to DV and RTL updates. Z resets to 0 when R increments." end="11" id="R_RTL" rwaccess="R" width="5"></bitfield>
    
  <bitfield begin="10" description="Major Revision (X)@@ maintained by IP specification owner. X changes ONLY when: (1) There is a major feature addition. An example would be adding Master Mode to Utopia Level2. The Func field (or Class/Type in old PID format) will remain the same. X does NOT change due to: (1) Bug fixes (2) Change in feature parameters." end="8" id="X_MAJOR" rwaccess="R" width="3"></bitfield>
    
  <bitfield begin="7" description="Indicates a special version for a particular device. Consequence of use may avoid use of standard Chip Support Library (CSL) / Drivers. Read�0x0 Non custom (standard) revision" end="6" id="CUSTOM" rwaccess="R" width="2"></bitfield>
    
  <bitfield begin="5" description="Minor Revision (Y)@@ maintained by IP specification owner. Y changes ONLY when: (1) Features are scaled (up or down). Flexibility exists in that this feature scalability may either be represented in the Y change or a specific register in the IP that indicates which features are exactly available. (2) When feature creeps from Is-Not list to Is list. But this may not be the case once it sees silicon; in which case X will change. Y does NOT change due to: (1) Bug fixes (2) Typos or clarifications (3) major functional/feature change/addition/deletion. Instead these changes may be reflected via R@@ S@@ X as applicable. Spec owner maintains a customer-invisible number 'S' which changes due to: (1) Typos/clarifications (2) Bug documentation. Note that this bug is not due to a spec change but due to implementation. Nevertheless@@ the spec tracks the IP bugs. An RTL release (say for silicon PG1.1) that occurs due to bug fix should document the corresponding spec number (X.Y.S) in its release notes." end="0" id="Y_MINOR" rwaccess="R" width="6"></bitfield>
  </register>
  
  
  <register acronym="S_SYSCONFIG" description=" Register AES_SYSCONFIG.This register configures the DMA signals and controls the IDLE and reset logic" id="S_SYSCONFIG" offset="0x84" width="32">
    
  <bitfield begin="31" description="reserved" end="13" id="RESERVED" rwaccess="R" width="19"></bitfield>
    
  <bitfield begin="12" description="If this bit is set to zero, a regular cryptographic operation is performed.This bit may be set to one only if bit directbusen of this register and bit key_enc of this register are cleared to zero. If this bit is one, the K3 key is used as key for the selected cryptographic operation.If this mode is selected, the key size should be 128-bit." end="12" id="K3" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="11" description="If this bit is set to zero, a regular cryptographic operation is performed.This bit may be set to one only if bit directbusen of this register is cleared to zero. If this bit is ‘1’, the KEK (see description of bit kek_mode) key is XOR-ed with a predefined constant value before it is used as key for the selected cryptographic operation." end="11" id="KEY_ENC" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="10" description="If this bit is zero, the direct key is used directly for the selected cryptographic operation, if it is selected by enabling directbusen of this register. If the direct key is not selected, a regular operation is performed.This bit may be set to one only if bit directbusen  is set to ‘1’. If this bit is to one and the direct key bit is selected, the direct key is XOR-ed with a predefined constant value (constant1  ) before it is used as key for the cryptographic operation. If both bits are set to ‘1’, the direction of the cryptographic operation is forced to ‘encryption’ (independent of the programmed direction in the AES_S_CTRL register). The result of the operation with this XOR-ed key is automatically stored in a separate internal key register (KEK). No output data is provided in this case; reading from the data output register returns zeroes.If this mode is selected, the cryptographic mode should be set to ECB and the key size should be 128-bit.Please refer to Appendix A.5 for details on the key selection mechanism.Note that for correct behavior of the core, this bit should only be changed if the core is ready for a new context on the secure HIB." end="10" id="KEK_MODE" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="9" description="If set to '1' the two context out requests (dma_req_context_out_en@@ Bit [8] above@@ and context_out interrupt enable@@ Bit [3] of AES_IRQENABLE register) are mapped on the corresponding data output request bit. In this case@@ the original ‘context out’ bit values are ignored." end="9" id="MAP_CONTEXT_OUT_ON_DATA_OUT" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="8" description="If set to ‘1’@@ the DMA context output request is enabled (for context data out@@ e.g. TAG for authentication modes). 0 Dma disabled 1 Dma enabled" end="8" id="DMA_REQ_CONTEXT_OUT_EN" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="7" description="If set to ‘1’@@ the DMA context request is enabled. 0 Dma disabled 1 Dma enabled" end="7" id="DMA_REQ_CONTEXT_IN_EN" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="6" description="If set to ‘1’@@ the DMA output request is enabled. 0 Dma disabled 1 Dma enabled" end="6" id="DMA_REQ_DATA_OUT_EN" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="5" description="If set to ‘1’@@ the DMA input request is enabled. 0 Dma disabled 1 Dma enabled" end="5" id="DMA_REQ_DATA_IN_EN" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="4" description="keys from register or directbus input 0:  Use the key registers  1:  Use the directbus" end="4" id="DIRECTBUSEN" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="3" description="sidle mode 0x0:  Force Idle mode.  0x1:  No idle  0x2:  Smart Idle mode  0x3:  reserved" end="2" id="SIDLE" rwaccess="RW" width="2"></bitfield>
    
  <bitfield begin="1" description="softreset 0:  No operation.  1:  When '1', starts softreset sequnce. " end="1" id="SOFTRESET" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="0" description="autoidle  0:  When '0', internal clocks are running.  1:  When '1', internal clocks are cut. " end="0" id="AUTOIDLE" rwaccess="RW" width="1"></bitfield>
  </register>
  
  
  <register acronym="S_SYSSTATUS" description=" " id="S_SYSSTATUS" offset="0x88" width="32">
    
  <bitfield begin="31" description="reserved" end="1" id="RESERVED" rwaccess="R" width="31"></bitfield>
    
  <bitfield begin="0" description="" end="0" id="RESETDONE" rwaccess="RW" width="1"></bitfield>
  </register>
  
  
  <register acronym="S_IRQSTATUS" description=" This register indicates the interrupt status. If one of the interrupt bits is set the interrupt output will be asserted" id="S_IRQSTATUS" offset="0x8C" width="32">
    
  <bitfield begin="31" description="reserved" end="4" id="RESERVED" rwaccess="R" width="28"></bitfield>
    
  <bitfield begin="3" description="This bit indicates authentication tag (and IV) interrupt(s) is/are active and triggers the interrupt output." end="3" id="CONTEXT_OUT" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="2" description="This bit indicates data output interrupt is active and triggers the interrupt output." end="2" id="DATA_OUT" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="1" description="This bit indicates data input interrupt is active and triggers the interrupt output." end="1" id="DATA_IN" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="0" description="This bit indicates context interrupt is active and triggers the interrupt output." end="0" id="CONTEX_IN" rwaccess="RW" width="1"></bitfield>
  </register>
  
  
  <register acronym="S_IRQENABLE" description=" This register contains an enable bit for each unique interrupt generated by the module. It matches the layout of AES_IRQSTATUS register. An interrupt is enabled when the bit in this register is set to ‘1’. An interrupt that is enabled is propagated to the SINTREQUEST_x output. All interrupts need to be enabled explicitly by writing this register." id="S_IRQENABLE" offset="0x90" width="32">
    
  <bitfield begin="31" description="reserved" end="4" id="RESERVED" rwaccess="R" width="28"></bitfield>
    
  <bitfield begin="3" description="This bit indicates authentication tag (and IV) interrupt(s) is/are active and triggers the interrupt output." end="3" id="CONTEXT_OUT" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="2" description="This bit indicates data output interrupt is active and triggers the interrupt output." end="2" id="DATA_OUT" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="1" description="This bit indicates data input interrupt is active and triggers the interrupt output." end="1" id="DATA_IN" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="0" description="This bit indicates context interrupt is active and triggers the interrupt output." end="0" id="CONTEX_IN" rwaccess="RW" width="1"></bitfield>
  </register>
  
  
  <register acronym="S_DIRTYBITS" id="S_DIRTYBITS" offset="0x94" width="32">
    
  <bitfield begin="31" description="reserved" end="4" id="RESERVED" rwaccess="R" width="28"></bitfield>
    
  <bitfield begin="3" description="This bit is set to 1 by the module if any of the AES_P_* registers is written. W1toClr" end="3" id="P_DIRTY" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="2" description="This bit is set to 1 by the module if any of the AES_P_* registers is read.W1toClr" end="2" id="P_ACCESS" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="1" description="This bit is set to 1 by the module if any of the AES_S_*  registers is written. Except AES_S_DIRTYBITS and AES_S_LOCKDOWN. W1toClr" end="1" id="S_DIRTY" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="0" description="This bit is set to 1 by the module if any of the AES_S_* registers is read. Except AES_S_DIRTYBITS and AES_S_LOCKDOWN. W1toClr" end="0" id="S_ACCESS" rwaccess="RW" width="1"></bitfield>
  </register>
  
  
  <register acronym="S_LOCKDOWN" id="S_LOCKDOWN" offset="0x98" width="32">
    
  <bitfield begin="31" description="reserved" end="6" id="RESERVED" rwaccess="R" width="26"></bitfield>
    
  <bitfield begin="5" description="If set to ‘1’ the DES_P length registers can not be written (this lock involves word address from 0x1054 to 0x105c)." end="5" id="LENGTH_LOCK" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="4" description="If set to ‘1’ the AES_P control register can not be written (this lock involves word address 0x1050)." end="4" id="CONTROL_LOCK" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="3" description="If set to ‘1’ the AES_P IV registers cannot be written (this lock involves word addresses 0x1040 up to 0x104C)." end="3" id="IV_LOCK" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="2" description="If set to ‘1’ the AES_P  key3 registers cannot be written (this lock involves word addresses 0x1030 up to 0x103C)." end="2" id="KEY3_LOCK" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="1" description="If set to ‘1’ the AES_P  key2 registers cannot be written (this lock involves word addresses 0x1020 up to 0x102C)." end="1" id="KEY2_LOCK" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="0" description="If set to ‘1’ the AES_P  key registers cannot be written (this lock involves word addresses 0x1000 up to 0x101C)." end="0" id="KEY_LOCK" rwaccess="RW" width="1"></bitfield>
  </register>
  
  
  <register acronym="P_KEY2_6" description=" XTS second key / CBC-MAC third key (Read-returns0s)" id="P_KEY2_6" offset="0x1000" width="32">
    
  <bitfield begin="31" description="key data" end="0" id="KEY" rwaccess="RW" width="32"></bitfield>
  </register>
  
  
  <register acronym="P_KEY2_7" description=" XTS second key (MSW for 256-bit key) / CBC-MAC third key (MSW) (Read-returns0s)" id="P_KEY2_7" offset="0x1004" width="32">
    
  <bitfield begin="31" description="key data" end="0" id="KEY" rwaccess="RW" width="32"></bitfield>
  </register>
  
  
  <register acronym="P_KEY2_4" description=" XTS / CCM second key / CBC-MAC third key (LSW) (Read-returns0s)" id="P_KEY2_4" offset="0x1008" width="32">
    
  <bitfield begin="31" description="key data" end="0" id="KEY" rwaccess="RW" width="32"></bitfield>
  </register>
  
  
  <register acronym="P_KEY2_5" description=" XTS second key (MSW for 192-bit key) / CBC-MAC third key (Read-returns0s)" id="P_KEY2_5" offset="0x100C" width="32">
    
  <bitfield begin="31" description="key data" end="0" id="KEY" rwaccess="RW" width="32"></bitfield>
  </register>
  
  
  <register acronym="P_KEY2_2" description=" XTS / CCM / CBC-MAC second key / Hash Key input (Read-returns0s)" id="P_KEY2_2" offset="0x1010" width="32">
    
  <bitfield begin="31" description="key data" end="0" id="KEY" rwaccess="RW" width="32"></bitfield>
  </register>
  
  
  <register acronym="P_KEY2_3" description=" XTS second key (MSW for 128-bit key) + CCM/CBC-MAC second key (MSW) / Hash Key input (MSW) (Read-returns0s)" id="P_KEY2_3" offset="0x1014" width="32">
    
  <bitfield begin="31" description="key data" end="0" id="KEY" rwaccess="RW" width="32"></bitfield>
  </register>
  
  
  <register acronym="P_KEY2_0" description=" XTS / CCM / CBC-MAC second key (LSW) / Hash Key input (LSW) (Read-returns0s)" id="P_KEY2_0" offset="0x1018" width="32">
    
  <bitfield begin="31" description="key data" end="0" id="KEY" rwaccess="RW" width="32"></bitfield>
  </register>
  
  
  <register acronym="P_KEY2_1" description=" XTS / CCM / CBC-MAC second key / Hash Key input (Read-returns0s)" id="P_KEY2_1" offset="0x101C" width="32">
    
  <bitfield begin="31" description="key data" end="0" id="KEY" rwaccess="RW" width="32"></bitfield>
  </register>
  
  
  <register acronym="P_KEY1_6" description=" Key (LSW for 256-bit key) (Read-returns0s)" id="P_KEY1_6" offset="0x1020" width="32">
    
  <bitfield begin="31" description="key data" end="0" id="KEY" rwaccess="RW" width="32"></bitfield>
  </register>
  
  
  <register acronym="P_KEY1_7" description=" Key (MSW for 256-bit key) (Read-returns0s)" id="P_KEY1_7" offset="0x1024" width="32">
    
  <bitfield begin="31" description="key data" end="0" id="KEY" rwaccess="RW" width="32"></bitfield>
  </register>
  
  
  <register acronym="P_KEY1_4" description=" Key (LSW for 192-bit key) (Read-returns0s)" id="P_KEY1_4" offset="0x1028" width="32">
    
  <bitfield begin="31" description="key data" end="0" id="KEY" rwaccess="RW" width="32"></bitfield>
  </register>
  
  
  <register acronym="P_KEY1_5" description=" Key (MSW for 192-bit key) (Read-returns0s)" id="P_KEY1_5" offset="0x102C" width="32">
    
  <bitfield begin="31" description="key data" end="0" id="KEY" rwaccess="RW" width="32"></bitfield>
  </register>
  
  
  <register acronym="P_KEY1_2" description=" Key (Read-returns0s)" id="P_KEY1_2" offset="0x1030" width="32">
    
  <bitfield begin="31" description="key data" end="0" id="KEY" rwaccess="RW" width="32"></bitfield>
  </register>
  
  
  <register acronym="P_KEY1_3" description=" Key (MSW for 128-bit key) (Read-returns0s)" id="P_KEY1_3" offset="0x1034" width="32">
    
  <bitfield begin="31" description="key data" end="0" id="KEY" rwaccess="RW" width="32"></bitfield>
  </register>
  
  
  <register acronym="P_KEY1_0" description=" Key (LSW for 128-bit key) (Read-returns0s)" id="P_KEY1_0" offset="0x1038" width="32">
    
  <bitfield begin="31" description="key data" end="0" id="KEY" rwaccess="RW" width="32"></bitfield>
  </register>
  
  
  <register acronym="P_KEY1_1" description=" Key (Read-returns0s)" id="P_KEY1_1" offset="0x103C" width="32">
    
  <bitfield begin="31" description="key data" end="0" id="KEY" rwaccess="RW" width="32"></bitfield>
  </register>
  
  
  <register acronym="P_IV_IN_0" description=" Initialization Vector input (LSW)" id="P_IV_IN_0" offset="0x1040" width="32">
    
  <bitfield begin="31" description="IV data" end="0" id="DATA" rwaccess="RW" width="32"></bitfield>
  </register>
  
  
  <register acronym="P_IV_IN_1" description=" Initialization vector input" id="P_IV_IN_1" offset="0x1044" width="32">
    
  <bitfield begin="31" description="IV data" end="0" id="DATA" rwaccess="RW" width="32"></bitfield>
  </register>
  
  
  <register acronym="P_IV_IN_2" description=" Initialization vector input" id="P_IV_IN_2" offset="0x1048" width="32">
    
  <bitfield begin="31" description="IV data" end="0" id="DATA" rwaccess="RW" width="32"></bitfield>
  </register>
  
  
  <register acronym="P_IV_IN_3" description=" Initialization Vector input (MSW)" id="P_IV_IN_3" offset="0x104C" width="32">
    
  <bitfield begin="31" description="IV data" end="0" id="DATA" rwaccess="RW" width="32"></bitfield>
  </register>
  
  
  <register acronym="P_CTRL" description=" register determines the mode of operation of the AES Engine" id="P_CTRL" offset="0x1050" width="32">
    
  <bitfield begin="31" description="If ‘1’@@ this read-only status bit indicates that the context data registers can be overwritten and the host is permitted to write the next context." end="31" id="CONTEXT_READY" rwaccess="R" width="1"></bitfield>
    
  <bitfield begin="30" description="If ‘1’@@ this read-only status bit indicates that an AES authentication TAG and/or IV block(s) is/are available for the host to retrieve. This bit is only asserted if the ‘save_context’ bit is set to ‘1’. The bit is mutual exclusive with the ‘context_ready’ bit." end="30" id="SAVE_CONTEXT_READY" rwaccess="R" width="1"></bitfield>
    
  <bitfield begin="29" description="This bit is used to indicate that an authentication TAG or result IV needs to be stored as a result context. If this bit is set@@ context output DMA and/or interrupt will be asserted if the operation is finished and related signals are enabled." end="29" id="SAVE_CONTEXT" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="28" description="reserved" end="25" id="RESERVED" rwaccess="R" width="4"></bitfield>
    
  <bitfield begin="24" description="Defines “M” that indicated the length of the authentication field for CCM operations; the authentication field length equals two times (the value of CCM-M plus one). Note that the AES Engine always returns a 128-bit authentication field@@ of which the M least significant bytes are valid. All values are supported." end="22" id="CCM_M" rwaccess="RW" width="3"></bitfield>
    
  <bitfield begin="21" description="Defines “L” that indicated the width of the length field for CCM operations; the length field in bytes equals the value of CMM-L plus one. Supported values for L are (programmed value): 2 (1)@@ 4 (3) and 8 (7)." end="19" id="CCM_L" rwaccess="RW" width="3"></bitfield>
    
  <bitfield begin="18" description="AES-CCM is selected@@ this is a combined mode@@ using AES for both authentication and encryption. No additional mode selection is required. 0 Other mode selected 1 ccm mode selected" end="18" id="CCM" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="17" description="AES-GCM mode is selected.this is a combined mode@@ using the Galois field multiplier GF(2^128) for authentication and AES-CTR mode for encryption@@ the bits specify the GCM mode. 0x0 No operation 0x1 GHASH with H loaded and Y0-encrypted forced to zero 0x2 GHASH with H loaded and Y0-encrypted calculated internally 0x3 Autonomous GHASH (both H and Y0-encrypted calculated internally)" end="16" id="GCM" rwaccess="RW" width="2"></bitfield>
    
  <bitfield begin="15" description="AES-CBC MAC is selected@@ the Direction bit must be set to ‘1’ for this mode. 0 Other mode selected 1 cbcmac mode selected" end="15" id="CBCMAC" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="14" description="AES f9 mode is selected@@ the AES key size must be set to 128-bit for this mode. 0 Other mode selected 1 f9 selected" end="14" id="F9" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="13" description="AES f8 mode is selected@@ the AES key size must be set to 128-bit for this mode. 0 Other mode selected 1 f8 selected" end="13" id="F8" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="12" description="AES-XTS operation is selected; the bits specify the XTS mode.01 = Previous/intermediate tweak value and ‘j’ loaded (value is loaded via IV@@ j is loaded via the AAD length register) 0x0 No operation 0x1 Previous/intermediate tweak value and ‘j’ loaded (value is loaded via IV@@ j is loaded via the AAD length register) 0x2 Key2@@ i and j loaded (i is loaded via IV@@ j is loaded via the AAD length register) 0x3 Key2 and i loaded@@ j=0 (i is loaded via IV)" end="11" id="XTS" rwaccess="RW" width="2"></bitfield>
    
  <bitfield begin="10" description="full block AES cipher feedback mode (CFB128) is selected. 0 other mode selected 1 cfb selected" end="10" id="CFB" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="9" description="AES integer counter mode (ICM) is selected@@ this is a counter mode with a 16-bit wide counter. 0 Other mode selected. 1 ICM mode selected" end="9" id="ICM" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="8" description="Specifies the counter width for AES-CTR mode 0x0 Counter is 32 bits 0x1 Counter is 64 bits 0x2 Counter is 128 bits 0x3 Counter is 192 bits" end="7" id="CTR_WIDTH" rwaccess="RW" width="2"></bitfield>
    
  <bitfield begin="6" description="Tthis bit must also be set for GCM and CCM@@ when encryption/decryption is required. 0 Other mode selected 1 Counter mode" end="6" id="CTR" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="5" description="ecb/cbc mode 0 ecb mode 1 cbc mode" end="5" id="MODE" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="4" description="key size 0x0 reserved 0x1 Key is 128 bits. 0x2 Key is 192 bits 0x3 Key is 256" end="3" id="KEY_SIZE" rwaccess="RW" width="2"></bitfield>
    
  <bitfield begin="2" description="If set to ‘1’ an encrypt operation is performed. If set to ‘0’ a decrypt operation is performed. Read 0 decryption is selected Read 1 Encryption is selected" end="2" id="DIRECTION" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="1" description="If ‘1’@@ this read-only status bit indicates that the 16-byte input buffer is empty@@ and the host is permitted to write the next block of data." end="1" id="INPUT_READY" rwaccess="R" width="1"></bitfield>
    
  <bitfield begin="0" description="If ‘1’@@ this read-only status bit indicates that an AES output block is available for the host to retrieve." end="0" id="OUTPUT_READY" rwaccess="R" width="1"></bitfield>
  </register>
  
  
  <register acronym="P_C_LENGTH_0" description=" Crypto data length registers (LSW and MSW) store the cryptographic data length in bytes for all modes. Once processing with this context is started@@ this length decrements to zero. Data lengths up to (2^61 – 1) bytes are allowed. For GCM@@ any value up to 2^36 - 32 bytes can be used. This is because a 32-bit counter mode is used; the maximum number of 128-bit blocks is 2^32 – 2@@ resulting in a maximum number of bytes of 2^36 - 32. A write to this register triggers the engine to start using this context. This is valid for all modes except GCM and CCM. Note that for the combined modes@@ this length does not include the authentication only data; the authentication length is specified in the AES_AUTH_LENGTH register below. All modes must have a length > 0. For the combined modes@@ it is allowed to have one of the lengths equal to zero. For the basic encryption modes (ECB/CBC/CTR/ICM/CFB128) it is allowed to program zero to the length field; in that case the length is assumed infinite. All data must be byte (8-bit) aligned; bit aligned data streams are not supported by the AES Engine. For a Host read operation@@ these registers return all-zeroes.  (Read-returns0s)" id="P_C_LENGTH_0" offset="0x1054" width="32">
    
  <bitfield begin="31" description="Data length (LSW)" end="0" id="RESERVED" rwaccess="RW" width="32"></bitfield>
  </register>
  
  
  <register acronym="P_C_LENGTH_1" description=" Crypto data length registers (LSW and MSW) store the cryptographic data length in bytes for all modes. Once processing with this context is started@@ this length decrements to zero. Data lengths up to (2^61 – 1) bytes are allowed. For GCM@@ any value up to 2^36 - 32 bytes can be used. This is because a 32-bit counter mode is used; the maximum number of 128-bit blocks is 2^32 – 2@@ resulting in a maximum number of bytes of 2^36 - 32. A write to this register triggers the engine to start using this context. This is valid for all modes except GCM and CCM. Note that for the combined modes@@ this length does not include the authentication only data; the authentication length is specified in the AES_AUTH_LENGTH register below. All modes must have a length > 0. For the combined modes@@ it is allowed to have one of the lengths equal to zero. For the basic encryption modes (ECB/CBC/CTR/ICM/CFB128) it is allowed to program zero to the length field; in that case the length is assumed infinite. All data must be byte (8-bit) aligned; bit aligned data streams are not supported by the AES Engine. For a Host read operation@@ these registers return all-zeroes.  (Read-returns0s)" id="P_C_LENGTH_1" offset="0x1058" width="32">
    
  <bitfield begin="31" description="reserved" end="29" id="RESERVED" rwaccess="R" width="3"></bitfield>
    
  <bitfield begin="28" description="Data length (MSW) length registers (LSW and MSW) store the cryptographic data length in bytes for all modes. Once processing with this context is started@@ this length decrements to zero. Data lengths up to (2^61 – 1) bytes are allowed. For GCM@@ any value up to 2^36 - 32 bytes can be used. This is because a 32-bit counter mode is used; the maximum number of 128-bit blocks is 2^32 – 2@@ resulting in a maximum number of bytes of 2^36 - 32. A write to this register triggers the engine to start using this context. This is valid for all modes except GCM and CCM. Note that for the combined modes@@ this length does not include the authentication only data; the authentication length is specified in the AES_AUTH_LENGTH register below. All modes must have a length > 0. For the combined modes@@ it is allowed to have one of the lengths equal to zero. For the basic encryption modes (ECB/CBC/CTR/ICM/CFB128) it is allowed to program zero to the length field; in that case the length is assumed infinite. All data must be byte (8-bit) aligned; bit aligned data streams are not supported by the AES Engine. For a Host read operation@@ these registers return all-zeroes." end="0" id="LENGTH" rwaccess="RW" width="29"></bitfield>
  </register>
  
  
  <register acronym="P_AUTH_LENGTH" description=" AAD data length. The authentication length register store the authentication data length in bytes for combined modes only (GCM or CCM) Supported AAD-lengths for CCM are from 0 to (2^16 - 2^8) bytes. For GCM any value up to (2^32 - 1) bytes can be used. Once processing with this context is started@@ this length decrements to zero. A write to this register triggers the engine to start using this context for GCM and CCM. For XTS this register is optionally used to load ‘j’. Loading of ‘j’ is only required if ‘j’ != 0. ‘j’ is a 28-bit value and must be written to bits [31-4] of this register. ‘j’ represents the sequential number of the 128-bit block inside the data unit. For the first block in a unit@@ this value is zero. It is not required to provide a ‘j’ for each new data block within a unit. Note that it is possible to start with a ‘j’ unequal to zero; refer to Table 4 for more details. For a Host read operation@@ these registers return all-zeroes.  (Read-returns0s)" id="P_AUTH_LENGTH" offset="0x105C" width="32">
    
  <bitfield begin="31" description="data" end="0" id="AUTH" rwaccess="RW" width="32"></bitfield>
  </register>
  
  
  <register acronym="P_DATA_IN_0" description=" Data register to read and write plaintext/ciphertext (MSW)" id="P_DATA_IN_0" offset="0x1060" width="32">
    
  <bitfield begin="31" description="Data to encrypt/decrypt" end="0" id="DATA" rwaccess="RW" width="32"></bitfield>
  </register>
  
  
  <register acronym="P_DATA_IN_1" description=" Data register to read and write plaintext/ciphertext" id="P_DATA_IN_1" offset="0x1064" width="32">
    
  <bitfield begin="31" description="Data to encrypt/decrypt" end="0" id="DATA" rwaccess="RW" width="32"></bitfield>
  </register>
  
  
  <register acronym="P_DATA_IN_2" description=" Data register to read and write plaintext/ciphertext" id="P_DATA_IN_2" offset="0x1068" width="32">
    
  <bitfield begin="31" description="Data to encrypt/decrypt" end="0" id="DATA" rwaccess="RW" width="32"></bitfield>
  </register>
  
  
  <register acronym="P_DATA_IN_3" description=" Data register to read and write plaintext/ciphertext (LSW)" id="P_DATA_IN_3" offset="0x106C" width="32">
    
  <bitfield begin="31" description="Data to encrypt/decrypt" end="0" id="DATA" rwaccess="RW" width="32"></bitfield>
  </register>
  
  
  <register acronym="P_TAG_OUT_0" description=" " id="P_TAG_OUT_0" offset="0x1070" width="32">
    
  <bitfield begin="31" description="Hash result (MSW)" end="0" id="HASH" rwaccess="RW" width="32"></bitfield>
  </register>
  
  
  <register acronym="P_TAG_OUT_1" description=" " id="P_TAG_OUT_1" offset="0x1074" width="32">
    
  <bitfield begin="31" description="Hash result (MSW)" end="0" id="HASH" rwaccess="RW" width="32"></bitfield>
  </register>
  
  
  <register acronym="P_TAG_OUT_2" description=" " id="P_TAG_OUT_2" offset="0x1078" width="32">
    
  <bitfield begin="31" description="Hash result (MSW)" end="0" id="HASH" rwaccess="RW" width="32"></bitfield>
  </register>
  
  
  <register acronym="P_TAG_OUT_3" description=" " id="P_TAG_OUT_3" offset="0x107C" width="32">
    
  <bitfield begin="31" description="Hash result (LSW)" end="0" id="HASH" rwaccess="RW" width="32"></bitfield>
  </register>
  
  
  <register acronym="P_REVISION" description=" Register AES_REVISION" id="P_REVISION" offset="0x1080" width="32">
    
  <bitfield begin="31" description="Used to distinguish between old scheme and current. Read�0x0 Legacy ASP or WTBU scheme Read�0x1 Highlander 0.8 scheme" end="30" id="SCHEME" rwaccess="R" width="2"></bitfield>
    
  <bitfield begin="29" description="Reserved" end="28" id="RESERVED" rwaccess="R" width="2"></bitfield>
    
  <bitfield begin="27" description="Function indicates a software compatible module family. If there is no level of software compatibility a new Func number (and hence REVISION) should be assigned." end="16" id="FUNC" rwaccess="R" width="12"></bitfield>
    
  <bitfield begin="15" description="RTL Version (R)@@ maintained by IP design owner. RTL follows a numbering such as X.Y.R.Z which are explained in this table. R changes ONLY when: (1) PDS uploads occur which may have been due to spec changes (2) Bug fixes occur (3) Resets to '0' when X or Y changes. Design team has an internal 'Z' (customer invisible) number which increments on every drop that happens due to DV and RTL updates. Z resets to 0 when R increments." end="11" id="R_RTL" rwaccess="R" width="5"></bitfield>
    
  <bitfield begin="10" description="Major Revision (X)@@ maintained by IP specification owner. X changes ONLY when: (1) There is a major feature addition. An example would be adding Master Mode to Utopia Level2. The Func field (or Class/Type in old PID format) will remain the same. X does NOT change due to: (1) Bug fixes (2) Change in feature parameters." end="8" id="X_MAJOR" rwaccess="R" width="3"></bitfield>
    
  <bitfield begin="7" description="Indicates a special version for a particular device. Consequence of use may avoid use of standard Chip Support Library (CSL) / Drivers. Read�0x0 Non custom (standard) revision" end="6" id="CUSTOM" rwaccess="R" width="2"></bitfield>
    
  <bitfield begin="5" description="Minor Revision (Y)@@ maintained by IP specification owner. Y changes ONLY when: (1) Features are scaled (up or down). Flexibility exists in that this feature scalability may either be represented in the Y change or a specific register in the IP that indicates which features are exactly available. (2) When feature creeps from Is-Not list to Is list. But this may not be the case once it sees silicon; in which case X will change. Y does NOT change due to: (1) Bug fixes (2) Typos or clarifications (3) major functional/feature change/addition/deletion. Instead these changes may be reflected via R@@ S@@ X as applicable. Spec owner maintains a customer-invisible number 'S' which changes due to: (1) Typos/clarifications (2) Bug documentation. Note that this bug is not due to a spec change but due to implementation. Nevertheless@@ the spec tracks the IP bugs. An RTL release (say for silicon PG1.1) that occurs due to bug fix should document the corresponding spec number (X.Y.S) in its release notes." end="0" id="Y_MINOR" rwaccess="R" width="6"></bitfield>
  </register>
  
  
  <register acronym="P_SYSCONFIG" description=" Register AES_SYSCONFIG.This register configures the DMA signals and controls the IDLE and reset logic" id="P_SYSCONFIG" offset="0x1084" width="32">
    
  <bitfield begin="31" description="reserved" end="10" id="RESERVED" rwaccess="RW" width="22"></bitfield>
    
  <bitfield begin="9" description="If set to '1' the two context out requests (dma_req_context_out_en@@ Bit [8] above@@ and context_out interrupt enable@@ Bit [3] of AES_IRQENABLE register) are mapped on the corresponding data output request bit. In this case@@ the original ‘context out’ bit values are ignored." end="9" id="MAP_CONTEXT_OUT_ON_DATA_OUT" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="8" description="If set to ‘1’@@ the DMA context output request is enabled (for context data out@@ e.g. TAG for authentication modes). 0 Dma disabled 1 Dma enabled" end="8" id="DMA_REQ_CONTEXT_OUT_EN" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="7" description="If set to ‘1’@@ the DMA context request is enabled. 0 Dma disabled 1 Dma enabled" end="7" id="DMA_REQ_CONTEXT_IN_EN" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="6" description="If set to ‘1’@@ the DMA output request is enabled. 0 Dma disabled 1 Dma enabled" end="6" id="DMA_REQ_DATA_OUT_EN" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="5" description="If set to ‘1’@@ the DMA input request is enabled. 0 Dma disabled 1 Dma enabled" end="5" id="DMA_REQ_DATA_IN_EN" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="4" description="keys from register or directbus input 0:  Use the key registers  1:  Use the directbus" end="4" id="DIRECTBUSEN" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="3" description="sidle mode 0x0:  Force Idle mode.  0x1:  No idle  0x2:  Smart Idle mode  0x3:  reserved" end="2" id="SIDLE" rwaccess="RW" width="2"></bitfield>
    
  <bitfield begin="1" description="softreset 0:  No operation.  1:  When '1', starts softreset sequnce. " end="1" id="SOFTRESET" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="0" description="autoidle  0:  When '0', internal clocks are running.  1:  When '1', internal clocks are cut. " end="0" id="AUTOIDLE" rwaccess="RW" width="1"></bitfield>
  </register>
  
  
  <register acronym="P_SYSSTATUS" description=" " id="P_SYSSTATUS" offset="0x1088" width="32">
    
  <bitfield begin="31" description="reserved" end="1" id="RESERVED" rwaccess="R" width="31"></bitfield>
    
  <bitfield begin="0" description="" end="0" id="RESETDONE" rwaccess="RW" width="1"></bitfield>
  </register>
  
  
  <register acronym="P_IRQSTATUS" description=" This register indicates the interrupt status. If one of the interrupt bits is set the interrupt output will be asserted" id="P_IRQSTATUS" offset="0x108C" width="32">
    
  <bitfield begin="31" description="reserved" end="4" id="RESERVED" rwaccess="R" width="28"></bitfield>
    
  <bitfield begin="3" description="This bit indicates authentication tag (and IV) interrupt(s) is/are active and triggers the interrupt output." end="3" id="CONTEXT_OUT" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="2" description="This bit indicates data output interrupt is active and triggers the interrupt output." end="2" id="DATA_OUT" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="1" description="This bit indicates data input interrupt is active and triggers the interrupt output." end="1" id="DATA_IN" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="0" description="This bit indicates context interrupt is active and triggers the interrupt output." end="0" id="CONTEX_IN" rwaccess="RW" width="1"></bitfield>
  </register>
  
  
  <register acronym="P_IRQENABLE" description=" This register contains an enable bit for each unique interrupt generated by the module. It matches the layout of AES_IRQSTATUS register. An interrupt is enabled when the bit in this register is set to ‘1’. An interrupt that is enabled is propagated to the SINTREQUEST_x output. All interrupts need to be enabled explicitly by writing this register." id="P_IRQENABLE" offset="0x1090" width="32">
    
  <bitfield begin="31" description="reserved" end="4" id="RESERVED" rwaccess="R" width="28"></bitfield>
    
  <bitfield begin="3" description="This bit indicates authentication tag (and IV) interrupt(s) is/are active and triggers the interrupt output." end="3" id="CONTEXT_OUT" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="2" description="This bit indicates data output interrupt is active and triggers the interrupt output." end="2" id="DATA_OUT" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="1" description="This bit indicates data input interrupt is active and triggers the interrupt output." end="1" id="DATA_IN" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="0" description="This bit indicates context interrupt is active and triggers the interrupt output." end="0" id="CONTEX_IN" rwaccess="RW" width="1"></bitfield>
  </register>
</module>
