/********************************************************************/
/* f280040c.gel                                                     */
/* Version 1.00.00.00                                               */
/*                                                                  */
/* This GEL file is to be used with the TMS320F280040C DSP.         */
/* Changes may be required to support specific hardware designs.    */
/*                                                                  */
/* Code Composer Studio supports six reserved GEL functions that    */
/* automatically get executed if they are defined. They are:        */
/*                                                                  */
/* StartUp()              - Executed whenever CCS is invoked        */
/* OnReset()              - Executed after Debug->Reset CPU         */
/* OnRestart()            - Executed after Debug->Restart           */
/* OnPreFileLoaded()      - Executed before File->Load Program      */
/* OnFileLoaded()         - Executed after File->Load Program       */
/* OnTargetConnect()      - Executed after Debug->Connect           */
/*                                                                  */
/********************************************************************/

StartUp()
{

}

OnReset(int nErrorCode)
{

    *(int *)0x5FB00 = 0; 		/* Disable Flash ECC */
    *(int *)0x7029 = 0x68;  		/* Disable WD */
    
    *(unsigned long *)0x7060 = 0x0001;  /* Enable NMI */
    
    SetupDCSM();  						/* Initialize DCSM */

    SetupErrorStatusPin();              /* setup error status pin */
    
    Device_Config();
      
    if (GEL_IsInRealtimeMode())     /* If in real-time-mode */
	{
	}
	else                            /* Put device into C28x Mode */
	{
	  C28x_Mode();   
	}

}

OnRestart(int nErrorCode)
{
/* CCS will call OnRestart() when you do a Debug->Restart and   */
/* after you load a new file.  Between running interrupt based  */
/* programs, this function will clear interrupts and help keep  */
/* the processor from going off into invalid memory.            */
    if (GEL_IsInRealtimeMode())     /* If in real-time-mode */
	{
	}
	else                            /* Put device into C28x Mode */
	{
	  C28x_Mode();   
	}
     IER = 0;
     IFR = 0;
}

OnPreFileLoaded()
{
	GEL_Reset();
}

OnFileLoaded(int nErrorCode, int bSymbolsOnly)
{

}

OnTargetConnect()
{

    *(int *)0x5F412 =0x0003;      /* RAM INIT FOR M0/M1 Memory        */
    *(int *)0x5F432 =0x00FF;      /* RAM INIT FOR LS0..LS7  Memory    */
    *(int *)0x5F452 =0x000F;      /* RAM INIT FOR GS0..GS3 Memory     */

    if (GEL_IsInRealtimeMode())     /* If in real-time-mode */
    {
    }
    else                            /* Put device into C28x Mode */
    {
        C28x_Mode();   
    }

    F280040C_Memory_Map();        /* Initialize the CCS memory map */

/* Check to see if CCS has been started-up with the DSP already */
/* running in real-time mode.  The user can add whatever        */
/* custom initialization stuff they want to each case.          */

    if (GEL_IsInRealtimeMode())     /* Do real-time mode target initialization */
    {

    }
    else                            /* Do stop-mode target initialization */
    {
        GEL_Reset();                /* Reset DSP */
    }
}


/********************************************************************/
/* These functions are useful to engage/disengage realtime          */
/* emulation mode during debug.  They save the user from having to  */
/* manually perform these steps in CCS.                             */
/********************************************************************/
menuitem "Realtime Emulation Control";

hotmenu Run_Realtime_with_Reset()
{
    GEL_Reset();                /* Reset the DSP */
    ST1 = ST1 & 0xFFFD;         /* clear DBGM bit in ST1 */
    GEL_EnableRealtime();       /* Enable Realtime mode */
    GEL_Run();                  /* Run the DSP */
}
hotmenu Run_Realtime_with_Restart()
{
    GEL_Restart();              /* Reset the DSP */
    ST1 = ST1 & 0xFFFD;         /* clear DBGM bit in ST1 */
    GEL_EnableRealtime();       /* Enable Realtime mode */
    GEL_Run();                  /* Run the DSP */
}
hotmenu Full_Halt()
{
    GEL_DisableRealtime();      /* Disable Realtime mode */
    GEL_Halt();                 /* Halt the DSP */
}
hotmenu Full_Halt_with_Reset()
{
    GEL_DisableRealtime();      /* Disable Realtime mode */
    GEL_Halt();                 /* Halt the DSP */
    GEL_Reset();                /* Reset the DSP */
}

/*********************************************************************/
/*                         F280040C Memory Map                       */
/*                                                                   */
/*********************************************************************/
menuitem "Initialize Memory Map";

hotmenu F280040C_Memory_Map()
{
    /* GEL_MapReset(); */
    GEL_MapOn();

    /* Program memory maps */
    GEL_MapAddStr(0x00000000,0, 0x400, "R|W|AS2",0);                     /*   M0 RAM (with ECC) (2 KByte)                             */
    GEL_MapAddStr(0x00000400,0, 0x400, "R|W|AS2",0);                     /*   M1 RAM (with ECC) (2 KByte)                             */
    GEL_MapAddStr(0x00008000,0, 0x800, "R|W|AS2",0);                     /*   LS0 RAM (with PARITY) (4KBytes)                         */
    GEL_MapAddStr(0x00008800,0, 0x800, "R|W|AS2",0);                     /*   LS1 RAM (with PARITY) (4KBytes)                         */
    GEL_MapAddStr(0x00009000,0, 0x800, "R|W|AS2",0);                     /*   LS2 RAM (with PARITY) (4KBytes)                         */
    GEL_MapAddStr(0x00009800,0, 0x800, "R|W|AS2",0);                     /*   LS3 RAM (with PARITY) (4KBytes)                         */
    GEL_MapAddStr(0x0000A000,0, 0x800, "R|W|AS2",0);                     /*   LS4 RAM (with PARITY) (4KBytes)                         */
    GEL_MapAddStr(0x0000A800,0, 0x800, "R|W|AS2",0);                     /*   LS5 RAM (with PARITY) (4KBytes)                         */   
    GEL_MapAddStr(0x0000B000,0, 0x800, "R|W|AS2",0);                     /*   LS6 RAM (with PARITY) (4KBytes)                         */    
    GEL_MapAddStr(0x0000B800,0, 0x800, "R|W|AS2",0);                     /*   LS7 RAM (with PARITY) (4KBytes)                         */    
    GEL_MapAddStr(0x0000C000,0, 0x2000, "R|W|AS2",0);                    /*   GS0 RAM (with PARITY) (16KBytes)                        */
    GEL_MapAddStr(0x0000E000,0, 0x2000, "R|W|AS2",0);                    /*   GS1 RAM (with PARITY) (16KBytes)                        */
    GEL_MapAddStr(0x00010000,0, 0x2000, "R|W|AS2",0);                    /*   GS2 RAM (with PARITY) (16KBytes)                        */
    GEL_MapAddStr(0x00012000,0, 0x2000, "R|W|AS2",0);                    /*   GS3 RAM (with PARITY) (16KBytes)                        */
    GEL_MapAddStr(0x00070000,0, 0x400, "R|AS2",0);                       /*   TI OTP BANK0 (2 KBytes)                                 */
    GEL_MapAddStr(0x00070400,0, 0x400, "R|AS2",0);                       /*   TI OTP BANK1 (Reserved)                                 */  
    GEL_MapAddStr(0x00078000,0, 0x400, "R|AS2",0);                       /*   USER OTP BANK0 (2 KBytes)                               */  
    GEL_MapAddStr(0x00078400,0, 0x400, "R|AS2",0);                       /*   USER OTP BANK1 (Reserved)                               */  
    GEL_MapAddStr(0x00080000,0, 0x10000, "R|AS2",0);                     /*   FLASH BANK0 (128 KBytes)                                */
    GEL_MapAddStr(0x003E8000,0, 0x8000, "R|AS2",0);                      /*   Secure ROM (64 KBytes)                                  */
    GEL_MapAddStr(0x003F0000,0, 0x10000, "R|AS2",0);                     /*   Boot ROM (master) (128 KBytes)                          */
    
    /* Data memory maps */
    GEL_MapAddStr(0x00000000,1, 0x400, "R|W|AS2",0);                     /*   M0 RAM (with ECC) (2 KByte)                             */
    GEL_MapAddStr(0x00000400,1, 0x400, "R|W|AS2",0);                     /*   M1 RAM (with ECC) (2 KByte)                             */
    GEL_MapAddStr(0x00000800,1, 0x200, "R|W|AS2",0);                     /*   Peripheral Space (512 Bytes)                            */
    GEL_MapAddStr(0x00000B00,1, 0x60, "R|AS2",0);                        /*   ADC Result Registers                                    */ 
    GEL_MapAddStr(0x00000C00,1, 0x18, "R|W|AS2",0);                      /*   CPU Timer Registers                                     */    
    GEL_MapAddStr(0x00000CE0,1, 0x20, "R|AS2",0);                        /*   PIE Registers                                           */ 
    GEL_MapAddStr(0x00000D00,1, 0x1C0, "R|W|AS2",0);                     /*   PIE Vectors                                             */    
    GEL_MapAddStr(0x00000F00,1, 0x100, "R|W|AS2",0);                     /*   FPU Registers                                           */    
    GEL_MapAddStr(0x00001000,1, 0x200, "R|W|AS2",0);                     /*   DMA Registers                                           */    
    GEL_MapAddStr(0x00001200,1, 0x100, "R|W|AS2",0);                     /*   VCU Registers                                           */         
    GEL_MapAddStr(0x00003000,1, 0x1000, "R|W|AS2",0);                    /*   Configurable Logic Registers (8 KBytes)                 */
    GEL_MapAddStr(0x00004000,1, 0x2000, "R|W|AS2",0);                    /*   Control Peripheral Space                                */
    GEL_MapAddStr(0x00006000,1, 0x0A00, "R|W|AS2",0);                    /*   High Speed Serial Port Registers (Excluding LIN)        */ 
    GEL_MapAddStr(0x00006B00,1, 0x0500, "R|W|AS2",0);                    /*   High Speed Serial Port Registers (Excluding LIN)        */    
    GEL_MapAddStr(0x00007000,1, 0x1000, "R|W|AS2",0);                    /*   System Configuration Registers (2 KBytes)               */
    GEL_MapAddStr(0x00008000,1, 0x800, "R|W|AS2",0);                     /*   LS0 RAM (with PARITY) (4KBytes)                         */
    GEL_MapAddStr(0x00008800,1, 0x800, "R|W|AS2",0);                     /*   LS1 RAM (with PARITY) (4KBytes)                         */
    GEL_MapAddStr(0x00009000,1, 0x800, "R|W|AS2",0);                     /*   LS2 RAM (with PARITY) (4KBytes)                         */
    GEL_MapAddStr(0x00009800,1, 0x800, "R|W|AS2",0);                     /*   LS3 RAM (with PARITY) (4KBytes)                         */
    GEL_MapAddStr(0x0000A000,1, 0x800, "R|W|AS2",0);                     /*   LS4 RAM (with PARITY) (4KBytes)                         */
    GEL_MapAddStr(0x0000A800,1, 0x800, "R|W|AS2",0);                     /*   LS5 RAM (with PARITY) (4KBytes)                         */   
    GEL_MapAddStr(0x0000B000,1, 0x800, "R|W|AS2",0);                     /*   LS6 RAM (with PARITY) (4KBytes)                         */    
    GEL_MapAddStr(0x0000B800,1, 0x800, "R|W|AS2",0);                     /*   LS7 RAM (with PARITY) (4KBytes)                         */   
    GEL_MapAddStr(0x0000C000,1, 0x2000, "R|W|AS2",0);                    /*   GS0 RAM (with PARITY) (16KBytes)                        */
    GEL_MapAddStr(0x0000E000,1, 0x2000, "R|W|AS2",0);                    /*   GS1 RAM (with PARITY) (16KBytes)                        */
    GEL_MapAddStr(0x00010000,1, 0x2000, "R|W|AS2",0);                    /*   GS2 RAM (with PARITY) (16KBytes)                        */
    GEL_MapAddStr(0x00012000,1, 0x2000, "R|W|AS2",0);                    /*   GS3 RAM (with PARITY) (16KBytes)                        */    
    GEL_MapAddStr(0x00040000,1, 0x8000, "R|W|AS4",0);                    /*   Peripheral Space                                        */       
    GEL_MapAddStr(0x00048800,1, 0x1800, "R|W|AS4",0);                    /*   Peripheral Space                                        */  
    GEL_MapAddStr(0x0004A800,1, 0x13F00, "R|W|AS4",0);                   /*   Peripheral Space                                        */
    GEL_MapAddStr(0x0005E740,1, 0x18C0, "R|W|AS4",0);                    /*   Peripheral Space                                        */
    GEL_MapAddStr(0x00070000,1, 0x400, "R|AS2",0);                       /*   TI OTP BANK0 (2 KBytes)                                 */
    GEL_MapAddStr(0x00070400,1, 0x400, "R|AS2",0);                       /*   TI OTP BANK1 (Reserved)                                 */  
    GEL_MapAddStr(0x00078000,1, 0x400, "R|AS2",0);                       /*   USER OTP BANK0 (2 KBytes)                               */  
    GEL_MapAddStr(0x00078400,1, 0x400, "R|AS2",0);                       /*   USER OTP BANK1 (Reserved)                               */  
    GEL_MapAddStr(0x00080000,1, 0x10000, "R|AS2",0);                     /*   FLASH BANK0 (128 KBytes)                                */
    GEL_MapAddStr(0x01070000,1, 0x80, "R|AS2",0);                        /*   TI OTP BANK0 ECC (256 Bytes)                            */
    GEL_MapAddStr(0x01070080,1, 0x80, "R|AS2",0);                        /*   TI OTP BANK1 ECC (Reserved)                             */
    GEL_MapAddStr(0x01071000,1, 0x80, "R|AS2",0);                        /*   USER OTP BANK0 ECC (256 Bytes)                          */
    GEL_MapAddStr(0x01071080,1, 0x80, "R|AS2",0);                        /*   USER OTP BANK1 ECC (Reserved)                           */
    GEL_MapAddStr(0x01080000,1, 0x2000, "R|AS2",0);                      /*   FLASH BANK0 ECC (16 KBytes)                             */
    GEL_MapAddStr(0x003E8000,1, 0x8000, "R|AS2",0);                      /*   Secure ROM (64 KBytes)                                  */
    GEL_MapAddStr(0x003F0000,1, 0x10000, "R|AS2",0);                     /*   Boot ROM (master) (128 KBytes)                          */
    
    /* Peripheral memory maps */
    GEL_MapAddStr(0x00006A00,3, 0x0100, "R|W|AS2",0);                    /*   LIN Registers                                           */ 
    GEL_MapAddStr(0x00048000,3, 0x800, "R|W|AS4",0);                     /*   CANA Registers                                          */   
    GEL_MapAddStr(0x0004A000,3, 0x800, "R|W|AS4",0);                     /*   CANB Registers                                          */
    GEL_MapAddStr(0x0005E700,3, 0x40, "R|W|AS4",0);                      /*   DCC Registers (0.125 KBytes)                            */
    
    GEL_TextOut("\nMemory Map Initialization Complete\n"); 
}

/********************************************************************/
/* The ESTOP0 fill functions are useful for debug.  They fill the   */
/* RAM with software breakpoints that will trap runaway code.       */
/********************************************************************/
hotmenu Fill_F280040C_RAM_with_ESTOP0()
{
    GEL_MemoryFill(0x000000,1,0x000800,0x7625);      /* Fill M0/M1  */
    
    GEL_MemoryFill(0x008000,1,0x000800,0x7625);      /* Fill L0     */
    GEL_MemoryFill(0x008800,1,0x001000,0x7625);      /* Fill L1/L2  */
    GEL_MemoryFill(0x009800,1,0x001000,0x7625);      /* Fill L3/L4  */
    GEL_MemoryFill(0x00A800,1,0x001000,0x7625);	     /* Fill L5/L6  */
    GEL_MemoryFill(0x00B800,1,0x000800,0x7625);	     /* Fill L7     */

    GEL_MemoryFill(0x00C000,1,0x008000,0x7625);	     /* Fill G0-G3  */   
}

/********************************************************************/
/*              TI OTP and USER OTP Memory Dump                     */
/********************************************************************/
menuitem "OTP Dump";
hotmenu OTP_Dump()
{
                GEL_MemorySave(0x00070000,1, 0x400, "TI_OTP_Bank0.dat");
                
                GEL_MemorySave(0x00078000,1, 0x400, "USER_OTP_Bank0.dat"); 
                
                GEL_TextOut("\n********************************************************************** 
                             \nTI OTP and USER OTP Memory Dump Complete!  
                             \nFile Output Directory: <CCS Install Directory>\\ccs<version>\\eclipse 
                             \n                       (e.g. C:\\ti\\ccsv6\\eclipse)
                             \n**********************************************************************\n"); 
}

/********************************************************************/
menuitem "Watchdog";
hotmenu Disable_WD()
{
    *0x7029 = *0x7029 | 0x0068;                /* Set the WDDIS bit */
    *0x7025 = 0x0055;                          /* Service the WD    */
    *0x7025 = 0x00AA;                          /*  once to be safe. */
    GEL_TextOut("\nWatchdog Timer Disabled");
}



/********************************************************************/
menuitem "Addressing Modes";

hotmenu C28x_Mode()
{
    ST1 = ST1 & (~0x0100);      /*   AMODE = 0  */
    ST1 = ST1 | 0x0200;         /* OBJMODE = 1  */
}

hotmenu C24x_Mode()
{
    ST1 = ST1 | 0x0100;         /*   AMODE = 1  */
    ST1 = ST1 | 0x0200;         /* OBJMODE = 1  */
}

hotmenu C27x_Mode()
{
    ST1 = ST1 & (~0x0100);      /*   AMODE = 0  */
    ST1 = ST1 & (~0x0200);      /* OBJMODE = 0  */
}



/********************************************************************/
/* EMU Boot Mode - Set Boot Mode During Debug                       */
/********************************************************************/
menuitem "EMU Boot Mode Select"
hotmenu EMU_BOOT_RAM()
{
    *(unsigned long *)0xD00 = 0x5AFFFFFF;
    *0xD04 = 0x0005;
}
hotmenu EMU_BOOT_FLASH()
{
    *(unsigned long *)0xD00 = 0x5AFFFFFF;
    *0xD04 = 0x0003;
}


hotmenu SetupDCSM()
{
    int i;
	int j;
	unsigned long LinkPointer;
	unsigned long *ZoneSelBlockPtr;
	unsigned long *Z1_ZoneSelBlockPtr;
	unsigned long *Z2_ZoneSelBlockPtr;
	int bitpos;
	int zerofound;

	GEL_TextOut("... DCSM Initialization Start ... \n");
  	XAR0 = *(unsigned long *)0x78000; // Read BANK0 Z1 Linkpointer1
   	XAR0 = *(unsigned long *)0x78004; // Read BANK0 Z1 Linkpointer2
   	XAR0 = *(unsigned long *)0x78008; // Read BANK0 Z1 Linkpointer3 
 
   	XAR0 = *(unsigned long *)0x78200; // Read BANK0 Z2 Linkpointer1
   	XAR0 = *(unsigned long *)0x78204; // Read BANK0 Z2 Linkpointer2
   	XAR0 = *(unsigned long *)0x78208; // Read BANK0 Z2 Linkpointer3

   	XAR0 = *(unsigned long *)0x78400; // Read BANK1 Z1 Linkpointer1
   	XAR0 = *(unsigned long *)0x78404; // Read BANK1 Z1 Linkpointer2
   	XAR0 = *(unsigned long *)0x78408; // Read BANK1 Z1 Linkpointer3 
 
   	XAR0 = *(unsigned long *)0x78600; // Read BANK1 Z2 Linkpointer1
  	XAR0 = *(unsigned long *)0x78604; // Read BANK1 Z2 Linkpointer2
   	XAR0 = *(unsigned long *)0x78608; // Read BANK1 Z2 Linkpointer3
  
   	XAR0 = *(unsigned long *)0x703F0; // Read SECDC   
   
   	XAR0 = *(unsigned long *)0x78010; // Read Z1 PSWDLOCK
   	XAR0 = *(unsigned long *)0x78014; // Read Z1 CRCLOCK
   	XAR0 = *(unsigned long *)0x78018; // Read Z1 JTAGLOCK
   	XAR0 = *(unsigned long *)0x7801E; // Read Z1 BOOTMODE

   	XAR0 = *(unsigned long *)0x7800C; // Read Z1 GPREG1
   	XAR0 = *(unsigned long *)0x7800E; // Read Z1 GPREG2
   	XAR0 = *(unsigned long *)0x7801C; // Read Z1 GPREG3

   	XAR0 = *(unsigned long *)0x78210; // Read Z2 PSWDLOCK
   	XAR0 = *(unsigned long *)0x78214; // Read Z2 CRCLOCK
   	XAR0 = *(unsigned long *)0x78218; // Read Z2 JTAGLOCK
   	XAR0 = *(unsigned long *)0x7821E; // Read Z2 BOOTMODE

   	XAR0 = *(unsigned long *)0x7820C; // Read Z2 GPREG1
   	XAR0 = *(unsigned long *)0x7820E; // Read Z2 GPREG2
   	XAR0 = *(unsigned long *)0x7821C; // Read Z2 GPREG3
	
	for (j=0;j<2;j++)
	{	
		bitpos = 28;
		zerofound = 0;
		
		LinkPointer = *(unsigned long *)(0x5F000 + (j * 256));         /* Read Z1-Linkpointer out of Z1-LINKPOINTER register */
//		GEL_TextOut("Value of Link Pointer is -%x-\n",,,,, LinkPointer);
		LinkPointer = LinkPointer << 3;                            	/* Bits 31 and 30 as most-sigificant 0 are invalid LinkPointer options */
		while ((zerofound == 0) && (bitpos > -1))
		{
	    		if ((LinkPointer & 0x80000000) == 0)
			{
		   		zerofound = 1;
				ZoneSelBlockPtr = (unsigned long *)((0x78000 + ((bitpos + 3)*16)) + (j * 1024));			
			}
			else
			{
		    		bitpos--;
				LinkPointer = LinkPointer << 1;
			}
		}
		if (zerofound == 0)
		{
	    		ZoneSelBlockPtr = (unsigned long *)(0x78020 + (j * 1024));
		}
	
		/* Perform dummy reads of the Zone Select Block locations */
		for (i = 0; i < 8; i++)
		{
	    		XAR0 =  *ZoneSelBlockPtr; 
			ZoneSelBlockPtr++;
		}
	}


	for (j=0;j<2;j++)
	{	
		bitpos = 28;
		zerofound = 0;
		LinkPointer = *(unsigned long *)(0x5F040 + (j * 256));         /* Read Z1-Linkpointer out of Z1-LINKPOINTER register */
		LinkPointer = LinkPointer << 3;                            	/* Bits 31 and 30 as most-sigificant 0 are invalid LinkPointer options */
		while ((zerofound == 0) && (bitpos > -1))
		{
	    		if ((LinkPointer & 0x80000000) == 0)
			{
		   		zerofound = 1;
				ZoneSelBlockPtr = (unsigned long *)((0x78200 + ((bitpos + 3)*16)) + (j * 1024));			
			}
			else
			{
		    		bitpos--;
				LinkPointer = LinkPointer << 1;
			}
		}
		if (zerofound == 0)
		{
	    		ZoneSelBlockPtr = (unsigned long *)(0x78220 + (j * 1024));
		}
	
		/* Perform dummy reads of the Zone Select Block locations */
		for (i = 0; i < 8; i++)
		{
	    		XAR0 =  *ZoneSelBlockPtr; 
			ZoneSelBlockPtr++;
		}
	}	

	GEL_TextOut("... DCSM Initialization Done ...\n");
	/* Write passwords to the KEY registers.  0xFFFFFFFF's are dummy passwords.
       	User should replace them with the correct password for their DSP */

   	*(unsigned long *)0x5F010 = 0xffffffff;
	*(unsigned long *)0x5F012 = 0x47FFFFFF;
	*(unsigned long *)0x5F014 = 0xFFFFFFFF;
	*(unsigned long *)0x5F016 = 0xFFFFFFFF;

   	*(unsigned long *)0x5F050 = 0xffffffff;
	*(unsigned long *)0x5F052 = 0xe3FFFFFF;
	*(unsigned long *)0x5F054 = 0xFFFFFFFF;
	*(unsigned long *)0x5F056 = 0xFFFFFFFF;
}

hotmenu SetupErrorStatusPin()
{
	//check if KEY correct in GPREG2
	if(((*(unsigned long *)0x5F00A & (unsigned long)0xFF000000) >> 24) == 0x5A)
	{
		//set ERROR_STS pin if enabled by user
		if(((*(unsigned long *)0x5F00A & (unsigned long)0x00000030) >> 4) == 0x0)
		{
			GEL_TextOut("Error Status Pin: GPIO24\n");
			//configure GPIO24 for Error Status Pin
			//write to GPAMUX2
			*(unsigned long *)0x7C08 &= ~((unsigned long)0x03 << 16);
			*(unsigned long *)0x7C08 |= ((unsigned long)0x01 << 16);
			//write to GPAGMUX2
			*(unsigned long *)0x7C22 &= ~((unsigned long)0x03 << 16);
			*(unsigned long *)0x7C22 |= ((unsigned long)0x03 << 16);
			//lock GPIO24
			*(unsigned long *)0x7C3C |= ((unsigned long)0x01 << 24);		
		}
		else if(((*(unsigned long *)0x5F00A & (unsigned long)0x00000030) >> 4) == 0x1)
		{
			GEL_TextOut("Error Status Pin: GPIO28\n");
			//configure GPIO28 for Error Status Pin
			//write to GPAMUX2
			*(unsigned long *)0x7C08 &= ~((unsigned long)0x03 << 24);
			*(unsigned long *)0x7C08 |= ((unsigned long)0x01 << 24);
			//write to GPAGMUX2
			*(unsigned long *)0x7C22 &= ~((unsigned long)0x03 << 24);
			*(unsigned long *)0x7C22 |= ((unsigned long)0x03 << 24);
			//lock GPIO24
			*(unsigned long *)0x7C3C |= ((unsigned long)0x01 << 28);
		}
		else if(((*(unsigned long *)0x5F00A & (unsigned long)0x00000030) >> 4) == 0x2)
		{
			GEL_TextOut("Error Status Pin: GPIO29\n");
			//configure GPIO29 for Error Status Pin
			//write to GPAMUX2
			*(unsigned long *)0x7C08 &= ~((unsigned long)0x03 << 26);
			*(unsigned long *)0x7C08 |= ((unsigned long)0x01 << 26);
			//write to GPAGMUX2
			*(unsigned long *)0x7C22 &= ~((unsigned long)0x03 << 26);
			*(unsigned long *)0x7C22 |= ((unsigned long)0x03 << 26);
			//lock GPIO24
			*(unsigned long *)0x7C3C |= ((unsigned long)0x01 << 29);
		}
	}
}

menuitem "Device Configuration"
hotmenu Device_Config()
{
    //PARTIDL
    *(unsigned long *)0x0005D008   = *(unsigned long *)0x00070200;    // LOAD PARTIDL Value
    *(unsigned long *)0x0005D00A   = *(unsigned long *)0x00070202;    // LOAD PARTIDH Value

    //DC0 to DC25    
//    *(unsigned long *)0x0005D010   = *(unsigned long *)0x00070204;    // LOAD DC0 Value
    *(unsigned long *)0x0005D012   = *(unsigned long *)0x00070206;    // LOAD DC1 Value 
//    *(unsigned long *)0x0005D014   = *(unsigned long *)0x00070208;    // LOAD DC2 Value 
    *(unsigned long *)0x0005D016   = *(unsigned long *)0x0007020A;    // LOAD DC3 Value 
    *(unsigned long *)0x0005D018   = *(unsigned long *)0x0007020C;    // LOAD DC4 Value
    *(unsigned long *)0x0005D01A   = *(unsigned long *)0x0007020E;    // LOAD DC5 Value
//    *(unsigned long *)0x0005D01C   = *(unsigned long *)0x00070210;    // LOAD DC6 Value
    *(unsigned long *)0x0005D01E   = *(unsigned long *)0x00070212;    // LOAD DC7 Value
    *(unsigned long *)0x0005D020   = *(unsigned long *)0x00070214;    // LOAD DC8 Value
    *(unsigned long *)0x0005D022   = *(unsigned long *)0x00070216;    // LOAD DC9 Value
    *(unsigned long *)0x0005D024   = *(unsigned long *)0x00070218;    // LOAD DC10 Value
    *(unsigned long *)0x0005D026   = *(unsigned long *)0x0007021A;    // LOAD DC11 Value
//    *(unsigned long *)0x0005D028   = *(unsigned long *)0x0007021C;    // LOAD DC12 Value
//    *(unsigned long *)0x0005D02A   = *(unsigned long *)0x0007021E;    // LOAD DC13 Value
    *(unsigned long *)0x0005D02C   = *(unsigned long *)0x00070220;    // LOAD DC14 Value
    *(unsigned long *)0x0005D02E   = *(unsigned long *)0x00070222;    // LOAD DC15 Value
    *(unsigned long *)0x0005D030   = *(unsigned long *)0x00070224;    // LOAD DC16 Value (Reserved)
    *(unsigned long *)0x0005D032   = *(unsigned long *)0x00070226;    // LOAD DC17 Value
    *(unsigned long *)0x0005D034   = *(unsigned long *)0x00070228;    // LOAD DC18 Value
//    *(unsigned long *)0x0005D036   = *(unsigned long *)0x0007022A;    // LOAD DC19 Value
    *(unsigned long *)0x0005D038   = *(unsigned long *)0x0007022C;    // LOAD DC20 Value
    *(unsigned long *)0x0005D03A   = *(unsigned long *)0x00070230;    // LOAD DC21 Value
    *(unsigned long *)0x0005D03C   = *(unsigned long *)0x00070232;    // LOAD DC22 Value
    *(unsigned long *)0x0005D03E   = *(unsigned long *)0x00070234;    // LOAD DC23 Value
    *(unsigned long *)0x0005D040   = *(unsigned long *)0x00070236;    // LOAD DC24 Value
    *(unsigned long *)0x0005D042   = *(unsigned long *)0x00070238;    // LOAD DC25 Value  

    //Load CPUROM_DCx
    *(unsigned long *)0x0005D140   = *(unsigned long *)0x00070604;    // LOAD CPUROM_DC1 Value  
    *(unsigned long *)0x0005D142   = *(unsigned long *)0x00070606;    // LOAD CPUROM_DC2 Value  
    *(unsigned long *)0x0005D144   = *(unsigned long *)0x00070608;    // LOAD CPUROM_DC3 Value  
    *(unsigned long *)0x0005D146   = *(unsigned long *)0x0007060A;    // LOAD CPUROM_DC4 Value  
     
    //Load PKGTYPE -  only if KEY is programmed
    if (((unsigned long)(*(unsigned long *)0x0007064C) >> 24) == 0x5A)
    {
        *(unsigned long *)0x0005D12E   = ((*(unsigned long *)0x0007064C) & (unsigned long)0x00000000F);          
    }
}

/*** End of file ***/
