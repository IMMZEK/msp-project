<?xml version="1.0" encoding="UTF-8" standalone="yes"?>


<module description="MSS_GPCFG_REG" id="MSS_GPCFG_REG">
  
  
  <register acronym="GPCFG0" id="GPCFG0" offset="0x0" width="32">
    
  <bitfield begin="31" description="General Purpose config register for SW use." end="0" id="GPCFG0" rwaccess="RW" width="32"></bitfield>
  </register>
  
  
  <register acronym="GPCFG1" id="GPCFG1" offset="0x4" width="32">
    
  <bitfield begin="31" description="General Purpose config register for SW use." end="0" id="GPCFG1" rwaccess="RW" width="32"></bitfield>
  </register>
  
  
  <register acronym="GPCFG2" id="GPCFG2" offset="0x8" width="32">
    
  <bitfield begin="31" description="General Purpose config register for SW use." end="0" id="GPCFG2" rwaccess="RW" width="32"></bitfield>
  </register>
  
  
  <register acronym="GPCFG3" id="GPCFG3" offset="0xC" width="32">
    
  <bitfield begin="31" description="General Purpose config register for SW use." end="0" id="GPCFG3" rwaccess="RW" width="32"></bitfield>
  </register>
  
  
  <register acronym="GPCFG4" id="GPCFG4" offset="0x10" width="32">
    
  <bitfield begin="31" description="General Purpose config register for SW use." end="0" id="GPCFG4" rwaccess="RW" width="32"></bitfield>
  </register>
  
  
  <register acronym="GPCFG11" id="GPCFG11" offset="0x2C" width="32">
    
  <bitfield begin="17" description="Self clearing register bit to generate interrupt to DSP from BSS. Writing a ‘1’ generates a pulse interrupt on one of the interrupt lines to DSP" end="17" id="BSS2DSSSWIRQ2" rwaccess="" width="1"></bitfield>
    
  <bitfield begin="16" description="Self clearing register bit to generate interrupt to DSP from BSS. Writing a ‘1’ generates a pulse interrupt on one of the interrupt lines to DSP" end="16" id="BSS2DSSSWIRQ1" rwaccess="" width="1"></bitfield>
    
  <bitfield begin="9" description="Self clearing register bit to generate interrupt to BSS from DSP. Writing a ‘1’ generates a pulse interrupt on one of the interrupt lines to BSS" end="9" id="DSS2BSSSWIRQ2" rwaccess="" width="1"></bitfield>
    
  <bitfield begin="8" description="Self clearing register bit to generate interrupt to BSS from DSP. Writing a ‘1’ generates a pulse interrupt on one of the interrupt lines to BSS" end="8" id="DSS2BSSSWIRQ1" rwaccess="" width="1"></bitfield>
    
  <bitfield begin="1" description="Self clearing register bit to generate interrupt to BSS from MSS. Writing a ‘1’ generates a pulse interrupt on one of the interrupt lines to BSS" end="1" id="MSS2BSSSWIRQ2" rwaccess="" width="1"></bitfield>
    
  <bitfield begin="0" description="Self clearing register bit to generate interrupt to BSS from MSS. Writing a ‘1’ generates a pulse interrupt on one of the interrupt lines to BSS" end="0" id="MSS2BSSSWIRQ1" rwaccess="" width="1"></bitfield>
  </register>
  
  
  <register acronym="CCCACFG0" id="CCCACFG0" offset="0xD0" width="32">
    
  <bitfield begin="31" description="Margin value for clock comparison in terms of counter1 clock.CCC error will not be generated if counter1 counter value is within “count1_expected_val” +/- MARGIN_COUNT" end="16" id="CCCA_MARGIN_COUNT" rwaccess="RW" width="16"></bitfield>
    
  <bitfield begin="8" description="1->Single shot mode, 0->Continuous mode" end="8" id="CCCA_SINGLE_SHOT_MODE" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="7" description="Enable for CCCA" end="7" id="CCCA_ENABLE_MODULE" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="6" description="1->Clock gated to counter0 and counter1 0-> Normal mode" end="6" id="CCCA_DISABLE_CLOCKS" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="5" description="Selection for Clock 1 0->Select clock0_src[0] as source for counter1 1->Select clock0_src[1] as source for counter1 2->Select clock0_src[2] as source for counter1 ... 7->Select clock0_src[7] as source for counter1" end="3" id="CCCA_CLOCK1_SEL" rwaccess="RW" width="3"></bitfield>
    
  <bitfield begin="2" description="Selection for Clock 0 0->Select clock0_src[0] as source for counter0 1->Select clock0_src[1] as source for counter0 2->Select clock0_src[2] as source for counter0 ... 7->Select clock0_src[7] as source for counter0" end="0" id="CCCA_CLOCK0_SEL" rwaccess="RW" width="3"></bitfield>
  </register>
  
  
  <register acronym="CCCACFG1" id="CCCACFG1" offset="0xD4" width="32">
    
  <bitfield begin="31" description="count0_expiry_val Counter 1 is compared for “count1_expected_val”  +/- MARGIN_COUNT when counter0 expires after counting down from  count0_expiry_val to 0" end="0" id="CCCACFG1" rwaccess="RW" width="32"></bitfield>
  </register>
  
  
  <register acronym="CCCACFG2" id="CCCACFG2" offset="0xD8" width="32">
    
  <bitfield begin="31" description="count1_expected_val Expected value of counter 1 when counter 0 expires after counting down from count0_expiry value" end="0" id="CCCACFG2" rwaccess="RW" width="32"></bitfield>
  </register>
  
  
  <register acronym="CCCACFG3" id="CCCACFG3" offset="0xDC" width="32">
    
  <bitfield begin="31" description="Timeout Error Counter value in counter1 clock" end="0" id="CCCACFG3" rwaccess="RW" width="32"></bitfield>
  </register>
  
  
  <register acronym="CCCBCFG0" id="CCCBCFG0" offset="0xE0" width="32">
    
  <bitfield begin="31" description="Margin value for clock comparison in terms of counter1 clock.CCC error will not be generated if counter1 counter value is within “count1_expected_val” +/- MARGIN_COUNT" end="16" id="CCCB_MARGIN_COUNT" rwaccess="RW" width="16"></bitfield>
    
  <bitfield begin="8" description="1->Single shot mode, 0->Continuous mode" end="8" id="CCCB_SINGLE_SHOT_MODE" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="7" description="Enable for CCCB" end="7" id="CCCB_ENABLE_MODULE" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="6" description="1->Clock gated to counter0 and counter1 0-> Normal mode" end="6" id="CCCB_DISABLE_CLOCKS" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="5" description="Selection for Clock 1 0->Select clock0_src[0] as source for counter1 1->Select clock0_src[1] as source for counter1 2->Select clock0_src[2] as source for counter1 ... 7->Select clock0_src[7] as source for counter1" end="3" id="CCCB_CLOCK1_SEL" rwaccess="RW" width="3"></bitfield>
    
  <bitfield begin="2" description="Selection for Clock 0 0->Select clock0_src[0] as source for counter0 1->Select clock0_src[1] as source for counter0 2->Select clock0_src[2] as source for counter0 ... 7->Select clock0_src[7] as source for counter0" end="0" id="CCCB_CLOCK0_SEL" rwaccess="RW" width="3"></bitfield>
  </register>
  
  
  <register acronym="CCCBCFG1" id="CCCBCFG1" offset="0xE4" width="32">
    
  <bitfield begin="31" description="count0_expiry_val Counter 1 is compared for “count1_expected_val”  +/- MARGIN_COUNT when counter0 expires after counting down from  count0_expiry_val to 0" end="0" id="CCCBCFG1" rwaccess="RW" width="32"></bitfield>
  </register>
  
  
  <register acronym="CCCBCFG2" id="CCCBCFG2" offset="0xE8" width="32">
    
  <bitfield begin="31" description="count1_expected_val Expected value of counter 1 when counter 0 expires after counting down from count0_expiry value" end="0" id="CCCBCFG2" rwaccess="RW" width="32"></bitfield>
  </register>
  
  
  <register acronym="CCCBCFG3" id="CCCBCFG3" offset="0xEC" width="32">
    
  <bitfield begin="31" description="Timeout Error Counter value in counter1 clock" end="0" id="CCCBCFG3" rwaccess="RW" width="32"></bitfield>
  </register>
  
  
  <register acronym="CCCACNTVAL" id="CCCACNTVAL" offset="0xF0" width="32">
    
  <bitfield begin="31" description="count1_val_out Real time value of counter1" end="0" id="CCCACNTVAL" rwaccess="R" width="32"></bitfield>
  </register>
  
  
  <register acronym="CCCBCNTVAL" id="CCCBCNTVAL" offset="0xF4" width="32">
    
  <bitfield begin="31" description="count1_val_out Real time value of counter1" end="0" id="CCCBCNTVAL" rwaccess="R" width="32"></bitfield>
  </register>
  
  
  <register acronym="CCCABERRSTAT" id="CCCABERRSTAT" offset="0xF8" width="32">
    
  <bitfield begin="31" description="7:0 : CCCA Error Status (for Debug) 15:8 : CCCB Error Status (for Debug) {3'd0, counter_error,  counter_done, timeout_error,  counter_error,  Counter_done}" end="0" id="CCCABERRSTAT" rwaccess="R" width="32"></bitfield>
  </register>
  
  
  <register acronym="USERMODEEN" id="USERMODEEN" offset="0xFC" width="32">
    
  <bitfield begin="31" description="Write 0XADADADAD to enable user mode write access to MSS GPCFG space." end="0" id="USERMODEEN" rwaccess="RW" width="32"></bitfield>
  </register>
  
  
  <register acronym="EPWMCFG" id="EPWMCFG" offset="0x140" width="32">
    
  <bitfield begin="31" description="EPWM configuration [1:0] : 0->rampgen Frame start is SYNCIN to EPWM1 1->FRC Frame Start is SYNCIN to EPWM1 2,3-> External SYNCIN is SYNCIN to EPWM1 [3:2]: 0->rampgen Frame start is SYNCIN to EPWM2 1->FRC Frame Start is SYNCIN to EPWM2 2,3-> EPWM1 SYNCO is SYNCIN to EPWM2 [5:4]: 0->rampgen Frame start is SYNCIN to EPWM3 1->FRC Frame Start is SYNCIN to EPWM3 2,3-> EPWM2 SYNCO is SYNCIN to EPWM3 [8]:TBCLKEN for EPWM1 [9]:TBCLKEN for EPWM2 [10]:TBCLKEN for EPWM3" end="0" id="EPWMCFG" rwaccess="RW" width="32"></bitfield>
  </register>
  
  
  <register acronym="DMMSWINT0" id="DMMSWINT0" offset="0x148" width="32">
    
  <bitfield begin="31" description="HIL Intr0 muxed with frame start interrupt to DSP HIL Intr1 muxed with logical frame start interrupt to DSP HIL Intr2 muxed with Ping/Pong threshold trigger interrupt for DSP HIL Intr3 muxed with ADC data valid interrupt for DSP HIL Intr4 - HIL Intr8 : SW interrupt for DSP HIL Intr9 muxed with frame start interrupt to TPCC0 HIL Intr10 muxed with logical frame start interrupt to TPCC0 HIL Intr11 muxed with Ping/Pong threshold trigger interrupt for TPCC0 HIL Intr12 muxed with ADC data valid interrupt for TPCC0 HIL Intr13 - HIL Intr18 as SW interrupt for TPCC0 HIL Intr19 muxed with frame start interrupt to TPCC1 HIL Intr20 muxed with logical frame start interrupt to TPCC1 HIL Intr21 muxed with Ping/Pong threshold trigger interrupt for TPCC1 HIL Intr22 muxed with ADC data valid interrupt for TPCC1 HIL Intr23 - HIL Intr28 as SW interrupt for TPCC1 HIL Intr29 muxed with frame start interrupt to VIMMR4F HIL Intr30 muxed with logical frame start interrupt to VIMMR4F HIL Intr31 muxed with Ping/Pong threshold trigger interrupt for VIMMR4F HIL Intr32 muxed with ADC data valid interrupt for VIMMR4F HIL Intr33 - HIL Intr38 as SW interrupt for VIMMR4F HIL Intr39 muxed with frame start interrupt right at the source - propagates throughout the system as actual FRC output does. This is muxed with the frame start coming from BSS to TOP so that it propagates to MSS/DSS. HIL Intr40 muxed with frame start interrupt right at the source - propagates throughout the system as actual FRC output does. This is muxed with the ADC clock enable signal coming from FRC. Intr41 muxed with logical frame start interrupt right at the source (FRC) - propagates throughout the system  Intr42 muxed with logical frame end interrupt right at the source (FRC) - propagates throughout the system  Intr43 muxed with Ping/Pong threshold trigger interrupt right at the source - propagates throughout the system  Intr44 muxed with ADC data valid interrupt right at the source - propagates throughout the system " end="0" id="DMMSWINT0" rwaccess="" width="32"></bitfield>
  </register>
  
  
  <register acronym="DMMSWINT1" id="DMMSWINT1" offset="0x14C" width="32">
    
  <bitfield begin="31" description="HIL Interrupts - MSB 32 bits [63:32]" end="0" id="DMMSWINT1" rwaccess="" width="32"></bitfield>
  </register>
  
  
  <register acronym="DMMSWINTSEL0" id="DMMSWINTSEL0" offset="0x150" width="32">
    
  <bitfield begin="31" description="Mux control for HIL Interrupts - LSB 32 bits" end="0" id="DMMSWINTSEL0" rwaccess="RW" width="32"></bitfield>
  </register>
  
  
  <register acronym="DMMSWINTSEL1" id="DMMSWINTSEL1" offset="0x154" width="32">
    
  <bitfield begin="31" description="Mux control for HIL Interrupts - MSB 32 bits" end="0" id="DMMSWINTSEL1" rwaccess="RW" width="32"></bitfield>
  </register>
  
  
  <register acronym="CCCBWDEN" id="CCCBWDEN" offset="0x158" width="32">
    
  <bitfield begin="16" description="Enable CCCB error to generate WD restn.In this mode CCCB has to compare MSS CR4 clock to XTAL" end="16" id="ENABLECCBERRRSTN" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="0" description="Enable CCCB error to generate NMI.In this mode CCCB has to compare MSS CR4 clock to XTAL" end="0" id="ENABLECCBERRNMI" rwaccess="RW" width="1"></bitfield>
  </register>
  
  
  <register acronym="GPIOINTREDGESEL" id="GPIOINTREDGESEL" offset="0x15C" width="32">
    
  <bitfield begin="2" description="0:Posedge of GPIO2 generates interruptt to MSS CR4 and DSP  1:Negedge                                                                                                                                                                                                                                                                                             " end="2" id="GPIO2EDGESEL" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="1" description="0:Posedge of GPIO1 generates interruptt to MSS CR4 and DSP  1:Negedge                                                                                                                                                                                                                                                                                             " end="1" id="GPIO1EDGESEL" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="0" description="0:Posedge of GPIO0 generates interruptt to MSS CR4 and DSP  1:Negedge                                                                                                                                                                                                                                                                                             " end="0" id="GPIO0EDGESEL" rwaccess="RW" width="1"></bitfield>
  </register>
  
  
  <register acronym="PWMDMATRIGEN" id="PWMDMATRIGEN" offset="0x164" width="32">
    
  <bitfield begin="3" description="PWMDMATRIGEN[0]: &quot;1&quot; -> Mux epwm1a instead of mss_event_gen_1_frc to DMA PWMDMATRIGEN[1]: &quot;1&quot; -> Mux epwm1b instead of mss_event_gen_1_frc to DMA PWMDMATRIGEN[2]: &quot;1&quot; -> Mux epwm2a instead of mss_event_gen_1_frc to DMA PWMDMATRIGEN[3]: &quot;1&quot; -> Mux epwm2b instead of mss_event_gen_1_frc to DMA" end="0" id="PWMDMATRIGEN" rwaccess="RW" width="4"></bitfield>
  </register>
  
  
  <register acronym="JTAGTXDATA" id="JTAGTXDATA" offset="0x168" width="32">
    
  <bitfield begin="31" description="Transmit Data. This register is used to pass data to the system security logic" end="0" id="JTAGTXDATA" rwaccess="R" width="32"></bitfield>
  </register>
  
  
  <register acronym="JTAGTXCONTROL" id="JTAGTXCONTROL" offset="0x16C" width="32">
    
  <bitfield begin="31" description="Provides the handshake for the JTAGTXDATA Register and can also be used to pass control information to the system security logic. Only bits [31:1] are valid" end="0" id="JTAGTXCONTROL" rwaccess="R" width="32"></bitfield>
  </register>
  
  
  <register acronym="JTAGRXDATA" id="JTAGRXDATA" offset="0x170" width="32">
    
  <bitfield begin="31" description="Receive data. This register is used to pass data from the system security logic" end="0" id="JTAGRXDATA" rwaccess="RW" width="32"></bitfield>
  </register>
  
  
  <register acronym="JTAGTXRXACK" id="JTAGTXRXACK" offset="0x178" width="32">
    
  <bitfield begin="8" description="Indication from system security logic that JTAGRXDATA is valid" end="8" id="JTAGRXDATAWR" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="0" description="Indication from the system security logic that JTAGTXDATA has been accepted" end="0" id="JTAGTXDATARD" rwaccess="RW" width="1"></bitfield>
  </register>
  
  
  <register acronym="JTAGRXCONTROL" id="JTAGRXCONTROL" offset="0x17C" width="32">
    
  <bitfield begin="31" description="Provides the handshake for the JTAGRXDATA Register and can also be used to pass control information from the system security logic. Only bits [31:1] is used." end="0" id="JTAGRXCONTROL" rwaccess="RW" width="32"></bitfield>
  </register>
  
  
  <register acronym="MSS2GEMSWIRQ" id="MSS2GEMSWIRQ" offset="0x180" width="32">
    
  <bitfield begin="1" description="Self clearing register bit to generate interrupt to DSP from MSS. Writing a ‘1’ generates a pulse interrupt on one of the interrupt lines to DSP" end="1" id="MSS2GEMSWIRQ2" rwaccess="" width="1"></bitfield>
    
  <bitfield begin="0" description="Self clearing register bit to generate interrupt to DSP from MSS. Writing a ‘1’ generates a pulse interrupt on one of the interrupt lines to DSP" end="0" id="MSS2GEMSWIRQ1" rwaccess="" width="1"></bitfield>
  </register>
  
  
  <register acronym="CSETBFLUSH" id="CSETBFLUSH" offset="0x184" width="32">
    
  <bitfield begin="10" description="When HIGH indicates that the ETB RAM has overflowed or wrapped around to address zero" end="10" id="CSETBFULL" rwaccess="R" width="1"></bitfield>
    
  <bitfield begin="9" description="When HIGH, indicates that trace acquisition is complete by ETB, that is, the trigger counter is at zero" end="9" id="CSETBACQ_COMPLETE" rwaccess="R" width="1"></bitfield>
    
  <bitfield begin="8" description="Return acknowledgement to CSETBFLUSHIN" end="8" id="CSETBFLUSHINACK" rwaccess="R" width="1"></bitfield>
    
  <bitfield begin="0" description="External control used to assert the ATB signal AFVALIDS and drain any historical FIFO information on the bus" end="0" id="CSETBFLUSHIN" rwaccess="RW" width="1"></bitfield>
  </register>
</module>
