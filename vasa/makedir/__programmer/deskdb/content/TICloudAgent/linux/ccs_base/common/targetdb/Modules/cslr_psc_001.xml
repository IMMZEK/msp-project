<?xml version="1.0" encoding="utf-8"?>
<module id="PSC" HW_revision="1" XML_version="1" description="Power and Sleep Controller (PSC)">
	<register id="PID" acronym="PID" offset="0" width="32" description="Peripheral Revision and Class Information">
		<bitfield id="SCHEME" width="2" begin="31" end="30" resetval="1" description="Used to distinguish between old scheme and current.  Spare bit to encode future schemes" range="-" rwaccess="R">
		</bitfield>
		<bitfield id="_RESV" width="2" begin="29" end="28" resetval="0" description="Reserved" range="" rwaccess="R">
		</bitfield>
		<bitfield id="FUNC" width="12" begin="27" end="16" resetval="0x208" description="Indicating a software compatible module family.  If there is no level of software compatibility a new ID should be assigned." range="" rwaccess="R">
		</bitfield>
		<bitfield id="RTL" width="5" begin="15" end="11" resetval="0" description="RTL Version. (R as described in PDR 9.3.2) Must be easily ECO'able or controlled during fabrication. Ideally through a top level metal mask or efuse.  Start with 0 for PSC1.0, 1 for PSC2.0" range="" rwaccess="R">
		</bitfield>
		<bitfield id="MAJOR" width="3" begin="10" end="8" resetval="0" description="Major Revision." range="" rwaccess="R">
		</bitfield>
		<bitfield id="CUSTOM" width="2" begin="7" end="6" resetval="0" description="Indicates a Special Version for a particular device.  Consequence of use may avoid use of standard CSL/Drivers. 0 if non-custom" range="" rwaccess="R">
		</bitfield>
		<bitfield id="MINOR" width="6" begin="5" end="0" resetval="0" description="Minor Revision Must be easily ECO'able or controlled during fabrication. Ideally through a top level metal mask or efuse. Start with 0." range="-" rwaccess="R">
		</bitfield>
	</register>
	<register id="GBLCTL" acronym="GBLCTL" offset="0x10" width="32" description="Global Control Register">
		<bitfield id="_RESV" width="30" begin="31" end="2" resetval="0" description="Reserved" range="-" rwaccess="R">
		</bitfield>
		<bitfield id="CCM" width="1" begin="1" end="1" resetval="0" description="PSC MMR controlled by Chip Config Module (CCM) only                               0: Software is allowed to control PSC                                                          1: PSC is controlled by CCM                                            " range="" rwaccess="RW">
		</bitfield>
		<bitfield id="FORCE" width="1" begin="0" end="0" resetval="0" description="Force bit. For PSC 2.0, this bit is considered only if all of the conditions are true:                                                                                                         -GBLCTL.CCM = 0                                                                                         -Software manual control method is used                                                    0: No force                                                                                                    1: Force" range="" rwaccess="RW">
		</bitfield>
	</register>
	<register id="GBLSTAT" acronym="GBLSTAT" offset="0x14" width="32" description="Global Status Register">
		<bitfield id="_RESV" width="31" begin="31" end="1" resetval="0" description="Reserved" range="-" rwaccess="R">
		</bitfield>
		<bitfield id="GBLTRANS" width="1" begin="0" end="0" resetval="0" description="PSC Global Transition Status                                                                         0: No Global Transition in progress                                                               1: Global Transition in progress. PSC hardware is in the process of putting all power domains to the desired next states, and all modules to the desired next states" range="" rwaccess="R">
		</bitfield>
	</register>
	<register id="ERRPR0" acronym="ERRPR0" offset="0x20" width="32" description="Error Pending 0 (mod 0 - 31) Register">
		<bitfield id="M_32" width="32" begin="31" end="0" resetval="0" description="Records pending error conditions for modules 0-31. Each bit n respresents a module. For each bit n,                                                          0: Module n does not have error condition                                                    1: Module n has error condition                                                                                 " range="-" rwaccess="R">
		</bitfield>
	</register>
	<register id="ERRPR1" acronym="ERRPR1" offset="0x24" width="32" description="Error Pending 1 (mod 32 - 63) Register">
		<bitfield id="M_32" width="32" begin="31" end="0" resetval="0" description="Records pending error conditions for modules 32-63. Each bit n respresents a module. For each bit n,                                                          0: Module n does not have error condition                                                    1: Module n has error condition                                                                                 " range="-" rwaccess="R">
		</bitfield>
	</register>
	<register id="ERRCR0" acronym="ERRCR0" offset="0x30" width="32" description="Error Clear 0 (mod 0-31) Register">
		<bitfield id="M_32" width="32" begin="31" end="0" resetval="0" description="Clears error bit set in corresponding ERRPR register bit field. This pertains to modules 0-31. For each bit n,                                                      0: Write of 0 has no effect                                                                            1: Write of 1 to bit n causes ERRPR bit n to be cleared, and the corresponding module's MDSTAT fields to be cleared - STERR, WKRSLP, ACSLP, MSTID." range="-" rwaccess="W">
		</bitfield>
	</register>
	<register id="ERRCR1" acronym="ERRCR1" offset="0x34" width="32" description="Error Clear 1 (mod 32-63) Register">
		<bitfield id="M_32" width="32" begin="31" end="0" resetval="0" description="Clears error bit set in corresponding ERRPR register bit field. This pertains to modules 32-63. For each bit n,                                                      0: Write of 0 has no effect                                                                            1: Write of 1 to bit n causes ERRPR bit n to be cleared, and the corresponding module's MDSTAT fields to be cleared - STERR, WKRSLP, ACSLP, MSTID." range="-" rwaccess="W">
		</bitfield>
	</register>
	<register id="INTEVAL" acronym="INTEVAL" offset="0x40" width="32" description="Interrupt Evaluation Register">
		<bitfield id="_RESV" width="13" begin="31" end="19" resetval="0" description="Reserved" range="-" rwaccess="R">
		</bitfield>
		<bitfield id="MPSET" width="1" begin="18" end="18" resetval="0" description="Memory Protection Interrupt Set (not documented to users)                       0: Write of 0 has no effect                                                                            1: Write of 1 causes the PSC_MPINT to be pulsed" range="" rwaccess="W">
		</bitfield>
		<bitfield id="TRANSET" width="1" begin="17" end="17" resetval="0" description="State Transition Interrupt Set (not documented to users)                             0: Write of 0 has no effect                                                                            1: Write of 1 causes the PSC_TRANSINT to be pulsed" range="" rwaccess="W">
		</bitfield>
		<bitfield id="ERRSET" width="1" begin="16" end="16" resetval="0" description="Error  Interrupt Set (not documented to users)                                          0: Write of 0 has no effect                                                                            1: Write of 1 causes the PSC_ERRINT to be pulsed" range="" rwaccess="W">
		</bitfield>
		<bitfield id="_RESV" width="13" begin="15" end="3" resetval="0" description="Reserved" range="" rwaccess="R">
		</bitfield>
		<bitfield id="MPEV" width="1" begin="2" end="2" resetval="0" description="Re-evaluate Memory Protection Interrupt                                                      0: Write of 0 has no effect                                                                            1: Write of 1 re-evaluates memory protection interrupt PSC_MPINT. Write of 1 causes interrupt logic to re-evaluate all pending Memory Protection error conditions and re-pulse the PSC_MPINT if any memory protection error conditions are pending" range="" rwaccess="W">
		</bitfield>
		<bitfield id="TRANSEV" width="1" begin="1" end="1" resetval="0" description="Re-evaluate State Transition Interrupt                                                        0: Write of 0 has no effect                                                                            1: Write of 1 re-evaluates state transition interrupt PSC_TRANSINT. Write of 1 causes interrupt logic to re-evaluate all pending MTSTAT conditions and re-pulse the PSC_TRANSINT if any MTSTAT bits are still set. " range="" rwaccess="W">
		</bitfield>
		<bitfield id="ERREV" width="1" begin="0" end="0" resetval="0" description="Re-evaluate Error Interrupt                                                                         0: Write of 0 has no effect                                                                            1: Write of 1 re-evaluates error interrupt PSC_ERRINT. Write of 1 causes interrupt logic to re-evaluate all pending  error interrupts and re-pulse the error interrupt signal if any error interrupt  conditions are pending" range="" rwaccess="W">
		</bitfield>
	</register>
	<register id="RAILSTAT" acronym="RAILSTAT" offset="0x100" width="32" description="Power Rail Status Register">
		<bitfield id="_RESV" width="3" begin="31" end="29" resetval="0" description="Reserved" range="" rwaccess="R">
		</bitfield>
		<bitfield id="RAILNUM" width="5" begin="28" end="24" resetval="0" description="Indicates Current Rail Requestor being processed by GPSC. Defaults to 0 indicating Always ON domain that has no rail request/grant associated with it. The 5 bit field allows up to 32 requestors." range="" rwaccess="R">
		</bitfield>
		<bitfield id="_RESV" width="16" begin="23" end="8" resetval="0" description="Reserved for RAILCNT expansion" range="" rwaccess="R">
		</bitfield>
		<bitfield id="RAILCNT" width="8" begin="7" end="0" resetval="0" description="Indicates the current rail counter value. This is a dynamic field and reading this will not reflect real-time value. " range="" rwaccess="R">
		</bitfield>
	</register>
	<register id="RAILCTL" acronym="RAILCTL" offset="0x104" width="32" description="Power Rail Counter Control Register">
		<bitfield id="_RESV" width="16" begin="31" end="16" resetval="0" description="Reserved" range="" rwaccess="R">
		</bitfield>
		<bitfield id="RAILCTR1" width="8" begin="15" end="8" resetval="0" description="Rail Counter Value 1" range="" rwaccess="RW">
		</bitfield>
		<bitfield id="RAILCTR0" width="8" begin="7" end="0" resetval="0" description="Rail Counter Value 0" range="" rwaccess="RW">
		</bitfield>
	</register>
	<register id="RAILSEL" acronym="RAILSEL" offset="0x108" width="32" description="Power Rail Counter Select Register">
		<bitfield id="P_32" width="32" begin="31" end="0" resetval="0" description="Rail Counter Select for Power Domain n                                                       0: Use RAILCTL.RailCtr0 count value to bring up power domain n               1: Use RAILCTL.RailCtr1 count value to bring up power domain n" range="" rwaccess="RW">
		</bitfield>
	</register>
	<register id="PUDSTAT" acronym="PUDSTAT" offset="0x110" width="32" description="Power Up Domain Status Register">
		<bitfield id="PUD_31" width="31" begin="31" end="1" resetval="0" description="Indicates Power ON for each power domain after the respective PUD bit is turned ON. This bit should be polled before turning OFF the isolation cells." range="" rwaccess="R">
		</bitfield>
		<bitfield id="PUD0" width="1" begin="0" end="0" resetval="1" description="This bit indicates that the power is ON and stable for the Always ON domain.                                                                                                          0: Power not ON (may be in progress)                                                         1: Power for domain is ON                                                                            PUD0 belongs to the Always ON domain and therefore it defaults to ON (1)" range="" rwaccess="R">
		</bitfield>
	</register>
	<register id="PUDPRG" acronym="PUDPRG" offset="0x114" width="32" description="Power Up Domain Programmed Register">
		<bitfield id="PUD_30" width="30" begin="31" end="2" resetval="0" description="Power Up Domain n , where n ranges 31 down-to 2.                                                                  0: Power domain n turns OFF                                                                       1: Power domain n turns ON" range="" rwaccess="R">
		</bitfield>
		<bitfield id="PUD1" width="1" begin="1" end="1" resetval="0" description="Power Up Domain 1                                                                                       0: Power Domain 1 turns OFF                                                                       1: Power Domain 1 turns ON                                                                                 " range="" rwaccess="R">
		</bitfield>
		<bitfield id="PUD0" width="1" begin="0" end="0" resetval="1" description="Always ON Power Domain control bit.                                                          This bit is tied off to 1. Modules that need to be powered on along with the device belong in this power domain.                                                        " range="" rwaccess="R">
		</bitfield>
	</register>
	<register id="PUDSET" acronym="PUDSET" offset="0x118" width="32" description="Power Up Domain Set Register">
		<bitfield id="PUD_30" width="30" begin="31" end="2" resetval="0" description="Power Up Domains n, where n ranges 31 down-to 2.                                 0: Writes of 0 have no effect                                                                        1: Writes of 1 asserts PUDPRG.PUD[n] to initiate power on for domain n" range="" rwaccess="W">
		</bitfield>
		<bitfield id="PUD1" width="1" begin="1" end="1" resetval="0" description="Power Up Domain 1                                                                                    0: Writes of 0 have no effect                                                                        1: Writes of 1 asserts PUDPRG.PUD1 to initiate power on for domain 1" range="" rwaccess="W">
		</bitfield>
		<bitfield id="PUD0" width="1" begin="0" end="0" resetval="0" description="Set PUDPRG bit 0. Note that Power Domain 0 is the Always On power domain, which is always on. Therefore this bit is special and it is not writeable." range="" rwaccess="R">
		</bitfield>
	</register>
	<register id="PUDCLR" acronym="PUDCLR" offset="0x11C" width="32" description="Power Up Domain Clear Register">
		<bitfield id="PUD_30" width="30" begin="31" end="2" resetval="0" description="Power Down Domains n, where n ranges 31 down-to 2.                                 0: Writes of 0 have no effect                                                                        1: Writes of 1 clears PUDPRG.PUD[n] to turn off power for domain n" range="" rwaccess="W">
		</bitfield>
		<bitfield id="PUD1" width="1" begin="1" end="1" resetval="0" description="Power Down Domain 1                                                                                    0: Writes of 0 have no effect                                                                        1: Writes of 1 clears PUDPRG.PUD1 to turn off power for domain 1" range="" rwaccess="W">
		</bitfield>
		<bitfield id="PUD0" width="1" begin="0" end="0" resetval="0" description="Clear PUDPRG bit 0. Note that Power Domain 0 is the Always On power domain, which is always on. Therefore this bit is special and it is not writeable to change the domain state." range="" rwaccess="R">
		</bitfield>
	</register>
	<register id="ISOSTAT" acronym="ISOSTAT" offset="0x120" width="32" description="Isolation Status Register">
		<bitfield id="ISO_31" width="31" begin="31" end="1" resetval="0" description="Isolation cell status for power domains 31 down to 1:                                 0: Power domain is not isolated.                                                                   1: Power domain is isolated." range="" rwaccess="R">
		</bitfield>
		<bitfield id="ISO0" width="1" begin="0" end="0" resetval="0" description="Always ON Power Domain's Isolation cell status bit. This bit indicates that the domain is not isolated (0)." range="" rwaccess="R">
		</bitfield>
	</register>
	<register id="ISOPRG" acronym="ISOPRG" offset="0x124" width="32" description="Isolation Cell Programmed Register">
		<bitfield id="ISO_31" width="31" begin="31" end="1" resetval="0" description="Isolation cell control for power domains 31 down to 1:                                0: Isolation cell is OFF. Power domain is not isolated                                    1: Isolation cell is ON. Power domain is isolated                                           The actual ON or OFF stable state is read from the isolation Cell Status register." range="" rwaccess="R">
		</bitfield>
		<bitfield id="ISO0" width="1" begin="0" end="0" resetval="0" description="Always ON Power Domain's Isolation cell control bit. This bit is tied  to 0" range="" rwaccess="R">
		</bitfield>
	</register>
	<register id="ISOSET" acronym="ISOSET" offset="0x128" width="32" description="Isolation Cell Set Register">
		<bitfield id="ISO_30" width="30" begin="31" end="2" resetval="0" description="Turn on the isolations cells for Power domains 31 down to 2:                     0: Writes of 0 have no effect                                                                        1: Writes of 1 asserts ISOPRG.ISO[n] to tun on iso. cells for domain n " range="" rwaccess="W">
		</bitfield>
		<bitfield id="ISO1" width="1" begin="1" end="1" resetval="0" description="Turn on the isolations cells for Power domain 1                                         0: Writes of 0 have no effect                                                                        1: Writes of 1 asserts ISOPRG.ISO1 to tun on iso. cells for domain 1 " range="" rwaccess="W">
		</bitfield>
		<bitfield id="ISO0" width="1" begin="0" end="0" resetval="0" description="Set ISOPRG bit 0. Note that Power Domain 0 is the Always ON power domain and therefore the isolation cells are always off (0). Therefore this bit is special and it is not writeable." range="" rwaccess="R">
		</bitfield>
	</register>
	<register id="ISOCLR" acronym="ISOCLR" offset="0x12C" width="32" description="Isolation Cell Clear Register">
		<bitfield id="ISO_30" width="30" begin="31" end="2" resetval="0" description="Clear ISO[n] bit to turn off iso. Cells for Power Domain n , where n ranges from 31 down-to 2.                                                                                       0: Writes of 0 have no effect                                                                        1: Writes of 1 clears ISO[n] to turn off iso cells for domain n" range="" rwaccess="W">
		</bitfield>
		<bitfield id="ISO1" width="1" begin="1" end="1" resetval="0" description="Clear ISO1 bit to turn off iso. Cells for Power Domain 1.                                                                                       0: Writes of 0 have no effect                                                                        1: Writes of 1 clears ISO1 to turn off iso cells for domain 1" range="" rwaccess="W">
		</bitfield>
		<bitfield id="ISO0" width="1" begin="0" end="0" resetval="0" description="Clear ISO0. Note that Power Domain 0 is the Always ON power domain and therefore the isolations cells are always off. Therefore this bit is special and it is not writeable to change the domain state." range="" rwaccess="R">
		</bitfield>
	</register>
	<register id="PTCMD" acronym="PTCMD" offset="0x130" width="32" description="Power Domain Transition Command Register">
		<bitfield id="GO_32" width="32" begin="31" end="0" resetval="0" description="PSC 1.0 definition: Power Domain n Evaluation                                             0: Writes of 0 has no effect                                                                          1: Writes of 1 cause the State Transition Interrupt Generation Block to evaluate the new PTNEXT and MDCTL.NEXT states as the Application desired states.                                                                                              PSC 2.0 definition: Power Domain n GO Transition                                       0: Writes of 0 have no effect                                                                        1: Writes of 1 cause PSC hardware to evaluate PTNEXT and MDCTL.NEXT (for this domain)." range="" rwaccess="RW">
		</bitfield>
	</register>
	<register id="PTNEXT" acronym="PTNEXT" offset="0x134" width="32" description="Power Domain Transition Next State Register">
		<bitfield id="NEXT_31" width="31" begin="31" end="1" resetval="0" description="Power Domain n Next State                                                                          0: OFF(PUD = 0, ISO = 1)                                                                               1: ON (PUD = 1, ISO = 0)" range="" rwaccess="R">
		</bitfield>
		<bitfield id="NEXT0" width="1" begin="0" end="0" resetval="0" description="Power Domain 0 Next State                                                                           Since power domain 0 is reserved for the Always ON domain, this bit is always 1 to indicate that Power Domain 0's next state is ON.                                  " range="" rwaccess="R">
		</bitfield>
	</register>
	<register id="PTSTAT" acronym="PTSTAT" offset="0x138" width="32" description="Power Domain Transition Status Register">
		<bitfield id="GOSTAT_30" width="30" begin="31" end="2" resetval="0" description="Power Domain n Transition Command Status, where n ranges from 31 down to 2                                                                                                                0: No transitions in progress in Power Domain 0                                          1: Power Domain 0 Transition in progress - either the power domain is transitioning, or modules on this domain are transitioning." range="" rwaccess="R">
		</bitfield>
		<bitfield id="GOSTAT1" width="1" begin="1" end="1" resetval="0" description="Power Domain 1 Transition Command Status                                                                                                                0: No transitions in progress in Power Domain 0                                          1: Power Domain 0 Transition in progress - either the power domain is transitioning, or modules on this domain are transitioning." range="" rwaccess="R">
		</bitfield>
		<bitfield id="GOSTAT0" width="1" begin="0" end="0" resetval="0" description="Power Domain 0 Transition Command Status                                               Power domain 0 is reserved for the Always ON domain, this bit is always 0." range="" rwaccess="R">
		</bitfield>
	</register>
	<register id="MRSTSTAT0" acronym="MRSTSTAT0" offset="0x200" width="32" description="Module Reset Status 0 (mod 0 - 31) Register">
		<bitfield id="MRSTz_31" width="31" begin="31" end="1" resetval="0" description="Shows Module 1 to Module 31's reset status" range="" rwaccess="R">
		</bitfield>
		<bitfield id="MRSTz0" width="1" begin="0" end="0" resetval="0" description="0: Module reset is asserted low.                                                                   1: Module reset is de-asserted high." range="" rwaccess="R">
		</bitfield>
	</register>
	<register id="MRSTSTAT1" acronym="MRSTSTAT1" offset="0x204" width="32" description="Module Reset Status 1 (mod  32-63) Register">
		<bitfield id="MRSTz_32" width="32" begin="31" end="0" resetval="0" description="Shows Module 32 to Module 63's reset status" range="" rwaccess="R">
		</bitfield>
	</register>
	<register id="MRSTPRG0" acronym="MRSTPRG0" offset="0x210" width="32" description="Module Reset Programmed 0 (mod 0 - 31) Register">
		<bitfield id="MRSTz_31" width="31" begin="31" end="1" resetval="0" description="Controls Module 1 to Module 31's reset " range="" rwaccess="R">
		</bitfield>
		<bitfield id="MRSTz0" width="1" begin="0" end="0" resetval="0" description="0: Module reset is asserted low.                                                                   1: Module reset is de-asserted high." range="" rwaccess="R">
		</bitfield>
	</register>
	<register id="MRSTPRG1" acronym="MRSTPRG1" offset="0x214" width="32" description="Module Reset Programmed 1 (mod 32 - 63) Register">
		<bitfield id="MRSTz_32" width="32" begin="31" end="0" resetval="0" description="Controls Module 32 to Module 63's reset" range="" rwaccess="R">
		</bitfield>
	</register>
	<register id="MRSTSET0" acronym="MRSTSET0" offset="0x220" width="32" description="Module Reset Set 0 (mod 0 - 31) Register">
		<bitfield id="MRSTz_31" width="31" begin="31" end="1" resetval="0" description="For Modules 31 down to 1,                                                                           0: Writes of 0 have no effect                                                                        1: Writes of 1 set MRSTz[n] to de-assert reset to that module                                                                        " range="" rwaccess="W">
		</bitfield>
		<bitfield id="MRSTz0" width="1" begin="0" end="0" resetval="0" description="Set to de-assert module reset                                                                       0: Writes of 0 have no effect                                                                        1: Writes of 1 set MRSTz0 to de-assert reset to module 0                                                                        " range="" rwaccess="W">
		</bitfield>
	</register>
	<register id="MRSTSET1" acronym="MRSTSET1" offset="0x224" width="32" description="Module Reset Set 1 (mod 32 - 63) Register">
		<bitfield id="MRSTz_32" width="32" begin="31" end="0" resetval="0" description="For Modules 63 down to 32,                                                                           0: Writes of 0 have no effect                                                                        1: Writes of 1 set MRSTz[n] to de-assert reset to that module                                                                         " range="" rwaccess="W">
		</bitfield>
	</register>
	<register id="MRSTCLR0" acronym="MRSTCLR0" offset="0x230" width="32" description="Module Reset Clear 0 (mod 0 - 31) Register">
		<bitfield id="MRSTz_31" width="31" begin="31" end="1" resetval="0" description="For Modules 31 down to 1,                                                                           0: Writes of 0 have no effect                                                                        1: Writes of 1 clear MRSTz[n] to assert reset to that module                                                                        " range="" rwaccess="W">
		</bitfield>
		<bitfield id="MRSTz0" width="1" begin="0" end="0" resetval="0" description="Clear to assert module reset                                                                       0: Writes of 0 have no effect                                                                        1: Writes of 1 clear MRSTz0 to assert reset to module 0                                                                        " range="" rwaccess="W">
		</bitfield>
	</register>
	<register id="MRSTCLR1" acronym="MRSTCLR1" offset="0x234" width="32" description="Module Reset Clear 1 (mod 32 - 63) Register">
		<bitfield id="MRSTz_32" width="32" begin="31" end="0" resetval="0" description="For Modules 63 down to 32,                                                                           0: Writes of 0 have no effect                                                                        1: Writes of 1 clear MRSTz[n] to assert reset to that module                                                                         " range="" rwaccess="W">
		</bitfield>
	</register>
	<register id="LRSTSTAT0" acronym="LRSTSTAT0" offset="0x240" width="32" description="Module Local Reset Status 0 (mod 0 - 31) Register">
		<bitfield id="LRSTz_31" width="31" begin="31" end="1" resetval="0" description="Shows Module 1 to Module 31's local reset status" range="" rwaccess="R">
		</bitfield>
		<bitfield id="LRSTz0" width="1" begin="0" end="0" resetval="0" description="0: Module local reset is asserted.                                                                   1: Module local reset is de-asserted." range="" rwaccess="R">
		</bitfield>
	</register>
	<register id="LRSTSTAT1" acronym="LRSTSTAT1" offset="0x244" width="32" description="Module Local Reset Status 1 (mod  32-63) Register">
		<bitfield id="MRSTz_32" width="32" begin="31" end="0" resetval="0" description="Shows Module 32 to Module 63's local reset status" range="" rwaccess="R">
		</bitfield>
	</register>
	<register id="LRSTPRG0" acronym="LRSTPRG0" offset="0x250" width="32" description="Module Local Reset Programmed 0 (mod 0 - 31) Register">
		<bitfield id="LRSTz_31" width="31" begin="31" end="1" resetval="0" description="Controls Module 1 to Module 31's local reset " range="" rwaccess="R">
		</bitfield>
		<bitfield id="LRSTz0" width="1" begin="0" end="0" resetval="0" description="0: Module local reset is asserted.                                                                   1: Module local reset is de-asserted." range="" rwaccess="R">
		</bitfield>
	</register>
	<register id="LRSTPRG1" acronym="LRSTPRG1" offset="0x254" width="32" description="Module Local Reset Programmed 1 (mod 32 - 63) Register">
		<bitfield id="LRSTz_32" width="32" begin="31" end="0" resetval="0" description="Controls Module 32 to Module 63's local reset" range="" rwaccess="R">
		</bitfield>
	</register>
	<register id="LRSTSET0" acronym="LRSTSET0" offset="0x260" width="32" description="Module Local Reset Set 0 (mod 0 - 31) Register">
		<bitfield id="LRSTz_31" width="31" begin="31" end="1" resetval="0" description="For Modules 31 down to 1,                                                                           0: Writes of 0 have no effect                                                                        1: Writes of 1 set LRSTz[n] to de-assert local reset to that module                                                                        " range="" rwaccess="W">
		</bitfield>
		<bitfield id="LRSTz0" width="1" begin="0" end="0" resetval="0" description="Set to de-assert module local reset                                                                       0: Writes of 0 have no effect                                                                        1: Writes of 1 set LRSTz0 to de-assert local  reset to module 0                                                                        " range="" rwaccess="W">
		</bitfield>
	</register>
	<register id="LRSTSET1" acronym="LRSTSET1" offset="0x264" width="32" description="Module Local Reset Set 1 (mod 32 - 63) Register">
		<bitfield id="LRSTz_32" width="32" begin="31" end="0" resetval="0" description="For Modules 63 down to 32,                                                                           0: Writes of 0 have no effect                                                                        1: Writes of 1 set LRSTz[n] to de-assert local reset to that module                                                                         " range="" rwaccess="W">
		</bitfield>
	</register>
	<register id="LRSTCLR0" acronym="LRSTCLR0" offset="0x270" width="32" description="Module Local Reset Clear 0 (mod 0 - 31) Register">
		<bitfield id="LRSTz_31" width="31" begin="31" end="1" resetval="0" description="For Modules 31 down to 1,                                                                           0: Writes of 0 have no effect                                                                        1: Writes of 1 clear LRSTz[n] to assert local reset to that module                                                                        " range="" rwaccess="W">
		</bitfield>
		<bitfield id="LRSTz0" width="1" begin="0" end="0" resetval="0" description="Clear to assert module local reset                                                                       0: Writes of 0 have no effect                                                                        1: Writes of 1 clear LRSTz0 to assert local  reset to module 0                                                                        " range="" rwaccess="W">
		</bitfield>
	</register>
	<register id="LRSTCLR1" acronym="LRSTCLR1" offset="0x274" width="32" description="Module Local Reset Clear 1 (mod 32 - 63) Register">
		<bitfield id="LRSTz_32" width="32" begin="31" end="0" resetval="0" description="For Modules 63 down to 32,                                                                           0: Writes of 0 have no effect                                                                        1: Writes of 1 clear LRSTz[n] to assert  local reset to that module                                                                         " range="" rwaccess="W">
		</bitfield>
	</register>
	<register id="PORSTAT0" acronym="PORSTAT0" offset="0x280" width="32" description="Module Power On Reset Status 0 (mod 0 - 31) Register">
		<bitfield id="PORz_31" width="31" begin="31" end="1" resetval="0" description="Shows Module 1 to Module 31's PORz reset status" range="" rwaccess="R">
		</bitfield>
		<bitfield id="PORz0" width="1" begin="0" end="0" resetval="0" description="0: Module PORz reset is asserted.                                                                   1: Module PORz reset is de-asserted." range="" rwaccess="R">
		</bitfield>
	</register>
	<register id="PORSTAT1" acronym="PORSTAT1" offset="0x284" width="32" description="Module Power On Reset Status 1 (mod  32-63) Register">
		<bitfield id="PORz_32" width="32" begin="31" end="0" resetval="0" description="Shows Module 32 to Module 63's PORz reset status" range="" rwaccess="R">
		</bitfield>
	</register>
	<register id="PORPRG0" acronym="PORPRG0" offset="0x290" width="32" description="Module Power On Reset Programmed 0 (mod 0 - 31) Register">
		<bitfield id="PORz_31" width="31" begin="31" end="1" resetval="0" description="Controls Module 1 to Module 31's PORz reset " range="" rwaccess="R">
		</bitfield>
		<bitfield id="PORz0" width="1" begin="0" end="0" resetval="0" description="0: Module PORz reset is asserted.                                                                   1: Module PORz reset is de-asserted." range="" rwaccess="R">
		</bitfield>
	</register>
	<register id="PORPRG1" acronym="PORPRG1" offset="0x294" width="32" description="Module Power On Reset Programmed 1 (mod 32 - 63) Register">
		<bitfield id="PORz_32" width="32" begin="31" end="0" resetval="0" description="Controls Module 32 to Module 63's PORz reset" range="" rwaccess="R">
		</bitfield>
	</register>
	<register id="PORSET0" acronym="PORSET0" offset="0x2A0" width="32" description="Module Power On Reset Set 0 (mod 0 - 31) Register">
		<bitfield id="PORz_31" width="31" begin="31" end="1" resetval="0" description="For Modules 31 down to 1,                                                                           0: Writes of 0 have no effect                                                                        1: Writes of 1 set PORz[n] to de-assert PORz reset to that module                                                                        " range="" rwaccess="W">
		</bitfield>
		<bitfield id="PORz0" width="1" begin="0" end="0" resetval="0" description="Set to de-assert module PORz reset                                                                       0: Writes of 0 have no effect                                                                        1: Writes of 1 set PORz0 to de-assert PORz reset to module 0                                                                        " range="" rwaccess="W">
		</bitfield>
	</register>
	<register id="PORSET1" acronym="PORSET1" offset="0x2A4" width="32" description="Module Power On Reset Set 1 (mod 32 - 63) Register">
		<bitfield id="PORz_32" width="32" begin="31" end="0" resetval="0" description="For Modules 63 down to 32,                                                                           0: Writes of 0 have no effect                                                                        1: Writes of 1 set PORz[n] to de-assert PORz reset to that module                                                                         " range="" rwaccess="W">
		</bitfield>
	</register>
	<register id="PORCLR0" acronym="PORCLR0" offset="0x2B0" width="32" description="Module Power On Reset Clear 0 (mod 0 - 31) Register">
		<bitfield id="PORz_31" width="31" begin="31" end="1" resetval="0" description="For Modules 31 down to 1,                                                                           0: Writes of 0 have no effect                                                                        1: Writes of 1 clear PORz[n] to assert PORz reset to that module                                                                        " range="" rwaccess="W">
		</bitfield>
		<bitfield id="PORz0" width="1" begin="0" end="0" resetval="0" description="Clear to assert module PORz reset                                                                       0: Writes of 0 have no effect                                                                        1: Writes of 1 clear PORz0 to assert PORz reset to module 0                                                                        " range="" rwaccess="W">
		</bitfield>
	</register>
	<register id="PORCLR1" acronym="PORCLR1" offset="0x2B4" width="32" description="Module Power On Reset Clear 1 (mod 32 - 63) Register">
		<bitfield id="PORz_32" width="32" begin="31" end="0" resetval="0" description="For Modules 63 down to 32,                                                                           0: Writes of 0 have no effect                                                                        1: Writes of 1 clear PORz[n] to assert PORz reset to that module                                                                         " range="" rwaccess="W">
		</bitfield>
	</register>
	<register id="CKENSTAT0" acronym="CKENSTAT0" offset="0x2C0" width="32" description="Module Clock Enable Status 0 (mod 0 - 31) Register">
		<bitfield id="CKEN_32" width="32" begin="31" end="0" resetval="0" description="0: Module clock is gated                                                                                1: Module clock is running. Does not have a direct relation to enabled state of the module.                                                                             " range="" rwaccess="R">
		</bitfield>
	</register>
	<register id="CKENSTAT1" acronym="CKENSTAT1" offset="0x2C4" width="32" description="Module Clock Enable Status 1 (mod 32-63) Register">
		<bitfield id="CKEN_32" width="32" begin="31" end="0" resetval="0" description="0: Module clock is gated                                                                                1: Module clock is running. Does not have a direct relation to enabled state of the module.                                                                             " range="" rwaccess="R">
		</bitfield>
	</register>
	<register id="CKENPRG0" acronym="CKENPRG0" offset="0x2D0" width="32" description="Module Clock Enable Programmed 0 (mod 0 - 31) Register">
		<bitfield id="CKEN_32" width="32" begin="31" end="0" resetval="0" description="0:Gate Module Clock.                                                                                  1: Ungate Module Clock." range="" rwaccess="R">
		</bitfield>
	</register>
	<register id="CKENPRG1" acronym="CKENPRG1" offset="0x2D4" width="32" description="Module Clock Enable Programmed 1 (mod 32 - 63) Register">
		<bitfield id="CKEN_32" width="32" begin="31" end="0" resetval="0" description="0:Gate Module Clock.                                                                                  1: Ungate Module Clock." range="" rwaccess="R">
		</bitfield>
	</register>
	<register id="CKENSET0" acronym="CKENSET0" offset="0x2E0" width="32" description="Module Clock Enable Set 0 (mod 0 - 31) Register">
		<bitfield id="CKEN_31" width="31" begin="31" end="1" resetval="0" description="For Modules 31 down to 1,                                                                           0: Writes of 0 have no effect                                                                        1: Writes of 1 set CKEN[n] to turn on clock to that module                                                                        " range="" rwaccess="W">
		</bitfield>
		<bitfield id="CKEN0" width="1" begin="0" end="0" resetval="0" description="Set CKEN0 = 1 to turn on module clock                                                                       0: Writes of 0 have no effect                                                                        1: Writes of 1 set CKEN0 to turn on clock to module 0                                                                        " range="" rwaccess="W">
		</bitfield>
	</register>
	<register id="CKENSET1" acronym="CKENSET1" offset="0x2E4" width="32" description="Module Clock Enable Set 1 (mod 32 - 63) Register">
		<bitfield id="CKEN_32" width="32" begin="31" end="0" resetval="0" description="For Modules 63 down to 32,                                                                           0: Writes of 0 have no effect                                                                        1: Writes of 1 set CKEN[n] to turn on clock to that module                                                                         " range="" rwaccess="W">
		</bitfield>
	</register>
	<register id="CKENCLR0" acronym="CKENCLR0" offset="0x2F0" width="32" description="Module Clock Enable Clear 0 (mod 0 - 31) Register">
		<bitfield id="CKEN_31" width="31" begin="31" end="1" resetval="0" description="For Modules 31 down to 1,                                                                           0: Writes of 0 have no effect                                                                        1: Writes of 1 clear CKEN[n] to gate clock to that module                                                                        " range="" rwaccess="W">
		</bitfield>
		<bitfield id="CKEN0" width="1" begin="0" end="0" resetval="0" description="Clear CKEN0 = 0 to gate module clock                                                                       0: Writes of 0 have no effect                                                                        1: Writes of 1 clear CKEN0 to gate clock to module 0                                                                        " range="" rwaccess="W">
		</bitfield>
	</register>
	<register id="CKENCLR1" acronym="CKENCLR1" offset="0x2F4" width="32" description="Module Clock Enable Clear 1 (mod 32 - 63) Register">
		<bitfield id="CKEN_32" width="32" begin="31" end="0" resetval="0" description="For Modules 63 down to 32,                                                                           0: Writes of 0 have no effect                                                                        1: Writes of 1 clear CKEN[n] to gate clock to that module                                                                         " range="" rwaccess="W">
		</bitfield>
	</register>
	<register id="SLPSTAT0" acronym="SLPSTAT0" offset="0x300" width="32" description="Module Sleep Status 0 (mod 0 - 31) Register">
		<bitfield id="SLP0_32" width="32" begin="31" end="0" resetval="0" description="0: Module is not in sleep state or any transitional states related to Sleep mode                                                                                                            1: Module is in Sleep state or any transitional states related to Sleep mode                                                                           " range="" rwaccess="R">
		</bitfield>
	</register>
	<register id="SLPSTAT1" acronym="SLPSTAT1" offset="0x304" width="32" description="Module Sleep Status 1 (mod 32-63) Register">
		<bitfield id="SLP1_32" width="32" begin="31" end="0" resetval="0" description="0: Module is not in sleep state or any transitional states related to Sleep mode                                                                                                            1: Module is in Sleep state or any transitional states related to Sleep mode                                                                           " range="" rwaccess="R">
		</bitfield>
	</register>
	<register id="SLPPRG0" acronym="SLPPRG0" offset="0x310" width="32" description="Module Sleep Programmed 0 (mod 0 - 31) Register">
		<bitfield id="SLP0_32" width="32" begin="31" end="0" resetval="0" description="0: Do not put module in sleep state or any transitional states related to sleep mode                                                                                                    1: Put module in sleep state or transitional states related to sleep mode" range="" rwaccess="R">
		</bitfield>
	</register>
	<register id="SLPPRG1" acronym="SLPPRG1" offset="0x314" width="32" description="Module Sleep Programmed 1 (mod 32 - 63) Register">
		<bitfield id="SLP1_32" width="32" begin="31" end="0" resetval="0" description="0: Do not put module in sleep state or any transitional states related to sleep mode                                                                                                    1: Put module in sleep state or transitional states related to sleep mode" range="" rwaccess="R">
		</bitfield>
	</register>
	<register id="SLPSET0" acronym="SLPSET0" offset="0x320" width="32" description="Module Sleep Set 0 (mod 0 - 31) Register">
		<bitfield id="SLP_31" width="31" begin="31" end="1" resetval="0" description="For Modules 31 down to 1,                                                                           0: Writes of 0 have no effect                                                                        1: Writes of 1 set SLP[n]                                                                        " range="" rwaccess="W">
		</bitfield>
		<bitfield id="SLP0" width="1" begin="0" end="0" resetval="0" description="Set SLP0 = 1                                                                                               0: Writes of 0 have no effect                                                                        1: Writes of 1 set SLP0                                                                        " range="" rwaccess="W">
		</bitfield>
	</register>
	<register id="SLPSET1" acronym="SLPSET1" offset="0x324" width="32" description="Module Sleep Set 1 (mod 32 - 63) Register">
		<bitfield id="SLP_32" width="32" begin="31" end="0" resetval="0" description="For Modules 63 down to 32,                                                                           0: Writes of 0 have no effect                                                                        1: Writes of 1 set SLP[n]                                                                          " range="" rwaccess="W">
		</bitfield>
	</register>
	<register id="SLPCLR0" acronym="SLPCLR0" offset="0x330" width="32" description="Module Sleep Clear 0 (mod 0 - 31) Register">
		<bitfield id="SLP_31" width="31" begin="31" end="1" resetval="0" description="For Modules 31 down to 1,                                                                           0: Writes of 0 have no effect                                                                        1: Writes of 1 clears SLP[n]                                                                        " range="" rwaccess="W">
		</bitfield>
		<bitfield id="SLP0" width="1" begin="0" end="0" resetval="0" description="Clear SLP0 = 0                                                                                            0: Writes of 0 have no effect                                                                        1: Writes of 1 clear SLP0                                                                        " range="" rwaccess="W">
		</bitfield>
	</register>
	<register id="SLPCLR1" acronym="SLPCLR1" offset="0x334" width="32" description="Module Sleep Clear 1 (mod 32 - 63) Register">
		<bitfield id="SLP_32" width="32" begin="31" end="0" resetval="0" description="For Modules 63 down to 32,                                                                           0: Writes of 0 have no effect                                                                        1: Writes of 1 clear SLP[n]                                                                         " range="" rwaccess="W">
		</bitfield>
	</register>
	<register id="TWKSTAT0" acronym="TWKSTAT0" offset="0x340" width="32" description="Module Temporary Wakeup Status 0 (mod 0 - 31) Register">
		<bitfield id="TWK0_32" width="32" begin="31" end="0" resetval="0" description="This register holds the temporary wakeup status of modules 0 - 31           0: Module is not in TWK state or any transitional states related to temporary wakeup                                                                                        1: Module is in TWK state or any transitional states related to temporary wakeup" range="" rwaccess="R">
		</bitfield>
	</register>
	<register id="TWKSTAT1" acronym="TWKSTAT1" offset="0x344" width="32" description="Module Temporary Wakeup Status 1 (mod 32 - 63) Register">
		<bitfield id="TWK1_32" width="32" begin="31" end="0" resetval="0" description="This register holds the temporary wakeup status of modules 32-63           0: Module is not in TWK state or any transitional states related to temporary wakeup                                                                                        1: Module is in TWK state or any transitional states related to temporary wakeup" range="" rwaccess="R">
		</bitfield>
	</register>
	<register id="TWKPRG0" acronym="TWKPRG0" offset="0x350" width="32" description="Module Temporary Wakeup Programmed 0 (mod 0 - 31) Register">
		<bitfield id="TWK0_32" width="32" begin="31" end="0" resetval="0" description="This register holds the temporary wakeup status of modules 0 - 31           0: Do not put module in TWK state or any transitional states related to temporary wakeup                                                                                        1: Put module in TWK state or any transitional states related to temporary wakeup" range="" rwaccess="R">
		</bitfield>
	</register>
	<register id="TWKPRG1" acronym="TWKPRG1" offset="0x354" width="32" description="Module Temporary Wakeup Programmed 1 (mod 32 - 63) Register">
		<bitfield id="TWK1_32" width="32" begin="31" end="0" resetval="0" description="This register holds the temporary wakeup status of modules 32-63           0: Do not put module in TWK state or any transitional states related to temporary wakeup                                                                                        1: Put module in TWK state or any transitional states related to temporary wakeup" range="" rwaccess="R">
		</bitfield>
	</register>
	<register id="MTSTAT0" acronym="MTSTAT0" offset="0x360" width="32" description="Module Transition Status 0 (mod 0 - 31) Register">
		<bitfield id="M_32" width="32" begin="31" end="0" resetval="0" description="PSC 1.0 Definition: Module n State Transition                                             0: No state transition required for this module                                              1: State transition required for this module                                                   PSC2.0 Definition: Module n State Transition                                                 0: Module n is not going through state transition                                           1: Module n state transition is in progress                                                    Note that n ranges from 0 to 31 in this case" range="" rwaccess="R">
		</bitfield>
	</register>
	<register id="MTSTAT1" acronym="MTSTAT1" offset="0x364" width="32" description="Module Transition Status 1 (mod 32 - 63) Register">
		<bitfield id="M_32" width="32" begin="31" end="0" resetval="0" description="PSC 1.0 Definition: Module n State Transition                                                0: No state transition required for this module                                              1: State transition required for this module                                                   PSC2.0 Definition: Module n State Transition                                                 0: Module n is not going through state transition                                           1: Module n state transition is in progress                                                     Note that n ranges from 32 to 63 in this case" range="" rwaccess="R">
		</bitfield>
	</register>
	<register id="MTCLR0" acronym="MTCLR0" offset="0x370" width="32" description="Module Transition Clear 0 (mod 0 - 31) Register">
		<bitfield id="M_32" width="32" begin="31" end="0" resetval="0" description="Module n Transition Status Clear, where n ranges from 0 to 31                   Writes of 1 clear the corresponding bit in MTSTAT. Writes of 0 have no effect. This register is used for Software Manual Control method- so that whenever software is done servicing the desired state transition, it can use this register to clear the corresponding status." range="" rwaccess="RW">
		</bitfield>
	</register>
	<register id="MTCLR1" acronym="MTCLR1" offset="0x374" width="32" description="Module Transition Clear 1 (mod 32 - 63) Register">
		<bitfield id="M_32" width="32" begin="31" end="0" resetval="0" description="Module n Transition Status Clear, where n ranges from 32 to 63                   Writes of 1 clear the corresponding bit in MTSTAT. Writes of 0 have no effect. This register is used for Software Manual Control method- so that whenever software is done servicing the desired state transition, it can use this register to clear the corresponding status." range="" rwaccess="RW">
		</bitfield>
	</register>
	<register id="ICEINHB0" acronym="ICEINHB0" offset="0x380" width="32" description="IcePick Inhibit Off 0 (mod 0 - 31) Register">
		<bitfield id="M_32" width="32" begin="31" end="0" resetval="0" description="IcePick Inhibit Off Request for Module n, where n ranges from 0 to 31        0: No IcePick Inhibit Off Request for Module n                                              1: IcePick Inhibit Off Request for Module n is detected" range="" rwaccess="R">
		</bitfield>
	</register>
	<register id="ICEINHB1" acronym="ICEINHB1" offset="0x384" width="32" description="IcePick Inhibit Off 1 (mod 32 - 63) Register">
		<bitfield id="M_32" width="32" begin="31" end="0" resetval="0" description="IcePick Inhibit Off Request for Module n, where n ranges from 32 to 63        0: No IcePick Inhibit Off Request for Module n                                              1: IcePick Inhibit Off Request for Module n is detected" range="" rwaccess="R">
		</bitfield>
	</register>
	<register id="ICEFRC0" acronym="ICEFRC0" offset="0x390" width="32" description="IcePick Force On 0 (mod 0 - 31) Register">
		<bitfield id="M_32" width="32" begin="31" end="0" resetval="0" description="IcePick Force On Request for Module n, where n ranges from 0 to 31        0: No IcePick Force On Request for Module n                                              1: IcePick Force On Request for Module n is detected" range="" rwaccess="R">
		</bitfield>
	</register>
	<register id="ICEFRC1" acronym="ICEFRC1" offset="0x394" width="32" description="IcePick Force On 1 (mod 32 - 63) Register">
		<bitfield id="M_32" width="32" begin="31" end="0" resetval="0" description="IcePick Force On Request for Module n, where n ranges from 32 to 63        0: No IcePick Force On Request for Module n                                              1: IcePick Force On Request for Module n is detected" range="" rwaccess="R">
		</bitfield>
	</register>
	<register id="MDCFG0" acronym="MDCFG0" offset="0x400" width="32" description="Module Configuration 0 Register">
		<bitfield id="_RESV" width="24" begin="31" end="8" resetval="0" description="Reserved" range="" rwaccess="R">
		</bitfield>
		<bitfield id="CKRST" width="1" begin="7" end="7" resetval="0" description="Modclk during hard_rst_src_assert. Shows the tieoff d_mod[x]_hard_rst_src_assert.                                                                   0: LPSC does not give modclk when hard_rst_src_assert_pi_n = 0 (asserted). LPSC only gives modclk after this reset is de-asserted            1: LPSC gives modclk even when hard_rst_src_assert_pi_n = 0 (assert)" range="" rwaccess="R">
		</bitfield>
		<bitfield id="PLLCKGT" width="1" begin="6" end="6" resetval="0" description="PLL Clock Gate. Shows the tieoff d_mod[x]_pll_clk_gate                             0: LPSC gates modclk directly                                                                       1: LPSC does not gate modclk directly. LPSC instructs the PLLCTRL to gate modclk                           " range="" rwaccess="R">
		</bitfield>
		<bitfield id="LSRSTBLK" width="1" begin="5" end="5" resetval="0" description="LRST Soft Reset Block. Shows the tieoff d_mod[x]_lrst_soft_rst_block value.                                                                                                             0: Soft resets are not blocked to LRST                                                         1: Soft resets are blocked to LRST" range="" rwaccess="R">
		</bitfield>
		<bitfield id="SRSTBLK" width="1" begin="4" end="4" resetval="0" description="Soft Reset Block. Shows the tieoff d_mod[x]_soft_rst_block value.            0: Soft resets are not blocked. Any grstz from PLLCTRL will be propagated to the module                                                                              1: Soft resets are blocked. LPSC only passes hard resets to the module" range="" rwaccess="R">
		</bitfield>
		<bitfield id="MSTGKT" width="1" begin="3" end="3" resetval="0" description="Master Gasket support. Reflects the RTL parameter MSTGKT                     0: Master Gasket not supported by LPSC                                                     1: Master Gasket supported by LPSC" range="" rwaccess="R">
		</bitfield>
		<bitfield id="_RESV" width="1" begin="2" end="2" resetval="0" description="Reserved" range="" rwaccess="R">
		</bitfield>
		<bitfield id="LPSCTYPE" width="2" begin="1" end="0" resetval="0" description="LPSC Type. Reflects the RTL parameter LPSCTYPE                                    00: Single-Port LPSC (1PORT)                                                                       01: Dual-Clock LPSC (2CLK)                                                                         10: Dual-Port LPSC (2PORT)                                                                         11: Reserved" range="" rwaccess="R">
		</bitfield>
	</register>
	<register id="MDCFG1" acronym="MDCFG1" offset="0x404" width="32" description="Module Configuration 1 Register">
		<bitfield id="_RESV" width="24" begin="31" end="8" resetval="0" description="Reserved" range="" rwaccess="R">
		</bitfield>
		<bitfield id="CKRST" width="1" begin="7" end="7" resetval="0" description="Modclk during hard_rst_src_assert. Shows the tieoff d_mod[x]_hard_rst_src_assert.                                                                   0: LPSC does not give modclk when hard_rst_src_assert_pi_n = 0 (asserted). LPSC only gives modclk after this reset is de-asserted            1: LPSC gives modclk even when hard_rst_src_assert_pi_n = 0 (assert)" range="" rwaccess="R">
		</bitfield>
		<bitfield id="PLLCKGT" width="1" begin="6" end="6" resetval="0" description="PLL Clock Gate. Shows the tieoff d_mod[x]_pll_clk_gate                             0: LPSC gates modclk directly                                                                       1: LPSC does not gate modclk directly. LPSC instructs the PLLCTRL to gate modclk                           " range="" rwaccess="R">
		</bitfield>
		<bitfield id="LSRSTBLK" width="1" begin="5" end="5" resetval="0" description="LRST Soft Reset Block. Shows the tieoff d_mod[x]_lrst_soft_rst_block value.                                                                                                             0: Soft resets are not blocked to LRST                                                         1: Soft resets are blocked to LRST" range="" rwaccess="R">
		</bitfield>
		<bitfield id="SRSTBLK" width="1" begin="4" end="4" resetval="0" description="Soft Reset Block. Shows the tieoff d_mod[x]_soft_rst_block value.            0: Soft resets are not blocked. Any grstz from PLLCTRL will be propagated to the module                                                                              1: Soft resets are blocked. LPSC only passes hard resets to the module" range="" rwaccess="R">
		</bitfield>
		<bitfield id="MSTGKT" width="1" begin="3" end="3" resetval="0" description="Master Gasket support. Reflects the RTL parameter MSTGKT                     0: Master Gasket not supported by LPSC                                                     1: Master Gasket supported by LPSC" range="" rwaccess="R">
		</bitfield>
		<bitfield id="_RESV" width="1" begin="2" end="2" resetval="0" description="Reserved" range="" rwaccess="R">
		</bitfield>
		<bitfield id="LPSCTYPE" width="2" begin="1" end="0" resetval="0" description="LPSC Type. Reflects the RTL parameter LPSCTYPE                                    00: Single-Port LPSC (1PORT)                                                                       01: Dual-Clock LPSC (2CLK)                                                                         10: Dual-Port LPSC (2PORT)                                                                         11: Reserved" range="" rwaccess="R">
		</bitfield>
	</register>
	<register id="MDCFG2" acronym="MDCFG2" offset="0x408" width="32" description="Module Configuration 2 Register">
		<bitfield id="_RESV" width="24" begin="31" end="8" resetval="0" description="Reserved" range="" rwaccess="R">
		</bitfield>
		<bitfield id="CKRST" width="1" begin="7" end="7" resetval="0" description="Modclk during hard_rst_src_assert. Shows the tieoff d_mod[x]_hard_rst_src_assert.                                                                   0: LPSC does not give modclk when hard_rst_src_assert_pi_n = 0 (asserted). LPSC only gives modclk after this reset is de-asserted            1: LPSC gives modclk even when hard_rst_src_assert_pi_n = 0 (assert)" range="" rwaccess="R">
		</bitfield>
		<bitfield id="PLLCKGT" width="1" begin="6" end="6" resetval="0" description="PLL Clock Gate. Shows the tieoff d_mod[x]_pll_clk_gate                             0: LPSC gates modclk directly                                                                       1: LPSC does not gate modclk directly. LPSC instructs the PLLCTRL to gate modclk                           " range="" rwaccess="R">
		</bitfield>
		<bitfield id="LSRSTBLK" width="1" begin="5" end="5" resetval="0" description="LRST Soft Reset Block. Shows the tieoff d_mod[x]_lrst_soft_rst_block value.                                                                                                             0: Soft resets are not blocked to LRST                                                         1: Soft resets are blocked to LRST" range="" rwaccess="R">
		</bitfield>
		<bitfield id="SRSTBLK" width="1" begin="4" end="4" resetval="0" description="Soft Reset Block. Shows the tieoff d_mod[x]_soft_rst_block value.            0: Soft resets are not blocked. Any grstz from PLLCTRL will be propagated to the module                                                                              1: Soft resets are blocked. LPSC only passes hard resets to the module" range="" rwaccess="R">
		</bitfield>
		<bitfield id="MSTGKT" width="1" begin="3" end="3" resetval="0" description="Master Gasket support. Reflects the RTL parameter MSTGKT                     0: Master Gasket not supported by LPSC                                                     1: Master Gasket supported by LPSC" range="" rwaccess="R">
		</bitfield>
		<bitfield id="_RESV" width="1" begin="2" end="2" resetval="0" description="Reserved" range="" rwaccess="R">
		</bitfield>
		<bitfield id="LPSCTYPE" width="2" begin="1" end="0" resetval="0" description="LPSC Type. Reflects the RTL parameter LPSCTYPE                                    00: Single-Port LPSC (1PORT)                                                                       01: Dual-Clock LPSC (2CLK)                                                                         10: Dual-Port LPSC (2PORT)                                                                         11: Reserved" range="" rwaccess="R">
		</bitfield>
	</register>
	<register id="MDCFG3" acronym="MDCFG3" offset="0x40C" width="32" description="Module Configuration 3 Register">
		<bitfield id="_RESV" width="24" begin="31" end="8" resetval="0" description="Reserved" range="" rwaccess="R">
		</bitfield>
		<bitfield id="CKRST" width="1" begin="7" end="7" resetval="0" description="Modclk during hard_rst_src_assert. Shows the tieoff d_mod[x]_hard_rst_src_assert.                                                                   0: LPSC does not give modclk when hard_rst_src_assert_pi_n = 0 (asserted). LPSC only gives modclk after this reset is de-asserted            1: LPSC gives modclk even when hard_rst_src_assert_pi_n = 0 (assert)" range="" rwaccess="R">
		</bitfield>
		<bitfield id="PLLCKGT" width="1" begin="6" end="6" resetval="0" description="PLL Clock Gate. Shows the tieoff d_mod[x]_pll_clk_gate                             0: LPSC gates modclk directly                                                                       1: LPSC does not gate modclk directly. LPSC instructs the PLLCTRL to gate modclk                           " range="" rwaccess="R">
		</bitfield>
		<bitfield id="LSRSTBLK" width="1" begin="5" end="5" resetval="0" description="LRST Soft Reset Block. Shows the tieoff d_mod[x]_lrst_soft_rst_block value.                                                                                                             0: Soft resets are not blocked to LRST                                                         1: Soft resets are blocked to LRST" range="" rwaccess="R">
		</bitfield>
		<bitfield id="SRSTBLK" width="1" begin="4" end="4" resetval="0" description="Soft Reset Block. Shows the tieoff d_mod[x]_soft_rst_block value.            0: Soft resets are not blocked. Any grstz from PLLCTRL will be propagated to the module                                                                              1: Soft resets are blocked. LPSC only passes hard resets to the module" range="" rwaccess="R">
		</bitfield>
		<bitfield id="MSTGKT" width="1" begin="3" end="3" resetval="0" description="Master Gasket support. Reflects the RTL parameter MSTGKT                     0: Master Gasket not supported by LPSC                                                     1: Master Gasket supported by LPSC" range="" rwaccess="R">
		</bitfield>
		<bitfield id="_RESV" width="1" begin="2" end="2" resetval="0" description="Reserved" range="" rwaccess="R">
		</bitfield>
		<bitfield id="LPSCTYPE" width="2" begin="1" end="0" resetval="0" description="LPSC Type. Reflects the RTL parameter LPSCTYPE                                    00: Single-Port LPSC (1PORT)                                                                       01: Dual-Clock LPSC (2CLK)                                                                         10: Dual-Port LPSC (2PORT)                                                                         11: Reserved" range="" rwaccess="R">
		</bitfield>
	</register>
	<register id="MDCFG4" acronym="MDCFG4" offset="0x410" width="32" description="Module Configuration 4 Register">
		<bitfield id="_RESV" width="24" begin="31" end="8" resetval="0" description="Reserved" range="" rwaccess="R">
		</bitfield>
		<bitfield id="CKRST" width="1" begin="7" end="7" resetval="0" description="Modclk during hard_rst_src_assert. Shows the tieoff d_mod[x]_hard_rst_src_assert.                                                                   0: LPSC does not give modclk when hard_rst_src_assert_pi_n = 0 (asserted). LPSC only gives modclk after this reset is de-asserted            1: LPSC gives modclk even when hard_rst_src_assert_pi_n = 0 (assert)" range="" rwaccess="R">
		</bitfield>
		<bitfield id="PLLCKGT" width="1" begin="6" end="6" resetval="0" description="PLL Clock Gate. Shows the tieoff d_mod[x]_pll_clk_gate                             0: LPSC gates modclk directly                                                                       1: LPSC does not gate modclk directly. LPSC instructs the PLLCTRL to gate modclk                           " range="" rwaccess="R">
		</bitfield>
		<bitfield id="LSRSTBLK" width="1" begin="5" end="5" resetval="0" description="LRST Soft Reset Block. Shows the tieoff d_mod[x]_lrst_soft_rst_block value.                                                                                                             0: Soft resets are not blocked to LRST                                                         1: Soft resets are blocked to LRST" range="" rwaccess="R">
		</bitfield>
		<bitfield id="SRSTBLK" width="1" begin="4" end="4" resetval="0" description="Soft Reset Block. Shows the tieoff d_mod[x]_soft_rst_block value.            0: Soft resets are not blocked. Any grstz from PLLCTRL will be propagated to the module                                                                              1: Soft resets are blocked. LPSC only passes hard resets to the module" range="" rwaccess="R">
		</bitfield>
		<bitfield id="MSTGKT" width="1" begin="3" end="3" resetval="0" description="Master Gasket support. Reflects the RTL parameter MSTGKT                     0: Master Gasket not supported by LPSC                                                     1: Master Gasket supported by LPSC" range="" rwaccess="R">
		</bitfield>
		<bitfield id="_RESV" width="1" begin="2" end="2" resetval="0" description="Reserved" range="" rwaccess="R">
		</bitfield>
		<bitfield id="LPSCTYPE" width="2" begin="1" end="0" resetval="0" description="LPSC Type. Reflects the RTL parameter LPSCTYPE                                    00: Single-Port LPSC (1PORT)                                                                       01: Dual-Clock LPSC (2CLK)                                                                         10: Dual-Port LPSC (2PORT)                                                                         11: Reserved" range="" rwaccess="R">
		</bitfield>
	</register>
	<register id="MDCFG5" acronym="MDCFG5" offset="0x414" width="32" description="Module Configuration 5 Register">
		<bitfield id="_RESV" width="24" begin="31" end="8" resetval="0" description="Reserved" range="" rwaccess="R">
		</bitfield>
		<bitfield id="CKRST" width="1" begin="7" end="7" resetval="0" description="Modclk during hard_rst_src_assert. Shows the tieoff d_mod[x]_hard_rst_src_assert.                                                                   0: LPSC does not give modclk when hard_rst_src_assert_pi_n = 0 (asserted). LPSC only gives modclk after this reset is de-asserted            1: LPSC gives modclk even when hard_rst_src_assert_pi_n = 0 (assert)" range="" rwaccess="R">
		</bitfield>
		<bitfield id="PLLCKGT" width="1" begin="6" end="6" resetval="0" description="PLL Clock Gate. Shows the tieoff d_mod[x]_pll_clk_gate                             0: LPSC gates modclk directly                                                                       1: LPSC does not gate modclk directly. LPSC instructs the PLLCTRL to gate modclk                           " range="" rwaccess="R">
		</bitfield>
		<bitfield id="LSRSTBLK" width="1" begin="5" end="5" resetval="0" description="LRST Soft Reset Block. Shows the tieoff d_mod[x]_lrst_soft_rst_block value.                                                                                                             0: Soft resets are not blocked to LRST                                                         1: Soft resets are blocked to LRST" range="" rwaccess="R">
		</bitfield>
		<bitfield id="SRSTBLK" width="1" begin="4" end="4" resetval="0" description="Soft Reset Block. Shows the tieoff d_mod[x]_soft_rst_block value.            0: Soft resets are not blocked. Any grstz from PLLCTRL will be propagated to the module                                                                              1: Soft resets are blocked. LPSC only passes hard resets to the module" range="" rwaccess="R">
		</bitfield>
		<bitfield id="MSTGKT" width="1" begin="3" end="3" resetval="0" description="Master Gasket support. Reflects the RTL parameter MSTGKT                     0: Master Gasket not supported by LPSC                                                     1: Master Gasket supported by LPSC" range="" rwaccess="R">
		</bitfield>
		<bitfield id="_RESV" width="1" begin="2" end="2" resetval="0" description="Reserved" range="" rwaccess="R">
		</bitfield>
		<bitfield id="LPSCTYPE" width="2" begin="1" end="0" resetval="0" description="LPSC Type. Reflects the RTL parameter LPSCTYPE                                    00: Single-Port LPSC (1PORT)                                                                       01: Dual-Clock LPSC (2CLK)                                                                         10: Dual-Port LPSC (2PORT)                                                                         11: Reserved" range="" rwaccess="R">
		</bitfield>
	</register>
	<register id="MDCFG6" acronym="MDCFG6" offset="0x418" width="32" description="Module Configuration 6 Register">
		<bitfield id="_RESV" width="24" begin="31" end="8" resetval="0" description="Reserved" range="" rwaccess="R">
		</bitfield>
		<bitfield id="CKRST" width="1" begin="7" end="7" resetval="0" description="Modclk during hard_rst_src_assert. Shows the tieoff d_mod[x]_hard_rst_src_assert.                                                                   0: LPSC does not give modclk when hard_rst_src_assert_pi_n = 0 (asserted). LPSC only gives modclk after this reset is de-asserted            1: LPSC gives modclk even when hard_rst_src_assert_pi_n = 0 (assert)" range="" rwaccess="R">
		</bitfield>
		<bitfield id="PLLCKGT" width="1" begin="6" end="6" resetval="0" description="PLL Clock Gate. Shows the tieoff d_mod[x]_pll_clk_gate                             0: LPSC gates modclk directly                                                                       1: LPSC does not gate modclk directly. LPSC instructs the PLLCTRL to gate modclk                           " range="" rwaccess="R">
		</bitfield>
		<bitfield id="LSRSTBLK" width="1" begin="5" end="5" resetval="0" description="LRST Soft Reset Block. Shows the tieoff d_mod[x]_lrst_soft_rst_block value.                                                                                                             0: Soft resets are not blocked to LRST                                                         1: Soft resets are blocked to LRST" range="" rwaccess="R">
		</bitfield>
		<bitfield id="SRSTBLK" width="1" begin="4" end="4" resetval="0" description="Soft Reset Block. Shows the tieoff d_mod[x]_soft_rst_block value.            0: Soft resets are not blocked. Any grstz from PLLCTRL will be propagated to the module                                                                              1: Soft resets are blocked. LPSC only passes hard resets to the module" range="" rwaccess="R">
		</bitfield>
		<bitfield id="MSTGKT" width="1" begin="3" end="3" resetval="0" description="Master Gasket support. Reflects the RTL parameter MSTGKT                     0: Master Gasket not supported by LPSC                                                     1: Master Gasket supported by LPSC" range="" rwaccess="R">
		</bitfield>
		<bitfield id="_RESV" width="1" begin="2" end="2" resetval="0" description="Reserved" range="" rwaccess="R">
		</bitfield>
		<bitfield id="LPSCTYPE" width="2" begin="1" end="0" resetval="0" description="LPSC Type. Reflects the RTL parameter LPSCTYPE                                    00: Single-Port LPSC (1PORT)                                                                       01: Dual-Clock LPSC (2CLK)                                                                         10: Dual-Port LPSC (2PORT)                                                                         11: Reserved" range="" rwaccess="R">
		</bitfield>
	</register>
	<register id="MDCFG7" acronym="MDCFG7" offset="0x41C" width="32" description="Module Configuration 7 Register">
		<bitfield id="_RESV" width="24" begin="31" end="8" resetval="0" description="Reserved" range="" rwaccess="R">
		</bitfield>
		<bitfield id="CKRST" width="1" begin="7" end="7" resetval="0" description="Modclk during hard_rst_src_assert. Shows the tieoff d_mod[x]_hard_rst_src_assert.                                                                   0: LPSC does not give modclk when hard_rst_src_assert_pi_n = 0 (asserted). LPSC only gives modclk after this reset is de-asserted            1: LPSC gives modclk even when hard_rst_src_assert_pi_n = 0 (assert)" range="" rwaccess="R">
		</bitfield>
		<bitfield id="PLLCKGT" width="1" begin="6" end="6" resetval="0" description="PLL Clock Gate. Shows the tieoff d_mod[x]_pll_clk_gate                             0: LPSC gates modclk directly                                                                       1: LPSC does not gate modclk directly. LPSC instructs the PLLCTRL to gate modclk                           " range="" rwaccess="R">
		</bitfield>
		<bitfield id="LSRSTBLK" width="1" begin="5" end="5" resetval="0" description="LRST Soft Reset Block. Shows the tieoff d_mod[x]_lrst_soft_rst_block value.                                                                                                             0: Soft resets are not blocked to LRST                                                         1: Soft resets are blocked to LRST" range="" rwaccess="R">
		</bitfield>
		<bitfield id="SRSTBLK" width="1" begin="4" end="4" resetval="0" description="Soft Reset Block. Shows the tieoff d_mod[x]_soft_rst_block value.            0: Soft resets are not blocked. Any grstz from PLLCTRL will be propagated to the module                                                                              1: Soft resets are blocked. LPSC only passes hard resets to the module" range="" rwaccess="R">
		</bitfield>
		<bitfield id="MSTGKT" width="1" begin="3" end="3" resetval="0" description="Master Gasket support. Reflects the RTL parameter MSTGKT                     0: Master Gasket not supported by LPSC                                                     1: Master Gasket supported by LPSC" range="" rwaccess="R">
		</bitfield>
		<bitfield id="_RESV" width="1" begin="2" end="2" resetval="0" description="Reserved" range="" rwaccess="R">
		</bitfield>
		<bitfield id="LPSCTYPE" width="2" begin="1" end="0" resetval="0" description="LPSC Type. Reflects the RTL parameter LPSCTYPE                                    00: Single-Port LPSC (1PORT)                                                                       01: Dual-Clock LPSC (2CLK)                                                                         10: Dual-Port LPSC (2PORT)                                                                         11: Reserved" range="" rwaccess="R">
		</bitfield>
	</register>
	<register id="MDCFG8" acronym="MDCFG8" offset="0x420" width="32" description="Module Configuration 8 Register">
		<bitfield id="_RESV" width="24" begin="31" end="8" resetval="0" description="Reserved" range="" rwaccess="R">
		</bitfield>
		<bitfield id="CKRST" width="1" begin="7" end="7" resetval="0" description="Modclk during hard_rst_src_assert. Shows the tieoff d_mod[x]_hard_rst_src_assert.                                                                   0: LPSC does not give modclk when hard_rst_src_assert_pi_n = 0 (asserted). LPSC only gives modclk after this reset is de-asserted            1: LPSC gives modclk even when hard_rst_src_assert_pi_n = 0 (assert)" range="" rwaccess="R">
		</bitfield>
		<bitfield id="PLLCKGT" width="1" begin="6" end="6" resetval="0" description="PLL Clock Gate. Shows the tieoff d_mod[x]_pll_clk_gate                             0: LPSC gates modclk directly                                                                       1: LPSC does not gate modclk directly. LPSC instructs the PLLCTRL to gate modclk                           " range="" rwaccess="R">
		</bitfield>
		<bitfield id="LSRSTBLK" width="1" begin="5" end="5" resetval="0" description="LRST Soft Reset Block. Shows the tieoff d_mod[x]_lrst_soft_rst_block value.                                                                                                             0: Soft resets are not blocked to LRST                                                         1: Soft resets are blocked to LRST" range="" rwaccess="R">
		</bitfield>
		<bitfield id="SRSTBLK" width="1" begin="4" end="4" resetval="0" description="Soft Reset Block. Shows the tieoff d_mod[x]_soft_rst_block value.            0: Soft resets are not blocked. Any grstz from PLLCTRL will be propagated to the module                                                                              1: Soft resets are blocked. LPSC only passes hard resets to the module" range="" rwaccess="R">
		</bitfield>
		<bitfield id="MSTGKT" width="1" begin="3" end="3" resetval="0" description="Master Gasket support. Reflects the RTL parameter MSTGKT                     0: Master Gasket not supported by LPSC                                                     1: Master Gasket supported by LPSC" range="" rwaccess="R">
		</bitfield>
		<bitfield id="_RESV" width="1" begin="2" end="2" resetval="0" description="Reserved" range="" rwaccess="R">
		</bitfield>
		<bitfield id="LPSCTYPE" width="2" begin="1" end="0" resetval="0" description="LPSC Type. Reflects the RTL parameter LPSCTYPE                                    00: Single-Port LPSC (1PORT)                                                                       01: Dual-Clock LPSC (2CLK)                                                                         10: Dual-Port LPSC (2PORT)                                                                         11: Reserved" range="" rwaccess="R">
		</bitfield>
	</register>
	<register id="MDCFG9" acronym="MDCFG9" offset="0x424" width="32" description="Module Configuration 9 Register">
		<bitfield id="_RESV" width="24" begin="31" end="8" resetval="0" description="Reserved" range="" rwaccess="R">
		</bitfield>
		<bitfield id="CKRST" width="1" begin="7" end="7" resetval="0" description="Modclk during hard_rst_src_assert. Shows the tieoff d_mod[x]_hard_rst_src_assert.                                                                   0: LPSC does not give modclk when hard_rst_src_assert_pi_n = 0 (asserted). LPSC only gives modclk after this reset is de-asserted            1: LPSC gives modclk even when hard_rst_src_assert_pi_n = 0 (assert)" range="" rwaccess="R">
		</bitfield>
		<bitfield id="PLLCKGT" width="1" begin="6" end="6" resetval="0" description="PLL Clock Gate. Shows the tieoff d_mod[x]_pll_clk_gate                             0: LPSC gates modclk directly                                                                       1: LPSC does not gate modclk directly. LPSC instructs the PLLCTRL to gate modclk                           " range="" rwaccess="R">
		</bitfield>
		<bitfield id="LSRSTBLK" width="1" begin="5" end="5" resetval="0" description="LRST Soft Reset Block. Shows the tieoff d_mod[x]_lrst_soft_rst_block value.                                                                                                             0: Soft resets are not blocked to LRST                                                         1: Soft resets are blocked to LRST" range="" rwaccess="R">
		</bitfield>
		<bitfield id="SRSTBLK" width="1" begin="4" end="4" resetval="0" description="Soft Reset Block. Shows the tieoff d_mod[x]_soft_rst_block value.            0: Soft resets are not blocked. Any grstz from PLLCTRL will be propagated to the module                                                                              1: Soft resets are blocked. LPSC only passes hard resets to the module" range="" rwaccess="R">
		</bitfield>
		<bitfield id="MSTGKT" width="1" begin="3" end="3" resetval="0" description="Master Gasket support. Reflects the RTL parameter MSTGKT                     0: Master Gasket not supported by LPSC                                                     1: Master Gasket supported by LPSC" range="" rwaccess="R">
		</bitfield>
		<bitfield id="_RESV" width="1" begin="2" end="2" resetval="0" description="Reserved" range="" rwaccess="R">
		</bitfield>
		<bitfield id="LPSCTYPE" width="2" begin="1" end="0" resetval="0" description="LPSC Type. Reflects the RTL parameter LPSCTYPE                                    00: Single-Port LPSC (1PORT)                                                                       01: Dual-Clock LPSC (2CLK)                                                                         10: Dual-Port LPSC (2PORT)                                                                         11: Reserved" range="" rwaccess="R">
		</bitfield>
	</register>
	<register id="MDCFG10" acronym="MDCFG10" offset="0x428" width="32" description="Module Configuration 10 Register">
		<bitfield id="_RESV" width="24" begin="31" end="8" resetval="0" description="Reserved" range="" rwaccess="R">
		</bitfield>
		<bitfield id="CKRST" width="1" begin="7" end="7" resetval="0" description="Modclk during hard_rst_src_assert. Shows the tieoff d_mod[x]_hard_rst_src_assert.                                                                   0: LPSC does not give modclk when hard_rst_src_assert_pi_n = 0 (asserted). LPSC only gives modclk after this reset is de-asserted            1: LPSC gives modclk even when hard_rst_src_assert_pi_n = 0 (assert)" range="" rwaccess="R">
		</bitfield>
		<bitfield id="PLLCKGT" width="1" begin="6" end="6" resetval="0" description="PLL Clock Gate. Shows the tieoff d_mod[x]_pll_clk_gate                             0: LPSC gates modclk directly                                                                       1: LPSC does not gate modclk directly. LPSC instructs the PLLCTRL to gate modclk                           " range="" rwaccess="R">
		</bitfield>
		<bitfield id="LSRSTBLK" width="1" begin="5" end="5" resetval="0" description="LRST Soft Reset Block. Shows the tieoff d_mod[x]_lrst_soft_rst_block value.                                                                                                             0: Soft resets are not blocked to LRST                                                         1: Soft resets are blocked to LRST" range="" rwaccess="R">
		</bitfield>
		<bitfield id="SRSTBLK" width="1" begin="4" end="4" resetval="0" description="Soft Reset Block. Shows the tieoff d_mod[x]_soft_rst_block value.            0: Soft resets are not blocked. Any grstz from PLLCTRL will be propagated to the module                                                                              1: Soft resets are blocked. LPSC only passes hard resets to the module" range="" rwaccess="R">
		</bitfield>
		<bitfield id="MSTGKT" width="1" begin="3" end="3" resetval="0" description="Master Gasket support. Reflects the RTL parameter MSTGKT                     0: Master Gasket not supported by LPSC                                                     1: Master Gasket supported by LPSC" range="" rwaccess="R">
		</bitfield>
		<bitfield id="_RESV" width="1" begin="2" end="2" resetval="0" description="Reserved" range="" rwaccess="R">
		</bitfield>
		<bitfield id="LPSCTYPE" width="2" begin="1" end="0" resetval="0" description="LPSC Type. Reflects the RTL parameter LPSCTYPE                                    00: Single-Port LPSC (1PORT)                                                                       01: Dual-Clock LPSC (2CLK)                                                                         10: Dual-Port LPSC (2PORT)                                                                         11: Reserved" range="" rwaccess="R">
		</bitfield>
	</register>
	<register id="MDCFG11" acronym="MDCFG11" offset="0x42C" width="32" description="Module Configuration 11 Register">
		<bitfield id="_RESV" width="24" begin="31" end="8" resetval="0" description="Reserved" range="" rwaccess="R">
		</bitfield>
		<bitfield id="CKRST" width="1" begin="7" end="7" resetval="0" description="Modclk during hard_rst_src_assert. Shows the tieoff d_mod[x]_hard_rst_src_assert.                                                                   0: LPSC does not give modclk when hard_rst_src_assert_pi_n = 0 (asserted). LPSC only gives modclk after this reset is de-asserted            1: LPSC gives modclk even when hard_rst_src_assert_pi_n = 0 (assert)" range="" rwaccess="R">
		</bitfield>
		<bitfield id="PLLCKGT" width="1" begin="6" end="6" resetval="0" description="PLL Clock Gate. Shows the tieoff d_mod[x]_pll_clk_gate                             0: LPSC gates modclk directly                                                                       1: LPSC does not gate modclk directly. LPSC instructs the PLLCTRL to gate modclk                           " range="" rwaccess="R">
		</bitfield>
		<bitfield id="LSRSTBLK" width="1" begin="5" end="5" resetval="0" description="LRST Soft Reset Block. Shows the tieoff d_mod[x]_lrst_soft_rst_block value.                                                                                                             0: Soft resets are not blocked to LRST                                                         1: Soft resets are blocked to LRST" range="" rwaccess="R">
		</bitfield>
		<bitfield id="SRSTBLK" width="1" begin="4" end="4" resetval="0" description="Soft Reset Block. Shows the tieoff d_mod[x]_soft_rst_block value.            0: Soft resets are not blocked. Any grstz from PLLCTRL will be propagated to the module                                                                              1: Soft resets are blocked. LPSC only passes hard resets to the module" range="" rwaccess="R">
		</bitfield>
		<bitfield id="MSTGKT" width="1" begin="3" end="3" resetval="0" description="Master Gasket support. Reflects the RTL parameter MSTGKT                     0: Master Gasket not supported by LPSC                                                     1: Master Gasket supported by LPSC" range="" rwaccess="R">
		</bitfield>
		<bitfield id="_RESV" width="1" begin="2" end="2" resetval="0" description="Reserved" range="" rwaccess="R">
		</bitfield>
		<bitfield id="LPSCTYPE" width="2" begin="1" end="0" resetval="0" description="LPSC Type. Reflects the RTL parameter LPSCTYPE                                    00: Single-Port LPSC (1PORT)                                                                       01: Dual-Clock LPSC (2CLK)                                                                         10: Dual-Port LPSC (2PORT)                                                                         11: Reserved" range="" rwaccess="R">
		</bitfield>
	</register>
	<register id="MDCFG12" acronym="MDCFG12" offset="0x430" width="32" description="Module Configuration 12 Register">
		<bitfield id="_RESV" width="24" begin="31" end="8" resetval="0" description="Reserved" range="" rwaccess="R">
		</bitfield>
		<bitfield id="CKRST" width="1" begin="7" end="7" resetval="0" description="Modclk during hard_rst_src_assert. Shows the tieoff d_mod[x]_hard_rst_src_assert.                                                                   0: LPSC does not give modclk when hard_rst_src_assert_pi_n = 0 (asserted). LPSC only gives modclk after this reset is de-asserted            1: LPSC gives modclk even when hard_rst_src_assert_pi_n = 0 (assert)" range="" rwaccess="R">
		</bitfield>
		<bitfield id="PLLCKGT" width="1" begin="6" end="6" resetval="0" description="PLL Clock Gate. Shows the tieoff d_mod[x]_pll_clk_gate                             0: LPSC gates modclk directly                                                                       1: LPSC does not gate modclk directly. LPSC instructs the PLLCTRL to gate modclk                           " range="" rwaccess="R">
		</bitfield>
		<bitfield id="LSRSTBLK" width="1" begin="5" end="5" resetval="0" description="LRST Soft Reset Block. Shows the tieoff d_mod[x]_lrst_soft_rst_block value.                                                                                                             0: Soft resets are not blocked to LRST                                                         1: Soft resets are blocked to LRST" range="" rwaccess="R">
		</bitfield>
		<bitfield id="SRSTBLK" width="1" begin="4" end="4" resetval="0" description="Soft Reset Block. Shows the tieoff d_mod[x]_soft_rst_block value.            0: Soft resets are not blocked. Any grstz from PLLCTRL will be propagated to the module                                                                              1: Soft resets are blocked. LPSC only passes hard resets to the module" range="" rwaccess="R">
		</bitfield>
		<bitfield id="MSTGKT" width="1" begin="3" end="3" resetval="0" description="Master Gasket support. Reflects the RTL parameter MSTGKT                     0: Master Gasket not supported by LPSC                                                     1: Master Gasket supported by LPSC" range="" rwaccess="R">
		</bitfield>
		<bitfield id="_RESV" width="1" begin="2" end="2" resetval="0" description="Reserved" range="" rwaccess="R">
		</bitfield>
		<bitfield id="LPSCTYPE" width="2" begin="1" end="0" resetval="0" description="LPSC Type. Reflects the RTL parameter LPSCTYPE                                    00: Single-Port LPSC (1PORT)                                                                       01: Dual-Clock LPSC (2CLK)                                                                         10: Dual-Port LPSC (2PORT)                                                                         11: Reserved" range="" rwaccess="R">
		</bitfield>
	</register>
	<register id="MDCFG13" acronym="MDCFG13" offset="0x434" width="32" description="Module Configuration 13 Register">
		<bitfield id="_RESV" width="24" begin="31" end="8" resetval="0" description="Reserved" range="" rwaccess="R">
		</bitfield>
		<bitfield id="CKRST" width="1" begin="7" end="7" resetval="0" description="Modclk during hard_rst_src_assert. Shows the tieoff d_mod[x]_hard_rst_src_assert.                                                                   0: LPSC does not give modclk when hard_rst_src_assert_pi_n = 0 (asserted). LPSC only gives modclk after this reset is de-asserted            1: LPSC gives modclk even when hard_rst_src_assert_pi_n = 0 (assert)" range="" rwaccess="R">
		</bitfield>
		<bitfield id="PLLCKGT" width="1" begin="6" end="6" resetval="0" description="PLL Clock Gate. Shows the tieoff d_mod[x]_pll_clk_gate                             0: LPSC gates modclk directly                                                                       1: LPSC does not gate modclk directly. LPSC instructs the PLLCTRL to gate modclk                           " range="" rwaccess="R">
		</bitfield>
		<bitfield id="LSRSTBLK" width="1" begin="5" end="5" resetval="0" description="LRST Soft Reset Block. Shows the tieoff d_mod[x]_lrst_soft_rst_block value.                                                                                                             0: Soft resets are not blocked to LRST                                                         1: Soft resets are blocked to LRST" range="" rwaccess="R">
		</bitfield>
		<bitfield id="SRSTBLK" width="1" begin="4" end="4" resetval="0" description="Soft Reset Block. Shows the tieoff d_mod[x]_soft_rst_block value.            0: Soft resets are not blocked. Any grstz from PLLCTRL will be propagated to the module                                                                              1: Soft resets are blocked. LPSC only passes hard resets to the module" range="" rwaccess="R">
		</bitfield>
		<bitfield id="MSTGKT" width="1" begin="3" end="3" resetval="0" description="Master Gasket support. Reflects the RTL parameter MSTGKT                     0: Master Gasket not supported by LPSC                                                     1: Master Gasket supported by LPSC" range="" rwaccess="R">
		</bitfield>
		<bitfield id="_RESV" width="1" begin="2" end="2" resetval="0" description="Reserved" range="" rwaccess="R">
		</bitfield>
		<bitfield id="LPSCTYPE" width="2" begin="1" end="0" resetval="0" description="LPSC Type. Reflects the RTL parameter LPSCTYPE                                    00: Single-Port LPSC (1PORT)                                                                       01: Dual-Clock LPSC (2CLK)                                                                         10: Dual-Port LPSC (2PORT)                                                                         11: Reserved" range="" rwaccess="R">
		</bitfield>
	</register>
	<register id="MDCFG14" acronym="MDCFG14" offset="0x438" width="32" description="Module Configuration 14 Register">
		<bitfield id="_RESV" width="24" begin="31" end="8" resetval="0" description="Reserved" range="" rwaccess="R">
		</bitfield>
		<bitfield id="CKRST" width="1" begin="7" end="7" resetval="0" description="Modclk during hard_rst_src_assert. Shows the tieoff d_mod[x]_hard_rst_src_assert.                                                                   0: LPSC does not give modclk when hard_rst_src_assert_pi_n = 0 (asserted). LPSC only gives modclk after this reset is de-asserted            1: LPSC gives modclk even when hard_rst_src_assert_pi_n = 0 (assert)" range="" rwaccess="R">
		</bitfield>
		<bitfield id="PLLCKGT" width="1" begin="6" end="6" resetval="0" description="PLL Clock Gate. Shows the tieoff d_mod[x]_pll_clk_gate                             0: LPSC gates modclk directly                                                                       1: LPSC does not gate modclk directly. LPSC instructs the PLLCTRL to gate modclk                           " range="" rwaccess="R">
		</bitfield>
		<bitfield id="LSRSTBLK" width="1" begin="5" end="5" resetval="0" description="LRST Soft Reset Block. Shows the tieoff d_mod[x]_lrst_soft_rst_block value.                                                                                                             0: Soft resets are not blocked to LRST                                                         1: Soft resets are blocked to LRST" range="" rwaccess="R">
		</bitfield>
		<bitfield id="SRSTBLK" width="1" begin="4" end="4" resetval="0" description="Soft Reset Block. Shows the tieoff d_mod[x]_soft_rst_block value.            0: Soft resets are not blocked. Any grstz from PLLCTRL will be propagated to the module                                                                              1: Soft resets are blocked. LPSC only passes hard resets to the module" range="" rwaccess="R">
		</bitfield>
		<bitfield id="MSTGKT" width="1" begin="3" end="3" resetval="0" description="Master Gasket support. Reflects the RTL parameter MSTGKT                     0: Master Gasket not supported by LPSC                                                     1: Master Gasket supported by LPSC" range="" rwaccess="R">
		</bitfield>
		<bitfield id="_RESV" width="1" begin="2" end="2" resetval="0" description="Reserved" range="" rwaccess="R">
		</bitfield>
		<bitfield id="LPSCTYPE" width="2" begin="1" end="0" resetval="0" description="LPSC Type. Reflects the RTL parameter LPSCTYPE                                    00: Single-Port LPSC (1PORT)                                                                       01: Dual-Clock LPSC (2CLK)                                                                         10: Dual-Port LPSC (2PORT)                                                                         11: Reserved" range="" rwaccess="R">
		</bitfield>
	</register>
	<register id="MDCFG15" acronym="MDCFG15" offset="0x43C" width="32" description="Module Configuration 15 Register">
		<bitfield id="_RESV" width="24" begin="31" end="8" resetval="0" description="Reserved" range="" rwaccess="R">
		</bitfield>
		<bitfield id="CKRST" width="1" begin="7" end="7" resetval="0" description="Modclk during hard_rst_src_assert. Shows the tieoff d_mod[x]_hard_rst_src_assert.                                                                   0: LPSC does not give modclk when hard_rst_src_assert_pi_n = 0 (asserted). LPSC only gives modclk after this reset is de-asserted            1: LPSC gives modclk even when hard_rst_src_assert_pi_n = 0 (assert)" range="" rwaccess="R">
		</bitfield>
		<bitfield id="PLLCKGT" width="1" begin="6" end="6" resetval="0" description="PLL Clock Gate. Shows the tieoff d_mod[x]_pll_clk_gate                             0: LPSC gates modclk directly                                                                       1: LPSC does not gate modclk directly. LPSC instructs the PLLCTRL to gate modclk                           " range="" rwaccess="R">
		</bitfield>
		<bitfield id="LSRSTBLK" width="1" begin="5" end="5" resetval="0" description="LRST Soft Reset Block. Shows the tieoff d_mod[x]_lrst_soft_rst_block value.                                                                                                             0: Soft resets are not blocked to LRST                                                         1: Soft resets are blocked to LRST" range="" rwaccess="R">
		</bitfield>
		<bitfield id="SRSTBLK" width="1" begin="4" end="4" resetval="0" description="Soft Reset Block. Shows the tieoff d_mod[x]_soft_rst_block value.            0: Soft resets are not blocked. Any grstz from PLLCTRL will be propagated to the module                                                                              1: Soft resets are blocked. LPSC only passes hard resets to the module" range="" rwaccess="R">
		</bitfield>
		<bitfield id="MSTGKT" width="1" begin="3" end="3" resetval="0" description="Master Gasket support. Reflects the RTL parameter MSTGKT                     0: Master Gasket not supported by LPSC                                                     1: Master Gasket supported by LPSC" range="" rwaccess="R">
		</bitfield>
		<bitfield id="_RESV" width="1" begin="2" end="2" resetval="0" description="Reserved" range="" rwaccess="R">
		</bitfield>
		<bitfield id="LPSCTYPE" width="2" begin="1" end="0" resetval="0" description="LPSC Type. Reflects the RTL parameter LPSCTYPE                                    00: Single-Port LPSC (1PORT)                                                                       01: Dual-Clock LPSC (2CLK)                                                                         10: Dual-Port LPSC (2PORT)                                                                         11: Reserved" range="" rwaccess="R">
		</bitfield>
	</register>
	<register id="MDCFG16" acronym="MDCFG16" offset="0x440" width="32" description="Module Configuration 16 Register">
		<bitfield id="_RESV" width="24" begin="31" end="8" resetval="0" description="Reserved" range="" rwaccess="R">
		</bitfield>
		<bitfield id="CKRST" width="1" begin="7" end="7" resetval="0" description="Modclk during hard_rst_src_assert. Shows the tieoff d_mod[x]_hard_rst_src_assert.                                                                   0: LPSC does not give modclk when hard_rst_src_assert_pi_n = 0 (asserted). LPSC only gives modclk after this reset is de-asserted            1: LPSC gives modclk even when hard_rst_src_assert_pi_n = 0 (assert)" range="" rwaccess="R">
		</bitfield>
		<bitfield id="PLLCKGT" width="1" begin="6" end="6" resetval="0" description="PLL Clock Gate. Shows the tieoff d_mod[x]_pll_clk_gate                             0: LPSC gates modclk directly                                                                       1: LPSC does not gate modclk directly. LPSC instructs the PLLCTRL to gate modclk                           " range="" rwaccess="R">
		</bitfield>
		<bitfield id="LSRSTBLK" width="1" begin="5" end="5" resetval="0" description="LRST Soft Reset Block. Shows the tieoff d_mod[x]_lrst_soft_rst_block value.                                                                                                             0: Soft resets are not blocked to LRST                                                         1: Soft resets are blocked to LRST" range="" rwaccess="R">
		</bitfield>
		<bitfield id="SRSTBLK" width="1" begin="4" end="4" resetval="0" description="Soft Reset Block. Shows the tieoff d_mod[x]_soft_rst_block value.            0: Soft resets are not blocked. Any grstz from PLLCTRL will be propagated to the module                                                                              1: Soft resets are blocked. LPSC only passes hard resets to the module" range="" rwaccess="R">
		</bitfield>
		<bitfield id="MSTGKT" width="1" begin="3" end="3" resetval="0" description="Master Gasket support. Reflects the RTL parameter MSTGKT                     0: Master Gasket not supported by LPSC                                                     1: Master Gasket supported by LPSC" range="" rwaccess="R">
		</bitfield>
		<bitfield id="_RESV" width="1" begin="2" end="2" resetval="0" description="Reserved" range="" rwaccess="R">
		</bitfield>
		<bitfield id="LPSCTYPE" width="2" begin="1" end="0" resetval="0" description="LPSC Type. Reflects the RTL parameter LPSCTYPE                                    00: Single-Port LPSC (1PORT)                                                                       01: Dual-Clock LPSC (2CLK)                                                                         10: Dual-Port LPSC (2PORT)                                                                         11: Reserved" range="" rwaccess="R">
		</bitfield>
	</register>
	<register id="MDCFG17" acronym="MDCFG17" offset="0x444" width="32" description="Module Configuration 17 Register">
		<bitfield id="_RESV" width="24" begin="31" end="8" resetval="0" description="Reserved" range="" rwaccess="R">
		</bitfield>
		<bitfield id="CKRST" width="1" begin="7" end="7" resetval="0" description="Modclk during hard_rst_src_assert. Shows the tieoff d_mod[x]_hard_rst_src_assert.                                                                   0: LPSC does not give modclk when hard_rst_src_assert_pi_n = 0 (asserted). LPSC only gives modclk after this reset is de-asserted            1: LPSC gives modclk even when hard_rst_src_assert_pi_n = 0 (assert)" range="" rwaccess="R">
		</bitfield>
		<bitfield id="PLLCKGT" width="1" begin="6" end="6" resetval="0" description="PLL Clock Gate. Shows the tieoff d_mod[x]_pll_clk_gate                             0: LPSC gates modclk directly                                                                       1: LPSC does not gate modclk directly. LPSC instructs the PLLCTRL to gate modclk                           " range="" rwaccess="R">
		</bitfield>
		<bitfield id="LSRSTBLK" width="1" begin="5" end="5" resetval="0" description="LRST Soft Reset Block. Shows the tieoff d_mod[x]_lrst_soft_rst_block value.                                                                                                             0: Soft resets are not blocked to LRST                                                         1: Soft resets are blocked to LRST" range="" rwaccess="R">
		</bitfield>
		<bitfield id="SRSTBLK" width="1" begin="4" end="4" resetval="0" description="Soft Reset Block. Shows the tieoff d_mod[x]_soft_rst_block value.            0: Soft resets are not blocked. Any grstz from PLLCTRL will be propagated to the module                                                                              1: Soft resets are blocked. LPSC only passes hard resets to the module" range="" rwaccess="R">
		</bitfield>
		<bitfield id="MSTGKT" width="1" begin="3" end="3" resetval="0" description="Master Gasket support. Reflects the RTL parameter MSTGKT                     0: Master Gasket not supported by LPSC                                                     1: Master Gasket supported by LPSC" range="" rwaccess="R">
		</bitfield>
		<bitfield id="_RESV" width="1" begin="2" end="2" resetval="0" description="Reserved" range="" rwaccess="R">
		</bitfield>
		<bitfield id="LPSCTYPE" width="2" begin="1" end="0" resetval="0" description="LPSC Type. Reflects the RTL parameter LPSCTYPE                                    00: Single-Port LPSC (1PORT)                                                                       01: Dual-Clock LPSC (2CLK)                                                                         10: Dual-Port LPSC (2PORT)                                                                         11: Reserved" range="" rwaccess="R">
		</bitfield>
	</register>
	<register id="MDCFG18" acronym="MDCFG18" offset="0x448" width="32" description="Module Configuration 18 Register">
		<bitfield id="_RESV" width="24" begin="31" end="8" resetval="0" description="Reserved" range="" rwaccess="R">
		</bitfield>
		<bitfield id="CKRST" width="1" begin="7" end="7" resetval="0" description="Modclk during hard_rst_src_assert. Shows the tieoff d_mod[x]_hard_rst_src_assert.                                                                   0: LPSC does not give modclk when hard_rst_src_assert_pi_n = 0 (asserted). LPSC only gives modclk after this reset is de-asserted            1: LPSC gives modclk even when hard_rst_src_assert_pi_n = 0 (assert)" range="" rwaccess="R">
		</bitfield>
		<bitfield id="PLLCKGT" width="1" begin="6" end="6" resetval="0" description="PLL Clock Gate. Shows the tieoff d_mod[x]_pll_clk_gate                             0: LPSC gates modclk directly                                                                       1: LPSC does not gate modclk directly. LPSC instructs the PLLCTRL to gate modclk                           " range="" rwaccess="R">
		</bitfield>
		<bitfield id="LSRSTBLK" width="1" begin="5" end="5" resetval="0" description="LRST Soft Reset Block. Shows the tieoff d_mod[x]_lrst_soft_rst_block value.                                                                                                             0: Soft resets are not blocked to LRST                                                         1: Soft resets are blocked to LRST" range="" rwaccess="R">
		</bitfield>
		<bitfield id="SRSTBLK" width="1" begin="4" end="4" resetval="0" description="Soft Reset Block. Shows the tieoff d_mod[x]_soft_rst_block value.            0: Soft resets are not blocked. Any grstz from PLLCTRL will be propagated to the module                                                                              1: Soft resets are blocked. LPSC only passes hard resets to the module" range="" rwaccess="R">
		</bitfield>
		<bitfield id="MSTGKT" width="1" begin="3" end="3" resetval="0" description="Master Gasket support. Reflects the RTL parameter MSTGKT                     0: Master Gasket not supported by LPSC                                                     1: Master Gasket supported by LPSC" range="" rwaccess="R">
		</bitfield>
		<bitfield id="_RESV" width="1" begin="2" end="2" resetval="0" description="Reserved" range="" rwaccess="R">
		</bitfield>
		<bitfield id="LPSCTYPE" width="2" begin="1" end="0" resetval="0" description="LPSC Type. Reflects the RTL parameter LPSCTYPE                                    00: Single-Port LPSC (1PORT)                                                                       01: Dual-Clock LPSC (2CLK)                                                                         10: Dual-Port LPSC (2PORT)                                                                         11: Reserved" range="" rwaccess="R">
		</bitfield>
	</register>
	<register id="MDCFG19" acronym="MDCFG19" offset="0x44C" width="32" description="Module Configuration 19 Register">
		<bitfield id="_RESV" width="24" begin="31" end="8" resetval="0" description="Reserved" range="" rwaccess="R">
		</bitfield>
		<bitfield id="CKRST" width="1" begin="7" end="7" resetval="0" description="Modclk during hard_rst_src_assert. Shows the tieoff d_mod[x]_hard_rst_src_assert.                                                                   0: LPSC does not give modclk when hard_rst_src_assert_pi_n = 0 (asserted). LPSC only gives modclk after this reset is de-asserted            1: LPSC gives modclk even when hard_rst_src_assert_pi_n = 0 (assert)" range="" rwaccess="R">
		</bitfield>
		<bitfield id="PLLCKGT" width="1" begin="6" end="6" resetval="0" description="PLL Clock Gate. Shows the tieoff d_mod[x]_pll_clk_gate                             0: LPSC gates modclk directly                                                                       1: LPSC does not gate modclk directly. LPSC instructs the PLLCTRL to gate modclk                           " range="" rwaccess="R">
		</bitfield>
		<bitfield id="LSRSTBLK" width="1" begin="5" end="5" resetval="0" description="LRST Soft Reset Block. Shows the tieoff d_mod[x]_lrst_soft_rst_block value.                                                                                                             0: Soft resets are not blocked to LRST                                                         1: Soft resets are blocked to LRST" range="" rwaccess="R">
		</bitfield>
		<bitfield id="SRSTBLK" width="1" begin="4" end="4" resetval="0" description="Soft Reset Block. Shows the tieoff d_mod[x]_soft_rst_block value.            0: Soft resets are not blocked. Any grstz from PLLCTRL will be propagated to the module                                                                              1: Soft resets are blocked. LPSC only passes hard resets to the module" range="" rwaccess="R">
		</bitfield>
		<bitfield id="MSTGKT" width="1" begin="3" end="3" resetval="0" description="Master Gasket support. Reflects the RTL parameter MSTGKT                     0: Master Gasket not supported by LPSC                                                     1: Master Gasket supported by LPSC" range="" rwaccess="R">
		</bitfield>
		<bitfield id="_RESV" width="1" begin="2" end="2" resetval="0" description="Reserved" range="" rwaccess="R">
		</bitfield>
		<bitfield id="LPSCTYPE" width="2" begin="1" end="0" resetval="0" description="LPSC Type. Reflects the RTL parameter LPSCTYPE                                    00: Single-Port LPSC (1PORT)                                                                       01: Dual-Clock LPSC (2CLK)                                                                         10: Dual-Port LPSC (2PORT)                                                                         11: Reserved" range="" rwaccess="R">
		</bitfield>
	</register>
	<register id="MDCFG20" acronym="MDCFG20" offset="0x450" width="32" description="Module Configuration 20 Register">
		<bitfield id="_RESV" width="24" begin="31" end="8" resetval="0" description="Reserved" range="" rwaccess="R">
		</bitfield>
		<bitfield id="CKRST" width="1" begin="7" end="7" resetval="0" description="Modclk during hard_rst_src_assert. Shows the tieoff d_mod[x]_hard_rst_src_assert.                                                                   0: LPSC does not give modclk when hard_rst_src_assert_pi_n = 0 (asserted). LPSC only gives modclk after this reset is de-asserted            1: LPSC gives modclk even when hard_rst_src_assert_pi_n = 0 (assert)" range="" rwaccess="R">
		</bitfield>
		<bitfield id="PLLCKGT" width="1" begin="6" end="6" resetval="0" description="PLL Clock Gate. Shows the tieoff d_mod[x]_pll_clk_gate                             0: LPSC gates modclk directly                                                                       1: LPSC does not gate modclk directly. LPSC instructs the PLLCTRL to gate modclk                           " range="" rwaccess="R">
		</bitfield>
		<bitfield id="LSRSTBLK" width="1" begin="5" end="5" resetval="0" description="LRST Soft Reset Block. Shows the tieoff d_mod[x]_lrst_soft_rst_block value.                                                                                                             0: Soft resets are not blocked to LRST                                                         1: Soft resets are blocked to LRST" range="" rwaccess="R">
		</bitfield>
		<bitfield id="SRSTBLK" width="1" begin="4" end="4" resetval="0" description="Soft Reset Block. Shows the tieoff d_mod[x]_soft_rst_block value.            0: Soft resets are not blocked. Any grstz from PLLCTRL will be propagated to the module                                                                              1: Soft resets are blocked. LPSC only passes hard resets to the module" range="" rwaccess="R">
		</bitfield>
		<bitfield id="MSTGKT" width="1" begin="3" end="3" resetval="0" description="Master Gasket support. Reflects the RTL parameter MSTGKT                     0: Master Gasket not supported by LPSC                                                     1: Master Gasket supported by LPSC" range="" rwaccess="R">
		</bitfield>
		<bitfield id="_RESV" width="1" begin="2" end="2" resetval="0" description="Reserved" range="" rwaccess="R">
		</bitfield>
		<bitfield id="LPSCTYPE" width="2" begin="1" end="0" resetval="0" description="LPSC Type. Reflects the RTL parameter LPSCTYPE                                    00: Single-Port LPSC (1PORT)                                                                       01: Dual-Clock LPSC (2CLK)                                                                         10: Dual-Port LPSC (2PORT)                                                                         11: Reserved" range="" rwaccess="R">
		</bitfield>
	</register>
	<register id="MDCFG21" acronym="MDCFG21" offset="0x454" width="32" description="Module Configuration 21 Register">
		<bitfield id="_RESV" width="24" begin="31" end="8" resetval="0" description="Reserved" range="" rwaccess="R">
		</bitfield>
		<bitfield id="CKRST" width="1" begin="7" end="7" resetval="0" description="Modclk during hard_rst_src_assert. Shows the tieoff d_mod[x]_hard_rst_src_assert.                                                                   0: LPSC does not give modclk when hard_rst_src_assert_pi_n = 0 (asserted). LPSC only gives modclk after this reset is de-asserted            1: LPSC gives modclk even when hard_rst_src_assert_pi_n = 0 (assert)" range="" rwaccess="R">
		</bitfield>
		<bitfield id="PLLCKGT" width="1" begin="6" end="6" resetval="0" description="PLL Clock Gate. Shows the tieoff d_mod[x]_pll_clk_gate                             0: LPSC gates modclk directly                                                                       1: LPSC does not gate modclk directly. LPSC instructs the PLLCTRL to gate modclk                           " range="" rwaccess="R">
		</bitfield>
		<bitfield id="LSRSTBLK" width="1" begin="5" end="5" resetval="0" description="LRST Soft Reset Block. Shows the tieoff d_mod[x]_lrst_soft_rst_block value.                                                                                                             0: Soft resets are not blocked to LRST                                                         1: Soft resets are blocked to LRST" range="" rwaccess="R">
		</bitfield>
		<bitfield id="SRSTBLK" width="1" begin="4" end="4" resetval="0" description="Soft Reset Block. Shows the tieoff d_mod[x]_soft_rst_block value.            0: Soft resets are not blocked. Any grstz from PLLCTRL will be propagated to the module                                                                              1: Soft resets are blocked. LPSC only passes hard resets to the module" range="" rwaccess="R">
		</bitfield>
		<bitfield id="MSTGKT" width="1" begin="3" end="3" resetval="0" description="Master Gasket support. Reflects the RTL parameter MSTGKT                     0: Master Gasket not supported by LPSC                                                     1: Master Gasket supported by LPSC" range="" rwaccess="R">
		</bitfield>
		<bitfield id="_RESV" width="1" begin="2" end="2" resetval="0" description="Reserved" range="" rwaccess="R">
		</bitfield>
		<bitfield id="LPSCTYPE" width="2" begin="1" end="0" resetval="0" description="LPSC Type. Reflects the RTL parameter LPSCTYPE                                    00: Single-Port LPSC (1PORT)                                                                       01: Dual-Clock LPSC (2CLK)                                                                         10: Dual-Port LPSC (2PORT)                                                                         11: Reserved" range="" rwaccess="R">
		</bitfield>
	</register>
	<register id="MDCFG22" acronym="MDCFG22" offset="0x458" width="32" description="Module Configuration 22 Register">
		<bitfield id="_RESV" width="24" begin="31" end="8" resetval="0" description="Reserved" range="" rwaccess="R">
		</bitfield>
		<bitfield id="CKRST" width="1" begin="7" end="7" resetval="0" description="Modclk during hard_rst_src_assert. Shows the tieoff d_mod[x]_hard_rst_src_assert.                                                                   0: LPSC does not give modclk when hard_rst_src_assert_pi_n = 0 (asserted). LPSC only gives modclk after this reset is de-asserted            1: LPSC gives modclk even when hard_rst_src_assert_pi_n = 0 (assert)" range="" rwaccess="R">
		</bitfield>
		<bitfield id="PLLCKGT" width="1" begin="6" end="6" resetval="0" description="PLL Clock Gate. Shows the tieoff d_mod[x]_pll_clk_gate                             0: LPSC gates modclk directly                                                                       1: LPSC does not gate modclk directly. LPSC instructs the PLLCTRL to gate modclk                           " range="" rwaccess="R">
		</bitfield>
		<bitfield id="LSRSTBLK" width="1" begin="5" end="5" resetval="0" description="LRST Soft Reset Block. Shows the tieoff d_mod[x]_lrst_soft_rst_block value.                                                                                                             0: Soft resets are not blocked to LRST                                                         1: Soft resets are blocked to LRST" range="" rwaccess="R">
		</bitfield>
		<bitfield id="SRSTBLK" width="1" begin="4" end="4" resetval="0" description="Soft Reset Block. Shows the tieoff d_mod[x]_soft_rst_block value.            0: Soft resets are not blocked. Any grstz from PLLCTRL will be propagated to the module                                                                              1: Soft resets are blocked. LPSC only passes hard resets to the module" range="" rwaccess="R">
		</bitfield>
		<bitfield id="MSTGKT" width="1" begin="3" end="3" resetval="0" description="Master Gasket support. Reflects the RTL parameter MSTGKT                     0: Master Gasket not supported by LPSC                                                     1: Master Gasket supported by LPSC" range="" rwaccess="R">
		</bitfield>
		<bitfield id="_RESV" width="1" begin="2" end="2" resetval="0" description="Reserved" range="" rwaccess="R">
		</bitfield>
		<bitfield id="LPSCTYPE" width="2" begin="1" end="0" resetval="0" description="LPSC Type. Reflects the RTL parameter LPSCTYPE                                    00: Single-Port LPSC (1PORT)                                                                       01: Dual-Clock LPSC (2CLK)                                                                         10: Dual-Port LPSC (2PORT)                                                                         11: Reserved" range="" rwaccess="R">
		</bitfield>
	</register>
	<register id="MDCFG23" acronym="MDCFG23" offset="0x45C" width="32" description="Module Configuration 23 Register">
		<bitfield id="_RESV" width="24" begin="31" end="8" resetval="0" description="Reserved" range="" rwaccess="R">
		</bitfield>
		<bitfield id="CKRST" width="1" begin="7" end="7" resetval="0" description="Modclk during hard_rst_src_assert. Shows the tieoff d_mod[x]_hard_rst_src_assert.                                                                   0: LPSC does not give modclk when hard_rst_src_assert_pi_n = 0 (asserted). LPSC only gives modclk after this reset is de-asserted            1: LPSC gives modclk even when hard_rst_src_assert_pi_n = 0 (assert)" range="" rwaccess="R">
		</bitfield>
		<bitfield id="PLLCKGT" width="1" begin="6" end="6" resetval="0" description="PLL Clock Gate. Shows the tieoff d_mod[x]_pll_clk_gate                             0: LPSC gates modclk directly                                                                       1: LPSC does not gate modclk directly. LPSC instructs the PLLCTRL to gate modclk                           " range="" rwaccess="R">
		</bitfield>
		<bitfield id="LSRSTBLK" width="1" begin="5" end="5" resetval="0" description="LRST Soft Reset Block. Shows the tieoff d_mod[x]_lrst_soft_rst_block value.                                                                                                             0: Soft resets are not blocked to LRST                                                         1: Soft resets are blocked to LRST" range="" rwaccess="R">
		</bitfield>
		<bitfield id="SRSTBLK" width="1" begin="4" end="4" resetval="0" description="Soft Reset Block. Shows the tieoff d_mod[x]_soft_rst_block value.            0: Soft resets are not blocked. Any grstz from PLLCTRL will be propagated to the module                                                                              1: Soft resets are blocked. LPSC only passes hard resets to the module" range="" rwaccess="R">
		</bitfield>
		<bitfield id="MSTGKT" width="1" begin="3" end="3" resetval="0" description="Master Gasket support. Reflects the RTL parameter MSTGKT                     0: Master Gasket not supported by LPSC                                                     1: Master Gasket supported by LPSC" range="" rwaccess="R">
		</bitfield>
		<bitfield id="_RESV" width="1" begin="2" end="2" resetval="0" description="Reserved" range="" rwaccess="R">
		</bitfield>
		<bitfield id="LPSCTYPE" width="2" begin="1" end="0" resetval="0" description="LPSC Type. Reflects the RTL parameter LPSCTYPE                                    00: Single-Port LPSC (1PORT)                                                                       01: Dual-Clock LPSC (2CLK)                                                                         10: Dual-Port LPSC (2PORT)                                                                         11: Reserved" range="" rwaccess="R">
		</bitfield>
	</register>
	<register id="MDCFG24" acronym="MDCFG24" offset="0x460" width="32" description="Module Configuration 24 Register">
		<bitfield id="_RESV" width="24" begin="31" end="8" resetval="0" description="Reserved" range="" rwaccess="R">
		</bitfield>
		<bitfield id="CKRST" width="1" begin="7" end="7" resetval="0" description="Modclk during hard_rst_src_assert. Shows the tieoff d_mod[x]_hard_rst_src_assert.                                                                   0: LPSC does not give modclk when hard_rst_src_assert_pi_n = 0 (asserted). LPSC only gives modclk after this reset is de-asserted            1: LPSC gives modclk even when hard_rst_src_assert_pi_n = 0 (assert)" range="" rwaccess="R">
		</bitfield>
		<bitfield id="PLLCKGT" width="1" begin="6" end="6" resetval="0" description="PLL Clock Gate. Shows the tieoff d_mod[x]_pll_clk_gate                             0: LPSC gates modclk directly                                                                       1: LPSC does not gate modclk directly. LPSC instructs the PLLCTRL to gate modclk                           " range="" rwaccess="R">
		</bitfield>
		<bitfield id="LSRSTBLK" width="1" begin="5" end="5" resetval="0" description="LRST Soft Reset Block. Shows the tieoff d_mod[x]_lrst_soft_rst_block value.                                                                                                             0: Soft resets are not blocked to LRST                                                         1: Soft resets are blocked to LRST" range="" rwaccess="R">
		</bitfield>
		<bitfield id="SRSTBLK" width="1" begin="4" end="4" resetval="0" description="Soft Reset Block. Shows the tieoff d_mod[x]_soft_rst_block value.            0: Soft resets are not blocked. Any grstz from PLLCTRL will be propagated to the module                                                                              1: Soft resets are blocked. LPSC only passes hard resets to the module" range="" rwaccess="R">
		</bitfield>
		<bitfield id="MSTGKT" width="1" begin="3" end="3" resetval="0" description="Master Gasket support. Reflects the RTL parameter MSTGKT                     0: Master Gasket not supported by LPSC                                                     1: Master Gasket supported by LPSC" range="" rwaccess="R">
		</bitfield>
		<bitfield id="_RESV" width="1" begin="2" end="2" resetval="0" description="Reserved" range="" rwaccess="R">
		</bitfield>
		<bitfield id="LPSCTYPE" width="2" begin="1" end="0" resetval="0" description="LPSC Type. Reflects the RTL parameter LPSCTYPE                                    00: Single-Port LPSC (1PORT)                                                                       01: Dual-Clock LPSC (2CLK)                                                                         10: Dual-Port LPSC (2PORT)                                                                         11: Reserved" range="" rwaccess="R">
		</bitfield>
	</register>
	<register id="MDCFG25" acronym="MDCFG25" offset="0x464" width="32" description="Module Configuration 25 Register">
		<bitfield id="_RESV" width="24" begin="31" end="8" resetval="0" description="Reserved" range="" rwaccess="R">
		</bitfield>
		<bitfield id="CKRST" width="1" begin="7" end="7" resetval="0" description="Modclk during hard_rst_src_assert. Shows the tieoff d_mod[x]_hard_rst_src_assert.                                                                   0: LPSC does not give modclk when hard_rst_src_assert_pi_n = 0 (asserted). LPSC only gives modclk after this reset is de-asserted            1: LPSC gives modclk even when hard_rst_src_assert_pi_n = 0 (assert)" range="" rwaccess="R">
		</bitfield>
		<bitfield id="PLLCKGT" width="1" begin="6" end="6" resetval="0" description="PLL Clock Gate. Shows the tieoff d_mod[x]_pll_clk_gate                             0: LPSC gates modclk directly                                                                       1: LPSC does not gate modclk directly. LPSC instructs the PLLCTRL to gate modclk                           " range="" rwaccess="R">
		</bitfield>
		<bitfield id="LSRSTBLK" width="1" begin="5" end="5" resetval="0" description="LRST Soft Reset Block. Shows the tieoff d_mod[x]_lrst_soft_rst_block value.                                                                                                             0: Soft resets are not blocked to LRST                                                         1: Soft resets are blocked to LRST" range="" rwaccess="R">
		</bitfield>
		<bitfield id="SRSTBLK" width="1" begin="4" end="4" resetval="0" description="Soft Reset Block. Shows the tieoff d_mod[x]_soft_rst_block value.            0: Soft resets are not blocked. Any grstz from PLLCTRL will be propagated to the module                                                                              1: Soft resets are blocked. LPSC only passes hard resets to the module" range="" rwaccess="R">
		</bitfield>
		<bitfield id="MSTGKT" width="1" begin="3" end="3" resetval="0" description="Master Gasket support. Reflects the RTL parameter MSTGKT                     0: Master Gasket not supported by LPSC                                                     1: Master Gasket supported by LPSC" range="" rwaccess="R">
		</bitfield>
		<bitfield id="_RESV" width="1" begin="2" end="2" resetval="0" description="Reserved" range="" rwaccess="R">
		</bitfield>
		<bitfield id="LPSCTYPE" width="2" begin="1" end="0" resetval="0" description="LPSC Type. Reflects the RTL parameter LPSCTYPE                                    00: Single-Port LPSC (1PORT)                                                                       01: Dual-Clock LPSC (2CLK)                                                                         10: Dual-Port LPSC (2PORT)                                                                         11: Reserved" range="" rwaccess="R">
		</bitfield>
	</register>
	<register id="MDCFG26" acronym="MDCFG26" offset="0x468" width="32" description="Module Configuration 26 Register">
		<bitfield id="_RESV" width="24" begin="31" end="8" resetval="0" description="Reserved" range="" rwaccess="R">
		</bitfield>
		<bitfield id="CKRST" width="1" begin="7" end="7" resetval="0" description="Modclk during hard_rst_src_assert. Shows the tieoff d_mod[x]_hard_rst_src_assert.                                                                   0: LPSC does not give modclk when hard_rst_src_assert_pi_n = 0 (asserted). LPSC only gives modclk after this reset is de-asserted            1: LPSC gives modclk even when hard_rst_src_assert_pi_n = 0 (assert)" range="" rwaccess="R">
		</bitfield>
		<bitfield id="PLLCKGT" width="1" begin="6" end="6" resetval="0" description="PLL Clock Gate. Shows the tieoff d_mod[x]_pll_clk_gate                             0: LPSC gates modclk directly                                                                       1: LPSC does not gate modclk directly. LPSC instructs the PLLCTRL to gate modclk                           " range="" rwaccess="R">
		</bitfield>
		<bitfield id="LSRSTBLK" width="1" begin="5" end="5" resetval="0" description="LRST Soft Reset Block. Shows the tieoff d_mod[x]_lrst_soft_rst_block value.                                                                                                             0: Soft resets are not blocked to LRST                                                         1: Soft resets are blocked to LRST" range="" rwaccess="R">
		</bitfield>
		<bitfield id="SRSTBLK" width="1" begin="4" end="4" resetval="0" description="Soft Reset Block. Shows the tieoff d_mod[x]_soft_rst_block value.            0: Soft resets are not blocked. Any grstz from PLLCTRL will be propagated to the module                                                                              1: Soft resets are blocked. LPSC only passes hard resets to the module" range="" rwaccess="R">
		</bitfield>
		<bitfield id="MSTGKT" width="1" begin="3" end="3" resetval="0" description="Master Gasket support. Reflects the RTL parameter MSTGKT                     0: Master Gasket not supported by LPSC                                                     1: Master Gasket supported by LPSC" range="" rwaccess="R">
		</bitfield>
		<bitfield id="_RESV" width="1" begin="2" end="2" resetval="0" description="Reserved" range="" rwaccess="R">
		</bitfield>
		<bitfield id="LPSCTYPE" width="2" begin="1" end="0" resetval="0" description="LPSC Type. Reflects the RTL parameter LPSCTYPE                                    00: Single-Port LPSC (1PORT)                                                                       01: Dual-Clock LPSC (2CLK)                                                                         10: Dual-Port LPSC (2PORT)                                                                         11: Reserved" range="" rwaccess="R">
		</bitfield>
	</register>
	<register id="MDCFG27" acronym="MDCFG27" offset="0x46C" width="32" description="Module Configuration 27 Register">
		<bitfield id="_RESV" width="24" begin="31" end="8" resetval="0" description="Reserved" range="" rwaccess="R">
		</bitfield>
		<bitfield id="CKRST" width="1" begin="7" end="7" resetval="0" description="Modclk during hard_rst_src_assert. Shows the tieoff d_mod[x]_hard_rst_src_assert.                                                                   0: LPSC does not give modclk when hard_rst_src_assert_pi_n = 0 (asserted). LPSC only gives modclk after this reset is de-asserted            1: LPSC gives modclk even when hard_rst_src_assert_pi_n = 0 (assert)" range="" rwaccess="R">
		</bitfield>
		<bitfield id="PLLCKGT" width="1" begin="6" end="6" resetval="0" description="PLL Clock Gate. Shows the tieoff d_mod[x]_pll_clk_gate                             0: LPSC gates modclk directly                                                                       1: LPSC does not gate modclk directly. LPSC instructs the PLLCTRL to gate modclk                           " range="" rwaccess="R">
		</bitfield>
		<bitfield id="LSRSTBLK" width="1" begin="5" end="5" resetval="0" description="LRST Soft Reset Block. Shows the tieoff d_mod[x]_lrst_soft_rst_block value.                                                                                                             0: Soft resets are not blocked to LRST                                                         1: Soft resets are blocked to LRST" range="" rwaccess="R">
		</bitfield>
		<bitfield id="SRSTBLK" width="1" begin="4" end="4" resetval="0" description="Soft Reset Block. Shows the tieoff d_mod[x]_soft_rst_block value.            0: Soft resets are not blocked. Any grstz from PLLCTRL will be propagated to the module                                                                              1: Soft resets are blocked. LPSC only passes hard resets to the module" range="" rwaccess="R">
		</bitfield>
		<bitfield id="MSTGKT" width="1" begin="3" end="3" resetval="0" description="Master Gasket support. Reflects the RTL parameter MSTGKT                     0: Master Gasket not supported by LPSC                                                     1: Master Gasket supported by LPSC" range="" rwaccess="R">
		</bitfield>
		<bitfield id="_RESV" width="1" begin="2" end="2" resetval="0" description="Reserved" range="" rwaccess="R">
		</bitfield>
		<bitfield id="LPSCTYPE" width="2" begin="1" end="0" resetval="0" description="LPSC Type. Reflects the RTL parameter LPSCTYPE                                    00: Single-Port LPSC (1PORT)                                                                       01: Dual-Clock LPSC (2CLK)                                                                         10: Dual-Port LPSC (2PORT)                                                                         11: Reserved" range="" rwaccess="R">
		</bitfield>
	</register>
	<register id="MDCFG28" acronym="MDCFG28" offset="0x470" width="32" description="Module Configuration 28 Register">
		<bitfield id="_RESV" width="24" begin="31" end="8" resetval="0" description="Reserved" range="" rwaccess="R">
		</bitfield>
		<bitfield id="CKRST" width="1" begin="7" end="7" resetval="0" description="Modclk during hard_rst_src_assert. Shows the tieoff d_mod[x]_hard_rst_src_assert.                                                                   0: LPSC does not give modclk when hard_rst_src_assert_pi_n = 0 (asserted). LPSC only gives modclk after this reset is de-asserted            1: LPSC gives modclk even when hard_rst_src_assert_pi_n = 0 (assert)" range="" rwaccess="R">
		</bitfield>
		<bitfield id="PLLCKGT" width="1" begin="6" end="6" resetval="0" description="PLL Clock Gate. Shows the tieoff d_mod[x]_pll_clk_gate                             0: LPSC gates modclk directly                                                                       1: LPSC does not gate modclk directly. LPSC instructs the PLLCTRL to gate modclk                           " range="" rwaccess="R">
		</bitfield>
		<bitfield id="LSRSTBLK" width="1" begin="5" end="5" resetval="0" description="LRST Soft Reset Block. Shows the tieoff d_mod[x]_lrst_soft_rst_block value.                                                                                                             0: Soft resets are not blocked to LRST                                                         1: Soft resets are blocked to LRST" range="" rwaccess="R">
		</bitfield>
		<bitfield id="SRSTBLK" width="1" begin="4" end="4" resetval="0" description="Soft Reset Block. Shows the tieoff d_mod[x]_soft_rst_block value.            0: Soft resets are not blocked. Any grstz from PLLCTRL will be propagated to the module                                                                              1: Soft resets are blocked. LPSC only passes hard resets to the module" range="" rwaccess="R">
		</bitfield>
		<bitfield id="MSTGKT" width="1" begin="3" end="3" resetval="0" description="Master Gasket support. Reflects the RTL parameter MSTGKT                     0: Master Gasket not supported by LPSC                                                     1: Master Gasket supported by LPSC" range="" rwaccess="R">
		</bitfield>
		<bitfield id="_RESV" width="1" begin="2" end="2" resetval="0" description="Reserved" range="" rwaccess="R">
		</bitfield>
		<bitfield id="LPSCTYPE" width="2" begin="1" end="0" resetval="0" description="LPSC Type. Reflects the RTL parameter LPSCTYPE                                    00: Single-Port LPSC (1PORT)                                                                       01: Dual-Clock LPSC (2CLK)                                                                         10: Dual-Port LPSC (2PORT)                                                                         11: Reserved" range="" rwaccess="R">
		</bitfield>
	</register>
	<register id="MDCFG29" acronym="MDCFG29" offset="0x474" width="32" description="Module Configuration 29 Register">
		<bitfield id="_RESV" width="24" begin="31" end="8" resetval="0" description="Reserved" range="" rwaccess="R">
		</bitfield>
		<bitfield id="CKRST" width="1" begin="7" end="7" resetval="0" description="Modclk during hard_rst_src_assert. Shows the tieoff d_mod[x]_hard_rst_src_assert.                                                                   0: LPSC does not give modclk when hard_rst_src_assert_pi_n = 0 (asserted). LPSC only gives modclk after this reset is de-asserted            1: LPSC gives modclk even when hard_rst_src_assert_pi_n = 0 (assert)" range="" rwaccess="R">
		</bitfield>
		<bitfield id="PLLCKGT" width="1" begin="6" end="6" resetval="0" description="PLL Clock Gate. Shows the tieoff d_mod[x]_pll_clk_gate                             0: LPSC gates modclk directly                                                                       1: LPSC does not gate modclk directly. LPSC instructs the PLLCTRL to gate modclk                           " range="" rwaccess="R">
		</bitfield>
		<bitfield id="LSRSTBLK" width="1" begin="5" end="5" resetval="0" description="LRST Soft Reset Block. Shows the tieoff d_mod[x]_lrst_soft_rst_block value.                                                                                                             0: Soft resets are not blocked to LRST                                                         1: Soft resets are blocked to LRST" range="" rwaccess="R">
		</bitfield>
		<bitfield id="SRSTBLK" width="1" begin="4" end="4" resetval="0" description="Soft Reset Block. Shows the tieoff d_mod[x]_soft_rst_block value.            0: Soft resets are not blocked. Any grstz from PLLCTRL will be propagated to the module                                                                              1: Soft resets are blocked. LPSC only passes hard resets to the module" range="" rwaccess="R">
		</bitfield>
		<bitfield id="MSTGKT" width="1" begin="3" end="3" resetval="0" description="Master Gasket support. Reflects the RTL parameter MSTGKT                     0: Master Gasket not supported by LPSC                                                     1: Master Gasket supported by LPSC" range="" rwaccess="R">
		</bitfield>
		<bitfield id="_RESV" width="1" begin="2" end="2" resetval="0" description="Reserved" range="" rwaccess="R">
		</bitfield>
		<bitfield id="LPSCTYPE" width="2" begin="1" end="0" resetval="0" description="LPSC Type. Reflects the RTL parameter LPSCTYPE                                    00: Single-Port LPSC (1PORT)                                                                       01: Dual-Clock LPSC (2CLK)                                                                         10: Dual-Port LPSC (2PORT)                                                                         11: Reserved" range="" rwaccess="R">
		</bitfield>
	</register>
	<register id="MDCFG30" acronym="MDCFG30" offset="0x478" width="32" description="Module Configuration 30 Register">
		<bitfield id="_RESV" width="24" begin="31" end="8" resetval="0" description="Reserved" range="" rwaccess="R">
		</bitfield>
		<bitfield id="CKRST" width="1" begin="7" end="7" resetval="0" description="Modclk during hard_rst_src_assert. Shows the tieoff d_mod[x]_hard_rst_src_assert.                                                                   0: LPSC does not give modclk when hard_rst_src_assert_pi_n = 0 (asserted). LPSC only gives modclk after this reset is de-asserted            1: LPSC gives modclk even when hard_rst_src_assert_pi_n = 0 (assert)" range="" rwaccess="R">
		</bitfield>
		<bitfield id="PLLCKGT" width="1" begin="6" end="6" resetval="0" description="PLL Clock Gate. Shows the tieoff d_mod[x]_pll_clk_gate                             0: LPSC gates modclk directly                                                                       1: LPSC does not gate modclk directly. LPSC instructs the PLLCTRL to gate modclk                           " range="" rwaccess="R">
		</bitfield>
		<bitfield id="LSRSTBLK" width="1" begin="5" end="5" resetval="0" description="LRST Soft Reset Block. Shows the tieoff d_mod[x]_lrst_soft_rst_block value.                                                                                                             0: Soft resets are not blocked to LRST                                                         1: Soft resets are blocked to LRST" range="" rwaccess="R">
		</bitfield>
		<bitfield id="SRSTBLK" width="1" begin="4" end="4" resetval="0" description="Soft Reset Block. Shows the tieoff d_mod[x]_soft_rst_block value.            0: Soft resets are not blocked. Any grstz from PLLCTRL will be propagated to the module                                                                              1: Soft resets are blocked. LPSC only passes hard resets to the module" range="" rwaccess="R">
		</bitfield>
		<bitfield id="MSTGKT" width="1" begin="3" end="3" resetval="0" description="Master Gasket support. Reflects the RTL parameter MSTGKT                     0: Master Gasket not supported by LPSC                                                     1: Master Gasket supported by LPSC" range="" rwaccess="R">
		</bitfield>
		<bitfield id="_RESV" width="1" begin="2" end="2" resetval="0" description="Reserved" range="" rwaccess="R">
		</bitfield>
		<bitfield id="LPSCTYPE" width="2" begin="1" end="0" resetval="0" description="LPSC Type. Reflects the RTL parameter LPSCTYPE                                    00: Single-Port LPSC (1PORT)                                                                       01: Dual-Clock LPSC (2CLK)                                                                         10: Dual-Port LPSC (2PORT)                                                                         11: Reserved" range="" rwaccess="R">
		</bitfield>
	</register>
	<register id="MDCFG31" acronym="MDCFG31" offset="0x47C" width="32" description="Module Configuration 31 Register">
		<bitfield id="_RESV" width="24" begin="31" end="8" resetval="0" description="Reserved" range="" rwaccess="R">
		</bitfield>
		<bitfield id="CKRST" width="1" begin="7" end="7" resetval="0" description="Modclk during hard_rst_src_assert. Shows the tieoff d_mod[x]_hard_rst_src_assert.                                                                   0: LPSC does not give modclk when hard_rst_src_assert_pi_n = 0 (asserted). LPSC only gives modclk after this reset is de-asserted            1: LPSC gives modclk even when hard_rst_src_assert_pi_n = 0 (assert)" range="" rwaccess="R">
		</bitfield>
		<bitfield id="PLLCKGT" width="1" begin="6" end="6" resetval="0" description="PLL Clock Gate. Shows the tieoff d_mod[x]_pll_clk_gate                             0: LPSC gates modclk directly                                                                       1: LPSC does not gate modclk directly. LPSC instructs the PLLCTRL to gate modclk                           " range="" rwaccess="R">
		</bitfield>
		<bitfield id="LSRSTBLK" width="1" begin="5" end="5" resetval="0" description="LRST Soft Reset Block. Shows the tieoff d_mod[x]_lrst_soft_rst_block value.                                                                                                             0: Soft resets are not blocked to LRST                                                         1: Soft resets are blocked to LRST" range="" rwaccess="R">
		</bitfield>
		<bitfield id="SRSTBLK" width="1" begin="4" end="4" resetval="0" description="Soft Reset Block. Shows the tieoff d_mod[x]_soft_rst_block value.            0: Soft resets are not blocked. Any grstz from PLLCTRL will be propagated to the module                                                                              1: Soft resets are blocked. LPSC only passes hard resets to the module" range="" rwaccess="R">
		</bitfield>
		<bitfield id="MSTGKT" width="1" begin="3" end="3" resetval="0" description="Master Gasket support. Reflects the RTL parameter MSTGKT                     0: Master Gasket not supported by LPSC                                                     1: Master Gasket supported by LPSC" range="" rwaccess="R">
		</bitfield>
		<bitfield id="_RESV" width="1" begin="2" end="2" resetval="0" description="Reserved" range="" rwaccess="R">
		</bitfield>
		<bitfield id="LPSCTYPE" width="2" begin="1" end="0" resetval="0" description="LPSC Type. Reflects the RTL parameter LPSCTYPE                                    00: Single-Port LPSC (1PORT)                                                                       01: Dual-Clock LPSC (2CLK)                                                                         10: Dual-Port LPSC (2PORT)                                                                         11: Reserved" range="" rwaccess="R">
		</bitfield>
	</register>
	<register id="MDSTAT0" acronym="MDSTAT0" offset="0x600" width="32" description="Module Status 0 Register">
		<bitfield id="_RESV" width="10" begin="31" end="22" resetval="0" description="Reserved" range="" rwaccess="R">
		</bitfield>
		<bitfield id="MSTID" width="6" begin="21" end="16" resetval="0" description="Master ID. If ACSLP occurs, this field records the master ID of the master that caused the access. This bit is cleared when the corresponding ERRCR bit is written with a 1. " range="" rwaccess="R">
		</bitfield>
		<bitfield id="_RESV" width="5" begin="15" end="11" resetval="0" description="Reserved" range="" rwaccess="R">
		</bitfield>
		<bitfield id="WKRSLP" width="1" begin="10" end="10" resetval="0" description="Wakeup Request to Module in Sleep Detected.  Wakeup_pi is detected for this module when it is in sleep. If MDCTL.WKRSLPIE = 1, the setting of this field can cause ERRPR for this module to be set.                                          0: Condition did not occur                                                                              1: wakeup_pi = 1 when module is in sleep.                                     " range="" rwaccess="R">
		</bitfield>
		<bitfield id="ACSLP" width="2" begin="9" end="8" resetval="0" description="Non-emulation access to Module in Sleep occurred.                                    00:  Condition did not occur                                                                           01:  Access to module in sleep occurred. PSC transitioned the module from Sleep state to Temp Wake state then back to Sleep state                                                     10:  Access to module in sleep occured. PSC transitioned the module from Sleep state to Enable state                                                                   11: Reserved           " range="" rwaccess="R">
		</bitfield>
		<bitfield id="STERR" width="1" begin="7" end="7" resetval="0" description="State Transition Error                                                                                    0: Error did not occur                                                                                    1: Error occured                      " range="" rwaccess="R">
		</bitfield>
		<bitfield id="PERMDIS" width="1" begin="6" end="6" resetval="0" description="Permanently Disable                                                                                      0: Do not permanently disable module                                                           1: Permanently disable module                                               " range="" rwaccess="R">
		</bitfield>
		<bitfield id="STATE" width="6" begin="5" end="0" resetval="0" description="These bits indiacte the current module state                                                010000:  Power Domain Off                                                                          110000:  Iso-PwrCtrl                                                                                      111000:  En-IsoCtrl                                                                                        101000:  SyncReset                                                                                      100000:  SwRstDisable                                                                                 100100:  Disable                                                                                            101100:  Enable                                                                                             101110:  SlpTrans                                                                                         100110:  Sleep                                                                                              100111:  TwkTrans                                                                                       101111:  Twk                                                                                                 Others:   Reserved" range="" rwaccess="R">
		</bitfield>
	</register>
	<register id="MDSTAT1" acronym="MDSTAT1" offset="0x604" width="32" description="Module Status 1 Register">
		<bitfield id="_RESV" width="10" begin="31" end="22" resetval="0" description="Reserved" range="" rwaccess="R">
		</bitfield>
		<bitfield id="MSTID" width="6" begin="21" end="16" resetval="0" description="Master ID. If ACSLP occurs, this field records the master ID of the master that caused the access. This bit is cleared when the corresponding ERRCR bit is written with a 1. " range="" rwaccess="R">
		</bitfield>
		<bitfield id="_RESV" width="5" begin="15" end="11" resetval="0" description="Reserved" range="" rwaccess="R">
		</bitfield>
		<bitfield id="WKRSLP" width="1" begin="10" end="10" resetval="0" description="Wakeup Request to Module in Sleep Detected.  Wakeup_pi is detected for this module when it is in sleep. If MDCTL.WKRSLPIE = 1, the setting of this field can cause ERRPR for this module to be set.                                          0: Condition did not occur                                                                              1: wakeup_pi = 1 when module is in sleep.                                     " range="" rwaccess="R">
		</bitfield>
		<bitfield id="ACSLP" width="2" begin="9" end="8" resetval="0" description="Non-emulation access to Module in Sleep occurred.                                    00:  Condition did not occur                                                                           01:  Access to module in sleep occurred. PSC transitioned the module from Sleep state to Temp Wake state then back to Sleep state                                                     10:  Access to module in sleep occured. PSC transitioned the module from Sleep state to Enable state                                                                   11: Reserved           " range="" rwaccess="R">
		</bitfield>
		<bitfield id="STERR" width="1" begin="7" end="7" resetval="0" description="State Transition Error                                                                                    0: Error did not occur                                                                                    1: Error occured                      " range="" rwaccess="R">
		</bitfield>
		<bitfield id="PERMDIS" width="1" begin="6" end="6" resetval="0" description="Permanently Disable                                                                                      0: Do not permanently disable module                                                           1: Permanently disable module                                               " range="" rwaccess="R">
		</bitfield>
		<bitfield id="STATE" width="6" begin="5" end="0" resetval="0" description="These bits indiacte the current module state                                                010000:  Power Domain Off                                                                          110000:  Iso-PwrCtrl                                                                                      111000:  En-IsoCtrl                                                                                        101000:  SyncReset                                                                                      100000:  SwRstDisable                                                                                 100100:  Disable                                                                                            101100:  Enable                                                                                             101110:  SlpTrans                                                                                         100110:  Sleep                                                                                              100111:  TwkTrans                                                                                       101111:  Twk                                                                                                 Others:   Reserved" range="" rwaccess="R">
		</bitfield>
	</register>
	<register id="MDSTAT2" acronym="MDSTAT2" offset="0x608" width="32" description="Module Status 2 Register">
		<bitfield id="_RESV" width="10" begin="31" end="22" resetval="0" description="Reserved" range="" rwaccess="R">
		</bitfield>
		<bitfield id="MSTID" width="6" begin="21" end="16" resetval="0" description="Master ID. If ACSLP occurs, this field records the master ID of the master that caused the access. This bit is cleared when the corresponding ERRCR bit is written with a 1. " range="" rwaccess="R">
		</bitfield>
		<bitfield id="_RESV" width="5" begin="15" end="11" resetval="0" description="Reserved" range="" rwaccess="R">
		</bitfield>
		<bitfield id="WKRSLP" width="1" begin="10" end="10" resetval="0" description="Wakeup Request to Module in Sleep Detected.  Wakeup_pi is detected for this module when it is in sleep. If MDCTL.WKRSLPIE = 1, the setting of this field can cause ERRPR for this module to be set.                                          0: Condition did not occur                                                                              1: wakeup_pi = 1 when module is in sleep.                                     " range="" rwaccess="R">
		</bitfield>
		<bitfield id="ACSLP" width="2" begin="9" end="8" resetval="0" description="Non-emulation access to Module in Sleep occurred.                                    00:  Condition did not occur                                                                           01:  Access to module in sleep occurred. PSC transitioned the module from Sleep state to Temp Wake state then back to Sleep state                                                     10:  Access to module in sleep occured. PSC transitioned the module from Sleep state to Enable state                                                                   11: Reserved           " range="" rwaccess="R">
		</bitfield>
		<bitfield id="STERR" width="1" begin="7" end="7" resetval="0" description="State Transition Error                                                                                    0: Error did not occur                                                                                    1: Error occured                      " range="" rwaccess="R">
		</bitfield>
		<bitfield id="PERMDIS" width="1" begin="6" end="6" resetval="0" description="Permanently Disable                                                                                      0: Do not permanently disable module                                                           1: Permanently disable module                                               " range="" rwaccess="R">
		</bitfield>
		<bitfield id="STATE" width="6" begin="5" end="0" resetval="0" description="These bits indiacte the current module state                                                010000:  Power Domain Off                                                                          110000:  Iso-PwrCtrl                                                                                      111000:  En-IsoCtrl                                                                                        101000:  SyncReset                                                                                      100000:  SwRstDisable                                                                                 100100:  Disable                                                                                            101100:  Enable                                                                                             101110:  SlpTrans                                                                                         100110:  Sleep                                                                                              100111:  TwkTrans                                                                                       101111:  Twk                                                                                                 Others:   Reserved" range="" rwaccess="R">
		</bitfield>
	</register>
	<register id="MDSTAT3" acronym="MDSTAT3" offset="0x60C" width="32" description="Module Status 3 Register">
		<bitfield id="_RESV" width="10" begin="31" end="22" resetval="0" description="Reserved" range="" rwaccess="R">
		</bitfield>
		<bitfield id="MSTID" width="6" begin="21" end="16" resetval="0" description="Master ID. If ACSLP occurs, this field records the master ID of the master that caused the access. This bit is cleared when the corresponding ERRCR bit is written with a 1. " range="" rwaccess="R">
		</bitfield>
		<bitfield id="_RESV" width="5" begin="15" end="11" resetval="0" description="Reserved" range="" rwaccess="R">
		</bitfield>
		<bitfield id="WKRSLP" width="1" begin="10" end="10" resetval="0" description="Wakeup Request to Module in Sleep Detected.  Wakeup_pi is detected for this module when it is in sleep. If MDCTL.WKRSLPIE = 1, the setting of this field can cause ERRPR for this module to be set.                                          0: Condition did not occur                                                                              1: wakeup_pi = 1 when module is in sleep.                                     " range="" rwaccess="R">
		</bitfield>
		<bitfield id="ACSLP" width="2" begin="9" end="8" resetval="0" description="Non-emulation access to Module in Sleep occurred.                                    00:  Condition did not occur                                                                           01:  Access to module in sleep occurred. PSC transitioned the module from Sleep state to Temp Wake state then back to Sleep state                                                     10:  Access to module in sleep occured. PSC transitioned the module from Sleep state to Enable state                                                                   11: Reserved           " range="" rwaccess="R">
		</bitfield>
		<bitfield id="STERR" width="1" begin="7" end="7" resetval="0" description="State Transition Error                                                                                    0: Error did not occur                                                                                    1: Error occured                      " range="" rwaccess="R">
		</bitfield>
		<bitfield id="PERMDIS" width="1" begin="6" end="6" resetval="0" description="Permanently Disable                                                                                      0: Do not permanently disable module                                                           1: Permanently disable module                                               " range="" rwaccess="R">
		</bitfield>
		<bitfield id="STATE" width="6" begin="5" end="0" resetval="0" description="These bits indiacte the current module state                                                010000:  Power Domain Off                                                                          110000:  Iso-PwrCtrl                                                                                      111000:  En-IsoCtrl                                                                                        101000:  SyncReset                                                                                      100000:  SwRstDisable                                                                                 100100:  Disable                                                                                            101100:  Enable                                                                                             101110:  SlpTrans                                                                                         100110:  Sleep                                                                                              100111:  TwkTrans                                                                                       101111:  Twk                                                                                                 Others:   Reserved" range="" rwaccess="R">
		</bitfield>
	</register>
	<register id="MDSTAT4" acronym="MDSTAT4" offset="0x610" width="32" description="Module Status 4 Register">
		<bitfield id="_RESV" width="10" begin="31" end="22" resetval="0" description="Reserved" range="" rwaccess="R">
		</bitfield>
		<bitfield id="MSTID" width="6" begin="21" end="16" resetval="0" description="Master ID. If ACSLP occurs, this field records the master ID of the master that caused the access. This bit is cleared when the corresponding ERRCR bit is written with a 1. " range="" rwaccess="R">
		</bitfield>
		<bitfield id="_RESV" width="5" begin="15" end="11" resetval="0" description="Reserved" range="" rwaccess="R">
		</bitfield>
		<bitfield id="WKRSLP" width="1" begin="10" end="10" resetval="0" description="Wakeup Request to Module in Sleep Detected.  Wakeup_pi is detected for this module when it is in sleep. If MDCTL.WKRSLPIE = 1, the setting of this field can cause ERRPR for this module to be set.                                          0: Condition did not occur                                                                              1: wakeup_pi = 1 when module is in sleep.                                     " range="" rwaccess="R">
		</bitfield>
		<bitfield id="ACSLP" width="2" begin="9" end="8" resetval="0" description="Non-emulation access to Module in Sleep occurred.                                    00:  Condition did not occur                                                                           01:  Access to module in sleep occurred. PSC transitioned the module from Sleep state to Temp Wake state then back to Sleep state                                                     10:  Access to module in sleep occured. PSC transitioned the module from Sleep state to Enable state                                                                   11: Reserved           " range="" rwaccess="R">
		</bitfield>
		<bitfield id="STERR" width="1" begin="7" end="7" resetval="0" description="State Transition Error                                                                                    0: Error did not occur                                                                                    1: Error occured                      " range="" rwaccess="R">
		</bitfield>
		<bitfield id="PERMDIS" width="1" begin="6" end="6" resetval="0" description="Permanently Disable                                                                                      0: Do not permanently disable module                                                           1: Permanently disable module                                               " range="" rwaccess="R">
		</bitfield>
		<bitfield id="STATE" width="6" begin="5" end="0" resetval="0" description="These bits indiacte the current module state                                                010000:  Power Domain Off                                                                          110000:  Iso-PwrCtrl                                                                                      111000:  En-IsoCtrl                                                                                        101000:  SyncReset                                                                                      100000:  SwRstDisable                                                                                 100100:  Disable                                                                                            101100:  Enable                                                                                             101110:  SlpTrans                                                                                         100110:  Sleep                                                                                              100111:  TwkTrans                                                                                       101111:  Twk                                                                                                 Others:   Reserved" range="" rwaccess="R">
		</bitfield>
	</register>
	<register id="MDSTAT5" acronym="MDSTAT5" offset="0x614" width="32" description="Module Status 5 Register">
		<bitfield id="_RESV" width="10" begin="31" end="22" resetval="0" description="Reserved" range="" rwaccess="R">
		</bitfield>
		<bitfield id="MSTID" width="6" begin="21" end="16" resetval="0" description="Master ID. If ACSLP occurs, this field records the master ID of the master that caused the access. This bit is cleared when the corresponding ERRCR bit is written with a 1. " range="" rwaccess="R">
		</bitfield>
		<bitfield id="_RESV" width="5" begin="15" end="11" resetval="0" description="Reserved" range="" rwaccess="R">
		</bitfield>
		<bitfield id="WKRSLP" width="1" begin="10" end="10" resetval="0" description="Wakeup Request to Module in Sleep Detected.  Wakeup_pi is detected for this module when it is in sleep. If MDCTL.WKRSLPIE = 1, the setting of this field can cause ERRPR for this module to be set.                                          0: Condition did not occur                                                                              1: wakeup_pi = 1 when module is in sleep.                                     " range="" rwaccess="R">
		</bitfield>
		<bitfield id="ACSLP" width="2" begin="9" end="8" resetval="0" description="Non-emulation access to Module in Sleep occurred.                                    00:  Condition did not occur                                                                           01:  Access to module in sleep occurred. PSC transitioned the module from Sleep state to Temp Wake state then back to Sleep state                                                     10:  Access to module in sleep occured. PSC transitioned the module from Sleep state to Enable state                                                                   11: Reserved           " range="" rwaccess="R">
		</bitfield>
		<bitfield id="STERR" width="1" begin="7" end="7" resetval="0" description="State Transition Error                                                                                    0: Error did not occur                                                                                    1: Error occured                      " range="" rwaccess="R">
		</bitfield>
		<bitfield id="PERMDIS" width="1" begin="6" end="6" resetval="0" description="Permanently Disable                                                                                      0: Do not permanently disable module                                                           1: Permanently disable module                                               " range="" rwaccess="R">
		</bitfield>
		<bitfield id="STATE" width="6" begin="5" end="0" resetval="0" description="These bits indiacte the current module state                                                010000:  Power Domain Off                                                                          110000:  Iso-PwrCtrl                                                                                      111000:  En-IsoCtrl                                                                                        101000:  SyncReset                                                                                      100000:  SwRstDisable                                                                                 100100:  Disable                                                                                            101100:  Enable                                                                                             101110:  SlpTrans                                                                                         100110:  Sleep                                                                                              100111:  TwkTrans                                                                                       101111:  Twk                                                                                                 Others:   Reserved" range="" rwaccess="R">
		</bitfield>
	</register>
	<register id="MDSTAT6" acronym="MDSTAT6" offset="0x618" width="32" description="Module Status 6 Register">
		<bitfield id="_RESV" width="10" begin="31" end="22" resetval="0" description="Reserved" range="" rwaccess="R">
		</bitfield>
		<bitfield id="MSTID" width="6" begin="21" end="16" resetval="0" description="Master ID. If ACSLP occurs, this field records the master ID of the master that caused the access. This bit is cleared when the corresponding ERRCR bit is written with a 1. " range="" rwaccess="R">
		</bitfield>
		<bitfield id="_RESV" width="5" begin="15" end="11" resetval="0" description="Reserved" range="" rwaccess="R">
		</bitfield>
		<bitfield id="WKRSLP" width="1" begin="10" end="10" resetval="0" description="Wakeup Request to Module in Sleep Detected.  Wakeup_pi is detected for this module when it is in sleep. If MDCTL.WKRSLPIE = 1, the setting of this field can cause ERRPR for this module to be set.                                          0: Condition did not occur                                                                              1: wakeup_pi = 1 when module is in sleep.                                     " range="" rwaccess="R">
		</bitfield>
		<bitfield id="ACSLP" width="2" begin="9" end="8" resetval="0" description="Non-emulation access to Module in Sleep occurred.                                    00:  Condition did not occur                                                                           01:  Access to module in sleep occurred. PSC transitioned the module from Sleep state to Temp Wake state then back to Sleep state                                                     10:  Access to module in sleep occured. PSC transitioned the module from Sleep state to Enable state                                                                   11: Reserved           " range="" rwaccess="R">
		</bitfield>
		<bitfield id="STERR" width="1" begin="7" end="7" resetval="0" description="State Transition Error                                                                                    0: Error did not occur                                                                                    1: Error occured                      " range="" rwaccess="R">
		</bitfield>
		<bitfield id="PERMDIS" width="1" begin="6" end="6" resetval="0" description="Permanently Disable                                                                                      0: Do not permanently disable module                                                           1: Permanently disable module                                               " range="" rwaccess="R">
		</bitfield>
		<bitfield id="STATE" width="6" begin="5" end="0" resetval="0" description="These bits indiacte the current module state                                                010000:  Power Domain Off                                                                          110000:  Iso-PwrCtrl                                                                                      111000:  En-IsoCtrl                                                                                        101000:  SyncReset                                                                                      100000:  SwRstDisable                                                                                 100100:  Disable                                                                                            101100:  Enable                                                                                             101110:  SlpTrans                                                                                         100110:  Sleep                                                                                              100111:  TwkTrans                                                                                       101111:  Twk                                                                                                 Others:   Reserved" range="" rwaccess="R">
		</bitfield>
	</register>
	<register id="MDSTAT7" acronym="MDSTAT7" offset="0x61C" width="32" description="Module Status 7 Register">
		<bitfield id="_RESV" width="10" begin="31" end="22" resetval="0" description="Reserved" range="" rwaccess="R">
		</bitfield>
		<bitfield id="MSTID" width="6" begin="21" end="16" resetval="0" description="Master ID. If ACSLP occurs, this field records the master ID of the master that caused the access. This bit is cleared when the corresponding ERRCR bit is written with a 1. " range="" rwaccess="R">
		</bitfield>
		<bitfield id="_RESV" width="5" begin="15" end="11" resetval="0" description="Reserved" range="" rwaccess="R">
		</bitfield>
		<bitfield id="WKRSLP" width="1" begin="10" end="10" resetval="0" description="Wakeup Request to Module in Sleep Detected.  Wakeup_pi is detected for this module when it is in sleep. If MDCTL.WKRSLPIE = 1, the setting of this field can cause ERRPR for this module to be set.                                          0: Condition did not occur                                                                              1: wakeup_pi = 1 when module is in sleep.                                     " range="" rwaccess="R">
		</bitfield>
		<bitfield id="ACSLP" width="2" begin="9" end="8" resetval="0" description="Non-emulation access to Module in Sleep occurred.                                    00:  Condition did not occur                                                                           01:  Access to module in sleep occurred. PSC transitioned the module from Sleep state to Temp Wake state then back to Sleep state                                                     10:  Access to module in sleep occured. PSC transitioned the module from Sleep state to Enable state                                                                   11: Reserved           " range="" rwaccess="R">
		</bitfield>
		<bitfield id="STERR" width="1" begin="7" end="7" resetval="0" description="State Transition Error                                                                                    0: Error did not occur                                                                                    1: Error occured                      " range="" rwaccess="R">
		</bitfield>
		<bitfield id="PERMDIS" width="1" begin="6" end="6" resetval="0" description="Permanently Disable                                                                                      0: Do not permanently disable module                                                           1: Permanently disable module                                               " range="" rwaccess="R">
		</bitfield>
		<bitfield id="STATE" width="6" begin="5" end="0" resetval="0" description="These bits indiacte the current module state                                                010000:  Power Domain Off                                                                          110000:  Iso-PwrCtrl                                                                                      111000:  En-IsoCtrl                                                                                        101000:  SyncReset                                                                                      100000:  SwRstDisable                                                                                 100100:  Disable                                                                                            101100:  Enable                                                                                             101110:  SlpTrans                                                                                         100110:  Sleep                                                                                              100111:  TwkTrans                                                                                       101111:  Twk                                                                                                 Others:   Reserved" range="" rwaccess="R">
		</bitfield>
	</register>
	<register id="MDSTAT8" acronym="MDSTAT8" offset="0x620" width="32" description="Module Status 8 Register">
		<bitfield id="_RESV" width="10" begin="31" end="22" resetval="0" description="Reserved" range="" rwaccess="R">
		</bitfield>
		<bitfield id="MSTID" width="6" begin="21" end="16" resetval="0" description="Master ID. If ACSLP occurs, this field records the master ID of the master that caused the access. This bit is cleared when the corresponding ERRCR bit is written with a 1. " range="" rwaccess="R">
		</bitfield>
		<bitfield id="_RESV" width="5" begin="15" end="11" resetval="0" description="Reserved" range="" rwaccess="R">
		</bitfield>
		<bitfield id="WKRSLP" width="1" begin="10" end="10" resetval="0" description="Wakeup Request to Module in Sleep Detected.  Wakeup_pi is detected for this module when it is in sleep. If MDCTL.WKRSLPIE = 1, the setting of this field can cause ERRPR for this module to be set.                                          0: Condition did not occur                                                                              1: wakeup_pi = 1 when module is in sleep.                                     " range="" rwaccess="R">
		</bitfield>
		<bitfield id="ACSLP" width="2" begin="9" end="8" resetval="0" description="Non-emulation access to Module in Sleep occurred.                                    00:  Condition did not occur                                                                           01:  Access to module in sleep occurred. PSC transitioned the module from Sleep state to Temp Wake state then back to Sleep state                                                     10:  Access to module in sleep occured. PSC transitioned the module from Sleep state to Enable state                                                                   11: Reserved           " range="" rwaccess="R">
		</bitfield>
		<bitfield id="STERR" width="1" begin="7" end="7" resetval="0" description="State Transition Error                                                                                    0: Error did not occur                                                                                    1: Error occured                      " range="" rwaccess="R">
		</bitfield>
		<bitfield id="PERMDIS" width="1" begin="6" end="6" resetval="0" description="Permanently Disable                                                                                      0: Do not permanently disable module                                                           1: Permanently disable module                                               " range="" rwaccess="R">
		</bitfield>
		<bitfield id="STATE" width="6" begin="5" end="0" resetval="0" description="These bits indiacte the current module state                                                010000:  Power Domain Off                                                                          110000:  Iso-PwrCtrl                                                                                      111000:  En-IsoCtrl                                                                                        101000:  SyncReset                                                                                      100000:  SwRstDisable                                                                                 100100:  Disable                                                                                            101100:  Enable                                                                                             101110:  SlpTrans                                                                                         100110:  Sleep                                                                                              100111:  TwkTrans                                                                                       101111:  Twk                                                                                                 Others:   Reserved" range="" rwaccess="R">
		</bitfield>
	</register>
	<register id="MDSTAT9" acronym="MDSTAT9" offset="0x624" width="32" description="Module Status 9 Register">
		<bitfield id="_RESV" width="10" begin="31" end="22" resetval="0" description="Reserved" range="" rwaccess="R">
		</bitfield>
		<bitfield id="MSTID" width="6" begin="21" end="16" resetval="0" description="Master ID. If ACSLP occurs, this field records the master ID of the master that caused the access. This bit is cleared when the corresponding ERRCR bit is written with a 1. " range="" rwaccess="R">
		</bitfield>
		<bitfield id="_RESV" width="5" begin="15" end="11" resetval="0" description="Reserved" range="" rwaccess="R">
		</bitfield>
		<bitfield id="WKRSLP" width="1" begin="10" end="10" resetval="0" description="Wakeup Request to Module in Sleep Detected.  Wakeup_pi is detected for this module when it is in sleep. If MDCTL.WKRSLPIE = 1, the setting of this field can cause ERRPR for this module to be set.                                          0: Condition did not occur                                                                              1: wakeup_pi = 1 when module is in sleep.                                     " range="" rwaccess="R">
		</bitfield>
		<bitfield id="ACSLP" width="2" begin="9" end="8" resetval="0" description="Non-emulation access to Module in Sleep occurred.                                    00:  Condition did not occur                                                                           01:  Access to module in sleep occurred. PSC transitioned the module from Sleep state to Temp Wake state then back to Sleep state                                                     10:  Access to module in sleep occured. PSC transitioned the module from Sleep state to Enable state                                                                   11: Reserved           " range="" rwaccess="R">
		</bitfield>
		<bitfield id="STERR" width="1" begin="7" end="7" resetval="0" description="State Transition Error                                                                                    0: Error did not occur                                                                                    1: Error occured                      " range="" rwaccess="R">
		</bitfield>
		<bitfield id="PERMDIS" width="1" begin="6" end="6" resetval="0" description="Permanently Disable                                                                                      0: Do not permanently disable module                                                           1: Permanently disable module                                               " range="" rwaccess="R">
		</bitfield>
		<bitfield id="STATE" width="6" begin="5" end="0" resetval="0" description="These bits indiacte the current module state                                                010000:  Power Domain Off                                                                          110000:  Iso-PwrCtrl                                                                                      111000:  En-IsoCtrl                                                                                        101000:  SyncReset                                                                                      100000:  SwRstDisable                                                                                 100100:  Disable                                                                                            101100:  Enable                                                                                             101110:  SlpTrans                                                                                         100110:  Sleep                                                                                              100111:  TwkTrans                                                                                       101111:  Twk                                                                                                 Others:   Reserved" range="" rwaccess="R">
		</bitfield>
	</register>
	<register id="MDSTAT10" acronym="MDSTAT10" offset="0x628" width="32" description="Module Status 10 Register">
		<bitfield id="_RESV" width="10" begin="31" end="22" resetval="0" description="Reserved" range="" rwaccess="R">
		</bitfield>
		<bitfield id="MSTID" width="6" begin="21" end="16" resetval="0" description="Master ID. If ACSLP occurs, this field records the master ID of the master that caused the access. This bit is cleared when the corresponding ERRCR bit is written with a 1. " range="" rwaccess="R">
		</bitfield>
		<bitfield id="_RESV" width="5" begin="15" end="11" resetval="0" description="Reserved" range="" rwaccess="R">
		</bitfield>
		<bitfield id="WKRSLP" width="1" begin="10" end="10" resetval="0" description="Wakeup Request to Module in Sleep Detected.  Wakeup_pi is detected for this module when it is in sleep. If MDCTL.WKRSLPIE = 1, the setting of this field can cause ERRPR for this module to be set.                                          0: Condition did not occur                                                                              1: wakeup_pi = 1 when module is in sleep.                                     " range="" rwaccess="R">
		</bitfield>
		<bitfield id="ACSLP" width="2" begin="9" end="8" resetval="0" description="Non-emulation access to Module in Sleep occurred.                                    00:  Condition did not occur                                                                           01:  Access to module in sleep occurred. PSC transitioned the module from Sleep state to Temp Wake state then back to Sleep state                                                     10:  Access to module in sleep occured. PSC transitioned the module from Sleep state to Enable state                                                                   11: Reserved           " range="" rwaccess="R">
		</bitfield>
		<bitfield id="STERR" width="1" begin="7" end="7" resetval="0" description="State Transition Error                                                                                    0: Error did not occur                                                                                    1: Error occured                      " range="" rwaccess="R">
		</bitfield>
		<bitfield id="PERMDIS" width="1" begin="6" end="6" resetval="0" description="Permanently Disable                                                                                      0: Do not permanently disable module                                                           1: Permanently disable module                                               " range="" rwaccess="R">
		</bitfield>
		<bitfield id="STATE" width="6" begin="5" end="0" resetval="0" description="These bits indiacte the current module state                                                010000:  Power Domain Off                                                                          110000:  Iso-PwrCtrl                                                                                      111000:  En-IsoCtrl                                                                                        101000:  SyncReset                                                                                      100000:  SwRstDisable                                                                                 100100:  Disable                                                                                            101100:  Enable                                                                                             101110:  SlpTrans                                                                                         100110:  Sleep                                                                                              100111:  TwkTrans                                                                                       101111:  Twk                                                                                                 Others:   Reserved" range="" rwaccess="R">
		</bitfield>
	</register>
	<register id="MDSTAT11" acronym="MDSTAT11" offset="0x62C" width="32" description="Module Status 11 Register">
		<bitfield id="_RESV" width="10" begin="31" end="22" resetval="0" description="Reserved" range="" rwaccess="R">
		</bitfield>
		<bitfield id="MSTID" width="6" begin="21" end="16" resetval="0" description="Master ID. If ACSLP occurs, this field records the master ID of the master that caused the access. This bit is cleared when the corresponding ERRCR bit is written with a 1. " range="" rwaccess="R">
		</bitfield>
		<bitfield id="_RESV" width="5" begin="15" end="11" resetval="0" description="Reserved" range="" rwaccess="R">
		</bitfield>
		<bitfield id="WKRSLP" width="1" begin="10" end="10" resetval="0" description="Wakeup Request to Module in Sleep Detected.  Wakeup_pi is detected for this module when it is in sleep. If MDCTL.WKRSLPIE = 1, the setting of this field can cause ERRPR for this module to be set.                                          0: Condition did not occur                                                                              1: wakeup_pi = 1 when module is in sleep.                                     " range="" rwaccess="R">
		</bitfield>
		<bitfield id="ACSLP" width="2" begin="9" end="8" resetval="0" description="Non-emulation access to Module in Sleep occurred.                                    00:  Condition did not occur                                                                           01:  Access to module in sleep occurred. PSC transitioned the module from Sleep state to Temp Wake state then back to Sleep state                                                     10:  Access to module in sleep occured. PSC transitioned the module from Sleep state to Enable state                                                                   11: Reserved           " range="" rwaccess="R">
		</bitfield>
		<bitfield id="STERR" width="1" begin="7" end="7" resetval="0" description="State Transition Error                                                                                    0: Error did not occur                                                                                    1: Error occured                      " range="" rwaccess="R">
		</bitfield>
		<bitfield id="PERMDIS" width="1" begin="6" end="6" resetval="0" description="Permanently Disable                                                                                      0: Do not permanently disable module                                                           1: Permanently disable module                                               " range="" rwaccess="R">
		</bitfield>
		<bitfield id="STATE" width="6" begin="5" end="0" resetval="0" description="These bits indiacte the current module state                                                010000:  Power Domain Off                                                                          110000:  Iso-PwrCtrl                                                                                      111000:  En-IsoCtrl                                                                                        101000:  SyncReset                                                                                      100000:  SwRstDisable                                                                                 100100:  Disable                                                                                            101100:  Enable                                                                                             101110:  SlpTrans                                                                                         100110:  Sleep                                                                                              100111:  TwkTrans                                                                                       101111:  Twk                                                                                                 Others:   Reserved" range="" rwaccess="R">
		</bitfield>
	</register>
	<register id="MDSTAT12" acronym="MDSTAT12" offset="0x630" width="32" description="Module Status 12 Register">
		<bitfield id="_RESV" width="10" begin="31" end="22" resetval="0" description="Reserved" range="" rwaccess="R">
		</bitfield>
		<bitfield id="MSTID" width="6" begin="21" end="16" resetval="0" description="Master ID. If ACSLP occurs, this field records the master ID of the master that caused the access. This bit is cleared when the corresponding ERRCR bit is written with a 1. " range="" rwaccess="R">
		</bitfield>
		<bitfield id="_RESV" width="5" begin="15" end="11" resetval="0" description="Reserved" range="" rwaccess="R">
		</bitfield>
		<bitfield id="WKRSLP" width="1" begin="10" end="10" resetval="0" description="Wakeup Request to Module in Sleep Detected.  Wakeup_pi is detected for this module when it is in sleep. If MDCTL.WKRSLPIE = 1, the setting of this field can cause ERRPR for this module to be set.                                          0: Condition did not occur                                                                              1: wakeup_pi = 1 when module is in sleep.                                     " range="" rwaccess="R">
		</bitfield>
		<bitfield id="ACSLP" width="2" begin="9" end="8" resetval="0" description="Non-emulation access to Module in Sleep occurred.                                    00:  Condition did not occur                                                                           01:  Access to module in sleep occurred. PSC transitioned the module from Sleep state to Temp Wake state then back to Sleep state                                                     10:  Access to module in sleep occured. PSC transitioned the module from Sleep state to Enable state                                                                   11: Reserved           " range="" rwaccess="R">
		</bitfield>
		<bitfield id="STERR" width="1" begin="7" end="7" resetval="0" description="State Transition Error                                                                                    0: Error did not occur                                                                                    1: Error occured                      " range="" rwaccess="R">
		</bitfield>
		<bitfield id="PERMDIS" width="1" begin="6" end="6" resetval="0" description="Permanently Disable                                                                                      0: Do not permanently disable module                                                           1: Permanently disable module                                               " range="" rwaccess="R">
		</bitfield>
		<bitfield id="STATE" width="6" begin="5" end="0" resetval="0" description="These bits indiacte the current module state                                                010000:  Power Domain Off                                                                          110000:  Iso-PwrCtrl                                                                                      111000:  En-IsoCtrl                                                                                        101000:  SyncReset                                                                                      100000:  SwRstDisable                                                                                 100100:  Disable                                                                                            101100:  Enable                                                                                             101110:  SlpTrans                                                                                         100110:  Sleep                                                                                              100111:  TwkTrans                                                                                       101111:  Twk                                                                                                 Others:   Reserved" range="" rwaccess="R">
		</bitfield>
	</register>
	<register id="MDSTAT13" acronym="MDSTAT13" offset="0x634" width="32" description="Module Status 13 Register">
		<bitfield id="_RESV" width="10" begin="31" end="22" resetval="0" description="Reserved" range="" rwaccess="R">
		</bitfield>
		<bitfield id="MSTID" width="6" begin="21" end="16" resetval="0" description="Master ID. If ACSLP occurs, this field records the master ID of the master that caused the access. This bit is cleared when the corresponding ERRCR bit is written with a 1. " range="" rwaccess="R">
		</bitfield>
		<bitfield id="_RESV" width="5" begin="15" end="11" resetval="0" description="Reserved" range="" rwaccess="R">
		</bitfield>
		<bitfield id="WKRSLP" width="1" begin="10" end="10" resetval="0" description="Wakeup Request to Module in Sleep Detected.  Wakeup_pi is detected for this module when it is in sleep. If MDCTL.WKRSLPIE = 1, the setting of this field can cause ERRPR for this module to be set.                                          0: Condition did not occur                                                                              1: wakeup_pi = 1 when module is in sleep.                                     " range="" rwaccess="R">
		</bitfield>
		<bitfield id="ACSLP" width="2" begin="9" end="8" resetval="0" description="Non-emulation access to Module in Sleep occurred.                                    00:  Condition did not occur                                                                           01:  Access to module in sleep occurred. PSC transitioned the module from Sleep state to Temp Wake state then back to Sleep state                                                     10:  Access to module in sleep occured. PSC transitioned the module from Sleep state to Enable state                                                                   11: Reserved           " range="" rwaccess="R">
		</bitfield>
		<bitfield id="STERR" width="1" begin="7" end="7" resetval="0" description="State Transition Error                                                                                    0: Error did not occur                                                                                    1: Error occured                      " range="" rwaccess="R">
		</bitfield>
		<bitfield id="PERMDIS" width="1" begin="6" end="6" resetval="0" description="Permanently Disable                                                                                      0: Do not permanently disable module                                                           1: Permanently disable module                                               " range="" rwaccess="R">
		</bitfield>
		<bitfield id="STATE" width="6" begin="5" end="0" resetval="0" description="These bits indiacte the current module state                                                010000:  Power Domain Off                                                                          110000:  Iso-PwrCtrl                                                                                      111000:  En-IsoCtrl                                                                                        101000:  SyncReset                                                                                      100000:  SwRstDisable                                                                                 100100:  Disable                                                                                            101100:  Enable                                                                                             101110:  SlpTrans                                                                                         100110:  Sleep                                                                                              100111:  TwkTrans                                                                                       101111:  Twk                                                                                                 Others:   Reserved" range="" rwaccess="R">
		</bitfield>
	</register>
	<register id="MDSTAT14" acronym="MDSTAT14" offset="0x638" width="32" description="Module Status 14 Register">
		<bitfield id="_RESV" width="10" begin="31" end="22" resetval="0" description="Reserved" range="" rwaccess="R">
		</bitfield>
		<bitfield id="MSTID" width="6" begin="21" end="16" resetval="0" description="Master ID. If ACSLP occurs, this field records the master ID of the master that caused the access. This bit is cleared when the corresponding ERRCR bit is written with a 1. " range="" rwaccess="R">
		</bitfield>
		<bitfield id="_RESV" width="5" begin="15" end="11" resetval="0" description="Reserved" range="" rwaccess="R">
		</bitfield>
		<bitfield id="WKRSLP" width="1" begin="10" end="10" resetval="0" description="Wakeup Request to Module in Sleep Detected.  Wakeup_pi is detected for this module when it is in sleep. If MDCTL.WKRSLPIE = 1, the setting of this field can cause ERRPR for this module to be set.                                          0: Condition did not occur                                                                              1: wakeup_pi = 1 when module is in sleep.                                     " range="" rwaccess="R">
		</bitfield>
		<bitfield id="ACSLP" width="2" begin="9" end="8" resetval="0" description="Non-emulation access to Module in Sleep occurred.                                    00:  Condition did not occur                                                                           01:  Access to module in sleep occurred. PSC transitioned the module from Sleep state to Temp Wake state then back to Sleep state                                                     10:  Access to module in sleep occured. PSC transitioned the module from Sleep state to Enable state                                                                   11: Reserved           " range="" rwaccess="R">
		</bitfield>
		<bitfield id="STERR" width="1" begin="7" end="7" resetval="0" description="State Transition Error                                                                                    0: Error did not occur                                                                                    1: Error occured                      " range="" rwaccess="R">
		</bitfield>
		<bitfield id="PERMDIS" width="1" begin="6" end="6" resetval="0" description="Permanently Disable                                                                                      0: Do not permanently disable module                                                           1: Permanently disable module                                               " range="" rwaccess="R">
		</bitfield>
		<bitfield id="STATE" width="6" begin="5" end="0" resetval="0" description="These bits indiacte the current module state                                                010000:  Power Domain Off                                                                          110000:  Iso-PwrCtrl                                                                                      111000:  En-IsoCtrl                                                                                        101000:  SyncReset                                                                                      100000:  SwRstDisable                                                                                 100100:  Disable                                                                                            101100:  Enable                                                                                             101110:  SlpTrans                                                                                         100110:  Sleep                                                                                              100111:  TwkTrans                                                                                       101111:  Twk                                                                                                 Others:   Reserved" range="" rwaccess="R">
		</bitfield>
	</register>
	<register id="MDSTAT15" acronym="MDSTAT15" offset="0x63C" width="32" description="Module Status 15 Register">
		<bitfield id="_RESV" width="10" begin="31" end="22" resetval="0" description="Reserved" range="" rwaccess="R">
		</bitfield>
		<bitfield id="MSTID" width="6" begin="21" end="16" resetval="0" description="Master ID. If ACSLP occurs, this field records the master ID of the master that caused the access. This bit is cleared when the corresponding ERRCR bit is written with a 1. " range="" rwaccess="R">
		</bitfield>
		<bitfield id="_RESV" width="5" begin="15" end="11" resetval="0" description="Reserved" range="" rwaccess="R">
		</bitfield>
		<bitfield id="WKRSLP" width="1" begin="10" end="10" resetval="0" description="Wakeup Request to Module in Sleep Detected.  Wakeup_pi is detected for this module when it is in sleep. If MDCTL.WKRSLPIE = 1, the setting of this field can cause ERRPR for this module to be set.                                          0: Condition did not occur                                                                              1: wakeup_pi = 1 when module is in sleep.                                     " range="" rwaccess="R">
		</bitfield>
		<bitfield id="ACSLP" width="2" begin="9" end="8" resetval="0" description="Non-emulation access to Module in Sleep occurred.                                    00:  Condition did not occur                                                                           01:  Access to module in sleep occurred. PSC transitioned the module from Sleep state to Temp Wake state then back to Sleep state                                                     10:  Access to module in sleep occured. PSC transitioned the module from Sleep state to Enable state                                                                   11: Reserved           " range="" rwaccess="R">
		</bitfield>
		<bitfield id="STERR" width="1" begin="7" end="7" resetval="0" description="State Transition Error                                                                                    0: Error did not occur                                                                                    1: Error occured                      " range="" rwaccess="R">
		</bitfield>
		<bitfield id="PERMDIS" width="1" begin="6" end="6" resetval="0" description="Permanently Disable                                                                                      0: Do not permanently disable module                                                           1: Permanently disable module                                               " range="" rwaccess="R">
		</bitfield>
		<bitfield id="STATE" width="6" begin="5" end="0" resetval="0" description="These bits indiacte the current module state                                                010000:  Power Domain Off                                                                          110000:  Iso-PwrCtrl                                                                                      111000:  En-IsoCtrl                                                                                        101000:  SyncReset                                                                                      100000:  SwRstDisable                                                                                 100100:  Disable                                                                                            101100:  Enable                                                                                             101110:  SlpTrans                                                                                         100110:  Sleep                                                                                              100111:  TwkTrans                                                                                       101111:  Twk                                                                                                 Others:   Reserved" range="" rwaccess="R">
		</bitfield>
	</register>
	<register id="MDSTAT16" acronym="MDSTAT16" offset="0x640" width="32" description="Module Status 16 Register">
		<bitfield id="_RESV" width="10" begin="31" end="22" resetval="0" description="Reserved" range="" rwaccess="R">
		</bitfield>
		<bitfield id="MSTID" width="6" begin="21" end="16" resetval="0" description="Master ID. If ACSLP occurs, this field records the master ID of the master that caused the access. This bit is cleared when the corresponding ERRCR bit is written with a 1. " range="" rwaccess="R">
		</bitfield>
		<bitfield id="_RESV" width="5" begin="15" end="11" resetval="0" description="Reserved" range="" rwaccess="R">
		</bitfield>
		<bitfield id="WKRSLP" width="1" begin="10" end="10" resetval="0" description="Wakeup Request to Module in Sleep Detected.  Wakeup_pi is detected for this module when it is in sleep. If MDCTL.WKRSLPIE = 1, the setting of this field can cause ERRPR for this module to be set.                                          0: Condition did not occur                                                                              1: wakeup_pi = 1 when module is in sleep.                                     " range="" rwaccess="R">
		</bitfield>
		<bitfield id="ACSLP" width="2" begin="9" end="8" resetval="0" description="Non-emulation access to Module in Sleep occurred.                                    00:  Condition did not occur                                                                           01:  Access to module in sleep occurred. PSC transitioned the module from Sleep state to Temp Wake state then back to Sleep state                                                     10:  Access to module in sleep occured. PSC transitioned the module from Sleep state to Enable state                                                                   11: Reserved           " range="" rwaccess="R">
		</bitfield>
		<bitfield id="STERR" width="1" begin="7" end="7" resetval="0" description="State Transition Error                                                                                    0: Error did not occur                                                                                    1: Error occured                      " range="" rwaccess="R">
		</bitfield>
		<bitfield id="PERMDIS" width="1" begin="6" end="6" resetval="0" description="Permanently Disable                                                                                      0: Do not permanently disable module                                                           1: Permanently disable module                                               " range="" rwaccess="R">
		</bitfield>
		<bitfield id="STATE" width="6" begin="5" end="0" resetval="0" description="These bits indiacte the current module state                                                010000:  Power Domain Off                                                                          110000:  Iso-PwrCtrl                                                                                      111000:  En-IsoCtrl                                                                                        101000:  SyncReset                                                                                      100000:  SwRstDisable                                                                                 100100:  Disable                                                                                            101100:  Enable                                                                                             101110:  SlpTrans                                                                                         100110:  Sleep                                                                                              100111:  TwkTrans                                                                                       101111:  Twk                                                                                                 Others:   Reserved" range="" rwaccess="R">
		</bitfield>
	</register>
	<register id="MDSTAT17" acronym="MDSTAT17" offset="0x644" width="32" description="Module Status 17 Register">
		<bitfield id="_RESV" width="10" begin="31" end="22" resetval="0" description="Reserved" range="" rwaccess="R">
		</bitfield>
		<bitfield id="MSTID" width="6" begin="21" end="16" resetval="0" description="Master ID. If ACSLP occurs, this field records the master ID of the master that caused the access. This bit is cleared when the corresponding ERRCR bit is written with a 1. " range="" rwaccess="R">
		</bitfield>
		<bitfield id="_RESV" width="5" begin="15" end="11" resetval="0" description="Reserved" range="" rwaccess="R">
		</bitfield>
		<bitfield id="WKRSLP" width="1" begin="10" end="10" resetval="0" description="Wakeup Request to Module in Sleep Detected.  Wakeup_pi is detected for this module when it is in sleep. If MDCTL.WKRSLPIE = 1, the setting of this field can cause ERRPR for this module to be set.                                          0: Condition did not occur                                                                              1: wakeup_pi = 1 when module is in sleep.                                     " range="" rwaccess="R">
		</bitfield>
		<bitfield id="ACSLP" width="2" begin="9" end="8" resetval="0" description="Non-emulation access to Module in Sleep occurred.                                    00:  Condition did not occur                                                                           01:  Access to module in sleep occurred. PSC transitioned the module from Sleep state to Temp Wake state then back to Sleep state                                                     10:  Access to module in sleep occured. PSC transitioned the module from Sleep state to Enable state                                                                   11: Reserved           " range="" rwaccess="R">
		</bitfield>
		<bitfield id="STERR" width="1" begin="7" end="7" resetval="0" description="State Transition Error                                                                                    0: Error did not occur                                                                                    1: Error occured                      " range="" rwaccess="R">
		</bitfield>
		<bitfield id="PERMDIS" width="1" begin="6" end="6" resetval="0" description="Permanently Disable                                                                                      0: Do not permanently disable module                                                           1: Permanently disable module                                               " range="" rwaccess="R">
		</bitfield>
		<bitfield id="STATE" width="6" begin="5" end="0" resetval="0" description="These bits indiacte the current module state                                                010000:  Power Domain Off                                                                          110000:  Iso-PwrCtrl                                                                                      111000:  En-IsoCtrl                                                                                        101000:  SyncReset                                                                                      100000:  SwRstDisable                                                                                 100100:  Disable                                                                                            101100:  Enable                                                                                             101110:  SlpTrans                                                                                         100110:  Sleep                                                                                              100111:  TwkTrans                                                                                       101111:  Twk                                                                                                 Others:   Reserved" range="" rwaccess="R">
		</bitfield>
	</register>
	<register id="MDSTAT18" acronym="MDSTAT18" offset="0x648" width="32" description="Module Status 18 Register">
		<bitfield id="_RESV" width="10" begin="31" end="22" resetval="0" description="Reserved" range="" rwaccess="R">
		</bitfield>
		<bitfield id="MSTID" width="6" begin="21" end="16" resetval="0" description="Master ID. If ACSLP occurs, this field records the master ID of the master that caused the access. This bit is cleared when the corresponding ERRCR bit is written with a 1. " range="" rwaccess="R">
		</bitfield>
		<bitfield id="_RESV" width="5" begin="15" end="11" resetval="0" description="Reserved" range="" rwaccess="R">
		</bitfield>
		<bitfield id="WKRSLP" width="1" begin="10" end="10" resetval="0" description="Wakeup Request to Module in Sleep Detected.  Wakeup_pi is detected for this module when it is in sleep. If MDCTL.WKRSLPIE = 1, the setting of this field can cause ERRPR for this module to be set.                                          0: Condition did not occur                                                                              1: wakeup_pi = 1 when module is in sleep.                                     " range="" rwaccess="R">
		</bitfield>
		<bitfield id="ACSLP" width="2" begin="9" end="8" resetval="0" description="Non-emulation access to Module in Sleep occurred.                                    00:  Condition did not occur                                                                           01:  Access to module in sleep occurred. PSC transitioned the module from Sleep state to Temp Wake state then back to Sleep state                                                     10:  Access to module in sleep occured. PSC transitioned the module from Sleep state to Enable state                                                                   11: Reserved           " range="" rwaccess="R">
		</bitfield>
		<bitfield id="STERR" width="1" begin="7" end="7" resetval="0" description="State Transition Error                                                                                    0: Error did not occur                                                                                    1: Error occured                      " range="" rwaccess="R">
		</bitfield>
		<bitfield id="PERMDIS" width="1" begin="6" end="6" resetval="0" description="Permanently Disable                                                                                      0: Do not permanently disable module                                                           1: Permanently disable module                                               " range="" rwaccess="R">
		</bitfield>
		<bitfield id="STATE" width="6" begin="5" end="0" resetval="0" description="These bits indiacte the current module state                                                010000:  Power Domain Off                                                                          110000:  Iso-PwrCtrl                                                                                      111000:  En-IsoCtrl                                                                                        101000:  SyncReset                                                                                      100000:  SwRstDisable                                                                                 100100:  Disable                                                                                            101100:  Enable                                                                                             101110:  SlpTrans                                                                                         100110:  Sleep                                                                                              100111:  TwkTrans                                                                                       101111:  Twk                                                                                                 Others:   Reserved" range="" rwaccess="R">
		</bitfield>
	</register>
	<register id="MDSTAT19" acronym="MDSTAT19" offset="0x64C" width="32" description="Module Status 19 Register">
		<bitfield id="_RESV" width="10" begin="31" end="22" resetval="0" description="Reserved" range="" rwaccess="R">
		</bitfield>
		<bitfield id="MSTID" width="6" begin="21" end="16" resetval="0" description="Master ID. If ACSLP occurs, this field records the master ID of the master that caused the access. This bit is cleared when the corresponding ERRCR bit is written with a 1. " range="" rwaccess="R">
		</bitfield>
		<bitfield id="_RESV" width="5" begin="15" end="11" resetval="0" description="Reserved" range="" rwaccess="R">
		</bitfield>
		<bitfield id="WKRSLP" width="1" begin="10" end="10" resetval="0" description="Wakeup Request to Module in Sleep Detected.  Wakeup_pi is detected for this module when it is in sleep. If MDCTL.WKRSLPIE = 1, the setting of this field can cause ERRPR for this module to be set.                                          0: Condition did not occur                                                                              1: wakeup_pi = 1 when module is in sleep.                                     " range="" rwaccess="R">
		</bitfield>
		<bitfield id="ACSLP" width="2" begin="9" end="8" resetval="0" description="Non-emulation access to Module in Sleep occurred.                                    00:  Condition did not occur                                                                           01:  Access to module in sleep occurred. PSC transitioned the module from Sleep state to Temp Wake state then back to Sleep state                                                     10:  Access to module in sleep occured. PSC transitioned the module from Sleep state to Enable state                                                                   11: Reserved           " range="" rwaccess="R">
		</bitfield>
		<bitfield id="STERR" width="1" begin="7" end="7" resetval="0" description="State Transition Error                                                                                    0: Error did not occur                                                                                    1: Error occured                      " range="" rwaccess="R">
		</bitfield>
		<bitfield id="PERMDIS" width="1" begin="6" end="6" resetval="0" description="Permanently Disable                                                                                      0: Do not permanently disable module                                                           1: Permanently disable module                                               " range="" rwaccess="R">
		</bitfield>
		<bitfield id="STATE" width="6" begin="5" end="0" resetval="0" description="These bits indiacte the current module state                                                010000:  Power Domain Off                                                                          110000:  Iso-PwrCtrl                                                                                      111000:  En-IsoCtrl                                                                                        101000:  SyncReset                                                                                      100000:  SwRstDisable                                                                                 100100:  Disable                                                                                            101100:  Enable                                                                                             101110:  SlpTrans                                                                                         100110:  Sleep                                                                                              100111:  TwkTrans                                                                                       101111:  Twk                                                                                                 Others:   Reserved" range="" rwaccess="R">
		</bitfield>
	</register>
	<register id="MDSTAT20" acronym="MDSTAT20" offset="0x650" width="32" description="Module Status 20 Register">
		<bitfield id="_RESV" width="10" begin="31" end="22" resetval="0" description="Reserved" range="" rwaccess="R">
		</bitfield>
		<bitfield id="MSTID" width="6" begin="21" end="16" resetval="0" description="Master ID. If ACSLP occurs, this field records the master ID of the master that caused the access. This bit is cleared when the corresponding ERRCR bit is written with a 1. " range="" rwaccess="R">
		</bitfield>
		<bitfield id="_RESV" width="5" begin="15" end="11" resetval="0" description="Reserved" range="" rwaccess="R">
		</bitfield>
		<bitfield id="WKRSLP" width="1" begin="10" end="10" resetval="0" description="Wakeup Request to Module in Sleep Detected.  Wakeup_pi is detected for this module when it is in sleep. If MDCTL.WKRSLPIE = 1, the setting of this field can cause ERRPR for this module to be set.                                          0: Condition did not occur                                                                              1: wakeup_pi = 1 when module is in sleep.                                     " range="" rwaccess="R">
		</bitfield>
		<bitfield id="ACSLP" width="2" begin="9" end="8" resetval="0" description="Non-emulation access to Module in Sleep occurred.                                    00:  Condition did not occur                                                                           01:  Access to module in sleep occurred. PSC transitioned the module from Sleep state to Temp Wake state then back to Sleep state                                                     10:  Access to module in sleep occured. PSC transitioned the module from Sleep state to Enable state                                                                   11: Reserved           " range="" rwaccess="R">
		</bitfield>
		<bitfield id="STERR" width="1" begin="7" end="7" resetval="0" description="State Transition Error                                                                                    0: Error did not occur                                                                                    1: Error occured                      " range="" rwaccess="R">
		</bitfield>
		<bitfield id="PERMDIS" width="1" begin="6" end="6" resetval="0" description="Permanently Disable                                                                                      0: Do not permanently disable module                                                           1: Permanently disable module                                               " range="" rwaccess="R">
		</bitfield>
		<bitfield id="STATE" width="6" begin="5" end="0" resetval="0" description="These bits indiacte the current module state                                                010000:  Power Domain Off                                                                          110000:  Iso-PwrCtrl                                                                                      111000:  En-IsoCtrl                                                                                        101000:  SyncReset                                                                                      100000:  SwRstDisable                                                                                 100100:  Disable                                                                                            101100:  Enable                                                                                             101110:  SlpTrans                                                                                         100110:  Sleep                                                                                              100111:  TwkTrans                                                                                       101111:  Twk                                                                                                 Others:   Reserved" range="" rwaccess="R">
		</bitfield>
	</register>
	<register id="MDSTAT21" acronym="MDSTAT21" offset="0x654" width="32" description="Module Status 21 Register">
		<bitfield id="_RESV" width="10" begin="31" end="22" resetval="0" description="Reserved" range="" rwaccess="R">
		</bitfield>
		<bitfield id="MSTID" width="6" begin="21" end="16" resetval="0" description="Master ID. If ACSLP occurs, this field records the master ID of the master that caused the access. This bit is cleared when the corresponding ERRCR bit is written with a 1. " range="" rwaccess="R">
		</bitfield>
		<bitfield id="_RESV" width="5" begin="15" end="11" resetval="0" description="Reserved" range="" rwaccess="R">
		</bitfield>
		<bitfield id="WKRSLP" width="1" begin="10" end="10" resetval="0" description="Wakeup Request to Module in Sleep Detected.  Wakeup_pi is detected for this module when it is in sleep. If MDCTL.WKRSLPIE = 1, the setting of this field can cause ERRPR for this module to be set.                                          0: Condition did not occur                                                                              1: wakeup_pi = 1 when module is in sleep.                                     " range="" rwaccess="R">
		</bitfield>
		<bitfield id="ACSLP" width="2" begin="9" end="8" resetval="0" description="Non-emulation access to Module in Sleep occurred.                                    00:  Condition did not occur                                                                           01:  Access to module in sleep occurred. PSC transitioned the module from Sleep state to Temp Wake state then back to Sleep state                                                     10:  Access to module in sleep occured. PSC transitioned the module from Sleep state to Enable state                                                                   11: Reserved           " range="" rwaccess="R">
		</bitfield>
		<bitfield id="STERR" width="1" begin="7" end="7" resetval="0" description="State Transition Error                                                                                    0: Error did not occur                                                                                    1: Error occured                      " range="" rwaccess="R">
		</bitfield>
		<bitfield id="PERMDIS" width="1" begin="6" end="6" resetval="0" description="Permanently Disable                                                                                      0: Do not permanently disable module                                                           1: Permanently disable module                                               " range="" rwaccess="R">
		</bitfield>
		<bitfield id="STATE" width="6" begin="5" end="0" resetval="0" description="These bits indiacte the current module state                                                010000:  Power Domain Off                                                                          110000:  Iso-PwrCtrl                                                                                      111000:  En-IsoCtrl                                                                                        101000:  SyncReset                                                                                      100000:  SwRstDisable                                                                                 100100:  Disable                                                                                            101100:  Enable                                                                                             101110:  SlpTrans                                                                                         100110:  Sleep                                                                                              100111:  TwkTrans                                                                                       101111:  Twk                                                                                                 Others:   Reserved" range="" rwaccess="R">
		</bitfield>
	</register>
	<register id="MDSTAT22" acronym="MDSTAT22" offset="0x658" width="32" description="Module Status 22 Register">
		<bitfield id="_RESV" width="10" begin="31" end="22" resetval="0" description="Reserved" range="" rwaccess="R">
		</bitfield>
		<bitfield id="MSTID" width="6" begin="21" end="16" resetval="0" description="Master ID. If ACSLP occurs, this field records the master ID of the master that caused the access. This bit is cleared when the corresponding ERRCR bit is written with a 1. " range="" rwaccess="R">
		</bitfield>
		<bitfield id="_RESV" width="5" begin="15" end="11" resetval="0" description="Reserved" range="" rwaccess="R">
		</bitfield>
		<bitfield id="WKRSLP" width="1" begin="10" end="10" resetval="0" description="Wakeup Request to Module in Sleep Detected.  Wakeup_pi is detected for this module when it is in sleep. If MDCTL.WKRSLPIE = 1, the setting of this field can cause ERRPR for this module to be set.                                          0: Condition did not occur                                                                              1: wakeup_pi = 1 when module is in sleep.                                     " range="" rwaccess="R">
		</bitfield>
		<bitfield id="ACSLP" width="2" begin="9" end="8" resetval="0" description="Non-emulation access to Module in Sleep occurred.                                    00:  Condition did not occur                                                                           01:  Access to module in sleep occurred. PSC transitioned the module from Sleep state to Temp Wake state then back to Sleep state                                                     10:  Access to module in sleep occured. PSC transitioned the module from Sleep state to Enable state                                                                   11: Reserved           " range="" rwaccess="R">
		</bitfield>
		<bitfield id="STERR" width="1" begin="7" end="7" resetval="0" description="State Transition Error                                                                                    0: Error did not occur                                                                                    1: Error occured                      " range="" rwaccess="R">
		</bitfield>
		<bitfield id="PERMDIS" width="1" begin="6" end="6" resetval="0" description="Permanently Disable                                                                                      0: Do not permanently disable module                                                           1: Permanently disable module                                               " range="" rwaccess="R">
		</bitfield>
		<bitfield id="STATE" width="6" begin="5" end="0" resetval="0" description="These bits indiacte the current module state                                                010000:  Power Domain Off                                                                          110000:  Iso-PwrCtrl                                                                                      111000:  En-IsoCtrl                                                                                        101000:  SyncReset                                                                                      100000:  SwRstDisable                                                                                 100100:  Disable                                                                                            101100:  Enable                                                                                             101110:  SlpTrans                                                                                         100110:  Sleep                                                                                              100111:  TwkTrans                                                                                       101111:  Twk                                                                                                 Others:   Reserved" range="" rwaccess="R">
		</bitfield>
	</register>
	<register id="MDSTAT23" acronym="MDSTAT23" offset="0x65C" width="32" description="Module Status 23 Register">
		<bitfield id="_RESV" width="10" begin="31" end="22" resetval="0" description="Reserved" range="" rwaccess="R">
		</bitfield>
		<bitfield id="MSTID" width="6" begin="21" end="16" resetval="0" description="Master ID. If ACSLP occurs, this field records the master ID of the master that caused the access. This bit is cleared when the corresponding ERRCR bit is written with a 1. " range="" rwaccess="R">
		</bitfield>
		<bitfield id="_RESV" width="5" begin="15" end="11" resetval="0" description="Reserved" range="" rwaccess="R">
		</bitfield>
		<bitfield id="WKRSLP" width="1" begin="10" end="10" resetval="0" description="Wakeup Request to Module in Sleep Detected.  Wakeup_pi is detected for this module when it is in sleep. If MDCTL.WKRSLPIE = 1, the setting of this field can cause ERRPR for this module to be set.                                          0: Condition did not occur                                                                              1: wakeup_pi = 1 when module is in sleep.                                     " range="" rwaccess="R">
		</bitfield>
		<bitfield id="ACSLP" width="2" begin="9" end="8" resetval="0" description="Non-emulation access to Module in Sleep occurred.                                    00:  Condition did not occur                                                                           01:  Access to module in sleep occurred. PSC transitioned the module from Sleep state to Temp Wake state then back to Sleep state                                                     10:  Access to module in sleep occured. PSC transitioned the module from Sleep state to Enable state                                                                   11: Reserved           " range="" rwaccess="R">
		</bitfield>
		<bitfield id="STERR" width="1" begin="7" end="7" resetval="0" description="State Transition Error                                                                                    0: Error did not occur                                                                                    1: Error occured                      " range="" rwaccess="R">
		</bitfield>
		<bitfield id="PERMDIS" width="1" begin="6" end="6" resetval="0" description="Permanently Disable                                                                                      0: Do not permanently disable module                                                           1: Permanently disable module                                               " range="" rwaccess="R">
		</bitfield>
		<bitfield id="STATE" width="6" begin="5" end="0" resetval="0" description="These bits indiacte the current module state                                                010000:  Power Domain Off                                                                          110000:  Iso-PwrCtrl                                                                                      111000:  En-IsoCtrl                                                                                        101000:  SyncReset                                                                                      100000:  SwRstDisable                                                                                 100100:  Disable                                                                                            101100:  Enable                                                                                             101110:  SlpTrans                                                                                         100110:  Sleep                                                                                              100111:  TwkTrans                                                                                       101111:  Twk                                                                                                 Others:   Reserved" range="" rwaccess="R">
		</bitfield>
	</register>
	<register id="MDSTAT24" acronym="MDSTAT24" offset="0x660" width="32" description="Module Status 24 Register">
		<bitfield id="_RESV" width="10" begin="31" end="22" resetval="0" description="Reserved" range="" rwaccess="R">
		</bitfield>
		<bitfield id="MSTID" width="6" begin="21" end="16" resetval="0" description="Master ID. If ACSLP occurs, this field records the master ID of the master that caused the access. This bit is cleared when the corresponding ERRCR bit is written with a 1. " range="" rwaccess="R">
		</bitfield>
		<bitfield id="_RESV" width="5" begin="15" end="11" resetval="0" description="Reserved" range="" rwaccess="R">
		</bitfield>
		<bitfield id="WKRSLP" width="1" begin="10" end="10" resetval="0" description="Wakeup Request to Module in Sleep Detected.  Wakeup_pi is detected for this module when it is in sleep. If MDCTL.WKRSLPIE = 1, the setting of this field can cause ERRPR for this module to be set.                                          0: Condition did not occur                                                                              1: wakeup_pi = 1 when module is in sleep.                                     " range="" rwaccess="R">
		</bitfield>
		<bitfield id="ACSLP" width="2" begin="9" end="8" resetval="0" description="Non-emulation access to Module in Sleep occurred.                                    00:  Condition did not occur                                                                           01:  Access to module in sleep occurred. PSC transitioned the module from Sleep state to Temp Wake state then back to Sleep state                                                     10:  Access to module in sleep occured. PSC transitioned the module from Sleep state to Enable state                                                                   11: Reserved           " range="" rwaccess="R">
		</bitfield>
		<bitfield id="STERR" width="1" begin="7" end="7" resetval="0" description="State Transition Error                                                                                    0: Error did not occur                                                                                    1: Error occured                      " range="" rwaccess="R">
		</bitfield>
		<bitfield id="PERMDIS" width="1" begin="6" end="6" resetval="0" description="Permanently Disable                                                                                      0: Do not permanently disable module                                                           1: Permanently disable module                                               " range="" rwaccess="R">
		</bitfield>
		<bitfield id="STATE" width="6" begin="5" end="0" resetval="0" description="These bits indiacte the current module state                                                010000:  Power Domain Off                                                                          110000:  Iso-PwrCtrl                                                                                      111000:  En-IsoCtrl                                                                                        101000:  SyncReset                                                                                      100000:  SwRstDisable                                                                                 100100:  Disable                                                                                            101100:  Enable                                                                                             101110:  SlpTrans                                                                                         100110:  Sleep                                                                                              100111:  TwkTrans                                                                                       101111:  Twk                                                                                                 Others:   Reserved" range="" rwaccess="R">
		</bitfield>
	</register>
	<register id="MDSTAT25" acronym="MDSTAT25" offset="0x664" width="32" description="Module Status 25 Register">
		<bitfield id="_RESV" width="10" begin="31" end="22" resetval="0" description="Reserved" range="" rwaccess="R">
		</bitfield>
		<bitfield id="MSTID" width="6" begin="21" end="16" resetval="0" description="Master ID. If ACSLP occurs, this field records the master ID of the master that caused the access. This bit is cleared when the corresponding ERRCR bit is written with a 1. " range="" rwaccess="R">
		</bitfield>
		<bitfield id="_RESV" width="5" begin="15" end="11" resetval="0" description="Reserved" range="" rwaccess="R">
		</bitfield>
		<bitfield id="WKRSLP" width="1" begin="10" end="10" resetval="0" description="Wakeup Request to Module in Sleep Detected.  Wakeup_pi is detected for this module when it is in sleep. If MDCTL.WKRSLPIE = 1, the setting of this field can cause ERRPR for this module to be set.                                          0: Condition did not occur                                                                              1: wakeup_pi = 1 when module is in sleep.                                     " range="" rwaccess="R">
		</bitfield>
		<bitfield id="ACSLP" width="2" begin="9" end="8" resetval="0" description="Non-emulation access to Module in Sleep occurred.                                    00:  Condition did not occur                                                                           01:  Access to module in sleep occurred. PSC transitioned the module from Sleep state to Temp Wake state then back to Sleep state                                                     10:  Access to module in sleep occured. PSC transitioned the module from Sleep state to Enable state                                                                   11: Reserved           " range="" rwaccess="R">
		</bitfield>
		<bitfield id="STERR" width="1" begin="7" end="7" resetval="0" description="State Transition Error                                                                                    0: Error did not occur                                                                                    1: Error occured                      " range="" rwaccess="R">
		</bitfield>
		<bitfield id="PERMDIS" width="1" begin="6" end="6" resetval="0" description="Permanently Disable                                                                                      0: Do not permanently disable module                                                           1: Permanently disable module                                               " range="" rwaccess="R">
		</bitfield>
		<bitfield id="STATE" width="6" begin="5" end="0" resetval="0" description="These bits indiacte the current module state                                                010000:  Power Domain Off                                                                          110000:  Iso-PwrCtrl                                                                                      111000:  En-IsoCtrl                                                                                        101000:  SyncReset                                                                                      100000:  SwRstDisable                                                                                 100100:  Disable                                                                                            101100:  Enable                                                                                             101110:  SlpTrans                                                                                         100110:  Sleep                                                                                              100111:  TwkTrans                                                                                       101111:  Twk                                                                                                 Others:   Reserved" range="" rwaccess="R">
		</bitfield>
	</register>
	<register id="MDSTAT26" acronym="MDSTAT26" offset="0x668" width="32" description="Module Status 26 Register">
		<bitfield id="_RESV" width="10" begin="31" end="22" resetval="0" description="Reserved" range="" rwaccess="R">
		</bitfield>
		<bitfield id="MSTID" width="6" begin="21" end="16" resetval="0" description="Master ID. If ACSLP occurs, this field records the master ID of the master that caused the access. This bit is cleared when the corresponding ERRCR bit is written with a 1. " range="" rwaccess="R">
		</bitfield>
		<bitfield id="_RESV" width="5" begin="15" end="11" resetval="0" description="Reserved" range="" rwaccess="R">
		</bitfield>
		<bitfield id="WKRSLP" width="1" begin="10" end="10" resetval="0" description="Wakeup Request to Module in Sleep Detected.  Wakeup_pi is detected for this module when it is in sleep. If MDCTL.WKRSLPIE = 1, the setting of this field can cause ERRPR for this module to be set.                                          0: Condition did not occur                                                                              1: wakeup_pi = 1 when module is in sleep.                                     " range="" rwaccess="R">
		</bitfield>
		<bitfield id="ACSLP" width="2" begin="9" end="8" resetval="0" description="Non-emulation access to Module in Sleep occurred.                                    00:  Condition did not occur                                                                           01:  Access to module in sleep occurred. PSC transitioned the module from Sleep state to Temp Wake state then back to Sleep state                                                     10:  Access to module in sleep occured. PSC transitioned the module from Sleep state to Enable state                                                                   11: Reserved           " range="" rwaccess="R">
		</bitfield>
		<bitfield id="STERR" width="1" begin="7" end="7" resetval="0" description="State Transition Error                                                                                    0: Error did not occur                                                                                    1: Error occured                      " range="" rwaccess="R">
		</bitfield>
		<bitfield id="PERMDIS" width="1" begin="6" end="6" resetval="0" description="Permanently Disable                                                                                      0: Do not permanently disable module                                                           1: Permanently disable module                                               " range="" rwaccess="R">
		</bitfield>
		<bitfield id="STATE" width="6" begin="5" end="0" resetval="0" description="These bits indiacte the current module state                                                010000:  Power Domain Off                                                                          110000:  Iso-PwrCtrl                                                                                      111000:  En-IsoCtrl                                                                                        101000:  SyncReset                                                                                      100000:  SwRstDisable                                                                                 100100:  Disable                                                                                            101100:  Enable                                                                                             101110:  SlpTrans                                                                                         100110:  Sleep                                                                                              100111:  TwkTrans                                                                                       101111:  Twk                                                                                                 Others:   Reserved" range="" rwaccess="R">
		</bitfield>
	</register>
	<register id="MDSTAT27" acronym="MDSTAT27" offset="0x66C" width="32" description="Module Status 27 Register">
		<bitfield id="_RESV" width="10" begin="31" end="22" resetval="0" description="Reserved" range="" rwaccess="R">
		</bitfield>
		<bitfield id="MSTID" width="6" begin="21" end="16" resetval="0" description="Master ID. If ACSLP occurs, this field records the master ID of the master that caused the access. This bit is cleared when the corresponding ERRCR bit is written with a 1. " range="" rwaccess="R">
		</bitfield>
		<bitfield id="_RESV" width="5" begin="15" end="11" resetval="0" description="Reserved" range="" rwaccess="R">
		</bitfield>
		<bitfield id="WKRSLP" width="1" begin="10" end="10" resetval="0" description="Wakeup Request to Module in Sleep Detected.  Wakeup_pi is detected for this module when it is in sleep. If MDCTL.WKRSLPIE = 1, the setting of this field can cause ERRPR for this module to be set.                                          0: Condition did not occur                                                                              1: wakeup_pi = 1 when module is in sleep.                                     " range="" rwaccess="R">
		</bitfield>
		<bitfield id="ACSLP" width="2" begin="9" end="8" resetval="0" description="Non-emulation access to Module in Sleep occurred.                                    00:  Condition did not occur                                                                           01:  Access to module in sleep occurred. PSC transitioned the module from Sleep state to Temp Wake state then back to Sleep state                                                     10:  Access to module in sleep occured. PSC transitioned the module from Sleep state to Enable state                                                                   11: Reserved           " range="" rwaccess="R">
		</bitfield>
		<bitfield id="STERR" width="1" begin="7" end="7" resetval="0" description="State Transition Error                                                                                    0: Error did not occur                                                                                    1: Error occured                      " range="" rwaccess="R">
		</bitfield>
		<bitfield id="PERMDIS" width="1" begin="6" end="6" resetval="0" description="Permanently Disable                                                                                      0: Do not permanently disable module                                                           1: Permanently disable module                                               " range="" rwaccess="R">
		</bitfield>
		<bitfield id="STATE" width="6" begin="5" end="0" resetval="0" description="These bits indiacte the current module state                                                010000:  Power Domain Off                                                                          110000:  Iso-PwrCtrl                                                                                      111000:  En-IsoCtrl                                                                                        101000:  SyncReset                                                                                      100000:  SwRstDisable                                                                                 100100:  Disable                                                                                            101100:  Enable                                                                                             101110:  SlpTrans                                                                                         100110:  Sleep                                                                                              100111:  TwkTrans                                                                                       101111:  Twk                                                                                                 Others:   Reserved" range="" rwaccess="R">
		</bitfield>
	</register>
	<register id="MDSTAT28" acronym="MDSTAT28" offset="0x670" width="32" description="Module Status 28 Register">
		<bitfield id="_RESV" width="10" begin="31" end="22" resetval="0" description="Reserved" range="" rwaccess="R">
		</bitfield>
		<bitfield id="MSTID" width="6" begin="21" end="16" resetval="0" description="Master ID. If ACSLP occurs, this field records the master ID of the master that caused the access. This bit is cleared when the corresponding ERRCR bit is written with a 1. " range="" rwaccess="R">
		</bitfield>
		<bitfield id="_RESV" width="5" begin="15" end="11" resetval="0" description="Reserved" range="" rwaccess="R">
		</bitfield>
		<bitfield id="WKRSLP" width="1" begin="10" end="10" resetval="0" description="Wakeup Request to Module in Sleep Detected.  Wakeup_pi is detected for this module when it is in sleep. If MDCTL.WKRSLPIE = 1, the setting of this field can cause ERRPR for this module to be set.                                          0: Condition did not occur                                                                              1: wakeup_pi = 1 when module is in sleep.                                     " range="" rwaccess="R">
		</bitfield>
		<bitfield id="ACSLP" width="2" begin="9" end="8" resetval="0" description="Non-emulation access to Module in Sleep occurred.                                    00:  Condition did not occur                                                                           01:  Access to module in sleep occurred. PSC transitioned the module from Sleep state to Temp Wake state then back to Sleep state                                                     10:  Access to module in sleep occured. PSC transitioned the module from Sleep state to Enable state                                                                   11: Reserved           " range="" rwaccess="R">
		</bitfield>
		<bitfield id="STERR" width="1" begin="7" end="7" resetval="0" description="State Transition Error                                                                                    0: Error did not occur                                                                                    1: Error occured                      " range="" rwaccess="R">
		</bitfield>
		<bitfield id="PERMDIS" width="1" begin="6" end="6" resetval="0" description="Permanently Disable                                                                                      0: Do not permanently disable module                                                           1: Permanently disable module                                               " range="" rwaccess="R">
		</bitfield>
		<bitfield id="STATE" width="6" begin="5" end="0" resetval="0" description="These bits indiacte the current module state                                                010000:  Power Domain Off                                                                          110000:  Iso-PwrCtrl                                                                                      111000:  En-IsoCtrl                                                                                        101000:  SyncReset                                                                                      100000:  SwRstDisable                                                                                 100100:  Disable                                                                                            101100:  Enable                                                                                             101110:  SlpTrans                                                                                         100110:  Sleep                                                                                              100111:  TwkTrans                                                                                       101111:  Twk                                                                                                 Others:   Reserved" range="" rwaccess="R">
		</bitfield>
	</register>
	<register id="MDSTAT29" acronym="MDSTAT29" offset="0x674" width="32" description="Module Status 29 Register">
		<bitfield id="_RESV" width="10" begin="31" end="22" resetval="0" description="Reserved" range="" rwaccess="R">
		</bitfield>
		<bitfield id="MSTID" width="6" begin="21" end="16" resetval="0" description="Master ID. If ACSLP occurs, this field records the master ID of the master that caused the access. This bit is cleared when the corresponding ERRCR bit is written with a 1. " range="" rwaccess="R">
		</bitfield>
		<bitfield id="_RESV" width="5" begin="15" end="11" resetval="0" description="Reserved" range="" rwaccess="R">
		</bitfield>
		<bitfield id="WKRSLP" width="1" begin="10" end="10" resetval="0" description="Wakeup Request to Module in Sleep Detected.  Wakeup_pi is detected for this module when it is in sleep. If MDCTL.WKRSLPIE = 1, the setting of this field can cause ERRPR for this module to be set.                                          0: Condition did not occur                                                                              1: wakeup_pi = 1 when module is in sleep.                                     " range="" rwaccess="R">
		</bitfield>
		<bitfield id="ACSLP" width="2" begin="9" end="8" resetval="0" description="Non-emulation access to Module in Sleep occurred.                                    00:  Condition did not occur                                                                           01:  Access to module in sleep occurred. PSC transitioned the module from Sleep state to Temp Wake state then back to Sleep state                                                     10:  Access to module in sleep occured. PSC transitioned the module from Sleep state to Enable state                                                                   11: Reserved           " range="" rwaccess="R">
		</bitfield>
		<bitfield id="STERR" width="1" begin="7" end="7" resetval="0" description="State Transition Error                                                                                    0: Error did not occur                                                                                    1: Error occured                      " range="" rwaccess="R">
		</bitfield>
		<bitfield id="PERMDIS" width="1" begin="6" end="6" resetval="0" description="Permanently Disable                                                                                      0: Do not permanently disable module                                                           1: Permanently disable module                                               " range="" rwaccess="R">
		</bitfield>
		<bitfield id="STATE" width="6" begin="5" end="0" resetval="0" description="These bits indiacte the current module state                                                010000:  Power Domain Off                                                                          110000:  Iso-PwrCtrl                                                                                      111000:  En-IsoCtrl                                                                                        101000:  SyncReset                                                                                      100000:  SwRstDisable                                                                                 100100:  Disable                                                                                            101100:  Enable                                                                                             101110:  SlpTrans                                                                                         100110:  Sleep                                                                                              100111:  TwkTrans                                                                                       101111:  Twk                                                                                                 Others:   Reserved" range="" rwaccess="R">
		</bitfield>
	</register>
	<register id="MDSTAT30" acronym="MDSTAT30" offset="0x678" width="32" description="Module Status 30 Register">
		<bitfield id="_RESV" width="10" begin="31" end="22" resetval="0" description="Reserved" range="" rwaccess="R">
		</bitfield>
		<bitfield id="MSTID" width="6" begin="21" end="16" resetval="0" description="Master ID. If ACSLP occurs, this field records the master ID of the master that caused the access. This bit is cleared when the corresponding ERRCR bit is written with a 1. " range="" rwaccess="R">
		</bitfield>
		<bitfield id="_RESV" width="5" begin="15" end="11" resetval="0" description="Reserved" range="" rwaccess="R">
		</bitfield>
		<bitfield id="WKRSLP" width="1" begin="10" end="10" resetval="0" description="Wakeup Request to Module in Sleep Detected.  Wakeup_pi is detected for this module when it is in sleep. If MDCTL.WKRSLPIE = 1, the setting of this field can cause ERRPR for this module to be set.                                          0: Condition did not occur                                                                              1: wakeup_pi = 1 when module is in sleep.                                     " range="" rwaccess="R">
		</bitfield>
		<bitfield id="ACSLP" width="2" begin="9" end="8" resetval="0" description="Non-emulation access to Module in Sleep occurred.                                    00:  Condition did not occur                                                                           01:  Access to module in sleep occurred. PSC transitioned the module from Sleep state to Temp Wake state then back to Sleep state                                                     10:  Access to module in sleep occured. PSC transitioned the module from Sleep state to Enable state                                                                   11: Reserved           " range="" rwaccess="R">
		</bitfield>
		<bitfield id="STERR" width="1" begin="7" end="7" resetval="0" description="State Transition Error                                                                                    0: Error did not occur                                                                                    1: Error occured                      " range="" rwaccess="R">
		</bitfield>
		<bitfield id="PERMDIS" width="1" begin="6" end="6" resetval="0" description="Permanently Disable                                                                                      0: Do not permanently disable module                                                           1: Permanently disable module                                               " range="" rwaccess="R">
		</bitfield>
		<bitfield id="STATE" width="6" begin="5" end="0" resetval="0" description="These bits indiacte the current module state                                                010000:  Power Domain Off                                                                          110000:  Iso-PwrCtrl                                                                                      111000:  En-IsoCtrl                                                                                        101000:  SyncReset                                                                                      100000:  SwRstDisable                                                                                 100100:  Disable                                                                                            101100:  Enable                                                                                             101110:  SlpTrans                                                                                         100110:  Sleep                                                                                              100111:  TwkTrans                                                                                       101111:  Twk                                                                                                 Others:   Reserved" range="" rwaccess="R">
		</bitfield>
	</register>
	<register id="MDSTAT31" acronym="MDSTAT31" offset="0x67C" width="32" description="Module Status 31 Register">
		<bitfield id="_RESV" width="10" begin="31" end="22" resetval="0" description="Reserved" range="" rwaccess="R">
		</bitfield>
		<bitfield id="MSTID" width="6" begin="21" end="16" resetval="0" description="Master ID. If ACSLP occurs, this field records the master ID of the master that caused the access. This bit is cleared when the corresponding ERRCR bit is written with a 1. " range="" rwaccess="R">
		</bitfield>
		<bitfield id="_RESV" width="5" begin="15" end="11" resetval="0" description="Reserved" range="" rwaccess="R">
		</bitfield>
		<bitfield id="WKRSLP" width="1" begin="10" end="10" resetval="0" description="Wakeup Request to Module in Sleep Detected.  Wakeup_pi is detected for this module when it is in sleep. If MDCTL.WKRSLPIE = 1, the setting of this field can cause ERRPR for this module to be set.                                          0: Condition did not occur                                                                              1: wakeup_pi = 1 when module is in sleep.                                     " range="" rwaccess="R">
		</bitfield>
		<bitfield id="ACSLP" width="2" begin="9" end="8" resetval="0" description="Non-emulation access to Module in Sleep occurred.                                    00:  Condition did not occur                                                                           01:  Access to module in sleep occurred. PSC transitioned the module from Sleep state to Temp Wake state then back to Sleep state                                                     10:  Access to module in sleep occured. PSC transitioned the module from Sleep state to Enable state                                                                   11: Reserved           " range="" rwaccess="R">
		</bitfield>
		<bitfield id="STERR" width="1" begin="7" end="7" resetval="0" description="State Transition Error                                                                                    0: Error did not occur                                                                                    1: Error occured                      " range="" rwaccess="R">
		</bitfield>
		<bitfield id="PERMDIS" width="1" begin="6" end="6" resetval="0" description="Permanently Disable                                                                                      0: Do not permanently disable module                                                           1: Permanently disable module                                               " range="" rwaccess="R">
		</bitfield>
		<bitfield id="STATE" width="6" begin="5" end="0" resetval="0" description="These bits indiacte the current module state                                                010000:  Power Domain Off                                                                          110000:  Iso-PwrCtrl                                                                                      111000:  En-IsoCtrl                                                                                        101000:  SyncReset                                                                                      100000:  SwRstDisable                                                                                 100100:  Disable                                                                                            101100:  Enable                                                                                             101110:  SlpTrans                                                                                         100110:  Sleep                                                                                              100111:  TwkTrans                                                                                       101111:  Twk                                                                                                 Others:   Reserved" range="" rwaccess="R">
		</bitfield>
	</register>
	<register id="MDCTL0" acronym="MDCTL0" offset="0x800" width="32" description="Module Control 0 Register">
		<bitfield id="_RESV" width="20" begin="31" end="12" resetval="0" description="Reserved" range="" rwaccess="R">
		</bitfield>
		<bitfield id="WKRSLPIE" width="1" begin="11" end="11" resetval="0" description="Wakeup Request to module in sleep Error Enable.                                        0: Wakeup request to module in sleep is not considered an error condition                                                                                                        1: Wakeup request to module in sleep is considered an error" range="" rwaccess="RW">
		</bitfield>
		<bitfield id="WKRSLP" width="1" begin="10" end="10" resetval="0" description="Wakeup Request to module in Sleep will cause this action.                         0: PSC transitions module from Sleep state to TWK state, once access completes (vbus_req = 0) put module back in Sleep state                           1: PSC transitions module to ENABLE state" range="" rwaccess="RW">
		</bitfield>
		<bitfield id="ACSLPIE" width="1" begin="9" end="9" resetval="0" description="Non-emulation Access to module in sleep Error enable                                0: Non-emulation access to module in sleep is not considered an error condition                                                                                                        1: Non-emulation access to module in sleep is considered an error" range="" rwaccess="RW">
		</bitfield>
		<bitfield id="ACSLP" width="1" begin="8" end="8" resetval="0" description="Non-emulation Access to module in Sleep will cause this action                              0: PSC transitions module from Sleep state to TWk state, once access completes put module back in Sleep state                                                    1: PSC transitions module to ENABLE state                                                                                            " range="" rwaccess="RW">
		</bitfield>
		<bitfield id="_RESV" width="5" begin="7" end="3" resetval="0" description="Reserved" range="" rwaccess="R">
		</bitfield>
		<bitfield id="NEXT" width="3" begin="2" end="0" resetval="0" description="Module Next State                                                                                          000: SwRstDisable                                                                                        001: Disable                                                                                                   010: SyncReset                                                                                             011: Enable                                                                                                    100: Reserved/Invalid                                                                                    101: Sleep                                                                                                     110: Reserved/Invalid                                                                                    111: Reserved/Invalid" range="" rwaccess="RW">
		</bitfield>
	</register>
	<register id="MDCTL1" acronym="MDCTL1" offset="0x804" width="32" description="Module Control 1 Register">
		<bitfield id="_RESV" width="20" begin="31" end="12" resetval="0" description="Reserved" range="" rwaccess="R">
		</bitfield>
		<bitfield id="WKRSLPIE" width="1" begin="11" end="11" resetval="0" description="Wakeup Request to module in sleep Error Enable.                                        0: Wakeup request to module in sleep is not considered an error condition                                                                                                        1: Wakeup request to module in sleep is considered an error" range="" rwaccess="RW">
		</bitfield>
		<bitfield id="WKRSLP" width="1" begin="10" end="10" resetval="0" description="Wakeup Request to module in Sleep will cause this action.                         0: PSC transitions module from Sleep state to TWK state, once access completes (vbus_req = 0) put module back in Sleep state                           1: PSC transitions module to ENABLE state" range="" rwaccess="RW">
		</bitfield>
		<bitfield id="ACSLPIE" width="1" begin="9" end="9" resetval="0" description="Non-emulation Access to module in sleep Error enable                                0: Non-emulation access to module in sleep is not considered an error condition                                                                                                        1: Non-emulation access to module in sleep is considered an error" range="" rwaccess="RW">
		</bitfield>
		<bitfield id="ACSLP" width="1" begin="8" end="8" resetval="0" description="Non-emulation Access to module in Sleep will cause this action                              0: PSC transitions module from Sleep state to TWk state, once access completes put module back in Sleep state                                                    1: PSC transitions module to ENABLE state                                                                                            " range="" rwaccess="RW">
		</bitfield>
		<bitfield id="_RESV" width="5" begin="7" end="3" resetval="0" description="Reserved" range="" rwaccess="R">
		</bitfield>
		<bitfield id="NEXT" width="3" begin="2" end="0" resetval="0" description="Module Next State                                                                                          000: SwRstDisable                                                                                        001: Disable                                                                                                   010: SyncReset                                                                                             011: Enable                                                                                                    100: Reserved/Invalid                                                                                    101: Sleep                                                                                                     110: Reserved/Invalid                                                                                    111: Reserved/Invalid" range="" rwaccess="RW">
		</bitfield>
	</register>
	<register id="MDCTL2" acronym="MDCTL2" offset="0x808" width="32" description="Module Control 2 Register">
		<bitfield id="_RESV" width="20" begin="31" end="12" resetval="0" description="Reserved" range="" rwaccess="R">
		</bitfield>
		<bitfield id="WKRSLPIE" width="1" begin="11" end="11" resetval="0" description="Wakeup Request to module in sleep Error Enable.                                        0: Wakeup request to module in sleep is not considered an error condition                                                                                                        1: Wakeup request to module in sleep is considered an error" range="" rwaccess="RW">
		</bitfield>
		<bitfield id="WKRSLP" width="1" begin="10" end="10" resetval="0" description="Wakeup Request to module in Sleep will cause this action.                         0: PSC transitions module from Sleep state to TWK state, once access completes (vbus_req = 0) put module back in Sleep state                           1: PSC transitions module to ENABLE state" range="" rwaccess="RW">
		</bitfield>
		<bitfield id="ACSLPIE" width="1" begin="9" end="9" resetval="0" description="Non-emulation Access to module in sleep Error enable                                0: Non-emulation access to module in sleep is not considered an error condition                                                                                                        1: Non-emulation access to module in sleep is considered an error" range="" rwaccess="RW">
		</bitfield>
		<bitfield id="ACSLP" width="1" begin="8" end="8" resetval="0" description="Non-emulation Access to module in Sleep will cause this action                              0: PSC transitions module from Sleep state to TWk state, once access completes put module back in Sleep state                                                    1: PSC transitions module to ENABLE state                                                                                            " range="" rwaccess="RW">
		</bitfield>
		<bitfield id="_RESV" width="5" begin="7" end="3" resetval="0" description="Reserved" range="" rwaccess="R">
		</bitfield>
		<bitfield id="NEXT" width="3" begin="2" end="0" resetval="0" description="Module Next State                                                                                          000: SwRstDisable                                                                                        001: Disable                                                                                                   010: SyncReset                                                                                             011: Enable                                                                                                    100: Reserved/Invalid                                                                                    101: Sleep                                                                                                     110: Reserved/Invalid                                                                                    111: Reserved/Invalid" range="" rwaccess="RW">
		</bitfield>
	</register>
	<register id="MDCTL3" acronym="MDCTL3" offset="0x80C" width="32" description="Module Control 3 Register">
		<bitfield id="_RESV" width="20" begin="31" end="12" resetval="0" description="Reserved" range="" rwaccess="R">
		</bitfield>
		<bitfield id="WKRSLPIE" width="1" begin="11" end="11" resetval="0" description="Wakeup Request to module in sleep Error Enable.                                        0: Wakeup request to module in sleep is not considered an error condition                                                                                                        1: Wakeup request to module in sleep is considered an error" range="" rwaccess="RW">
		</bitfield>
		<bitfield id="WKRSLP" width="1" begin="10" end="10" resetval="0" description="Wakeup Request to module in Sleep will cause this action.                         0: PSC transitions module from Sleep state to TWK state, once access completes (vbus_req = 0) put module back in Sleep state                           1: PSC transitions module to ENABLE state" range="" rwaccess="RW">
		</bitfield>
		<bitfield id="ACSLPIE" width="1" begin="9" end="9" resetval="0" description="Non-emulation Access to module in sleep Error enable                                0: Non-emulation access to module in sleep is not considered an error condition                                                                                                        1: Non-emulation access to module in sleep is considered an error" range="" rwaccess="RW">
		</bitfield>
		<bitfield id="ACSLP" width="1" begin="8" end="8" resetval="0" description="Non-emulation Access to module in Sleep will cause this action                              0: PSC transitions module from Sleep state to TWk state, once access completes put module back in Sleep state                                                    1: PSC transitions module to ENABLE state                                                                                            " range="" rwaccess="RW">
		</bitfield>
		<bitfield id="_RESV" width="5" begin="7" end="3" resetval="0" description="Reserved" range="" rwaccess="R">
		</bitfield>
		<bitfield id="NEXT" width="3" begin="2" end="0" resetval="0" description="Module Next State                                                                                          000: SwRstDisable                                                                                        001: Disable                                                                                                   010: SyncReset                                                                                             011: Enable                                                                                                    100: Reserved/Invalid                                                                                    101: Sleep                                                                                                     110: Reserved/Invalid                                                                                    111: Reserved/Invalid" range="" rwaccess="RW">
		</bitfield>
	</register>
	<register id="MDCTL4" acronym="MDCTL4" offset="0x810" width="32" description="Module Control 4 Register">
		<bitfield id="_RESV" width="20" begin="31" end="12" resetval="0" description="Reserved" range="" rwaccess="R">
		</bitfield>
		<bitfield id="WKRSLPIE" width="1" begin="11" end="11" resetval="0" description="Wakeup Request to module in sleep Error Enable.                                        0: Wakeup request to module in sleep is not considered an error condition                                                                                                        1: Wakeup request to module in sleep is considered an error" range="" rwaccess="RW">
		</bitfield>
		<bitfield id="WKRSLP" width="1" begin="10" end="10" resetval="0" description="Wakeup Request to module in Sleep will cause this action.                         0: PSC transitions module from Sleep state to TWK state, once access completes (vbus_req = 0) put module back in Sleep state                           1: PSC transitions module to ENABLE state" range="" rwaccess="RW">
		</bitfield>
		<bitfield id="ACSLPIE" width="1" begin="9" end="9" resetval="0" description="Non-emulation Access to module in sleep Error enable                                0: Non-emulation access to module in sleep is not considered an error condition                                                                                                        1: Non-emulation access to module in sleep is considered an error" range="" rwaccess="RW">
		</bitfield>
		<bitfield id="ACSLP" width="1" begin="8" end="8" resetval="0" description="Non-emulation Access to module in Sleep will cause this action                              0: PSC transitions module from Sleep state to TWk state, once access completes put module back in Sleep state                                                    1: PSC transitions module to ENABLE state                                                                                            " range="" rwaccess="RW">
		</bitfield>
		<bitfield id="_RESV" width="5" begin="7" end="3" resetval="0" description="Reserved" range="" rwaccess="R">
		</bitfield>
		<bitfield id="NEXT" width="3" begin="2" end="0" resetval="0" description="Module Next State                                                                                          000: SwRstDisable                                                                                        001: Disable                                                                                                   010: SyncReset                                                                                             011: Enable                                                                                                    100: Reserved/Invalid                                                                                    101: Sleep                                                                                                     110: Reserved/Invalid                                                                                    111: Reserved/Invalid" range="" rwaccess="RW">
		</bitfield>
	</register>
	<register id="MDCTL5" acronym="MDCTL5" offset="0x814" width="32" description="Module Control 5 Register">
		<bitfield id="_RESV" width="20" begin="31" end="12" resetval="0" description="Reserved" range="" rwaccess="R">
		</bitfield>
		<bitfield id="WKRSLPIE" width="1" begin="11" end="11" resetval="0" description="Wakeup Request to module in sleep Error Enable.                                        0: Wakeup request to module in sleep is not considered an error condition                                                                                                        1: Wakeup request to module in sleep is considered an error" range="" rwaccess="RW">
		</bitfield>
		<bitfield id="WKRSLP" width="1" begin="10" end="10" resetval="0" description="Wakeup Request to module in Sleep will cause this action.                         0: PSC transitions module from Sleep state to TWK state, once access completes (vbus_req = 0) put module back in Sleep state                           1: PSC transitions module to ENABLE state" range="" rwaccess="RW">
		</bitfield>
		<bitfield id="ACSLPIE" width="1" begin="9" end="9" resetval="0" description="Non-emulation Access to module in sleep Error enable                                0: Non-emulation access to module in sleep is not considered an error condition                                                                                                        1: Non-emulation access to module in sleep is considered an error" range="" rwaccess="RW">
		</bitfield>
		<bitfield id="ACSLP" width="1" begin="8" end="8" resetval="0" description="Non-emulation Access to module in Sleep will cause this action                              0: PSC transitions module from Sleep state to TWk state, once access completes put module back in Sleep state                                                    1: PSC transitions module to ENABLE state                                                                                            " range="" rwaccess="RW">
		</bitfield>
		<bitfield id="_RESV" width="5" begin="7" end="3" resetval="0" description="Reserved" range="" rwaccess="R">
		</bitfield>
		<bitfield id="NEXT" width="3" begin="2" end="0" resetval="0" description="Module Next State                                                                                          000: SwRstDisable                                                                                        001: Disable                                                                                                   010: SyncReset                                                                                             011: Enable                                                                                                    100: Reserved/Invalid                                                                                    101: Sleep                                                                                                     110: Reserved/Invalid                                                                                    111: Reserved/Invalid" range="" rwaccess="RW">
		</bitfield>
	</register>
	<register id="MDCTL6" acronym="MDCTL6" offset="0x818" width="32" description="Module Control 6 Register">
		<bitfield id="_RESV" width="20" begin="31" end="12" resetval="0" description="Reserved" range="" rwaccess="R">
		</bitfield>
		<bitfield id="WKRSLPIE" width="1" begin="11" end="11" resetval="0" description="Wakeup Request to module in sleep Error Enable.                                        0: Wakeup request to module in sleep is not considered an error condition                                                                                                        1: Wakeup request to module in sleep is considered an error" range="" rwaccess="RW">
		</bitfield>
		<bitfield id="WKRSLP" width="1" begin="10" end="10" resetval="0" description="Wakeup Request to module in Sleep will cause this action.                         0: PSC transitions module from Sleep state to TWK state, once access completes (vbus_req = 0) put module back in Sleep state                           1: PSC transitions module to ENABLE state" range="" rwaccess="RW">
		</bitfield>
		<bitfield id="ACSLPIE" width="1" begin="9" end="9" resetval="0" description="Non-emulation Access to module in sleep Error enable                                0: Non-emulation access to module in sleep is not considered an error condition                                                                                                        1: Non-emulation access to module in sleep is considered an error" range="" rwaccess="RW">
		</bitfield>
		<bitfield id="ACSLP" width="1" begin="8" end="8" resetval="0" description="Non-emulation Access to module in Sleep will cause this action                              0: PSC transitions module from Sleep state to TWk state, once access completes put module back in Sleep state                                                    1: PSC transitions module to ENABLE state                                                                                            " range="" rwaccess="RW">
		</bitfield>
		<bitfield id="_RESV" width="5" begin="7" end="3" resetval="0" description="Reserved" range="" rwaccess="R">
		</bitfield>
		<bitfield id="NEXT" width="3" begin="2" end="0" resetval="0" description="Module Next State                                                                                          000: SwRstDisable                                                                                        001: Disable                                                                                                   010: SyncReset                                                                                             011: Enable                                                                                                    100: Reserved/Invalid                                                                                    101: Sleep                                                                                                     110: Reserved/Invalid                                                                                    111: Reserved/Invalid" range="" rwaccess="RW">
		</bitfield>
	</register>
	<register id="MDCTL7" acronym="MDCTL7" offset="0x81C" width="32" description="Module Control 7 Register">
		<bitfield id="_RESV" width="20" begin="31" end="12" resetval="0" description="Reserved" range="" rwaccess="R">
		</bitfield>
		<bitfield id="WKRSLPIE" width="1" begin="11" end="11" resetval="0" description="Wakeup Request to module in sleep Error Enable.                                        0: Wakeup request to module in sleep is not considered an error condition                                                                                                        1: Wakeup request to module in sleep is considered an error" range="" rwaccess="RW">
		</bitfield>
		<bitfield id="WKRSLP" width="1" begin="10" end="10" resetval="0" description="Wakeup Request to module in Sleep will cause this action.                         0: PSC transitions module from Sleep state to TWK state, once access completes (vbus_req = 0) put module back in Sleep state                           1: PSC transitions module to ENABLE state" range="" rwaccess="RW">
		</bitfield>
		<bitfield id="ACSLPIE" width="1" begin="9" end="9" resetval="0" description="Non-emulation Access to module in sleep Error enable                                0: Non-emulation access to module in sleep is not considered an error condition                                                                                                        1: Non-emulation access to module in sleep is considered an error" range="" rwaccess="RW">
		</bitfield>
		<bitfield id="ACSLP" width="1" begin="8" end="8" resetval="0" description="Non-emulation Access to module in Sleep will cause this action                              0: PSC transitions module from Sleep state to TWk state, once access completes put module back in Sleep state                                                    1: PSC transitions module to ENABLE state                                                                                            " range="" rwaccess="RW">
		</bitfield>
		<bitfield id="_RESV" width="5" begin="7" end="3" resetval="0" description="Reserved" range="" rwaccess="R">
		</bitfield>
		<bitfield id="NEXT" width="3" begin="2" end="0" resetval="0" description="Module Next State                                                                                          000: SwRstDisable                                                                                        001: Disable                                                                                                   010: SyncReset                                                                                             011: Enable                                                                                                    100: Reserved/Invalid                                                                                    101: Sleep                                                                                                     110: Reserved/Invalid                                                                                    111: Reserved/Invalid" range="" rwaccess="RW">
		</bitfield>
	</register>
	<register id="MDCTL8" acronym="MDCTL8" offset="0x820" width="32" description="Module Control 8 Register">
		<bitfield id="_RESV" width="20" begin="31" end="12" resetval="0" description="Reserved" range="" rwaccess="R">
		</bitfield>
		<bitfield id="WKRSLPIE" width="1" begin="11" end="11" resetval="0" description="Wakeup Request to module in sleep Error Enable.                                        0: Wakeup request to module in sleep is not considered an error condition                                                                                                        1: Wakeup request to module in sleep is considered an error" range="" rwaccess="RW">
		</bitfield>
		<bitfield id="WKRSLP" width="1" begin="10" end="10" resetval="0" description="Wakeup Request to module in Sleep will cause this action.                         0: PSC transitions module from Sleep state to TWK state, once access completes (vbus_req = 0) put module back in Sleep state                           1: PSC transitions module to ENABLE state" range="" rwaccess="RW">
		</bitfield>
		<bitfield id="ACSLPIE" width="1" begin="9" end="9" resetval="0" description="Non-emulation Access to module in sleep Error enable                                0: Non-emulation access to module in sleep is not considered an error condition                                                                                                        1: Non-emulation access to module in sleep is considered an error" range="" rwaccess="RW">
		</bitfield>
		<bitfield id="ACSLP" width="1" begin="8" end="8" resetval="0" description="Non-emulation Access to module in Sleep will cause this action                              0: PSC transitions module from Sleep state to TWk state, once access completes put module back in Sleep state                                                    1: PSC transitions module to ENABLE state                                                                                            " range="" rwaccess="RW">
		</bitfield>
		<bitfield id="_RESV" width="5" begin="7" end="3" resetval="0" description="Reserved" range="" rwaccess="R">
		</bitfield>
		<bitfield id="NEXT" width="3" begin="2" end="0" resetval="0" description="Module Next State                                                                                          000: SwRstDisable                                                                                        001: Disable                                                                                                   010: SyncReset                                                                                             011: Enable                                                                                                    100: Reserved/Invalid                                                                                    101: Sleep                                                                                                     110: Reserved/Invalid                                                                                    111: Reserved/Invalid" range="" rwaccess="RW">
		</bitfield>
	</register>
	<register id="MDCTL9" acronym="MDCTL9" offset="0x824" width="32" description="Module Control 9 Register">
		<bitfield id="_RESV" width="20" begin="31" end="12" resetval="0" description="Reserved" range="" rwaccess="R">
		</bitfield>
		<bitfield id="WKRSLPIE" width="1" begin="11" end="11" resetval="0" description="Wakeup Request to module in sleep Error Enable.                                        0: Wakeup request to module in sleep is not considered an error condition                                                                                                        1: Wakeup request to module in sleep is considered an error" range="" rwaccess="RW">
		</bitfield>
		<bitfield id="WKRSLP" width="1" begin="10" end="10" resetval="0" description="Wakeup Request to module in Sleep will cause this action.                         0: PSC transitions module from Sleep state to TWK state, once access completes (vbus_req = 0) put module back in Sleep state                           1: PSC transitions module to ENABLE state" range="" rwaccess="RW">
		</bitfield>
		<bitfield id="ACSLPIE" width="1" begin="9" end="9" resetval="0" description="Non-emulation Access to module in sleep Error enable                                0: Non-emulation access to module in sleep is not considered an error condition                                                                                                        1: Non-emulation access to module in sleep is considered an error" range="" rwaccess="RW">
		</bitfield>
		<bitfield id="ACSLP" width="1" begin="8" end="8" resetval="0" description="Non-emulation Access to module in Sleep will cause this action                              0: PSC transitions module from Sleep state to TWk state, once access completes put module back in Sleep state                                                    1: PSC transitions module to ENABLE state                                                                                            " range="" rwaccess="RW">
		</bitfield>
		<bitfield id="_RESV" width="5" begin="7" end="3" resetval="0" description="Reserved" range="" rwaccess="R">
		</bitfield>
		<bitfield id="NEXT" width="3" begin="2" end="0" resetval="0" description="Module Next State                                                                                          000: SwRstDisable                                                                                        001: Disable                                                                                                   010: SyncReset                                                                                             011: Enable                                                                                                    100: Reserved/Invalid                                                                                    101: Sleep                                                                                                     110: Reserved/Invalid                                                                                    111: Reserved/Invalid" range="" rwaccess="RW">
		</bitfield>
	</register>
	<register id="MDCTL10" acronym="MDCTL10" offset="0x828" width="32" description="Module Control 10 Register">
		<bitfield id="_RESV" width="20" begin="31" end="12" resetval="0" description="Reserved" range="" rwaccess="R">
		</bitfield>
		<bitfield id="WKRSLPIE" width="1" begin="11" end="11" resetval="0" description="Wakeup Request to module in sleep Error Enable.                                        0: Wakeup request to module in sleep is not considered an error condition                                                                                                        1: Wakeup request to module in sleep is considered an error" range="" rwaccess="RW">
		</bitfield>
		<bitfield id="WKRSLP" width="1" begin="10" end="10" resetval="0" description="Wakeup Request to module in Sleep will cause this action.                         0: PSC transitions module from Sleep state to TWK state, once access completes (vbus_req = 0) put module back in Sleep state                           1: PSC transitions module to ENABLE state" range="" rwaccess="RW">
		</bitfield>
		<bitfield id="ACSLPIE" width="1" begin="9" end="9" resetval="0" description="Non-emulation Access to module in sleep Error enable                                0: Non-emulation access to module in sleep is not considered an error condition                                                                                                        1: Non-emulation access to module in sleep is considered an error" range="" rwaccess="RW">
		</bitfield>
		<bitfield id="ACSLP" width="1" begin="8" end="8" resetval="0" description="Non-emulation Access to module in Sleep will cause this action                              0: PSC transitions module from Sleep state to TWk state, once access completes put module back in Sleep state                                                    1: PSC transitions module to ENABLE state                                                                                            " range="" rwaccess="RW">
		</bitfield>
		<bitfield id="_RESV" width="5" begin="7" end="3" resetval="0" description="Reserved" range="" rwaccess="R">
		</bitfield>
		<bitfield id="NEXT" width="3" begin="2" end="0" resetval="0" description="Module Next State                                                                                          000: SwRstDisable                                                                                        001: Disable                                                                                                   010: SyncReset                                                                                             011: Enable                                                                                                    100: Reserved/Invalid                                                                                    101: Sleep                                                                                                     110: Reserved/Invalid                                                                                    111: Reserved/Invalid" range="" rwaccess="RW">
		</bitfield>
	</register>
	<register id="MDCTL11" acronym="MDCTL11" offset="0x82C" width="32" description="Module Control 11 Register">
		<bitfield id="_RESV" width="20" begin="31" end="12" resetval="0" description="Reserved" range="" rwaccess="R">
		</bitfield>
		<bitfield id="WKRSLPIE" width="1" begin="11" end="11" resetval="0" description="Wakeup Request to module in sleep Error Enable.                                        0: Wakeup request to module in sleep is not considered an error condition                                                                                                        1: Wakeup request to module in sleep is considered an error" range="" rwaccess="RW">
		</bitfield>
		<bitfield id="WKRSLP" width="1" begin="10" end="10" resetval="0" description="Wakeup Request to module in Sleep will cause this action.                         0: PSC transitions module from Sleep state to TWK state, once access completes (vbus_req = 0) put module back in Sleep state                           1: PSC transitions module to ENABLE state" range="" rwaccess="RW">
		</bitfield>
		<bitfield id="ACSLPIE" width="1" begin="9" end="9" resetval="0" description="Non-emulation Access to module in sleep Error enable                                0: Non-emulation access to module in sleep is not considered an error condition                                                                                                        1: Non-emulation access to module in sleep is considered an error" range="" rwaccess="RW">
		</bitfield>
		<bitfield id="ACSLP" width="1" begin="8" end="8" resetval="0" description="Non-emulation Access to module in Sleep will cause this action                              0: PSC transitions module from Sleep state to TWk state, once access completes put module back in Sleep state                                                    1: PSC transitions module to ENABLE state                                                                                            " range="" rwaccess="RW">
		</bitfield>
		<bitfield id="_RESV" width="5" begin="7" end="3" resetval="0" description="Reserved" range="" rwaccess="R">
		</bitfield>
		<bitfield id="NEXT" width="3" begin="2" end="0" resetval="0" description="Module Next State                                                                                          000: SwRstDisable                                                                                        001: Disable                                                                                                   010: SyncReset                                                                                             011: Enable                                                                                                    100: Reserved/Invalid                                                                                    101: Sleep                                                                                                     110: Reserved/Invalid                                                                                    111: Reserved/Invalid" range="" rwaccess="RW">
		</bitfield>
	</register>
	<register id="MDCTL12" acronym="MDCTL12" offset="0x830" width="32" description="Module Control 12 Register">
		<bitfield id="_RESV" width="20" begin="31" end="12" resetval="0" description="Reserved" range="" rwaccess="R">
		</bitfield>
		<bitfield id="WKRSLPIE" width="1" begin="11" end="11" resetval="0" description="Wakeup Request to module in sleep Error Enable.                                        0: Wakeup request to module in sleep is not considered an error condition                                                                                                        1: Wakeup request to module in sleep is considered an error" range="" rwaccess="RW">
		</bitfield>
		<bitfield id="WKRSLP" width="1" begin="10" end="10" resetval="0" description="Wakeup Request to module in Sleep will cause this action.                         0: PSC transitions module from Sleep state to TWK state, once access completes (vbus_req = 0) put module back in Sleep state                           1: PSC transitions module to ENABLE state" range="" rwaccess="RW">
		</bitfield>
		<bitfield id="ACSLPIE" width="1" begin="9" end="9" resetval="0" description="Non-emulation Access to module in sleep Error enable                                0: Non-emulation access to module in sleep is not considered an error condition                                                                                                        1: Non-emulation access to module in sleep is considered an error" range="" rwaccess="RW">
		</bitfield>
		<bitfield id="ACSLP" width="1" begin="8" end="8" resetval="0" description="Non-emulation Access to module in Sleep will cause this action                              0: PSC transitions module from Sleep state to TWk state, once access completes put module back in Sleep state                                                    1: PSC transitions module to ENABLE state                                                                                            " range="" rwaccess="RW">
		</bitfield>
		<bitfield id="_RESV" width="5" begin="7" end="3" resetval="0" description="Reserved" range="" rwaccess="R">
		</bitfield>
		<bitfield id="NEXT" width="3" begin="2" end="0" resetval="0" description="Module Next State                                                                                          000: SwRstDisable                                                                                        001: Disable                                                                                                   010: SyncReset                                                                                             011: Enable                                                                                                    100: Reserved/Invalid                                                                                    101: Sleep                                                                                                     110: Reserved/Invalid                                                                                    111: Reserved/Invalid" range="" rwaccess="RW">
		</bitfield>
	</register>
	<register id="MDCTL13" acronym="MDCTL13" offset="0x834" width="32" description="Module Control 13 Register">
		<bitfield id="_RESV" width="20" begin="31" end="12" resetval="0" description="Reserved" range="" rwaccess="R">
		</bitfield>
		<bitfield id="WKRSLPIE" width="1" begin="11" end="11" resetval="0" description="Wakeup Request to module in sleep Error Enable.                                        0: Wakeup request to module in sleep is not considered an error condition                                                                                                        1: Wakeup request to module in sleep is considered an error" range="" rwaccess="RW">
		</bitfield>
		<bitfield id="WKRSLP" width="1" begin="10" end="10" resetval="0" description="Wakeup Request to module in Sleep will cause this action.                         0: PSC transitions module from Sleep state to TWK state, once access completes (vbus_req = 0) put module back in Sleep state                           1: PSC transitions module to ENABLE state" range="" rwaccess="RW">
		</bitfield>
		<bitfield id="ACSLPIE" width="1" begin="9" end="9" resetval="0" description="Non-emulation Access to module in sleep Error enable                                0: Non-emulation access to module in sleep is not considered an error condition                                                                                                        1: Non-emulation access to module in sleep is considered an error" range="" rwaccess="RW">
		</bitfield>
		<bitfield id="ACSLP" width="1" begin="8" end="8" resetval="0" description="Non-emulation Access to module in Sleep will cause this action                              0: PSC transitions module from Sleep state to TWk state, once access completes put module back in Sleep state                                                    1: PSC transitions module to ENABLE state                                                                                            " range="" rwaccess="RW">
		</bitfield>
		<bitfield id="_RESV" width="5" begin="7" end="3" resetval="0" description="Reserved" range="" rwaccess="R">
		</bitfield>
		<bitfield id="NEXT" width="3" begin="2" end="0" resetval="0" description="Module Next State                                                                                          000: SwRstDisable                                                                                        001: Disable                                                                                                   010: SyncReset                                                                                             011: Enable                                                                                                    100: Reserved/Invalid                                                                                    101: Sleep                                                                                                     110: Reserved/Invalid                                                                                    111: Reserved/Invalid" range="" rwaccess="RW">
		</bitfield>
	</register>
	<register id="MDCTL14" acronym="MDCTL14" offset="0x838" width="32" description="Module Control 14 Register">
		<bitfield id="_RESV" width="20" begin="31" end="12" resetval="0" description="Reserved" range="" rwaccess="R">
		</bitfield>
		<bitfield id="WKRSLPIE" width="1" begin="11" end="11" resetval="0" description="Wakeup Request to module in sleep Error Enable.                                        0: Wakeup request to module in sleep is not considered an error condition                                                                                                        1: Wakeup request to module in sleep is considered an error" range="" rwaccess="RW">
		</bitfield>
		<bitfield id="WKRSLP" width="1" begin="10" end="10" resetval="0" description="Wakeup Request to module in Sleep will cause this action.                         0: PSC transitions module from Sleep state to TWK state, once access completes (vbus_req = 0) put module back in Sleep state                           1: PSC transitions module to ENABLE state" range="" rwaccess="RW">
		</bitfield>
		<bitfield id="ACSLPIE" width="1" begin="9" end="9" resetval="0" description="Non-emulation Access to module in sleep Error enable                                0: Non-emulation access to module in sleep is not considered an error condition                                                                                                        1: Non-emulation access to module in sleep is considered an error" range="" rwaccess="RW">
		</bitfield>
		<bitfield id="ACSLP" width="1" begin="8" end="8" resetval="0" description="Non-emulation Access to module in Sleep will cause this action                              0: PSC transitions module from Sleep state to TWk state, once access completes put module back in Sleep state                                                    1: PSC transitions module to ENABLE state                                                                                            " range="" rwaccess="RW">
		</bitfield>
		<bitfield id="_RESV" width="5" begin="7" end="3" resetval="0" description="Reserved" range="" rwaccess="R">
		</bitfield>
		<bitfield id="NEXT" width="3" begin="2" end="0" resetval="0" description="Module Next State                                                                                          000: SwRstDisable                                                                                        001: Disable                                                                                                   010: SyncReset                                                                                             011: Enable                                                                                                    100: Reserved/Invalid                                                                                    101: Sleep                                                                                                     110: Reserved/Invalid                                                                                    111: Reserved/Invalid" range="" rwaccess="RW">
		</bitfield>
	</register>
	<register id="MDCTL15" acronym="MDCTL15" offset="0x83C" width="32" description="Module Control 15 Register">
		<bitfield id="_RESV" width="20" begin="31" end="12" resetval="0" description="Reserved" range="" rwaccess="R">
		</bitfield>
		<bitfield id="WKRSLPIE" width="1" begin="11" end="11" resetval="0" description="Wakeup Request to module in sleep Error Enable.                                        0: Wakeup request to module in sleep is not considered an error condition                                                                                                        1: Wakeup request to module in sleep is considered an error" range="" rwaccess="RW">
		</bitfield>
		<bitfield id="WKRSLP" width="1" begin="10" end="10" resetval="0" description="Wakeup Request to module in Sleep will cause this action.                         0: PSC transitions module from Sleep state to TWK state, once access completes (vbus_req = 0) put module back in Sleep state                           1: PSC transitions module to ENABLE state" range="" rwaccess="RW">
		</bitfield>
		<bitfield id="ACSLPIE" width="1" begin="9" end="9" resetval="0" description="Non-emulation Access to module in sleep Error enable                                0: Non-emulation access to module in sleep is not considered an error condition                                                                                                        1: Non-emulation access to module in sleep is considered an error" range="" rwaccess="RW">
		</bitfield>
		<bitfield id="ACSLP" width="1" begin="8" end="8" resetval="0" description="Non-emulation Access to module in Sleep will cause this action                              0: PSC transitions module from Sleep state to TWk state, once access completes put module back in Sleep state                                                    1: PSC transitions module to ENABLE state                                                                                            " range="" rwaccess="RW">
		</bitfield>
		<bitfield id="_RESV" width="5" begin="7" end="3" resetval="0" description="Reserved" range="" rwaccess="R">
		</bitfield>
		<bitfield id="NEXT" width="3" begin="2" end="0" resetval="0" description="Module Next State                                                                                          000: SwRstDisable                                                                                        001: Disable                                                                                                   010: SyncReset                                                                                             011: Enable                                                                                                    100: Reserved/Invalid                                                                                    101: Sleep                                                                                                     110: Reserved/Invalid                                                                                    111: Reserved/Invalid" range="" rwaccess="RW">
		</bitfield>
	</register>
	<register id="MDCTL16" acronym="MDCTL16" offset="0x840" width="32" description="Module Control 16 Register">
		<bitfield id="_RESV" width="20" begin="31" end="12" resetval="0" description="Reserved" range="" rwaccess="R">
		</bitfield>
		<bitfield id="WKRSLPIE" width="1" begin="11" end="11" resetval="0" description="Wakeup Request to module in sleep Error Enable.                                        0: Wakeup request to module in sleep is not considered an error condition                                                                                                        1: Wakeup request to module in sleep is considered an error" range="" rwaccess="RW">
		</bitfield>
		<bitfield id="WKRSLP" width="1" begin="10" end="10" resetval="0" description="Wakeup Request to module in Sleep will cause this action.                         0: PSC transitions module from Sleep state to TWK state, once access completes (vbus_req = 0) put module back in Sleep state                           1: PSC transitions module to ENABLE state" range="" rwaccess="RW">
		</bitfield>
		<bitfield id="ACSLPIE" width="1" begin="9" end="9" resetval="0" description="Non-emulation Access to module in sleep Error enable                                0: Non-emulation access to module in sleep is not considered an error condition                                                                                                        1: Non-emulation access to module in sleep is considered an error" range="" rwaccess="RW">
		</bitfield>
		<bitfield id="ACSLP" width="1" begin="8" end="8" resetval="0" description="Non-emulation Access to module in Sleep will cause this action                              0: PSC transitions module from Sleep state to TWk state, once access completes put module back in Sleep state                                                    1: PSC transitions module to ENABLE state                                                                                            " range="" rwaccess="RW">
		</bitfield>
		<bitfield id="_RESV" width="5" begin="7" end="3" resetval="0" description="Reserved" range="" rwaccess="R">
		</bitfield>
		<bitfield id="NEXT" width="3" begin="2" end="0" resetval="0" description="Module Next State                                                                                          000: SwRstDisable                                                                                        001: Disable                                                                                                   010: SyncReset                                                                                             011: Enable                                                                                                    100: Reserved/Invalid                                                                                    101: Sleep                                                                                                     110: Reserved/Invalid                                                                                    111: Reserved/Invalid" range="" rwaccess="RW">
		</bitfield>
	</register>
	<register id="MDCTL17" acronym="MDCTL17" offset="0x844" width="32" description="Module Control 17 Register">
		<bitfield id="_RESV" width="20" begin="31" end="12" resetval="0" description="Reserved" range="" rwaccess="R">
		</bitfield>
		<bitfield id="WKRSLPIE" width="1" begin="11" end="11" resetval="0" description="Wakeup Request to module in sleep Error Enable.                                        0: Wakeup request to module in sleep is not considered an error condition                                                                                                        1: Wakeup request to module in sleep is considered an error" range="" rwaccess="RW">
		</bitfield>
		<bitfield id="WKRSLP" width="1" begin="10" end="10" resetval="0" description="Wakeup Request to module in Sleep will cause this action.                         0: PSC transitions module from Sleep state to TWK state, once access completes (vbus_req = 0) put module back in Sleep state                           1: PSC transitions module to ENABLE state" range="" rwaccess="RW">
		</bitfield>
		<bitfield id="ACSLPIE" width="1" begin="9" end="9" resetval="0" description="Non-emulation Access to module in sleep Error enable                                0: Non-emulation access to module in sleep is not considered an error condition                                                                                                        1: Non-emulation access to module in sleep is considered an error" range="" rwaccess="RW">
		</bitfield>
		<bitfield id="ACSLP" width="1" begin="8" end="8" resetval="0" description="Non-emulation Access to module in Sleep will cause this action                              0: PSC transitions module from Sleep state to TWk state, once access completes put module back in Sleep state                                                    1: PSC transitions module to ENABLE state                                                                                            " range="" rwaccess="RW">
		</bitfield>
		<bitfield id="_RESV" width="5" begin="7" end="3" resetval="0" description="Reserved" range="" rwaccess="R">
		</bitfield>
		<bitfield id="NEXT" width="3" begin="2" end="0" resetval="0" description="Module Next State                                                                                          000: SwRstDisable                                                                                        001: Disable                                                                                                   010: SyncReset                                                                                             011: Enable                                                                                                    100: Reserved/Invalid                                                                                    101: Sleep                                                                                                     110: Reserved/Invalid                                                                                    111: Reserved/Invalid" range="" rwaccess="RW">
		</bitfield>
	</register>
	<register id="MDCTL18" acronym="MDCTL18" offset="0x848" width="32" description="Module Control 18 Register">
		<bitfield id="_RESV" width="20" begin="31" end="12" resetval="0" description="Reserved" range="" rwaccess="R">
		</bitfield>
		<bitfield id="WKRSLPIE" width="1" begin="11" end="11" resetval="0" description="Wakeup Request to module in sleep Error Enable.                                        0: Wakeup request to module in sleep is not considered an error condition                                                                                                        1: Wakeup request to module in sleep is considered an error" range="" rwaccess="RW">
		</bitfield>
		<bitfield id="WKRSLP" width="1" begin="10" end="10" resetval="0" description="Wakeup Request to module in Sleep will cause this action.                         0: PSC transitions module from Sleep state to TWK state, once access completes (vbus_req = 0) put module back in Sleep state                           1: PSC transitions module to ENABLE state" range="" rwaccess="RW">
		</bitfield>
		<bitfield id="ACSLPIE" width="1" begin="9" end="9" resetval="0" description="Non-emulation Access to module in sleep Error enable                                0: Non-emulation access to module in sleep is not considered an error condition                                                                                                        1: Non-emulation access to module in sleep is considered an error" range="" rwaccess="RW">
		</bitfield>
		<bitfield id="ACSLP" width="1" begin="8" end="8" resetval="0" description="Non-emulation Access to module in Sleep will cause this action                              0: PSC transitions module from Sleep state to TWk state, once access completes put module back in Sleep state                                                    1: PSC transitions module to ENABLE state                                                                                            " range="" rwaccess="RW">
		</bitfield>
		<bitfield id="_RESV" width="5" begin="7" end="3" resetval="0" description="Reserved" range="" rwaccess="R">
		</bitfield>
		<bitfield id="NEXT" width="3" begin="2" end="0" resetval="0" description="Module Next State                                                                                          000: SwRstDisable                                                                                        001: Disable                                                                                                   010: SyncReset                                                                                             011: Enable                                                                                                    100: Reserved/Invalid                                                                                    101: Sleep                                                                                                     110: Reserved/Invalid                                                                                    111: Reserved/Invalid" range="" rwaccess="RW">
		</bitfield>
	</register>
	<register id="MDCTL19" acronym="MDCTL19" offset="0x84C" width="32" description="Module Control 19 Register">
		<bitfield id="_RESV" width="20" begin="31" end="12" resetval="0" description="Reserved" range="" rwaccess="R">
		</bitfield>
		<bitfield id="WKRSLPIE" width="1" begin="11" end="11" resetval="0" description="Wakeup Request to module in sleep Error Enable.                                        0: Wakeup request to module in sleep is not considered an error condition                                                                                                        1: Wakeup request to module in sleep is considered an error" range="" rwaccess="RW">
		</bitfield>
		<bitfield id="WKRSLP" width="1" begin="10" end="10" resetval="0" description="Wakeup Request to module in Sleep will cause this action.                         0: PSC transitions module from Sleep state to TWK state, once access completes (vbus_req = 0) put module back in Sleep state                           1: PSC transitions module to ENABLE state" range="" rwaccess="RW">
		</bitfield>
		<bitfield id="ACSLPIE" width="1" begin="9" end="9" resetval="0" description="Non-emulation Access to module in sleep Error enable                                0: Non-emulation access to module in sleep is not considered an error condition                                                                                                        1: Non-emulation access to module in sleep is considered an error" range="" rwaccess="RW">
		</bitfield>
		<bitfield id="ACSLP" width="1" begin="8" end="8" resetval="0" description="Non-emulation Access to module in Sleep will cause this action                              0: PSC transitions module from Sleep state to TWk state, once access completes put module back in Sleep state                                                    1: PSC transitions module to ENABLE state                                                                                            " range="" rwaccess="RW">
		</bitfield>
		<bitfield id="_RESV" width="5" begin="7" end="3" resetval="0" description="Reserved" range="" rwaccess="R">
		</bitfield>
		<bitfield id="NEXT" width="3" begin="2" end="0" resetval="0" description="Module Next State                                                                                          000: SwRstDisable                                                                                        001: Disable                                                                                                   010: SyncReset                                                                                             011: Enable                                                                                                    100: Reserved/Invalid                                                                                    101: Sleep                                                                                                     110: Reserved/Invalid                                                                                    111: Reserved/Invalid" range="" rwaccess="RW">
		</bitfield>
	</register>
	<register id="MDCTL20" acronym="MDCTL20" offset="0x850" width="32" description="Module Control 20 Register">
		<bitfield id="_RESV" width="20" begin="31" end="12" resetval="0" description="Reserved" range="" rwaccess="R">
		</bitfield>
		<bitfield id="WKRSLPIE" width="1" begin="11" end="11" resetval="0" description="Wakeup Request to module in sleep Error Enable.                                        0: Wakeup request to module in sleep is not considered an error condition                                                                                                        1: Wakeup request to module in sleep is considered an error" range="" rwaccess="RW">
		</bitfield>
		<bitfield id="WKRSLP" width="1" begin="10" end="10" resetval="0" description="Wakeup Request to module in Sleep will cause this action.                         0: PSC transitions module from Sleep state to TWK state, once access completes (vbus_req = 0) put module back in Sleep state                           1: PSC transitions module to ENABLE state" range="" rwaccess="RW">
		</bitfield>
		<bitfield id="ACSLPIE" width="1" begin="9" end="9" resetval="0" description="Non-emulation Access to module in sleep Error enable                                0: Non-emulation access to module in sleep is not considered an error condition                                                                                                        1: Non-emulation access to module in sleep is considered an error" range="" rwaccess="RW">
		</bitfield>
		<bitfield id="ACSLP" width="1" begin="8" end="8" resetval="0" description="Non-emulation Access to module in Sleep will cause this action                              0: PSC transitions module from Sleep state to TWk state, once access completes put module back in Sleep state                                                    1: PSC transitions module to ENABLE state                                                                                            " range="" rwaccess="RW">
		</bitfield>
		<bitfield id="_RESV" width="5" begin="7" end="3" resetval="0" description="Reserved" range="" rwaccess="R">
		</bitfield>
		<bitfield id="NEXT" width="3" begin="2" end="0" resetval="0" description="Module Next State                                                                                          000: SwRstDisable                                                                                        001: Disable                                                                                                   010: SyncReset                                                                                             011: Enable                                                                                                    100: Reserved/Invalid                                                                                    101: Sleep                                                                                                     110: Reserved/Invalid                                                                                    111: Reserved/Invalid" range="" rwaccess="RW">
		</bitfield>
	</register>
	<register id="MDCTL21" acronym="MDCTL21" offset="0x854" width="32" description="Module Control 21 Register">
		<bitfield id="_RESV" width="20" begin="31" end="12" resetval="0" description="Reserved" range="" rwaccess="R">
		</bitfield>
		<bitfield id="WKRSLPIE" width="1" begin="11" end="11" resetval="0" description="Wakeup Request to module in sleep Error Enable.                                        0: Wakeup request to module in sleep is not considered an error condition                                                                                                        1: Wakeup request to module in sleep is considered an error" range="" rwaccess="RW">
		</bitfield>
		<bitfield id="WKRSLP" width="1" begin="10" end="10" resetval="0" description="Wakeup Request to module in Sleep will cause this action.                         0: PSC transitions module from Sleep state to TWK state, once access completes (vbus_req = 0) put module back in Sleep state                           1: PSC transitions module to ENABLE state" range="" rwaccess="RW">
		</bitfield>
		<bitfield id="ACSLPIE" width="1" begin="9" end="9" resetval="0" description="Non-emulation Access to module in sleep Error enable                                0: Non-emulation access to module in sleep is not considered an error condition                                                                                                        1: Non-emulation access to module in sleep is considered an error" range="" rwaccess="RW">
		</bitfield>
		<bitfield id="ACSLP" width="1" begin="8" end="8" resetval="0" description="Non-emulation Access to module in Sleep will cause this action                              0: PSC transitions module from Sleep state to TWk state, once access completes put module back in Sleep state                                                    1: PSC transitions module to ENABLE state                                                                                            " range="" rwaccess="RW">
		</bitfield>
		<bitfield id="_RESV" width="5" begin="7" end="3" resetval="0" description="Reserved" range="" rwaccess="R">
		</bitfield>
		<bitfield id="NEXT" width="3" begin="2" end="0" resetval="0" description="Module Next State                                                                                          000: SwRstDisable                                                                                        001: Disable                                                                                                   010: SyncReset                                                                                             011: Enable                                                                                                    100: Reserved/Invalid                                                                                    101: Sleep                                                                                                     110: Reserved/Invalid                                                                                    111: Reserved/Invalid" range="" rwaccess="RW">
		</bitfield>
	</register>
	<register id="MDCTL22" acronym="MDCTL22" offset="0x858" width="32" description="Module Control 22 Register">
		<bitfield id="_RESV" width="20" begin="31" end="12" resetval="0" description="Reserved" range="" rwaccess="R">
		</bitfield>
		<bitfield id="WKRSLPIE" width="1" begin="11" end="11" resetval="0" description="Wakeup Request to module in sleep Error Enable.                                        0: Wakeup request to module in sleep is not considered an error condition                                                                                                        1: Wakeup request to module in sleep is considered an error" range="" rwaccess="RW">
		</bitfield>
		<bitfield id="WKRSLP" width="1" begin="10" end="10" resetval="0" description="Wakeup Request to module in Sleep will cause this action.                         0: PSC transitions module from Sleep state to TWK state, once access completes (vbus_req = 0) put module back in Sleep state                           1: PSC transitions module to ENABLE state" range="" rwaccess="RW">
		</bitfield>
		<bitfield id="ACSLPIE" width="1" begin="9" end="9" resetval="0" description="Non-emulation Access to module in sleep Error enable                                0: Non-emulation access to module in sleep is not considered an error condition                                                                                                        1: Non-emulation access to module in sleep is considered an error" range="" rwaccess="RW">
		</bitfield>
		<bitfield id="ACSLP" width="1" begin="8" end="8" resetval="0" description="Non-emulation Access to module in Sleep will cause this action                              0: PSC transitions module from Sleep state to TWk state, once access completes put module back in Sleep state                                                    1: PSC transitions module to ENABLE state                                                                                            " range="" rwaccess="RW">
		</bitfield>
		<bitfield id="_RESV" width="5" begin="7" end="3" resetval="0" description="Reserved" range="" rwaccess="R">
		</bitfield>
		<bitfield id="NEXT" width="3" begin="2" end="0" resetval="0" description="Module Next State                                                                                          000: SwRstDisable                                                                                        001: Disable                                                                                                   010: SyncReset                                                                                             011: Enable                                                                                                    100: Reserved/Invalid                                                                                    101: Sleep                                                                                                     110: Reserved/Invalid                                                                                    111: Reserved/Invalid" range="" rwaccess="RW">
		</bitfield>
	</register>
	<register id="MDCTL23" acronym="MDCTL23" offset="0x85C" width="32" description="Module Control 23 Register">
		<bitfield id="_RESV" width="20" begin="31" end="12" resetval="0" description="Reserved" range="" rwaccess="R">
		</bitfield>
		<bitfield id="WKRSLPIE" width="1" begin="11" end="11" resetval="0" description="Wakeup Request to module in sleep Error Enable.                                        0: Wakeup request to module in sleep is not considered an error condition                                                                                                        1: Wakeup request to module in sleep is considered an error" range="" rwaccess="RW">
		</bitfield>
		<bitfield id="WKRSLP" width="1" begin="10" end="10" resetval="0" description="Wakeup Request to module in Sleep will cause this action.                         0: PSC transitions module from Sleep state to TWK state, once access completes (vbus_req = 0) put module back in Sleep state                           1: PSC transitions module to ENABLE state" range="" rwaccess="RW">
		</bitfield>
		<bitfield id="ACSLPIE" width="1" begin="9" end="9" resetval="0" description="Non-emulation Access to module in sleep Error enable                                0: Non-emulation access to module in sleep is not considered an error condition                                                                                                        1: Non-emulation access to module in sleep is considered an error" range="" rwaccess="RW">
		</bitfield>
		<bitfield id="ACSLP" width="1" begin="8" end="8" resetval="0" description="Non-emulation Access to module in Sleep will cause this action                              0: PSC transitions module from Sleep state to TWk state, once access completes put module back in Sleep state                                                    1: PSC transitions module to ENABLE state                                                                                            " range="" rwaccess="RW">
		</bitfield>
		<bitfield id="_RESV" width="5" begin="7" end="3" resetval="0" description="Reserved" range="" rwaccess="R">
		</bitfield>
		<bitfield id="NEXT" width="3" begin="2" end="0" resetval="0" description="Module Next State                                                                                          000: SwRstDisable                                                                                        001: Disable                                                                                                   010: SyncReset                                                                                             011: Enable                                                                                                    100: Reserved/Invalid                                                                                    101: Sleep                                                                                                     110: Reserved/Invalid                                                                                    111: Reserved/Invalid" range="" rwaccess="RW">
		</bitfield>
	</register>
	<register id="MDCTL24" acronym="MDCTL24" offset="0x860" width="32" description="Module Control 24 Register">
		<bitfield id="_RESV" width="20" begin="31" end="12" resetval="0" description="Reserved" range="" rwaccess="R">
		</bitfield>
		<bitfield id="WKRSLPIE" width="1" begin="11" end="11" resetval="0" description="Wakeup Request to module in sleep Error Enable.                                        0: Wakeup request to module in sleep is not considered an error condition                                                                                                        1: Wakeup request to module in sleep is considered an error" range="" rwaccess="RW">
		</bitfield>
		<bitfield id="WKRSLP" width="1" begin="10" end="10" resetval="0" description="Wakeup Request to module in Sleep will cause this action.                         0: PSC transitions module from Sleep state to TWK state, once access completes (vbus_req = 0) put module back in Sleep state                           1: PSC transitions module to ENABLE state" range="" rwaccess="RW">
		</bitfield>
		<bitfield id="ACSLPIE" width="1" begin="9" end="9" resetval="0" description="Non-emulation Access to module in sleep Error enable                                0: Non-emulation access to module in sleep is not considered an error condition                                                                                                        1: Non-emulation access to module in sleep is considered an error" range="" rwaccess="RW">
		</bitfield>
		<bitfield id="ACSLP" width="1" begin="8" end="8" resetval="0" description="Non-emulation Access to module in Sleep will cause this action                              0: PSC transitions module from Sleep state to TWk state, once access completes put module back in Sleep state                                                    1: PSC transitions module to ENABLE state                                                                                            " range="" rwaccess="RW">
		</bitfield>
		<bitfield id="_RESV" width="5" begin="7" end="3" resetval="0" description="Reserved" range="" rwaccess="R">
		</bitfield>
		<bitfield id="NEXT" width="3" begin="2" end="0" resetval="0" description="Module Next State                                                                                          000: SwRstDisable                                                                                        001: Disable                                                                                                   010: SyncReset                                                                                             011: Enable                                                                                                    100: Reserved/Invalid                                                                                    101: Sleep                                                                                                     110: Reserved/Invalid                                                                                    111: Reserved/Invalid" range="" rwaccess="RW">
		</bitfield>
	</register>
	<register id="MDCTL25" acronym="MDCTL25" offset="0x864" width="32" description="Module Control 25 Register">
		<bitfield id="_RESV" width="20" begin="31" end="12" resetval="0" description="Reserved" range="" rwaccess="R">
		</bitfield>
		<bitfield id="WKRSLPIE" width="1" begin="11" end="11" resetval="0" description="Wakeup Request to module in sleep Error Enable.                                        0: Wakeup request to module in sleep is not considered an error condition                                                                                                        1: Wakeup request to module in sleep is considered an error" range="" rwaccess="RW">
		</bitfield>
		<bitfield id="WKRSLP" width="1" begin="10" end="10" resetval="0" description="Wakeup Request to module in Sleep will cause this action.                         0: PSC transitions module from Sleep state to TWK state, once access completes (vbus_req = 0) put module back in Sleep state                           1: PSC transitions module to ENABLE state" range="" rwaccess="RW">
		</bitfield>
		<bitfield id="ACSLPIE" width="1" begin="9" end="9" resetval="0" description="Non-emulation Access to module in sleep Error enable                                0: Non-emulation access to module in sleep is not considered an error condition                                                                                                        1: Non-emulation access to module in sleep is considered an error" range="" rwaccess="RW">
		</bitfield>
		<bitfield id="ACSLP" width="1" begin="8" end="8" resetval="0" description="Non-emulation Access to module in Sleep will cause this action                              0: PSC transitions module from Sleep state to TWk state, once access completes put module back in Sleep state                                                    1: PSC transitions module to ENABLE state                                                                                            " range="" rwaccess="RW">
		</bitfield>
		<bitfield id="_RESV" width="5" begin="7" end="3" resetval="0" description="Reserved" range="" rwaccess="R">
		</bitfield>
		<bitfield id="NEXT" width="3" begin="2" end="0" resetval="0" description="Module Next State                                                                                          000: SwRstDisable                                                                                        001: Disable                                                                                                   010: SyncReset                                                                                             011: Enable                                                                                                    100: Reserved/Invalid                                                                                    101: Sleep                                                                                                     110: Reserved/Invalid                                                                                    111: Reserved/Invalid" range="" rwaccess="RW">
		</bitfield>
	</register>
	<register id="MDCTL26" acronym="MDCTL26" offset="0x868" width="32" description="Module Control 26 Register">
		<bitfield id="_RESV" width="20" begin="31" end="12" resetval="0" description="Reserved" range="" rwaccess="R">
		</bitfield>
		<bitfield id="WKRSLPIE" width="1" begin="11" end="11" resetval="0" description="Wakeup Request to module in sleep Error Enable.                                        0: Wakeup request to module in sleep is not considered an error condition                                                                                                        1: Wakeup request to module in sleep is considered an error" range="" rwaccess="RW">
		</bitfield>
		<bitfield id="WKRSLP" width="1" begin="10" end="10" resetval="0" description="Wakeup Request to module in Sleep will cause this action.                         0: PSC transitions module from Sleep state to TWK state, once access completes (vbus_req = 0) put module back in Sleep state                           1: PSC transitions module to ENABLE state" range="" rwaccess="RW">
		</bitfield>
		<bitfield id="ACSLPIE" width="1" begin="9" end="9" resetval="0" description="Non-emulation Access to module in sleep Error enable                                0: Non-emulation access to module in sleep is not considered an error condition                                                                                                        1: Non-emulation access to module in sleep is considered an error" range="" rwaccess="RW">
		</bitfield>
		<bitfield id="ACSLP" width="1" begin="8" end="8" resetval="0" description="Non-emulation Access to module in Sleep will cause this action                              0: PSC transitions module from Sleep state to TWk state, once access completes put module back in Sleep state                                                    1: PSC transitions module to ENABLE state                                                                                            " range="" rwaccess="RW">
		</bitfield>
		<bitfield id="_RESV" width="5" begin="7" end="3" resetval="0" description="Reserved" range="" rwaccess="R">
		</bitfield>
		<bitfield id="NEXT" width="3" begin="2" end="0" resetval="0" description="Module Next State                                                                                          000: SwRstDisable                                                                                        001: Disable                                                                                                   010: SyncReset                                                                                             011: Enable                                                                                                    100: Reserved/Invalid                                                                                    101: Sleep                                                                                                     110: Reserved/Invalid                                                                                    111: Reserved/Invalid" range="" rwaccess="RW">
		</bitfield>
	</register>
	<register id="MDCTL27" acronym="MDCTL27" offset="0x86C" width="32" description="Module Control 27 Register">
		<bitfield id="_RESV" width="20" begin="31" end="12" resetval="0" description="Reserved" range="" rwaccess="R">
		</bitfield>
		<bitfield id="WKRSLPIE" width="1" begin="11" end="11" resetval="0" description="Wakeup Request to module in sleep Error Enable.                                        0: Wakeup request to module in sleep is not considered an error condition                                                                                                        1: Wakeup request to module in sleep is considered an error" range="" rwaccess="RW">
		</bitfield>
		<bitfield id="WKRSLP" width="1" begin="10" end="10" resetval="0" description="Wakeup Request to module in Sleep will cause this action.                         0: PSC transitions module from Sleep state to TWK state, once access completes (vbus_req = 0) put module back in Sleep state                           1: PSC transitions module to ENABLE state" range="" rwaccess="RW">
		</bitfield>
		<bitfield id="ACSLPIE" width="1" begin="9" end="9" resetval="0" description="Non-emulation Access to module in sleep Error enable                                0: Non-emulation access to module in sleep is not considered an error condition                                                                                                        1: Non-emulation access to module in sleep is considered an error" range="" rwaccess="RW">
		</bitfield>
		<bitfield id="ACSLP" width="1" begin="8" end="8" resetval="0" description="Non-emulation Access to module in Sleep will cause this action                              0: PSC transitions module from Sleep state to TWk state, once access completes put module back in Sleep state                                                    1: PSC transitions module to ENABLE state                                                                                            " range="" rwaccess="RW">
		</bitfield>
		<bitfield id="_RESV" width="5" begin="7" end="3" resetval="0" description="Reserved" range="" rwaccess="R">
		</bitfield>
		<bitfield id="NEXT" width="3" begin="2" end="0" resetval="0" description="Module Next State                                                                                          000: SwRstDisable                                                                                        001: Disable                                                                                                   010: SyncReset                                                                                             011: Enable                                                                                                    100: Reserved/Invalid                                                                                    101: Sleep                                                                                                     110: Reserved/Invalid                                                                                    111: Reserved/Invalid" range="" rwaccess="RW">
		</bitfield>
	</register>
	<register id="MDCTL28" acronym="MDCTL28" offset="0x870" width="32" description="Module Control 28 Register">
		<bitfield id="_RESV" width="20" begin="31" end="12" resetval="0" description="Reserved" range="" rwaccess="R">
		</bitfield>
		<bitfield id="WKRSLPIE" width="1" begin="11" end="11" resetval="0" description="Wakeup Request to module in sleep Error Enable.                                        0: Wakeup request to module in sleep is not considered an error condition                                                                                                        1: Wakeup request to module in sleep is considered an error" range="" rwaccess="RW">
		</bitfield>
		<bitfield id="WKRSLP" width="1" begin="10" end="10" resetval="0" description="Wakeup Request to module in Sleep will cause this action.                         0: PSC transitions module from Sleep state to TWK state, once access completes (vbus_req = 0) put module back in Sleep state                           1: PSC transitions module to ENABLE state" range="" rwaccess="RW">
		</bitfield>
		<bitfield id="ACSLPIE" width="1" begin="9" end="9" resetval="0" description="Non-emulation Access to module in sleep Error enable                                0: Non-emulation access to module in sleep is not considered an error condition                                                                                                        1: Non-emulation access to module in sleep is considered an error" range="" rwaccess="RW">
		</bitfield>
		<bitfield id="ACSLP" width="1" begin="8" end="8" resetval="0" description="Non-emulation Access to module in Sleep will cause this action                              0: PSC transitions module from Sleep state to TWk state, once access completes put module back in Sleep state                                                    1: PSC transitions module to ENABLE state                                                                                            " range="" rwaccess="RW">
		</bitfield>
		<bitfield id="_RESV" width="5" begin="7" end="3" resetval="0" description="Reserved" range="" rwaccess="R">
		</bitfield>
		<bitfield id="NEXT" width="3" begin="2" end="0" resetval="0" description="Module Next State                                                                                          000: SwRstDisable                                                                                        001: Disable                                                                                                   010: SyncReset                                                                                             011: Enable                                                                                                    100: Reserved/Invalid                                                                                    101: Sleep                                                                                                     110: Reserved/Invalid                                                                                    111: Reserved/Invalid" range="" rwaccess="RW">
		</bitfield>
	</register>
	<register id="MDCTL29" acronym="MDCTL29" offset="0x874" width="32" description="Module Control 29 Register">
		<bitfield id="_RESV" width="20" begin="31" end="12" resetval="0" description="Reserved" range="" rwaccess="R">
		</bitfield>
		<bitfield id="WKRSLPIE" width="1" begin="11" end="11" resetval="0" description="Wakeup Request to module in sleep Error Enable.                                        0: Wakeup request to module in sleep is not considered an error condition                                                                                                        1: Wakeup request to module in sleep is considered an error" range="" rwaccess="RW">
		</bitfield>
		<bitfield id="WKRSLP" width="1" begin="10" end="10" resetval="0" description="Wakeup Request to module in Sleep will cause this action.                         0: PSC transitions module from Sleep state to TWK state, once access completes (vbus_req = 0) put module back in Sleep state                           1: PSC transitions module to ENABLE state" range="" rwaccess="RW">
		</bitfield>
		<bitfield id="ACSLPIE" width="1" begin="9" end="9" resetval="0" description="Non-emulation Access to module in sleep Error enable                                0: Non-emulation access to module in sleep is not considered an error condition                                                                                                        1: Non-emulation access to module in sleep is considered an error" range="" rwaccess="RW">
		</bitfield>
		<bitfield id="ACSLP" width="1" begin="8" end="8" resetval="0" description="Non-emulation Access to module in Sleep will cause this action                              0: PSC transitions module from Sleep state to TWk state, once access completes put module back in Sleep state                                                    1: PSC transitions module to ENABLE state                                                                                            " range="" rwaccess="RW">
		</bitfield>
		<bitfield id="_RESV" width="5" begin="7" end="3" resetval="0" description="Reserved" range="" rwaccess="R">
		</bitfield>
		<bitfield id="NEXT" width="3" begin="2" end="0" resetval="0" description="Module Next State                                                                                          000: SwRstDisable                                                                                        001: Disable                                                                                                   010: SyncReset                                                                                             011: Enable                                                                                                    100: Reserved/Invalid                                                                                    101: Sleep                                                                                                     110: Reserved/Invalid                                                                                    111: Reserved/Invalid" range="" rwaccess="RW">
		</bitfield>
	</register>
	<register id="MDCTL30" acronym="MDCTL30" offset="0x878" width="32" description="Module Control 30 Register">
		<bitfield id="_RESV" width="20" begin="31" end="12" resetval="0" description="Reserved" range="" rwaccess="R">
		</bitfield>
		<bitfield id="WKRSLPIE" width="1" begin="11" end="11" resetval="0" description="Wakeup Request to module in sleep Error Enable.                                        0: Wakeup request to module in sleep is not considered an error condition                                                                                                        1: Wakeup request to module in sleep is considered an error" range="" rwaccess="RW">
		</bitfield>
		<bitfield id="WKRSLP" width="1" begin="10" end="10" resetval="0" description="Wakeup Request to module in Sleep will cause this action.                         0: PSC transitions module from Sleep state to TWK state, once access completes (vbus_req = 0) put module back in Sleep state                           1: PSC transitions module to ENABLE state" range="" rwaccess="RW">
		</bitfield>
		<bitfield id="ACSLPIE" width="1" begin="9" end="9" resetval="0" description="Non-emulation Access to module in sleep Error enable                                0: Non-emulation access to module in sleep is not considered an error condition                                                                                                        1: Non-emulation access to module in sleep is considered an error" range="" rwaccess="RW">
		</bitfield>
		<bitfield id="ACSLP" width="1" begin="8" end="8" resetval="0" description="Non-emulation Access to module in Sleep will cause this action                              0: PSC transitions module from Sleep state to TWk state, once access completes put module back in Sleep state                                                    1: PSC transitions module to ENABLE state                                                                                            " range="" rwaccess="RW">
		</bitfield>
		<bitfield id="_RESV" width="5" begin="7" end="3" resetval="0" description="Reserved" range="" rwaccess="R">
		</bitfield>
		<bitfield id="NEXT" width="3" begin="2" end="0" resetval="0" description="Module Next State                                                                                          000: SwRstDisable                                                                                        001: Disable                                                                                                   010: SyncReset                                                                                             011: Enable                                                                                                    100: Reserved/Invalid                                                                                    101: Sleep                                                                                                     110: Reserved/Invalid                                                                                    111: Reserved/Invalid" range="" rwaccess="RW">
		</bitfield>
	</register>
	<register id="MDCTL31" acronym="MDCTL31" offset="0x87C" width="32" description="Module Control 31 Register">
		<bitfield id="_RESV" width="20" begin="31" end="12" resetval="0" description="Reserved" range="" rwaccess="R">
		</bitfield>
		<bitfield id="WKRSLPIE" width="1" begin="11" end="11" resetval="0" description="Wakeup Request to module in sleep Error Enable.                                        0: Wakeup request to module in sleep is not considered an error condition                                                                                                        1: Wakeup request to module in sleep is considered an error" range="" rwaccess="RW">
		</bitfield>
		<bitfield id="WKRSLP" width="1" begin="10" end="10" resetval="0" description="Wakeup Request to module in Sleep will cause this action.                         0: PSC transitions module from Sleep state to TWK state, once access completes (vbus_req = 0) put module back in Sleep state                           1: PSC transitions module to ENABLE state" range="" rwaccess="RW">
		</bitfield>
		<bitfield id="ACSLPIE" width="1" begin="9" end="9" resetval="0" description="Non-emulation Access to module in sleep Error enable                                0: Non-emulation access to module in sleep is not considered an error condition                                                                                                        1: Non-emulation access to module in sleep is considered an error" range="" rwaccess="RW">
		</bitfield>
		<bitfield id="ACSLP" width="1" begin="8" end="8" resetval="0" description="Non-emulation Access to module in Sleep will cause this action                              0: PSC transitions module from Sleep state to TWk state, once access completes put module back in Sleep state                                                    1: PSC transitions module to ENABLE state                                                                                            " range="" rwaccess="RW">
		</bitfield>
		<bitfield id="_RESV" width="5" begin="7" end="3" resetval="0" description="Reserved" range="" rwaccess="R">
		</bitfield>
		<bitfield id="NEXT" width="3" begin="2" end="0" resetval="0" description="Module Next State                                                                                          000: SwRstDisable                                                                                        001: Disable                                                                                                   010: SyncReset                                                                                             011: Enable                                                                                                    100: Reserved/Invalid                                                                                    101: Sleep                                                                                                     110: Reserved/Invalid                                                                                    111: Reserved/Invalid" range="" rwaccess="RW">
		</bitfield>
	</register>
	<register id="MPFAR" acronym="MPFAR" offset="0x1000" width="32" description="Memory Protection Fault Address Register">
		<bitfield id="FADDR" width="32" begin="31" end="0" resetval="0" description="Memory Protection Fault Address                                                                 Captures the faulting address when a memory protection vioaltion is detected. This register can only be cleared via MPFCR.MPFCLR" range="" rwaccess="R">
		</bitfield>
	</register>
	<register id="MPFSR" acronym="MPFSR" offset="0x1004" width="32" description="Memory Protection Fault Status Register">
		<bitfield id="_RESV" width="19" begin="31" end="13" resetval="0" description="Reserved" range="" rwaccess="W">
		</bitfield>
		<bitfield id="FID" width="4" begin="12" end="9" resetval="0" description="Faulted ID                                                                                                        FID contains valid info if any of the MP error bits (UXE, UWE, URE, SXE, SWE, SRE) are non-zero. The FID field contains the vbus PrivID for the specific request/requestor that resulted in a MP error.   " range="" rwaccess="R">
		</bitfield>
		<bitfield id="_RESV" width="1" begin="8" end="8" resetval="0" description="Reserved" range="" rwaccess="R">
		</bitfield>
		<bitfield id="SECE" width="1" begin="7" end="7" resetval="0" description="Secure Access Error                                                                                    Hard-wired to 0 to show no secure access error - because PSC does not check for security." range="" rwaccess="R">
		</bitfield>
		<bitfield id="_RESV" width="1" begin="6" end="6" resetval="0" description="Reserved" range="" rwaccess="R">
		</bitfield>
		<bitfield id="SRE" width="1" begin="5" end="5" resetval="0" description="Supervisor Read Error                                                                                  SRE = 0: No error detected                                                                            SRE = 1: Supervisor level task attempted to read from a MP page without SR permissions" range="" rwaccess="R">
		</bitfield>
		<bitfield id="SWE" width="1" begin="4" end="4" resetval="0" description="Supervisor Write Error                                                                                  SWE = 0: No error detected                                                                            SWE = 1: Supervisor level task attempted to write to a MP page without SW permissions" range="" rwaccess="R">
		</bitfield>
		<bitfield id="SXE" width="1" begin="3" end="3" resetval="0" description="Supervisor Execute Error. This bit is hard-wired to 0 to indicate no Supervisor Execute Error (because PSC does not check for VBUS data type vbus_dtype)                                                                             " range="" rwaccess="R">
		</bitfield>
		<bitfield id="URE" width="1" begin="2" end="2" resetval="0" description="User Read Error                                                                                            URE = 0: No Error detected                                                                           URE = 1: User level task attempted to read from a MP page without UR permissions" range="" rwaccess="R">
		</bitfield>
		<bitfield id="UWE" width="1" begin="1" end="1" resetval="0" description="User Write Error                                                                                             UWE = 0: No error detected                                                                          UWE = 1: User level task attempted to write to a MP page without UW permissions" range="" rwaccess="R">
		</bitfield>
		<bitfield id="UXE" width="1" begin="0" end="0" resetval="0" description="User Execute Error. This bit is hard-wired to 0 to indicate no User Execute Error (because PSC does not check for VBUS data type vbus_dtype)" range="" rwaccess="R">
		</bitfield>
	</register>
	<register id="MPFCR" acronym="MPFCR" offset="0x1008" width="32" description="Memory Protection Fault Command Register">
		<bitfield id="_RESV" width="31" begin="31" end="1" resetval="0" description="Reserved" range="" rwaccess="R">
		</bitfield>
		<bitfield id="MPFCLR" width="1" begin="0" end="0" resetval="0" description="Fault Clear                                                                                                     Write of 1 to this bit causes any error conditions stored in MPFAR and MPFSR registers to be cleared. Write of 0 has no effect" range="" rwaccess="W">
		</bitfield>
	</register>
	<register id="MPAA" acronym="MPAA" offset="0x100C" width="32" description="Memory Protection Page Attribute Register">
		<bitfield id="_RESV" width="16" begin="31" end="16" resetval="0" description="Reserved" range="" rwaccess="R">
		</bitfield>
		<bitfield id="AID5" width="1" begin="15" end="15" resetval="0" description="Allowed ID 5                                                                                                  AID5 = 0: VBUS requests with PrivID == 5 are not allowed to this MMR region regardless of permission settings (UW, UR, SW, SR)                       AID5 = 1: VBUS requests with PrivID == 5 are permitted if access type is allowed as defined by permission settings (UW, UR, SW, SR)" range="" rwaccess="RW">
		</bitfield>
		<bitfield id="AID4" width="1" begin="14" end="14" resetval="0" description="Allowed ID 4                                                                                                 AID4 = 0: VBUS requests with PrivID == 4 are not allowed to this MMR region regardless of permission settings (UW, UR, SW, SR)                       AID4 = 1: VBUS requests with PrivID == 4 are permitted if access type is allowed as defined by permission settings (UW, UR, SW, SR)" range="" rwaccess="RW">
		</bitfield>
		<bitfield id="AID3" width="1" begin="13" end="13" resetval="0" description="Allowed ID 3                                                                                                  AID3 = 0: VBUS requests with PrivID == 3 are not allowed to this MMR region regardless of permission settings (UW, UR, SW, SR)                       AID3 = 1: VBUS requests with PrivID == 3 are permitted if access type is allowed as defined by permission settings (UW, UR, SW, SR)" range="" rwaccess="RW">
		</bitfield>
		<bitfield id="AID2" width="1" begin="12" end="12" resetval="0" description="Allowed ID 2                                                                                                 AID2 = 0: VBUS requests with PrivID == 2 are not allowed to this MMR region regardless of permission settings (UW, UR, SW, SR)                       AID2 = 1: VBUS requests with PrivID == 2 are permitted if access type is allowed as defined by permission settings (UW, UR, SW, SR)" range="" rwaccess="RW">
		</bitfield>
		<bitfield id="AID1" width="1" begin="11" end="11" resetval="0" description="Allowed ID 1                                                                                                  AID1 = 0: VBUS requests with PrivID == 1 are not allowed to this MMR region regardless of permission settings (UW, UR, SW, SR)                       AID1 = 1: VBUS requests with PrivID == 1 are permitted if access type is allowed as defined by permission settings (UW, UR, SW, SR)" range="" rwaccess="RW">
		</bitfield>
		<bitfield id="AID0" width="1" begin="10" end="10" resetval="0" description="Allowed ID 0                                                                                                 AID0 = 0: VBUS requests with PrivID == 0 are not allowed to this MMR region regardless of permission settings (UW, UR, SW, SR)                       AID0 = 1: VBUS requests with PrivID == 0 are permitted if access type is allowed as defined by permission settings (UW, UR, SW, SR)" range="" rwaccess="RW">
		</bitfield>
		<bitfield id="EXT" width="1" begin="9" end="9" resetval="0" description="External Allowed ID                                                                                       EXT = 0: VBUS requests with PrivID &gt;= 6 are not allowed to this MMR region regardless of permission settings (UW, UR, SW, SR)                       EXT = 1: VBUS requests with PrivID &gt;= 6 are permitted if access type is allowed as defined by permission settings (UW, UR, SW, SR)" range="" rwaccess="RW">
		</bitfield>
		<bitfield id="LCL" width="1" begin="8" end="8" resetval="0" description="Local access permission (Not applicable)                                                    Local accesses are not applicable, therefore hard-code this value to 0" range="" rwaccess="R">
		</bitfield>
		<bitfield id="NS" width="1" begin="7" end="7" resetval="1" description="Secure Access Permission (not applicable)                                                 Hard-wired to 1 to show page is not secure. Secure and non-secure code can both access this MMR region." range="" rwaccess="R">
		</bitfield>
		<bitfield id="EMU" width="1" begin="6" end="6" resetval="1" description="Emulation Security Permission (not applicable)                                             Hard-wired to 1 to indicate emulation read/write to this page is permitted." range="" rwaccess="R">
		</bitfield>
		<bitfield id="SR" width="1" begin="5" end="5" resetval="0" description="Supervisor Read Permission                                                                         UR = 0: Supervisor reads are not allowed to this MMR region                     UR = 1: Supervisor reads allowed to this MMR region                                  " range="" rwaccess="RW">
		</bitfield>
		<bitfield id="SW" width="1" begin="4" end="4" resetval="0" description="Supervisor Write Permission                                                                         UW = 0: Supervisor writes are not allowed to this MMR region                     UW = 1: Supervisor writes allowed to this MMR region                                  " range="" rwaccess="RW">
		</bitfield>
		<bitfield id="SX" width="1" begin="3" end="3" resetval="0" description="Supervisor Execute Permission (not applicable)                                           This bit is hard-wired to 0 to indicate no Supervisor Execute Permission (because PSC does not check for VBUS data type vbus_dtype)" range="" rwaccess="R">
		</bitfield>
		<bitfield id="UR" width="1" begin="2" end="2" resetval="0" description="User Read Permission                                                                                   UR = 0: User reads not allowed to this MMR region                                      UR = 1: User reads allowed to this MMR region                                            " range="" rwaccess="RW">
		</bitfield>
		<bitfield id="UW" width="1" begin="1" end="1" resetval="0" description="User Write Permission                                                                                   UW = 0: User writesnot allowed to this MMR region                                      UW = 1: User writes allowed to this MMR region                                            " range="" rwaccess="RW">
		</bitfield>
		<bitfield id="UX" width="1" begin="0" end="0" resetval="0" description="User Execute Permission (not applicable)                                                     This bit is hard-wired to 0 to indicate no User Execute Permission (because PSC does not check for VBUS data type vbus_dtype)                                                    " range="" rwaccess="R">
		</bitfield>
	</register>
</module>
