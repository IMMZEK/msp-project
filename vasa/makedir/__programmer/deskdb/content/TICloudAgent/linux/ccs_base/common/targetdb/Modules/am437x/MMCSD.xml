<?xml version="1.0" encoding="UTF-8" standalone="yes"?>


<module description="MMCSD" id="MMCSD">
  
  
  <register acronym="SD_SYSCONFIG" description="This register allows controlling various parameters of the OCP interface." id="SD_SYSCONFIG" offset="0x110" width="32">
    
  <bitfield begin="31" description=" " end="14" id="RESERVED_1" rwaccess="R" width="18"></bitfield>
    
  <bitfield begin="13" description=" Master interface power Management, standby/wait control. [[br]]The bit field is only useful when generic parameter MADMA_EN (Master ADMA enable) is set as active, otherwise it is a read only register read a 0. " end="12" id="STANDBYMODE" rwaccess="RW" width="2">
    <bitenum description="Smart-Standby wake-up-capable modelocal initiator standby status depends on local conditions, i.e. the module's functional requirement from the initiator. IP module can generate (master-related) wake-up events when in standby state. Mode is only relevant if the appropriate IP module &quot;mwake-up&quot; output is implemented. Functional clock is maintained. Interface clock may be switched off." id="en_4_0x3" token="en_4_0x3" value="0x3"></bitenum>
    <bitenum description="Smart-standby modelocal initiator standby status depends on local conditions, i.e. the module's functional requirement from the initiator. IP module shall not generate (initiator-related) wake-up events." id="en_3_0x2" token="en_3_0x2" value="0x2"></bitenum>
    <bitenum description="No-standby. Mstandby is never asserted." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="Force-standby. Mstandby is forced unconditionally." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="11" description=" " end="10" id="RESERVED_2" rwaccess="R" width="2"></bitfield>
    
  <bitfield begin="9" description=" Clocks activity during wake up mode period. [[br]]Bit 8 is the Interface clock. [[br]]Bit 9 is the Functional clock. " end="8" id="CLOCKACTIVITY" rwaccess="RW" width="2">
    <bitenum description="Interface and Functional clocks are maintained." id="en_4_0x3" token="en_4_0x3" value="0x3"></bitenum>
    <bitenum description="Functional clock is maintained. Interface clock may be switched-off." id="en_3_0x2" token="en_3_0x2" value="0x2"></bitenum>
    <bitenum description="Interface clock is maintained. Functional clock may be switched-off." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="Interface and Functional clock may be switched off." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="7" description=" " end="5" id="RESERVED_3" rwaccess="R" width="3"></bitfield>
    
  <bitfield begin="4" description=" Power management" end="3" id="SIDLEMODE" rwaccess="RW" width="2">
    <bitenum description="Reserved." id="en_4_0x3" token="en_4_0x3" value="0x3"></bitenum>
    <bitenum description="If an idle request is detected, the module will switch to wake up mode based on its internal activity, and the wake up capability can be used if the wake up capability is enabled (bit SD_SYSCONFIG[2] ENAWAKEUP bit is set to 1)." id="en_3_0x2" token="en_3_0x2" value="0x2"></bitenum>
    <bitenum description="If an idle request is detected, the request is ignored and the module keeps on behaving normally." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="If an idle request is detected, the MMC/SD/SDIO host controller acknowledges it unconditionally and goes in Inactive mode. Interrupt and DMA requests are unconditionally deasserted." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="2" description=" Wake-up feature control" end="2" id="ENAWAKEUP" rwaccess="RW" width="1">
    <bitenum description="Wake-up capability is enabled." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="Wake-up capability is disabled." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="1" description=" Software reset. [[br]]The bit is automatically reset by the hardware. [[br]]During reset, it always returns 0. " end="1" id="SOFTRESET" rwaccess="RW" width="1">
    <bitenum description="The module is reset." id="en_4_0x1" token="en_4_0x1" value="0x1"></bitenum>
    <bitenum description="Trigger a module reset." id="en_3_0x1" token="en_3_0x1" value="0x1"></bitenum>
    <bitenum description="Normal mode" id="en_2_0x0" token="en_2_0x0" value="0x0"></bitenum>
    <bitenum description="No effect" id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="0" description=" Internal Clock gating strategy" end="0" id="AUTOIDLE" rwaccess="RW" width="1">
    <bitenum description="Automatic clock gating strategy is applied, based on the interconnect and MMC interface activity." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="Clocks are free-running." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
  </register>
  
  
  <register acronym="SD_SYSSTATUS" description="This register provides status information about the module excluding the interrupt status information." id="SD_SYSSTATUS" offset="0x114" width="32">
    
  <bitfield begin="31" description=" " end="1" id="RESERVED_1" rwaccess="R" width="31"></bitfield>
    
  <bitfield begin="0" description=" Internal Reset Monitoring. [[br]]Note the debounce clock, the interface clock and the functional clock shall be provided to the MMC/SD/SDIO host controller to allow the internal reset monitoring. " end="0" id="RESETDONE" rwaccess="R" width="1">
    <bitenum description="Reset completed" id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="Internal module reset is on-going" id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
  </register>
  
  
  <register acronym="SD_CSRE" description="This register enables the host controller to detect card status errors of response type R1, R1b for all cards and of R5, R5b and R6 response for cards types SD or SDIO. When a bit SD_CSRE[i] is set to 1, if the corresponding bit at the same position in the response SD_RSP10[I] is set to 1, the host controller indicates a card error (SD_STAT[28] CERR bit) interrupt status to avoid the host driver reading the response register (SD_RSP10). No automatic card error detection for autoCMD12 is implemented; the host system has to check autoCMD12 response register (SD_RSP76) for possible card errors." id="SD_CSRE" offset="0x124" width="32">
    
  <bitfield begin="31" description=" Card status response error" end="0" id="CSRE" rwaccess="RW" width="32"></bitfield>
  </register>
  
  
  <register acronym="SD_SYSTEST" description="This register is used to control the signals that connect to I/O pins when the module is configured in system test (SYSTEST) mode for boundary connectivity verification. In SYSTEST mode, a write into SD_CMD register will not start a transfer. The buffer behaves as a stack accessible only by the local host (push and pop operations). In this mode, the Transfer Block Size (SD_BLK[10:0] BLEN bits) and the Blocks count for current transfer (SD_BLK[31:16] NBLK bits) are needed to generate a Buffer write ready interrupt (SD_STAT[4] BWR bit) or a Buffer read ready interrupt (SD_STAT[5] BRR bit) and DMA requests if enabled." id="SD_SYSTEST" offset="0x128" width="32">
    
  <bitfield begin="31" description=" " end="17" id="RESERVED_1" rwaccess="R" width="15"></bitfield>
    
  <bitfield begin="16" description=" Out-of-band interrupt (OBI) data value." end="16" id="OBI" rwaccess="RW" width="1">
    <bitenum description="The out-of-band interrupt pin is driven high." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="The out-of-band interrupt pin is driven low." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="15" description=" Card detect input signal (SDCD) data value" end="15" id="SDCD" rwaccess="RW" width="1">
    <bitenum description="The card detect pin is driven high." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="The card detect pin is driven low." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="14" description=" Write protect input signal (SDWP) data value" end="14" id="SDWP" rwaccess="RW" width="1">
    <bitenum description="The write protect pin SDWP is driven high." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="The write protect pin SDWP is driven low." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="13" description=" Wake request output signal data value." end="13" id="WAKD" rwaccess="RW" width="1">
    <bitenum description="No action. Returns 1." id="en_4_0x1" token="en_4_0x1" value="0x1"></bitenum>
    <bitenum description="The pin SWAKEUP is driven high." id="en_3_0x1" token="en_3_0x1" value="0x1"></bitenum>
    <bitenum description="No action. Returns 0." id="en_2_0x0" token="en_2_0x0" value="0x0"></bitenum>
    <bitenum description="The pin SWAKEUP is driven low." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="12" description=" Set status bit. [[br]]This bit must be cleared prior attempting to clear a status bit of the interrupt status register (SD_STAT). " end="12" id="SSB" rwaccess="RW" width="1">
    <bitenum description="No action. Returns 1." id="en_4_0x1" token="en_4_0x1" value="0x1"></bitenum>
    <bitenum description="Force to 1 all status bits of the interrupt status register (SD_STAT) only if the corresponding bit field in the Interrupt signal enable register (SD_ISE) is set." id="en_3_0x1" token="en_3_0x1" value="0x1"></bitenum>
    <bitenum description="No action. Returns 0." id="en_2_0x0" token="en_2_0x0" value="0x0"></bitenum>
    <bitenum description="Clear this SSB bit field. Writing 0 does not clear already set status bits." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="11" description=" DAT7 input/output signal data value." end="11" id="D7D" rwaccess="RW" width="1">
    <bitenum description="If SD_SYSTEST[3] DDIR bit = 1 (input mode direction), returns the value on the DAT7 line (high) If SD_SYSTEST[3] DDIR bit = 0 (output mode direction), returns 1." id="en_4_0x1" token="en_4_0x1" value="0x1"></bitenum>
    <bitenum description="If SD_SYSTEST[3] DDIR bit = 0 (output mode direction), the DAT7 line is driven high. If SD_SYSTEST[3] DDIR bit = 1 (input mode direction), no effect." id="en_3_0x1" token="en_3_0x1" value="0x1"></bitenum>
    <bitenum description="If SD_SYSTEST[3] DDIR bit = 0 (output mode direction), the DAT7 line is driven low. If SD_SYSTEST[3] DDIR bit = 1 (input mode direction), no effect." id="en_2_0x0" token="en_2_0x0" value="0x0"></bitenum>
    <bitenum description="If SD_SYSTEST[3] DDIR bit = 1 (input mode direction), returns the value on the DAT7 line (low). If SD_SYSTEST[3] DDIR bit = 0 (output mode direction), returns 0." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="10" description=" DAT6 input/output signal data value." end="10" id="D6D" rwaccess="RW" width="1">
    <bitenum description="If SD_SYSTEST[3] DDIR bit = 1 (input mode direction), returns the value on the DAT6 line (high) If SD_SYSTEST[3] DDIR bit = 0 (output mode direction), returns 1." id="en_4_0x1" token="en_4_0x1" value="0x1"></bitenum>
    <bitenum description="If SD_SYSTEST[3] DDIR bit = 0 (output mode direction), the DAT6 line is driven high. If SD_SYSTEST[3] DDIR bit = 1 (input mode direction), no effect." id="en_3_0x1" token="en_3_0x1" value="0x1"></bitenum>
    <bitenum description="If SD_SYSTEST[3] DDIR bit = 1 (input mode direction), returns the value on the DAT6 line (low). If SD_SYSTEST[3] DDIR bit = 0 (output mode direction), returns 0." id="en_2_0x0" token="en_2_0x0" value="0x0"></bitenum>
    <bitenum description="If SD_SYSTEST[3] DDIR bit = 0 (output mode direction), the DAT6 line is driven low. If SD_SYSTEST[3] DDIR bit = 1 (input mode direction), no effect." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="9" description=" DAT5 input/output signal data value." end="9" id="D5D" rwaccess="RW" width="1">
    <bitenum description="If SD_SYSTEST[3] DDIR bit = 1 (input mode direction), returns the value on the DAT5 line (high) If SD_SYSTEST[3] DDIR bit = 0 (output mode direction), returns 1." id="en_4_0x1" token="en_4_0x1" value="0x1"></bitenum>
    <bitenum description="If SD_SYSTEST[3] DDIR bit = 0 (output mode direction), the DAT5 line is driven high. If SD_SYSTEST[3] DDIR bit = 1 (input mode direction), no effect." id="en_3_0x1" token="en_3_0x1" value="0x1"></bitenum>
    <bitenum description="If SD_SYSTEST[3] DDIR bit = 0 (output mode direction), the DAT5 line is driven low. If SD_SYSTEST[3] DDIR bit = 1 (input mode direction), no effect." id="en_2_0x0" token="en_2_0x0" value="0x0"></bitenum>
    <bitenum description="If SD_SYSTEST[3] DDIR bit = 1 (input mode direction), returns the value on the DAT5 line (low). If SD_SYSTEST[3] DDIR bit = 0 (output mode direction), returns 0." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="8" description=" DAT4 input/output signal data value." end="8" id="D4D" rwaccess="RW" width="1">
    <bitenum description="If SD_SYSTEST[3] DDIR bit = 1 (input mode direction), returns the value on the DAT4 line (high) If SD_SYSTEST[3] DDIR bit = 0 (output mode direction), returns 1." id="en_4_0x1" token="en_4_0x1" value="0x1"></bitenum>
    <bitenum description="If SD_SYSTEST[3] DDIR bit = 0 (output mode direction), the DAT4 line is driven high. If SD_SYSTEST[3] DDIR bit = 1 (input mode direction), no effect." id="en_3_0x1" token="en_3_0x1" value="0x1"></bitenum>
    <bitenum description="If SD_SYSTEST[3] DDIR bit = 1 (input mode direction), returns the value on the DAT4 line (low). If SD_SYSTEST[3] DDIR bit = 0 (output mode direction), returns 0." id="en_2_0x0" token="en_2_0x0" value="0x0"></bitenum>
    <bitenum description="If SD_SYSTEST[3] DDIR bit = 0 (output mode direction), the DAT4 line is driven low. If SD_SYSTEST[3] DDIR bit = 1 (input mode direction), no effect." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="7" description=" DAT3 input/output signal data value." end="7" id="D3D" rwaccess="RW" width="1">
    <bitenum description="If SD_SYSTEST[3] DDIR bit = 0 (output mode direction), the DAT3 line is driven high. If SD_SYSTEST[3] DDIR bit = 1 (input mode direction), no effect." id="en_4_0x1" token="en_4_0x1" value="0x1"></bitenum>
    <bitenum description="If SD_SYSTEST[3] DDIR bit = 1 (input mode direction), returns the value on the DAT3 line (high) If SD_SYSTEST[3] DDIR bit = 0 (output mode direction), returns 1." id="en_3_0x1" token="en_3_0x1" value="0x1"></bitenum>
    <bitenum description="If SD_SYSTEST[3] DDIR bit = 1 (input mode direction), returns the value on the DAT3 line (low). If SD_SYSTEST[3] DDIR bit = 0 (output mode direction), returns 0." id="en_2_0x0" token="en_2_0x0" value="0x0"></bitenum>
    <bitenum description="If SD_SYSTEST[3] DDIR bit = 0 (output mode direction), the DAT3 line is driven low. If SD_SYSTEST[3] DDIR bit = 1 (input mode direction), no effect." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="6" description=" DAT2 input/output signal data value." end="6" id="D2D" rwaccess="RW" width="1">
    <bitenum description="If SD_SYSTEST[3] DDIR bit = 0 (output mode direction), the DAT2 line is driven high. If SD_SYSTEST[3] DDIR bit = 1 (input mode direction), no effect." id="en_4_0x1" token="en_4_0x1" value="0x1"></bitenum>
    <bitenum description="If SD_SYSTEST[3] DDIR bit = 1 (input mode direction), returns the value on the DAT2 line (high) If SD_SYSTEST[3] DDIR bit = 0 (output mode direction), returns 1." id="en_3_0x1" token="en_3_0x1" value="0x1"></bitenum>
    <bitenum description="If SD_SYSTEST[3] DDIR bit = 1 (input mode direction), returns the value on the DAT2 line (low). If SD_SYSTEST[3] DDIR bit = 0 (output mode direction), returns 0." id="en_2_0x0" token="en_2_0x0" value="0x0"></bitenum>
    <bitenum description="If SD_SYSTEST[3] DDIR bit = 0 (output mode direction), the DAT2 line is driven low. If SD_SYSTEST[3] DDIR bit = 1 (input mode direction), no effect." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="5" description=" DAT1 input/output signal data value." end="5" id="D1D" rwaccess="RW" width="1">
    <bitenum description="If SD_SYSTEST[3] DDIR bit = 0 (output mode direction), the DAT1 line is driven high. If SD_SYSTEST[3] DDIR bit = 1 (input mode direction), no effect." id="en_4_0x1" token="en_4_0x1" value="0x1"></bitenum>
    <bitenum description="If SD_SYSTEST[3] DDIR bit = 1 (input mode direction), returns the value on the DAT1 line (high) If SD_SYSTEST[3] DDIR bit = 0 (output mode direction), returns 1." id="en_3_0x1" token="en_3_0x1" value="0x1"></bitenum>
    <bitenum description="If SD_SYSTEST[3] DDIR bit = 1 (input mode direction), returns the value on the DAT1 line (low). If SD_SYSTEST[3] DDIR bit = 0 (output mode direction), returns 0." id="en_2_0x0" token="en_2_0x0" value="0x0"></bitenum>
    <bitenum description="If SD_SYSTEST[3] DDIR bit = 0 (output mode direction), the DAT1 line is driven low. If SD_SYSTEST[3] DDIR bit = 1 (input mode direction), no effect." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="4" description=" DAT0 input/output signal data value." end="4" id="D0D" rwaccess="RW" width="1">
    <bitenum description="If SD_SYSTEST[3] DDIR bit = 0 (output mode direction), the DAT0 line is driven high. If SD_SYSTEST[3] DDIR bit = 1 (input mode direction), no effect." id="en_4_0x1" token="en_4_0x1" value="0x1"></bitenum>
    <bitenum description="If SD_SYSTEST[3] DDIR bit = 1 (input mode direction), returns the value on the DAT0 line (high) If SD_SYSTEST[3] DDIR bit = 0 (output mode direction), returns 1." id="en_3_0x1" token="en_3_0x1" value="0x1"></bitenum>
    <bitenum description="If SD_SYSTEST[3] DDIR bit = 1 (input mode direction), returns the value on the DAT0 line (low). If SD_SYSTEST[3] DDIR bit = 0 (output mode direction), returns 0." id="en_2_0x0" token="en_2_0x0" value="0x0"></bitenum>
    <bitenum description="If SD_SYSTEST[3] DDIR bit = 0 (output mode direction), the DAT0 line is driven low. If SD_SYSTEST[3] DDIR bit = 1 (input mode direction), no effect." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="3" description=" Control of the DAT[[br]][7:0] pins direction. " end="3" id="DDIR" rwaccess="RW" width="1">
    <bitenum description="No action. Returns 1." id="en_4_0x1" token="en_4_0x1" value="0x1"></bitenum>
    <bitenum description="The DAT lines are inputs (card to host)." id="en_3_0x1" token="en_3_0x1" value="0x1"></bitenum>
    <bitenum description="No action. Returns 0." id="en_2_0x0" token="en_2_0x0" value="0x0"></bitenum>
    <bitenum description="The DAT lines are outputs (host to card)." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="2" description=" CMD input/output signal data value" end="2" id="CDAT" rwaccess="RW" width="1">
    <bitenum description="If SD_SYSTEST[1] CDIR bit = 0 (output mode direction), the CMD line is driven high. If SD_SYSTEST[1] CDIR bit = 1 (input mode direction), no effect." id="en_4_0x1" token="en_4_0x1" value="0x1"></bitenum>
    <bitenum description="If SD_SYSTEST[1] CDIR bit = 1 (input mode direction), returns the value on the CMD line (high) If SD_SYSTEST[1] CDIR bit = 0 (output mode direction), returns 1 ." id="en_3_0x1" token="en_3_0x1" value="0x1"></bitenum>
    <bitenum description="If SD_SYSTEST[1] CDIR bit = 0 (output mode direction), the CMD line is driven low. If SD_SYSTEST[1] CDIR bit = 1 (input mode direction), no effect." id="en_2_0x0" token="en_2_0x0" value="0x0"></bitenum>
    <bitenum description="If SD_SYSTEST[1] CDIR bit = 1 (input mode direction), returns the value on the CMD line (low). If SD_SYSTEST[1] CDIR bit = 0 (output mode direction), returns 0 ." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="1" description=" Control of the CMD pin direction" end="1" id="CDIR" rwaccess="RW" width="1">
    <bitenum description="The CMD line is an input (card to host) ." id="en_4_0x1" token="en_4_0x1" value="0x1"></bitenum>
    <bitenum description="No action. Returns 1." id="en_3_0x1" token="en_3_0x1" value="0x1"></bitenum>
    <bitenum description="No action. Returns 0." id="en_2_0x0" token="en_2_0x0" value="0x0"></bitenum>
    <bitenum description="The CMD line is an output (host to card)." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="0" description=" MMC clock output signal data value" end="0" id="MCKD" rwaccess="RW" width="1">
    <bitenum description="No action. Returns 1." id="en_4_0x1" token="en_4_0x1" value="0x1"></bitenum>
    <bitenum description="The output clock is driven high." id="en_3_0x1" token="en_3_0x1" value="0x1"></bitenum>
    <bitenum description="No action. Returns 0." id="en_2_0x0" token="en_2_0x0" value="0x0"></bitenum>
    <bitenum description="The output clock is driven low." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
  </register>
  
  
  <register acronym="SD_CON" description="This register is used: To select the functional mode for any card. To send an initialization sequence to any card. To send an initialization sequence to any card. To enable the detection on the mmc_dat[1] signal of a card interrupt for SDIO cards only. It also configures the parameters related to the card detect and write protect input signals" id="SD_CON" offset="0x12C" width="32">
    
  <bitfield begin="31" description=" " end="22" id="RESERVED_1" rwaccess="R" width="10"></bitfield>
    
  <bitfield begin="21" description=" Slave DMA Level/Edge Request. [[br]]The waveform of the DMA request can be configured either edge sensitive with early de-assertion on first access to SD_DATA register or late de-assertion, request remains active until last allowed data written into SD_DATA. [[br]] " end="21" id="SDMA_LnE" rwaccess="RW" width="1">
    <bitenum description="Slave DMA level sensitive." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="Slave DMA edge sensitive." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="20" description=" DMA Master or Slave selection. [[br]]When this bit is set and the controller is configured to use the DMA, Ocp master interface is used to get datas from system using ADMA2 procedure (direct access to the memory). [[br]]This option is only available if generic parameter MADMA_EN is asserted to 1. [[br]] " end="20" id="DMA_MnS" rwaccess="RW" width="1">
    <bitenum description="Not available on this device." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="The controller is slave on data transfers with system." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="19" description=" Dual Data Rate mode. [[br]]When this register is set, the controller uses both clock edge to emit or receive data. [[br]]Odd bytes are transmitted on falling edges and even bytes are transmitted on rise edges. [[br]]It only applies on Data bytes and CRC, Start, end bits and CRC status are kept full cycle. [[br]]This bit field is only meaningful and active for even clock divider ratio of SD_SYSCTL[CLKD], it is insensitive to SD_HCTL[HSPE] setting. [[br]]Note: DDR mode is not supported on this device. [[br]]Always set this bit to 0. " end="19" id="DDR" rwaccess="RW" width="1">
    <bitenum description="Data Bytes and CRC are transmitted on both edges." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="Standard modeData are transmitted on a single edge." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="18" description=" Boot Status Supported. [[br]]This register is set when the CMD line needs to be forced to 0 for a boot sequence. [[br]]CMD line is driven to 0 after writing in SD_CMD. [[br]]The line is released when this bit field is de-asserted and aborts data transfer in case of a pending transaction. [[br]] " end="18" id="BOOT_CF0" rwaccess="RW" width="1">
    <bitenum description="CMD line forced to 0 is enabled and will be active after writing into SD_CMD register." id="en_4_0x1" token="en_4_0x1" value="0x1"></bitenum>
    <bitenum description="CMD line is released when it was previously forced to 0 by a boot sequence." id="en_3_0x1" token="en_3_0x1" value="0x1"></bitenum>
    <bitenum description="CMD line forced to 0 is enabled." id="en_2_0x0" token="en_2_0x0" value="0x0"></bitenum>
    <bitenum description="CMD line not forced." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="17" description=" Book acknowledge received. [[br]]When this bit is set the controller should receive a boot status on DAT0 line after next command issued. [[br]]If no status is received a data timeout will be generated. " end="17" id="BOOT_ACK" rwaccess="RW" width="1">
    <bitenum description="A boot status will be received on DAT0 line after issuing a command." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="No acknowledge to be received." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="16" description=" External clock free running. [[br]]This register is used to maintain card clock out of transfer transaction to enable slave module (for example to generate a synchronous interrupt on mmc_dat[1] ). [[br]]The Clock will be maintain only if SD_SYSCTL[2] CEN bit is set. " end="16" id="CLKEXTFREE" rwaccess="RW" width="1">
    <bitenum description="External card clock is maintain even out of active transaction period only if SD_SYSCTL[2] CEN bit is set." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="External card clock is cut off outside active transaction period." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="15" description=" Control power for MMC lines. [[br]]This register is only useful when MMC PADs contain power saving mechanism to minimize its leakage power. [[br]]It works as a GPIO that directly control the ACTIVE pin of PADs. [[br]]Excepted for mmc_dat[1] , the signal is also combine outside the module with the dedicated power control SD_CON[11] CTPL bit. " end="15" id="PADEN" rwaccess="RW" width="1">
    <bitenum description="ADPIDLE module pin is forced to active state" id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="ADPIDLE module pin is not forced, it is automatically generated by the MMC fsms." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="14" description=" " end="13" id="RESERVED_2" rwaccess="R" width="2"></bitfield>
    
  <bitfield begin="12" description=" CE-ATA control mode (MMC cards compliant with CE-ATA). [[br]]This bit selects the active level of the out-of-band interrupt coming from MMC cards. [[br]]The usage of the Out-of-Band signal (OBI) is not supported. " end="12" id="CEATA" rwaccess="RW" width="1">
    <bitenum description="CE-ATA mode. Next commands are considered as CE-ATA commands." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="Standard MMC/SD/SDIO mode." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="11" description=" Control Power for mmc_dat[1] line (SD cards). [[br]]By default, this bit is cleared to 0 and the host controller automatically disables all the input buffers outside of a transaction to minimize the leakage current. [[br]]SDIO cards. [[br]]When this bit is set to 1, the host controller automatically disables all the input buffers except the buffer of mmc_dat[1] outside of a transaction in order to detect asynchronous card interrupt on mmc_dat[1] line and minimize the leakage current of the buffers. " end="11" id="CTPL" rwaccess="RW" width="1">
    <bitenum description="Disable all the input buffers except the buffer of mmc_dat[1] outside of a transaction." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="Disable all the input buffers outside of a transaction." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="10" description=" Debounce filter value (all cards). [[br]]This register is used to define a debounce period to filter the card detect input signal (SDCD). [[br]]The usage of the card detect input signal (SDCD) is optional and depends on the system integration and the type of the connector housing that accommodates the card. " end="9" id="DVAL" rwaccess="RW" width="2">
    <bitenum description="8.4 ms debounce period" id="en_4_0x3" token="en_4_0x3" value="0x3"></bitenum>
    <bitenum description="1 ms debounce period" id="en_3_0x2" token="en_3_0x2" value="0x2"></bitenum>
    <bitenum description="231 us debounce period" id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="33 us debounce period" id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="8" description=" Write protect polarity (SD and SDIO cards only). [[br]]This bit selects the active level of the write protect input signal (SDWP). [[br]]The usage of the write protect input signal (SDWP) is optional and depends on the system integration and the type of the connector housing that accommodates the card. " end="8" id="WPP" rwaccess="RW" width="1">
    <bitenum description="Active low level" id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="Active high level" id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="7" description=" Card detect polarity (all cards). [[br]]This bit selects the active level of the write protect input signal (SDWP). [[br]]The usage of the write protect input signal (SDWP) is optional and depends on the system integration and the type of the connector housing that accommodates the card. " end="7" id="CDP" rwaccess="RW" width="1">
    <bitenum description="Active low level" id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="Active high level" id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="6" description=" MMC interrupt command (MMC cards only). [[br]]This bit must be set to 1, when the next write access to the command register (SD_CMD) is for writing a MMC interrupt command (CMD40) requiring the command timeout detection to be disabled for the command response. " end="6" id="MIT" rwaccess="RW" width="1">
    <bitenum description="Command timeout disabled." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="Command timeout enabled." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="5" description=" [[br]]8-bit mode MMC select (MMC cards only). [[br]]For SD/SDIO cards, this bit must be cleared to 0. [[br]]For MMC card, this bit must be set following a valid SWITCH command (CMD6) with the correct value and extend CSD index written in the argument. [[br]]Prior to this command, the MMC card configuration register (CSD and EXT_CSD) must be verified for compliancy with MMC standard specification. " end="5" id="DW8" rwaccess="RW" width="1">
    <bitenum description="8-bit data width" id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="1-bit or 4-bit data width" id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="4" description=" Mode select (all cards). [[br]]This bit selects the functional mode. " end="4" id="MODE" rwaccess="RW" width="1">
    <bitenum description="SYSTEST mode. SYSTEST mode. The signal pins are configured as general-purpose input/output and the 1024-byte buffer is configured as a stack memory accessible only by the local host or system DMA. The pins retain their default type (input, output or in-out). SYSTEST mode is operated under the control of the SYSTEST register." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="Functional mode. Transfers to the MMC/SD/SDIO cards follow the card protocol. The MMC clock is enabled. MMC/SD transfers are operated under the control of the SD_CMD register." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="3" description=" Stream command (MMC cards only). [[br]]This bit must be set to 1 only for the stream data transfers (read or write) of the adtc commands. [[br]]Stream read is a class 1 command (CMD11READ_DAT_UNTIL_STOP). [[br]]Stream write is a class 3 command (CMD20WRITE_DAT_UNTIL_STOP). " end="3" id="STR" rwaccess="RW" width="1">
    <bitenum description="Stream oriented data transfer" id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="Block oriented data transfer" id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="2" description=" Broadcast host response (MMC cards only). [[br]]This register is used to force the host to generate a [[br]]48-bit response for bc command type. [[br]]It can be used to terminate the interrupt mode by generating a CMD40 response by the core. [[br]]In order to have the host response to be generated in open drain mode, the register SD_CON[OD] must be set to 1. [[br]]When SD_CON[12] CEATA bit is set to 1 and SD_ARG cleared to 0, when writing 0000 0000h into SD_CMD register, the host controller performs a 'command completion signal disable' token (i.e., mmc_cmd line held to 0 during 47 cycles followed by a 1). " end="2" id="HR" rwaccess="RW" width="1">
    <bitenum description="The host generates a 48-bit response instead of a command or a command completion signal disable token." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="The host does not generate a 48-bit response instead of a command." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="1" description=" Send initialization stream (all cards). [[br]]When this bit is set to 1, and the card is idle, an initialization sequence is sent to the card. [[br]]An initialization sequence consists of setting the mmc_cmd line to 1 during 80 clock cycles. [[br]]The initialization sequence is mandatory - but it is not required to do it through this bit - this bit makes it easier. [[br]]Clock divider (SD_SYSCTL[[br]][15:6] CLKD bits) should be set to ensure that 80 clock periods are greater than 1ms. [[br]]Note: In this mode, there is no command sent to the card and no response is expected. [[br]]A command complete interrupt will be generated once the initialization sequence is completed. [[br]]SD_STAT[0] CC bit can be polled. " end="1" id="INIT" rwaccess="RW" width="1">
    <bitenum description="The host sends an initialization sequence" id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="The host does not send an initialization sequence" id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="0" description=" Card open drain mode (MMC cards only). [[br]]This bit must be set to 1 for MMC card commands 1, 2, 3 and 40, and if the MMC card bus is operating in open-drain mode during the response phase to the command sent. [[br]]Typically, during card identification mode when the card is either in idle, ready or ident state. [[br]]It is also necessary to set this bit to 1, for a broadcast host response (see Broadcast host response register SD_CON[2] HR bit). " end="0" id="OD" rwaccess="RW" width="1">
    <bitenum description="Open drain or broadcast host response" id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="No open drain" id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
  </register>
  
  
  <register acronym="SD_PWCNT" description="This register is used to program a mmc counter to delay command transfers after activating the PAD power, this value depends on PAD characteristics and voltage." id="SD_PWCNT" offset="0x130" width="32">
    
  <bitfield begin="31" description=" " end="16" id="RESERVED_1" rwaccess="R" width="16"></bitfield>
    
  <bitfield begin="15" description=" Power counter register. [[br]]This register is used to introduce a delay between the PAD ACTIVE pin assertion and the command issued. " end="0" id="PWRCNT" rwaccess="RW" width="16">
    <bitenum description="TCF x 65535 delay (card clock period)" id="en_5_0xFFFF" token="en_5_0xFFFF" value="0xFFFF"></bitenum>
    <bitenum description="TCF x 65534 delay (card clock period)" id="en_4_0xFFFE" token="en_4_0xFFFE" value="0xFFFE"></bitenum>
    <bitenum description="TCF x 2 delay (card clock period)" id="en_3_0x2" token="en_3_0x2" value="0x2"></bitenum>
    <bitenum description="TCF delay (card clock period)" id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="No additional delay added" id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
  </register>
  
  
  <register acronym="SD_SDMASA" description="This register is used to program a mmc counter to delay command transfers after activating the PAD power. This value depends on PAD characteristics and voltage." id="SD_SDMASA" offset="0x200" width="32">
    
  <bitfield begin="31" description=" This register contains the system memory address for a SDMA transfer. [[br]]When the Host Controller stops a SDMA transfer, this register shall point to the system address of the next contiguous data position. [[br]]It can be accessed only if no transaction is executing (i.e., after a transaction has stopped). [[br]]Read operations during transfers may return an invalid value. [[br]]The Host Driver shall initialize this register before starting a SDMA transaction. [[br]]After SDMA has stopped, the next system address of the next contiguous data position can be read from this register. [[br]]The SDMA transfer waits at the every boundary specified by the Host SDMA Buffer Boundary in the Block Size register. [[br]]The Host Controller generates DMA Interrupt to request the Host Driver to update this register. [[br]]The Host Driver sets the next system address of the next data position to this register. [[br]]When the most upper byte of this register (003h) is written, the Host Controller restarts the SDMA transfer. [[br]]When restarting SDMA by the Resume command or by setting Continue Request in the Block Gap Control register, the Host Controller shall start at the next contiguous address stored here in the SDMA System Address register. [[br]]ADMA does not use this register." end="0" id="SDMA_SYSADDR" rwaccess="R" width="32"></bitfield>
  </register>
  
  
  <register acronym="SD_BLK" description="This register shall be used for any card. SD_BLK[BLEN] is the block size register. SD_BLK[NBLK] is the block count register." id="SD_BLK" offset="0x204" width="32">
    
  <bitfield begin="31" description=" Blocks count for current transfer. [[br]]This register is enabled when Block count Enable (SD_CMD[1] BCE bit) is set to 1 and is valid only for multiple block transfers. [[br]]Setting the block count to 0 results no data blocks being transferred. [[br]]Note: The host controller decrements the block count after each block transfer and stops when the count reaches zero. [[br]]This register can be accessed only if no transaction is executing (i.e., after a transaction has stopped). [[br]]Read operations during transfers may return an invalid value and write operation will be ignored. [[br]]In suspend context, the number of blocks yet to be transferred can be determined by reading this register. [[br]]When restoring transfer context prior to issuing a Resume command, The local host shall restore the previously saved block count. " end="16" id="NBLK" rwaccess="RW" width="16">
    <bitenum description="65535 blocks" id="en_4_0xFFFF" token="en_4_0xFFFF" value="0xFFFF"></bitenum>
    <bitenum description="2 blocks" id="en_3_0x2" token="en_3_0x2" value="0x2"></bitenum>
    <bitenum description="1 block" id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="Stop count" id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="15" description=" " end="12" id="RESERVED_1" rwaccess="R" width="4"></bitfield>
    
  <bitfield begin="11" description=" Transfer block size. [[br]]This register specifies the block size for block data transfers. [[br]]Read operations during transfers may return an invalid value, and write operations are ignored. [[br]]When a CMD12 command is issued to stop the transfer, a read of the BLEN field after transfer completion (SD_STAT[1] TC bit set to 1) will not return the true byte number of data length while the stop occurs but the value written in this register before transfer is launched. " end="0" id="BLEN" rwaccess="RW" width="12">
    <bitenum description="2048 bytes block length" id="en_8_0x800" token="en_8_0x800" value="0x800"></bitenum>
    <bitenum description="2047 bytes block length" id="en_7_0x7FF" token="en_7_0x7FF" value="0x7FF"></bitenum>
    <bitenum description="512 bytes block length" id="en_6_0x200" token="en_6_0x200" value="0x200"></bitenum>
    <bitenum description="511 bytes block length" id="en_5_0x1FF" token="en_5_0x1FF" value="0x1FF"></bitenum>
    <bitenum description="3 bytes block length" id="en_4_0x3" token="en_4_0x3" value="0x3"></bitenum>
    <bitenum description="2 bytes block length" id="en_3_0x2" token="en_3_0x2" value="0x2"></bitenum>
    <bitenum description="1 byte block length" id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="No data transfer" id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
  </register>
  
  
  <register acronym="SD_ARG" description="This register contains command argument specified as bit 39-8 of Command-Format. These registers must be initialized prior to sending the command itself to the card (write action into the register SD_CMD register). Only exception is for a command index specifying stuff bits in arguments, making a write unnecessary." id="SD_ARG" offset="0x208" width="32">
    
  <bitfield begin="31" description=" Command argument bits [31:0] ." end="0" id="ARG" rwaccess="RW" width="32"></bitfield>
  </register>
  
  
  <register acronym="SD_CMD" description="SD_CMD[31:16] = the command register. SD_CMD[15:0] = the transfer mode. This register configures the data and command transfers. A write into the most significant byte send the command. A write into SD_CMD[15:0] registers during data transfer has no effect. This register can be used for any card. In SYSTEST mode, a write into SD_CMD register will not start a transfer." id="SD_CMD" offset="0x20C" width="32">
    
  <bitfield begin="31" description=" " end="30" id="RESERVED_1" rwaccess="R" width="2"></bitfield>
    
  <bitfield begin="29" description=" Command index binary encoded value from 0 to 63 specifying the command number send to card (CMD0 or ACMD0 to CMD63 or ACMD63)." end="24" id="INDX" rwaccess="RW" width="6"></bitfield>
    
  <bitfield begin="23" description=" Command type. [[br]]This register specifies three types of special commands: Suspend, Resume and Abort. [[br]]These bits shall be cleared to 0b00 for all other commands. " end="22" id="CMD_TYPE" rwaccess="RW" width="2">
    <bitenum description="Upon CMD12 or CMD52 &quot;I/O Abort&quot; command" id="en_4_0x3" token="en_4_0x3" value="0x3"></bitenum>
    <bitenum description="Upon CMD52 &quot;Function Select&quot; operation" id="en_3_0x2" token="en_3_0x2" value="0x2"></bitenum>
    <bitenum description="Upon CMD52 &quot;Bus Suspend&quot; operation" id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="Others commands" id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="21" description=" Data present select. [[br]]This register indicates that data is present and mmc_dat line shall be used. [[br]]It must be cleared to 0 in the following conditions: Command using only mmc_cmd line. [[br]]Command with no data transfer but using busy signal on mmc_dat0. [[br]]Resume command. " end="21" id="DP" rwaccess="RW" width="1">
    <bitenum description="Command with data transfer" id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="Command with no data transfer" id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="20" description=" Command Index check enable. [[br]]This bit must be set to 1 to enable index check on command response to compare the index field in the response against the index of the command. [[br]]If the index is not the same in the response as in the command, it is reported as a command index error (SD_STAT[19] CIE bit set to1) Note: The CICE bit cannot be configured for an Auto CMD12, then index check is automatically checked when this command is issued. " end="20" id="CICE" rwaccess="RW" width="1">
    <bitenum description="Index check enable" id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="Index check disable" id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="19" description=" Command CRC check enable. [[br]]This bit must be set to 1 to enable CRC7 check on command response to protect the response against transmission errors on the bus. [[br]]If an error is detected, it is reported as a command CRC error (SD_STAT[17] CCRC bit set to 1). [[br]]Note: The CCCE bit cannot be configured for an Auto CMD12, and then CRC check is automatically checked when this command is issued. " end="19" id="CCCE" rwaccess="RW" width="1">
    <bitenum description="CRC7 check enable" id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="CRC7 check disable" id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="18" description=" " end="18" id="RESERVED_2" rwaccess="R" width="1"></bitfield>
    
  <bitfield begin="17" description=" Response type. [[br]]This bits defines the response type of the command. " end="16" id="RSP_TYPE" rwaccess="RW" width="2">
    <bitenum description="Response Length 48 bits with busy after response" id="en_4_0x3" token="en_4_0x3" value="0x3"></bitenum>
    <bitenum description="Response Length 48 bits" id="en_3_0x2" token="en_3_0x2" value="0x2"></bitenum>
    <bitenum description="Response Length 136 bits" id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="No response" id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="15" description=" " end="6" id="RESERVED_3" rwaccess="R" width="10"></bitfield>
    
  <bitfield begin="5" description=" Multi/Single block select. [[br]]This bit must be set to 1 for data transfer in case of multi block command. [[br]]For any others command this bit shall be cleared to 0. " end="5" id="MSBS" rwaccess="RW" width="1">
    <bitenum description="Multi block. When Block Count is disabled (SD_CMD[1] BCE bit is cleared to 0) in Multiple block transfers (SD_CMD[5] MSBS bit is set to 1), the module can perform infinite transfer." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="Single block. If this bit is 0, it is not necessary to set the register SD_BLK[31:16] NBLK bits." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="4" description=" Data transfer Direction. [[br]]Select This bit defines either data transfer will be a read or a write. " end="4" id="DDIR" rwaccess="RW" width="1">
    <bitenum description="Data Read (card to host)" id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="Data Write (host to card)" id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="3" description=" " end="3" id="RESERVED_4" rwaccess="R" width="1"></bitfield>
    
  <bitfield begin="2" description=" Auto CMD12 Enable (SD cards only). [[br]]When this bit is set to 1, the host controller issues a CMD12 automatically after the transfer completion of the last block. [[br]]The Host Driver shall not set this bit to issue commands that do not require CMD12 to stop data transfer. [[br]]In particular, secure commands do not require CMD12. [[br]]For CE-ATA commands (SD_CON[12] CEATA bit set to 1), auto CMD12 is useless[[br]] therefore when this bit is set the mechanism to detect command completion signal, named CCS, interrupt is activated. " end="2" id="ACEN" rwaccess="RW" width="1">
    <bitenum description="Auto CMD12 enable or CCS detection enabled." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="Auto CMD12 disable" id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="1" description=" Block Count Enable (Multiple block transfers only). [[br]]This bit is used to enable the block count register (SD_BLK[[br]][31:16] NBLK bits). [[br]]When Block Count is disabled (SD_CMD[1] BCE bit is cleared to 0) in Multiple block transfers (SD_CMD[5] MSBS bits is set to 1), the module can perform infinite transfer. " end="1" id="BCE" rwaccess="RW" width="1">
    <bitenum description="Block count enabled for multiple block transfer with known number of blocks" id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="Block count disabled for infinite transfer." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="0" description=" DMA Enable. [[br]]This bit is used to enable DMA mode for host data access. " end="0" id="DE" rwaccess="RW" width="1">
    <bitenum description="DMA mode enable" id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="DMA mode disable" id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
  </register>
  
  
  <register acronym="SD_RSP10" description="This 32-bit register holds bits positions [31:0] of command response type R1, R1b, R2, R3, R4, R5, R5b, or R6." id="SD_RSP10" offset="0x210" width="32">
    
  <bitfield begin="31" description=" Command Response [[br]][31:16]" end="16" id="RSP1" rwaccess="R" width="16"></bitfield>
    
  <bitfield begin="15" description=" Command Response [[br]][15:0]" end="0" id="RSP0" rwaccess="R" width="16"></bitfield>
  </register>
  
  
  <register acronym="SD_RSP32" description="This 32-bit register holds bits positions [63:32] of command response type R2." id="SD_RSP32" offset="0x214" width="32">
    
  <bitfield begin="31" description=" Command Response [[br]][63:48]" end="16" id="RSP3" rwaccess="R" width="16"></bitfield>
    
  <bitfield begin="15" description=" Command Response [[br]][47:32]" end="0" id="RSP2" rwaccess="R" width="16"></bitfield>
  </register>
  
  
  <register acronym="SD_RSP54" description="This 32-bit register holds bits positions [95:64] of command response type R2." id="SD_RSP54" offset="0x218" width="32">
    
  <bitfield begin="31" description=" Command Response [[br]][95:80]" end="16" id="RSP5" rwaccess="R" width="16"></bitfield>
    
  <bitfield begin="15" description=" Command Response [[br]][79:64]" end="0" id="RSP4" rwaccess="R" width="16"></bitfield>
  </register>
  
  
  <register acronym="SD_RSP76" description="This 32-bit register holds bits positions [127:96] of command response type R2." id="SD_RSP76" offset="0x21C" width="32">
    
  <bitfield begin="31" description=" Command Response [[br]][127:112]" end="16" id="RSP7" rwaccess="R" width="16"></bitfield>
    
  <bitfield begin="15" description=" Command Response [[br]][111:96]" end="0" id="RSP6" rwaccess="R" width="16"></bitfield>
  </register>
  
  
  <register acronym="SD_DATA" description="This register is the 32-bit entry point of the buffer for read or write data transfers. The buffer size is 32bitsx256(1024 bytes). Bytes within a word are stored and read in little endian format. This buffer can be used as two 512 byte buffers to transfer data efficiently without reducing the throughput. Sequential and contiguous access is necessary to increment the pointer correctly. Random or skipped access is not allowed. In little endian, if the local host accesses this register byte-wise or 16bit-wise, the least significant byte (bits [7:0]) must always be written/read first. The update of the buffer address is done on the most significant byte write for full 32-bit DATA register or on the most significant byte of the last word of block transfer. Example 1Byte or 16-bit access: Mbyteen[3:0]=0001 (1-byte) => Mbyteen[3:0]=0010 (1-byte) => Mbyteen[3:0]=1100 (2-bytes) OK. Mbyteen[3:0]=0001 (1-byte) => Mbyteen[3:0]=0010 (1-byte) => Mbyteen[3:0]=0100 (1-byte) OK. Mbyteen[3:0]=0001 (1-byte) => Mbyteen[3:0]=0010 (1-byte) => Mbyteen[3:0]=1000 (1-byte) Bad." id="SD_DATA" offset="0x220" width="32">
    
  <bitfield begin="31" description=" Data register [31:0]. [[br]]In functional mode (SD_CON[4] MODE bit set to the default value 0): A read access to this register is allowed only when the buffer read enable status is set to 1 (SD_PSTATE[11] BRE bit), otherwise a bad access (SD_STAT[29] BADA bit) is signaled. [[br]]A write access to this register is allowed only when the buffer write enable status is set to 1 (SD_PSTATE[10] BWE bit), otherwise a bad access (SD_STAT[29] BADA bit) is signaled and the data is not written." end="0" id="DATA" rwaccess="RW" width="32"></bitfield>
  </register>
  
  
  <register acronym="SD_PSTATE" description="The Host can get the status of the Host controller from this 32-bit read only register." id="SD_PSTATE" offset="0x224" width="32">
    
  <bitfield begin="31" description=" " end="25" id="RESERVED_1" rwaccess="R" width="7"></bitfield>
    
  <bitfield begin="24" description=" mmc_cmd line signal level. [[br]]This status is used to check the mmc_cmd line level to recover from errors, and for debugging. [[br]]The value of this register after reset depends on the mmc_cmd line level at that time. " end="24" id="CLEV" rwaccess="R" width="1">
    <bitenum description="The mmc_cmd line level is 1." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="The mmc_cmd line level is 0." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="23" description=" mmc_dat[[br]][3:0] line signal level mmc_dat3 equal to or greater than bit 23. [[br]]mmc_dat2 equal to or greater than bit 22. [[br]]mmc_dat1 equal to or greater than bit 21. [[br]]mmc_dat0 equal to or greater than bit 20. [[br]]This status is used to check mmc_dat line level to recover from errors, and for debugging. [[br]]This is especially useful in detecting the busy signal level from mmc_dat0 . [[br]]The value of these registers after reset depends on the mmc_dat lines level at that time." end="20" id="DLEV" rwaccess="R" width="4"></bitfield>
    
  <bitfield begin="19" description=" Write Protect. [[br]]MMC/SD/SDIO1 only. [[br]]SDIO cards only. [[br]]This bit reflects the write protect input pin (SDWP) level. [[br]]The value of this register after reset depends one the protect input pin (SDWP) level at that time. [[br]] " end="19" id="WP" rwaccess="R" width="1">
    <bitenum description="If SD_CON[8] WPP is cleared to 0 (default), the card is not write protected, otherwise the card is write protected." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="If SD_CON[8] WPP is cleared to 0 (default), the card is write protected, otherwise the card is not write protected." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="18" description=" Card Detect Pin Level. [[br]]MMC/SD/SDIO1 only. [[br]]SDIO cards only. [[br]]This bit reflects the inverse value of the card detect input pin (SDCD). [[br]]Debouncing is not performed on this bit and is valid only when Card State is stable. [[br]](SD_PSTATE[17] is set to 1). [[br]]This bit must be debounced by software. [[br]]The value of this register after reset depends on the card detect input pin (SDCD) level at that time. [[br]] " end="18" id="CDPL" rwaccess="R" width="1">
    <bitenum description="The value of the card detect input pin (SDCD) is 0." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="The value of the card detect input pin (SDCD) is 1." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="17" description=" Card State Stable. [[br]]This bit is used for testing. [[br]]It is set to 1 only when Card Detect Pin Level is stable (SD_PSTATE[18] CPDL). [[br]]Debouncing is performed on the card detect input pin (SDCD) to detect card stability. [[br]]This bit is not affected by software reset. [[br]] " end="17" id="CSS" rwaccess="R" width="1">
    <bitenum description="Reset or Debouncing." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="Reset or Debouncing." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="16" description=" Card inserted. [[br]]This bit is the debounced value of the card detect input pin (SDCD). [[br]]An inactive to active transition of the card detect input pin (SDCD) will generate a card insertion interrupt (SD_STAT[CINS]). [[br]]A active to inactive transition of the card detect input pin (SDCD) will generate a card removal interrupt (SD_STAT[REM]). [[br]]This bit is not affected by a software reset. [[br]] " end="16" id="CINS" rwaccess="R" width="1">
    <bitenum description="If SD_CON[CDP] is cleared to 0 (default), the card has been inserted from the card slot. If SD_CON[CDP] is set to 1, no card is detected. The card may have been removed from the card slot." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="If SD_CON[CDP] is cleared to 0 (default), no card is detected. The card may have been removed from the card slot. If SD_CON[CDP] is set to 1, the card has been inserted." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="15" description=" " end="12" id="RESERVED_2" rwaccess="R" width="4"></bitfield>
    
  <bitfield begin="11" description=" Buffer read enable. [[br]]This bit is used for non-DMA read transfers. [[br]]It indicates that a complete block specified by SD_BLK[[br]][10:0] BLEN bits has been written in the buffer and is ready to be read. [[br]]It is cleared to 0 when the entire block is read from the buffer. [[br]]It is set to 1 when a block data is ready in the buffer and generates the Buffer read ready status of interrupt (SD_STAT[5] BRR bit). " end="11" id="BRE" rwaccess="R" width="1">
    <bitenum description="Read BLEN bytes enable. Readable data exists in the buffer." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="Read BLEN bytes disable" id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="10" description=" Buffer Write enable. [[br]]This status is used for non-DMA write transfers. [[br]]It indicates if space is available for write data. " end="10" id="BWE" rwaccess="R" width="1">
    <bitenum description="There is enough space in the buffer to write BLEN bytes of data." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="There is no room left in the buffer to write BLEN bytes of data." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="9" description=" Read transfer active. [[br]]This status is used for detecting completion of a read transfer. [[br]]It is set to 1 after the end bit of read command or by activating a continue request (SD_HCTL[17] CR bit) following a stop at block gap request. [[br]]This bit is cleared to 0 when all data have been read by the local host after last block or after a stop at block gap request. " end="9" id="RTA" rwaccess="R" width="1">
    <bitenum description="Read data transfer on going." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="No valid data on the mmc_dat lines." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="8" description=" Write transfer active. [[br]]This status indicates a write transfer active. [[br]]It is set to 1 after the end bit of write command or by activating a continue request (SD_HCTL[17] CR bit) following a stop at block gap request. [[br]]This bit is cleared to 0 when CRC status has been received after last block or after a stop at block gap request. " end="8" id="WTA" rwaccess="R" width="1">
    <bitenum description="Write data transfer on going." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="No valid data on the mmc_dat lines." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="7" description=" " end="3" id="RESERVED_3" rwaccess="R" width="5"></bitfield>
    
  <bitfield begin="2" description=" mmc_dat line active. [[br]]This status bit indicates whether one of the mmc_dat lines is in use. [[br]]In the case of read transactions (card to host)This bit is set to 1 after the end bit of read command or by activating continue request SD_HCTL[17] CR bit. [[br]]This bit is cleared to 0 when the host controller received the end bit of the last data block or at the beginning of the read wait mode. [[br]]In the case of write transactions (host to card)This bit is set to 1 after the end bit of write command or by activating continue request SD_HCTL[17] CR bit. [[br]]This bit is cleared to 0 on the end of busy event for the last block. [[br]]The host controller must wait 8 clock cycles with line not busy to really consider not &quot;busy state&quot; or after the busy block as a result of a stop at gap request. " end="2" id="DLA" rwaccess="R" width="1">
    <bitenum description="mmc_dat line active" id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="mmc_dat line inactive" id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="1" description=" Command inhibit (mmc_dat). [[br]]This status bit is generated if either mmc_dat line is active (SD_PSTATE[2] DLA bit) or Read transfer is active (SD_PSTATE[9] RTA bit) or when a command with busy is issued. [[br]]This bit prevents the local host to issue a command. [[br]]A change of this bit from 1 to 0 generates a transfer complete interrupt (SD_STAT[1] TC bit). " end="1" id="DATI" rwaccess="R" width="1">
    <bitenum description="Issuing of command using mmc_dat lines is not allowed" id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="Issuing of command using the mmc_dat lines is allowed" id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="0" description=" Command inhibit(mmc_cmd). [[br]]This status bit indicates that the mmc_cmd line is in use. [[br]]This bit is cleared to 0 when the most significant byte is written into the command register. [[br]]This bit is not set when Auto CMD12 is transmitted. [[br]]This bit is cleared to 0 in either the following cases: After the end bit of the command response, excepted if there is a command conflict error (SD_STAT[17] CCRC bit or SD_STAT[18] CEB bit set to 1) or a Auto CMD12 is not executed (SD_AC12[0] ACNE bit). [[br]]After the end bit of the command without response (SD_CMD[[br]][17:16] RSP_TYPE bits set to &quot;00&quot;). [[br]]In case of a command data error is detected (SD_STAT[19] CTO bit set to 10, this register is not automatically cleared. " end="0" id="CMDI" rwaccess="R" width="1">
    <bitenum description="Issuing of command using mmc_cmd line is not allowed" id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="Issuing of command using mmc_cmd line is allowed" id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
  </register>
  
  
  <register acronym="SD_HCTL" description="This register defines the host controls to set power, wake-up and transfer parameters. SD_HCTL[31:24] = Wake-up control. SD_HCTL[23:16] = Block gap control. SD_HCTL[15:8] = Power control. SD_HCTL[7:0] = Host control. If your device does not support MMC cards, then those bits in this register which are meant for MMC card use should be assumed to be reserved." id="SD_HCTL" offset="0x228" width="32">
    
  <bitfield begin="31" description=" " end="28" id="RESERVED_1" rwaccess="R" width="4"></bitfield>
    
  <bitfield begin="27" description=" Wake-up event enable for 'out-of-band' Interrupt. [[br]]This bit enables wake-up events for 'out-of-band' assertion. [[br]]Wake-up is generated if the wake-up feature is enabled (SD_SYSCONFIG[2] ENAWAKEUP bit). [[br]]The write to this register is ignored when SD_CON[14] OBIE bit is not set. " end="27" id="OBWE" rwaccess="RW" width="1">
    <bitenum description="Enable wake-up on 'out-of-band' Interrupt" id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="Disable wake-up on 'out-of-band' Interrupt" id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="26" description=" Wake-up event enable on SD card removal. [[br]]This bit enables wake-up events for card removal assertion. [[br]]Wake-up is generated if the wake-up feature is enabled (SD_SYSCONFIG[2] ENAWAKEUP bit). " end="26" id="REM" rwaccess="RW" width="1">
    <bitenum description="Enable wake-up on card removal" id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="Disable wake-up on card removal" id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="25" description=" Wake-up event enable on SD card insertion This bit enables wake-up events for card insertion assertion. [[br]]Wake-up is generated if the wake-up feature is enabled (SD_SYSCONFIG[2] ENAWAKEUP bit). " end="25" id="INS" rwaccess="RW" width="1">
    <bitenum description="Enable wake-up on card insertion" id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="Disable wake-up on card insertion" id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="24" description=" Wake-up event enable on SD card interrupt. [[br]]This bit enables wake-up events for card interrupt assertion. [[br]]Wake-up is generated if the wake-up feature is enabled (SD_SYSCONFIG[2] ENAWAKEUP bit) and enable status bit is set (SD_IE[8] CIRQ_ENABLE bit). " end="24" id="IWE" rwaccess="RW" width="1">
    <bitenum description="Enable wake-up on card interrupt" id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="Disable wake-up on card interrupt" id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="23" description=" " end="20" id="RESERVED_2" rwaccess="R" width="4"></bitfield>
    
  <bitfield begin="19" description=" Interrupt block at gap. [[br]]This bit is valid only in [[br]]4-bit mode of SDIO card to enable interrupt detection in the interrupt cycle at block gap for a multiple block transfer. [[br]]For MMC cards and for SD card this bit should be cleared to 0. " end="19" id="IBG" rwaccess="RW" width="1">
    <bitenum description="Enable interrupt detection at the block gap in 4-bit mode" id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="Disable interrupt detection at the block gap in 4-bit mode" id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="18" description=" Read wait control. [[br]]The read wait function is optional only for SDIO cards. [[br]]If the card supports read wait, this bit must be enabled, then requesting a stop at block gap (SD_HCTL[16] SBGR bit) generates a read wait period after the current end of block. [[br]]Be careful, if read wait is not supported it may cause a conflict on mmc_dat line. " end="18" id="RWC" rwaccess="RW" width="1">
    <bitenum description="Enable read wait control" id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="Disable read wait control. Suspend/resume cannot be supported." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="17" description=" Continue request. [[br]]This bit is used to restart a transaction that was stopped by requesting a stop at block gap (SD_HCTL[16] SBGR bit). [[br]]Set this bit to 1 restarts the transfer. [[br]]The bit is automatically cleared to 0 by the host controller when transfer has restarted, that is, mmc_dat line is active (SD_PSTATE[2] DLA bit) or transferring data (SD_PSTATE[8] WTA bit). [[br]]The Stop at block gap request must be disabled (SD_HCTL[16] SBGR bit =0) before setting this bit. " end="17" id="CR" rwaccess="RW" width="1">
    <bitenum description="Transfer restart" id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="No affect" id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="16" description=" Stop at block gap request. [[br]]This bit is used to stop executing a transaction at the next block gap. [[br]]The transfer can restart with a continue request (SD_HCTL[17] CR bit) or during a suspend/resume sequence. [[br]]In case of read transfer, the card must support read wait control. [[br]]In case of write transfer, the host driver shall set this bit after all block data written. [[br]]Until the transfer completion (SD_STAT[1] TC bit set to 1), the host driver shall leave this bit set to 1.If this bit is set, the local host shall not write to the data register (SD_DATA). " end="16" id="SBGR" rwaccess="RW" width="1">
    <bitenum description="Stop at block gap" id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="Transfer mode" id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="15" description=" " end="12" id="RESERVED_3" rwaccess="R" width="4"></bitfield>
    
  <bitfield begin="11" description=" SD bus voltage select (All cards). [[br]]The host driver should set these bits to select the voltage level for the card according to the voltage supported by the system (SD_CAPA[26] VS18 bit, SD_CAPA[25] VS30 bit, SD_CAPA[24] VS33 bit) before starting a transfer. [[br]]If MMCSD[[br]]2: This field must be set to 5h. [[br]]If MMCSD[[br]]3: This field must be set to 5h. " end="9" id="SDVS" rwaccess="RW" width="3">
    <bitenum description="3.3 V (Typical)" id="en_3_0x7" token="en_3_0x7" value="0x7"></bitenum>
    <bitenum description="3.0 V (Typical)" id="en_2_0x6" token="en_2_0x6" value="0x6"></bitenum>
    <bitenum description="1.8 V (Typical)" id="en_1_0x5" token="en_1_0x5" value="0x5"></bitenum>
  </bitfield>
    
  <bitfield begin="8" description=" SD bus power. [[br]]Before setting this bit, the host driver shall select the SD bus voltage (SD_HCTL[[br]][11:9] SDVS bits). [[br]]If the host controller detects the No card state, this bit is automatically cleared to 0. [[br]]If the module is power off, a write in the command register (SD_CMD) will not start the transfer. [[br]]A write to this bit has no effect if the selected SD bus voltage is not supported according to capability register (SD_CAPA[VS*]). " end="8" id="SDBP" rwaccess="RW" width="1">
    <bitenum description="Power on" id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="Power off" id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="7" description=" Card Detect Signal Selection. [[br]]This bit selects source for the card detection. [[br]]When the source for the card detection is switched, the interrupt should be disabled during the switching period by clearing the Interrupt Status/Signal Enable register in order to mask unexpected interrupt being caused by the glitch. [[br]]The Interrupt Status/Signal Enable should be disabled during over the period of debouncing. [[br]] " end="7" id="CDSS" rwaccess="RW" width="1">
    <bitenum description="The Card Detect Test Level is selected (for test purposes)." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="SDCD# is selected (for normal use)." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="6" description=" Card Detect Test Level. [[br]]This bit is enabled while the Card Detect Signal Selection is set to 1 and it indicates card inserted or not. [[br]]0 = No card [[br]]1 = Card inserted." end="6" id="CDTL" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="5" description=" " end="5" id="RESERVED_4" rwaccess="R" width="1"></bitfield>
    
  <bitfield begin="4" description=" DMA Select. [[br]]One of the supported DMA modes can be selected. [[br]]The host driver shall check support of DMA modes by referencing the Capabilities register. [[br]]Use of selected DMA is determined by DMA Enable of the Transfer Mode register. [[br]]This register is only meaningful when MADMA_EN is set to 1. [[br]]When MADMA_EN is cleared to 0 the bit field is read only and returned value is 0. [[br]] " end="3" id="DMAS" rwaccess="RW" width="2">
    <bitenum description="Reserved" id="en_4_0x3" token="en_4_0x3" value="0x3"></bitenum>
    <bitenum description="32-bit Address ADMA2 is selected." id="en_3_0x2" token="en_3_0x2" value="0x2"></bitenum>
    <bitenum description="Reserved" id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="Reserved" id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="2" description=" High Speed Enable. [[br]]Before setting this bit, the Host Driver shall check the High Speed Support in the Capabilities register. [[br]]If this bit is cleared to 0 (default), the Host Controller outputs CMD line and DAT lines at the falling edge of the SD Clock. [[br]]If this bit is set to 1, the Host Controller outputs CMD line and DAT lines at the rising edge of the SD Clock. [[br]]This bit shall not be set when dual data rate mode is activated in SD_CON[DDR]. [[br]] " end="2" id="HSPE" rwaccess="RW" width="1">
    <bitenum description="High speed mode" id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="Normal speed mode" id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="1" description=" Data transfer width. [[br]]This bit must be set following a valid SET_BUS_WIDTH command (ACMD6) with the value written in bit 1 of the argument. [[br]]Prior to this command, the SD card configuration register (SCR) must be verified for the supported bus width by the SD card. [[br]] " end="1" id="DTW" rwaccess="RW" width="1">
    <bitenum description="4-bit Data width (mmc_dat[3:0] used)" id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="1-bit Data width (mmc_dat0 used)" id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="0" description=" " end="0" id="RESERVED_5" rwaccess="R" width="1"></bitfield>
  </register>
  
  
  <register acronym="SD_SYSCTL" description="This register defines the system controls to set software resets, clock frequency management and data timeout. SD_SYSCTL[31:24] = Software resets. SD_SYSCTL[23:16] = Timeout control. SD_SYSCTL[15:0] = Clock control." id="SD_SYSCTL" offset="0x22C" width="32">
    
  <bitfield begin="31" description=" " end="27" id="RESERVED_1" rwaccess="R" width="5"></bitfield>
    
  <bitfield begin="26" description=" Software reset for mmc_dat line. [[br]]This bit is set to 1 for reset and released to 0 when completed. [[br]]Due to additional implementation logic, the reset does not immediately start when asserted. [[br]]The proper procedure is: (a) Set to 1 to start reset, (b) Poll for 1 to identify start of reset, and (c) Poll for 0 to identify reset is complete. [[br]]mmc_dat finite state machine in both clock domain are also reset. [[br]]These registers are cleared by the SD_SYSCTL[26] SRD bit: SD_DATA. [[br]]SD_PSTATEBRE, BWE, RTA, WTA, DLA and DATI. [[br]]SD_HCTLSBGR and CR. [[br]]SD_STATBRR, BWR, BGE and TC Interconnect and MMC buffer data management is reinitialized. [[br]]Note: If a soft reset is issued when an interrupt is asserted, data may be lost. " end="26" id="SRD" rwaccess="RW" width="1">
    <bitenum description="Software reset for mmc_dat line" id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="Reset completed" id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="25" description=" Software reset for mmc_cmd line. [[br]]This bit is set to 1 for reset and released to 0 when completed. [[br]]Due to additional implementation logic, the reset does not immediately start when asserted. [[br]]The proper procedure is: (a) Set to 1 to start reset, (b) Poll for 1 to identify start of reset, and (c) Poll for 0 to identify reset is complete. [[br]]mmc_cmd finite state machine in both clock domain are also reset. [[br]]These registers are cleared by the SD_SYSCTL[25] SRC bit: SD_PSTATECMDI. [[br]]SD_STATCC Interconnect and MMC command status management is reinitialized. [[br]]Note: If a soft reset is issued when an interrupt is asserted, data may be lost. " end="25" id="SRC" rwaccess="RW" width="1">
    <bitenum description="Software reset for mmc_cmd line" id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="Reset completed" id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="24" description=" Software reset for all. [[br]]This bit is set to 1 for reset , and released to 0 when completed. [[br]]This reset affects the entire host controller except for the card detection circuit and capabilities registers. " end="24" id="SRA" rwaccess="RW" width="1">
    <bitenum description="Software reset for all the design" id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="Reset completed" id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="23" description=" " end="20" id="RESERVED_2" rwaccess="R" width="4"></bitfield>
    
  <bitfield begin="19" description=" Data timeout counter value and busy timeout. [[br]]This value determines the interval by which mmc_dat lines timeouts are detected. [[br]]The host driver needs to set this bit field based on: The maximum read access time (NAC) (Refer to the SD Specification Part1 Physical Layer). [[br]]The data read access time values (TAAC and NSAC) in the card specific data register (CSD) of the card. [[br]]The timeout clock base frequency (SD_CAPA[[br]][5:0] TCF bits). [[br]]If the card does not respond within the specified number of cycles, a data timeout error occurs (SD_STAT[20] DTO bit). [[br]]The SD_SYSCTL[19,16] DTO bit field is also used to check busy duration, to generate busy timeout for commands with busy response or for busy programming during a write command. [[br]]Timeout on CRC status is generated if no CRC token is present after a block write. " end="16" id="DTO" rwaccess="RW" width="4">
    <bitenum description="Reserved" id="en_4_0xF" token="en_4_0xF" value="0xF"></bitenum>
    <bitenum description="TCF x 2^27" id="en_3_0xE" token="en_3_0xE" value="0xE"></bitenum>
    <bitenum description="TCF x 2^14" id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="TCF x 2^13" id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="15" description=" Clock frequency select. [[br]]These bits define the ratio between a reference clock frequency (system dependant) and the output clock frequency on the mmc_clk pin of either the memory card (MMC, SD, or SDIO). " end="6" id="CLKD" rwaccess="RW" width="10">
    <bitenum description="Clock Ref / 1023" id="en_5_0x3FF" token="en_5_0x3FF" value="0x3FF"></bitenum>
    <bitenum description="Clock Ref / 3" id="en_4_0x3" token="en_4_0x3" value="0x3"></bitenum>
    <bitenum description="Clock Ref / 2" id="en_3_0x2" token="en_3_0x2" value="0x2"></bitenum>
    <bitenum description="Clock Ref bypass" id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="Clock Ref bypass" id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="5" description=" " end="3" id="RESERVED_3" rwaccess="R" width="3"></bitfield>
    
  <bitfield begin="2" description=" Clock enable. [[br]]This bit controls if the clock is provided to the card or not. " end="2" id="CEN" rwaccess="RW" width="1">
    <bitenum description="The clock is provided to the card and can be automatically gated when SD_SYSCONFIG[0] AUTOIDLE bit is set to 1 (default value). The host driver shall wait to set this bit to 1 until the Internal clock is stable (SD_SYSCTL[1] ICS bit)." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="The clock is not provided to the card . Clock frequency can be changed ." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="1" description=" Internal clock stable (status)This bit indicates either the internal clock is stable or not." end="1" id="ICS" rwaccess="R" width="1">
    <bitenum description="The internal clock is stable after enabling the clock (SD_SYSCTL[0] ICE bit) or after changing the clock ratio (SD_SYSCTL[15:6] CLKD bits)." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="The internal clock is not stable." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="0" description=" Internal clock enable. [[br]]This register controls the internal clock activity. [[br]]In very low power state, the internal clock is stopped. [[br]]Note: The activity of the debounce clock (used for wake-up events) and the interface clock (used for reads and writes to the module register map) are not affected by this register. " end="0" id="ICE" rwaccess="RW" width="1">
    <bitenum description="The internal clock oscillates and can be automatically gated when SD_SYSCONFIG[0] AUTOIDLE bit is set to 1 (default value)." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="The internal clock is stopped (very low power state)." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
  </register>
  
  
  <register acronym="SD_STAT" description="The interrupt status regroups all the status of the module internal events that can generate an interrupt. SD_STAT[31:16] = Error Interrupt Status. SD_STAT[15:0] = Normal Interrupt Status. The error bits are located in the upper 16 bits of the SD_STAT register. All bits are cleared by writing a 1 to them. Additionally, bits 15 and 8 serve as special error bits. These cannot be cleared by writing a 1 to them. Bit 15 (ERRI) is automatically cleared when the error causing to ERRI to be set is handled. (that is, when bits 31:16 are cleared, bit 15 will be automatically cleared). Bit 8 (CIRQ) is cleared by writing a 0 to SD_IE[8] (masking the interrupt) and servicing the interrupt." id="SD_STAT" offset="0x230" width="32">
    
  <bitfield begin="31" description=" " end="30" id="RESERVED_1" rwaccess="R" width="2"></bitfield>
    
  <bitfield begin="29" description=" Bad access to data space. [[br]]This bit is set automatically to indicate a bad access to buffer when not allowed: During a read access to the data register (SD_DATA) while buffer reads are not allowed (SD_PSTATE[11] BRE bit =0). [[br]]During a write access to the data register (SD_DATA) while buffer writes are not allowed (SD_PSTATE[10] BWE bit=0). " end="29" id="BADA" rwaccess="RW" width="1">
    <bitenum description="Status is cleared." id="en_4_0x1" token="en_4_0x1" value="0x1"></bitenum>
    <bitenum description="Bad access" id="en_3_0x1" token="en_3_0x1" value="0x1"></bitenum>
    <bitenum description="No interrupt" id="en_2_0x0" token="en_2_0x0" value="0x0"></bitenum>
    <bitenum description="Status bit unchanged" id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="28" description=" Card error. [[br]]This bit is set automatically when there is at least one error in a response of type R1, R1b, R6, R5 or R5b. [[br]]Only bits referenced as type E (error) in status field in the response can set a card status error. [[br]]An error bit in the response is flagged only if corresponding bit in card status response error SD_CSRE in set. [[br]]There is no card error detection for autoCMD12 command. [[br]]The host driver shall read SD_RSP76 register to detect error bits in the command response. " end="28" id="CERR" rwaccess="RW" width="1">
    <bitenum description="Status is cleared." id="en_4_0x1" token="en_4_0x1" value="0x1"></bitenum>
    <bitenum description="Card error" id="en_3_0x1" token="en_3_0x1" value="0x1"></bitenum>
    <bitenum description="No error" id="en_2_0x0" token="en_2_0x0" value="0x0"></bitenum>
    <bitenum description="Status bit unchanged" id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="27" description=" " end="26" id="RESERVED_2" rwaccess="R" width="2"></bitfield>
    
  <bitfield begin="25" description=" ADMA Error. [[br]]This bit is set when the Host Controller detects errors during ADMA based data transfer. [[br]]The state of the ADMA at an error occurrence is saved in the ADMA Error Status Register. [[br]]In addition, the Host Controller generates this interrupt when it detects invalid descriptor data (Valid=0) at the ST_FDS state. [[br]]ADMA Error State in the ADMA Error Status indicates that an error occurs in ST_FDS state. [[br]]The Host Driver may find that Valid bit is not set at the error descriptor. [[br]] " end="25" id="ADMAE" rwaccess="RW" width="1">
    <bitenum description="Status is cleared." id="en_4_0x1" token="en_4_0x1" value="0x1"></bitenum>
    <bitenum description="ADMA error" id="en_3_0x1" token="en_3_0x1" value="0x1"></bitenum>
    <bitenum description="No interrupt" id="en_2_0x0" token="en_2_0x0" value="0x0"></bitenum>
    <bitenum description="Status bit unchanged" id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="24" description=" Auto CMD12 error. [[br]]This bit is set automatically when one of the bits in Auto CMD12 Error status register has changed from 0 to 1. " end="24" id="ACE" rwaccess="RW" width="1">
    <bitenum description="AutoCMD12 error" id="en_4_0x1" token="en_4_0x1" value="0x1"></bitenum>
    <bitenum description="Status is cleared." id="en_3_0x1" token="en_3_0x1" value="0x1"></bitenum>
    <bitenum description="No error" id="en_2_0x0" token="en_2_0x0" value="0x0"></bitenum>
    <bitenum description="Status bit unchanged" id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="23" description=" " end="23" id="RESERVED_3" rwaccess="R" width="1"></bitfield>
    
  <bitfield begin="22" description=" Data End Bit error. [[br]]This bit is set automatically when detecting a 0 at the end bit position of read data on mmc_dat line or at the end position of the CRC status in write mode. " end="22" id="DEB" rwaccess="RW" width="1">
    <bitenum description="Status is cleared." id="en_4_0x1" token="en_4_0x1" value="0x1"></bitenum>
    <bitenum description="Data end bit error" id="en_3_0x1" token="en_3_0x1" value="0x1"></bitenum>
    <bitenum description="No error" id="en_2_0x0" token="en_2_0x0" value="0x0"></bitenum>
    <bitenum description="Status bit unchanged" id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="21" description=" Data CRC Error. [[br]]This bit is set automatically when there is a CRC16 error in the data phase response following a block read command or if there is a [[br]]3-bit CRC status different of a position &quot;010&quot; token during a block write command. " end="21" id="DCRC" rwaccess="RW" width="1">
    <bitenum description="Status is cleared." id="en_4_0x1" token="en_4_0x1" value="0x1"></bitenum>
    <bitenum description="Data CRC error" id="en_3_0x1" token="en_3_0x1" value="0x1"></bitenum>
    <bitenum description="No error" id="en_2_0x0" token="en_2_0x0" value="0x0"></bitenum>
    <bitenum description="Status bit unchanged" id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="20" description=" Data timeout error. [[br]]This bit is set automatically according to the following conditions: Busy timeout for R1b, R5b response type. [[br]]Busy timeout after write CRC status. [[br]]Write CRC status timeout. [[br]]Read data timeout. " end="20" id="DTO" rwaccess="RW" width="1">
    <bitenum description="Status is cleared." id="en_4_0x1" token="en_4_0x1" value="0x1"></bitenum>
    <bitenum description="Time out" id="en_3_0x1" token="en_3_0x1" value="0x1"></bitenum>
    <bitenum description="No error" id="en_2_0x0" token="en_2_0x0" value="0x0"></bitenum>
    <bitenum description="Status bit unchanged" id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="19" description=" Command index error. [[br]]This bit is set automatically when response index differs from corresponding command index previously emitted. [[br]]It depends on the enable bit (SD_CMD[20] CICE). " end="19" id="CIE" rwaccess="RW" width="1">
    <bitenum description="Status is cleared." id="en_4_0x1" token="en_4_0x1" value="0x1"></bitenum>
    <bitenum description="Command index error" id="en_3_0x1" token="en_3_0x1" value="0x1"></bitenum>
    <bitenum description="No error" id="en_2_0x0" token="en_2_0x0" value="0x0"></bitenum>
    <bitenum description="Status bit unchanged" id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="18" description=" Command end bit error. [[br]]This bit is set automatically when detecting a 0 at the end bit position of a command response. " end="18" id="CEB" rwaccess="RW" width="1">
    <bitenum description="Command end bit error" id="en_4_0x1" token="en_4_0x1" value="0x1"></bitenum>
    <bitenum description="Status is cleared." id="en_3_0x1" token="en_3_0x1" value="0x1"></bitenum>
    <bitenum description="No error" id="en_2_0x0" token="en_2_0x0" value="0x0"></bitenum>
    <bitenum description="Status bit unchanged" id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="17" description=" Command CRC error. [[br]]This bit is set automatically when there is a CRC7 error in the command response depending on the enable bit (SD_CMD[19] CCCE). " end="17" id="CCRC" rwaccess="RW" width="1">
    <bitenum description="Status is cleared." id="en_4_0x1" token="en_4_0x1" value="0x1"></bitenum>
    <bitenum description="Command CRC error" id="en_3_0x1" token="en_3_0x1" value="0x1"></bitenum>
    <bitenum description="No error" id="en_2_0x0" token="en_2_0x0" value="0x0"></bitenum>
    <bitenum description="Status bit unchanged" id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="16" description=" Command timeout error. [[br]]This bit is set automatically when no response is received within 64 clock cycles from the end bit of the command. [[br]]For commands that reply within 5 clock cycles - the timeout is still detected at 64 clock cycles. " end="16" id="CTO" rwaccess="RW" width="1">
    <bitenum description="Time Out" id="en_4_0x1" token="en_4_0x1" value="0x1"></bitenum>
    <bitenum description="Status is cleared." id="en_3_0x1" token="en_3_0x1" value="0x1"></bitenum>
    <bitenum description="No error" id="en_2_0x0" token="en_2_0x0" value="0x0"></bitenum>
    <bitenum description="Status bit unchanged" id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="15" description=" Error interrupt. [[br]]If any of the bits in the Error Interrupt Status register (SD_STAT[[br]][31:16]) are set, then this bit is set to 1. [[br]]Therefore the host driver can efficiently test for an error by checking this bit first. [[br]]Writes to this bit are ignored. " end="15" id="ERRI" rwaccess="R" width="1">
    <bitenum description="Error interrupt event(s) occurred" id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="No interrupt" id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="14" description=" " end="11" id="RESERVED_4" rwaccess="R" width="4"></bitfield>
    
  <bitfield begin="10" description=" Boot Status Received Interrupt. [[br]]This bit is set automatically when SD_CON[BOOT] is set 1 or 2 and a boot status is received on DAT[0] line. [[br]]This interrupt is only useful for MMC card. " end="10" id="BSR" rwaccess="RW" width="1">
    <bitenum description="Status is cleared." id="en_4_0x1" token="en_4_0x1" value="0x1"></bitenum>
    <bitenum description="Boot Status Received Interrupt occurred." id="en_3_0x1" token="en_3_0x1" value="0x1"></bitenum>
    <bitenum description="No interrupt" id="en_2_0x0" token="en_2_0x0" value="0x0"></bitenum>
    <bitenum description="Status bit unchanged" id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="9" description=" Out-of-band interrupt (This interrupt is only useful for MMC card). [[br]]This bit is set automatically when SD_CON[14] OBIE bit is set and an out-of-band interrupt occurs on OBI pin. [[br]]The interrupt detection depends on polarity controlled by SD_CON[13] OBIP bit. [[br]]The out-of-band interrupt signal is a system specific feature for future use, this signal is not required for existing specification implementation. " end="9" id="OBI" rwaccess="R" width="1">
    <bitenum description="Status is cleared." id="en_4_0x1" token="en_4_0x1" value="0x1"></bitenum>
    <bitenum description="Interrupt out-of-band occurs" id="en_3_0x1" token="en_3_0x1" value="0x1"></bitenum>
    <bitenum description="No out-of-band interrupt" id="en_2_0x0" token="en_2_0x0" value="0x0"></bitenum>
    <bitenum description="Status bit unchanged" id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="8" description=" Card interrupt. [[br]]This bit is only used for SD and SDIO cards. [[br]]In [[br]]1-bit mode, interrupt source is asynchronous (can be a source of asynchronous wake-up). [[br]]In [[br]]4-bit mode, interrupt source is sampled during the interrupt cycle. [[br]]In CE-ATA mode, interrupt source is detected when the card drives mmc_cmd line to zero during one cycle after data transmission end. [[br]]All modes above are fully exclusive. [[br]]The controller interrupt must be clear by setting SD_IE[8] CIRQ_ENABLE to 0, then the host driver must start the interrupt service with card (clearing card interrupt status) to remove card interrupt source. [[br]]Otherwise the Controller interrupt will be reasserted as soon as SD_IE[8] CIRQ_ENABLE is set to 1. [[br]]Writes to this bit are ignored. " end="8" id="CIRQ" rwaccess="R" width="1">
    <bitenum description="Generate card interrupt" id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="No card interrupt" id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="7" description=" Card Removal. [[br]]This bit is set automatically when SD_PSTATE[CINS] changes from 1 to 0. [[br]]A clear of this bit doesn't affect Card inserted present state (SD_PSTATE[CINS]). " end="7" id="CREM" rwaccess="RW" width="1">
    <bitenum description="Status is cleared" id="en_4_0x1" token="en_4_0x1" value="0x1"></bitenum>
    <bitenum description="Card Removed" id="en_3_0x1" token="en_3_0x1" value="0x1"></bitenum>
    <bitenum description="Card State stable or debouncing" id="en_2_0x0" token="en_2_0x0" value="0x0"></bitenum>
    <bitenum description="Status bit unchanged" id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="6" description=" Card Insertion. [[br]]This bit is set automatically when SD_PSTATE[CINS] changes from 0 to 1. [[br]]A clear of this bit doesn't affect Card inserted present state (SD_PSTATE[CINS]). " end="6" id="CINS" rwaccess="RW" width="1">
    <bitenum description="Card inserted" id="en_4_0x1" token="en_4_0x1" value="0x1"></bitenum>
    <bitenum description="Status is cleared." id="en_3_0x1" token="en_3_0x1" value="0x1"></bitenum>
    <bitenum description="Card State stable or debouncing" id="en_2_0x0" token="en_2_0x0" value="0x0"></bitenum>
    <bitenum description="Status bit unchanged" id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="5" description=" Buffer read ready. [[br]]This bit is set automatically during a read operation to the card (see class [[br]]2 - block oriented read commands) when one block specified by the SD_BLK[[br]][10:0] BLEN bit field is completely written in the buffer. [[br]]It indicates that the memory card has filled out the buffer and that the local host needs to empty the buffer by reading it. [[br]]Note: If the DMA receive-mode is enabled, this bit is never set[[br]] instead a DMA receive request to the main DMA controller of the system is generated. " end="5" id="BRR" rwaccess="RW" width="1">
    <bitenum description="Status is cleared." id="en_4_0x1" token="en_4_0x1" value="0x1"></bitenum>
    <bitenum description="Ready to read buffer" id="en_3_0x1" token="en_3_0x1" value="0x1"></bitenum>
    <bitenum description="Not ready to read buffer" id="en_2_0x0" token="en_2_0x0" value="0x0"></bitenum>
    <bitenum description="Status bit unchanged" id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="4" description=" Buffer write ready. [[br]]This bit is set automatically during a write operation to the card (see class [[br]]4 - block oriented write command) when the host can write a complete block as specified by SD_BLK[[br]][10:0] BLEN. [[br]]It indicates that the memory card has emptied one block from the buffer and that the local host is able to write one block of data into the buffer. [[br]]Note: If the DMA transmit mode is enabled, this bit is never set[[br]] instead, a DMA transmit request to the main DMA controller of the system is generated. " end="4" id="BWR" rwaccess="RW" width="1">
    <bitenum description="Ready to write buffer" id="en_4_0x1" token="en_4_0x1" value="0x1"></bitenum>
    <bitenum description="Status is cleared." id="en_3_0x1" token="en_3_0x1" value="0x1"></bitenum>
    <bitenum description="Not ready to write buffer" id="en_2_0x0" token="en_2_0x0" value="0x0"></bitenum>
    <bitenum description="Status bit unchanged" id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="3" description=" DMA Interrupt. [[br]]This status is set when an interrupt is required in the ADMA instruction and after the data transfer completion. " end="3" id="DMA" rwaccess="RW" width="1">
    <bitenum description="No DMA Interrupt" id="en_4_0x1" token="en_4_0x1" value="0x1"></bitenum>
    <bitenum description="Status is cleared." id="en_3_0x1" token="en_3_0x1" value="0x1"></bitenum>
    <bitenum description="DMA Interrupt detected" id="en_2_0x0" token="en_2_0x0" value="0x0"></bitenum>
    <bitenum description="Status bit unchanged" id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="2" description=" Block gap event. [[br]]When a stop at block gap is requested (SD_HCTL[16] SBGR bit), this bit is automatically set when transaction is stopped at the block gap during a read or write operation. [[br]] " end="2" id="BGE" rwaccess="RW" width="1">
    <bitenum description="Transaction stopped at block gap" id="en_4_0x1" token="en_4_0x1" value="0x1"></bitenum>
    <bitenum description="Status is cleared" id="en_3_0x1" token="en_3_0x1" value="0x1"></bitenum>
    <bitenum description="No block gap event" id="en_2_0x0" token="en_2_0x0" value="0x0"></bitenum>
    <bitenum description="Status bit unchanged" id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="1" description=" Transfer completed. [[br]]This bit is always set when a read/write transfer is completed or between two blocks when the transfer is stopped due to a stop at block gap request (SD_HCTL[16] SBGR bit). [[br]] " end="1" id="TC" rwaccess="RW" width="1">
    <bitenum description="Data transfer complete" id="en_4_0x1" token="en_4_0x1" value="0x1"></bitenum>
    <bitenum description="Status is cleared" id="en_3_0x1" token="en_3_0x1" value="0x1"></bitenum>
    <bitenum description="No transfer complete" id="en_2_0x0" token="en_2_0x0" value="0x0"></bitenum>
    <bitenum description="Status bit unchanged" id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="0" description=" Command complete. [[br]]This bit is set when a [[br]]1-to-0 transition occurs in the register command inhibit (SD_PSTATE[0] CMDI bit)  " end="0" id="CC" rwaccess="RW" width="1">
    <bitenum description="Command complete" id="en_4_0x1" token="en_4_0x1" value="0x1"></bitenum>
    <bitenum description="Status is cleared" id="en_3_0x1" token="en_3_0x1" value="0x1"></bitenum>
    <bitenum description="No command complete" id="en_2_0x0" token="en_2_0x0" value="0x0"></bitenum>
    <bitenum description="Status bit unchanged" id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
  </register>
  
  
  <register acronym="SD_IE" description="This register allows to enable/disable the module to set status bits, on an event-by-event basis. SD_IE[31:16] = Error Interrupt Status Enable. SD_IE[15:0] = Normal Interrupt Status Enable." id="SD_IE" offset="0x234" width="32">
    
  <bitfield begin="31" description=" " end="30" id="RESERVED_1" rwaccess="R" width="2"></bitfield>
    
  <bitfield begin="29" description=" Bad access to data space interrupt enable" end="29" id="BADA_ENABLE" rwaccess="RW" width="1">
    <bitenum description="Enabled" id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="Masked" id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="28" description=" Card error interrupt enable" end="28" id="CERR_ENABLE" rwaccess="RW" width="1">
    <bitenum description="Enabled" id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="Masked" id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="27" description=" " end="26" id="RESERVED_2" rwaccess="R" width="2"></bitfield>
    
  <bitfield begin="25" description=" ADMA error Interrupt Enable" end="25" id="ADMA_ENABLE" rwaccess="RW" width="1">
    <bitenum description="Enabled" id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="Masked" id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="24" description=" Auto CMD12 error interrupt enable" end="24" id="ACE_ENABLE" rwaccess="RW" width="1">
    <bitenum description="Enabled" id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="Masked" id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="23" description=" " end="23" id="RESERVED_3" rwaccess="R" width="1"></bitfield>
    
  <bitfield begin="22" description=" Data end bit error interrupt enable" end="22" id="DEB_ENABLE" rwaccess="RW" width="1">
    <bitenum description="Enabled" id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="Masked" id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="21" description=" Data CRC error interrupt enable" end="21" id="DCRC_ENABLE" rwaccess="RW" width="1">
    <bitenum description="Enabled" id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="Masked" id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="20" description=" Data timeout error interrupt enable" end="20" id="DTO_ENABLE" rwaccess="RW" width="1">
    <bitenum description="Enabled" id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="Masked" id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="19" description=" Command index error interrupt enable" end="19" id="CIE_ENABLE" rwaccess="RW" width="1">
    <bitenum description="Enabled" id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="Masked" id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="18" description=" Command end bit error interrupt enable" end="18" id="CEB_ENABLE" rwaccess="RW" width="1">
    <bitenum description="Enabled" id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="Masked" id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="17" description=" Command CRC error interrupt enable" end="17" id="CCRC_ENABLE" rwaccess="RW" width="1">
    <bitenum description="Enabled" id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="Masked" id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="16" description=" Command timeout error interrupt enable" end="16" id="CTO_ENABLE" rwaccess="RW" width="1">
    <bitenum description="Enabled" id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="Masked" id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="15" description=" Fixed to 0. [[br]]The host driver shall control error interrupts using the Error Interrupt Signal Enable register. [[br]]Writes to this bit are ignored." end="15" id="NULL" rwaccess="R" width="1"></bitfield>
    
  <bitfield begin="14" description=" " end="11" id="RESERVED_4" rwaccess="R" width="4"></bitfield>
    
  <bitfield begin="10" description=" Boot Status Interrupt Enable A write to this register when SD_CON[BOOT] is cleared to 0 is ignored." end="10" id="BSR_ENABLE" rwaccess="RW" width="1">
    <bitenum description="Enabled" id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="Masked" id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="9" description=" Out-of-band interrupt enable A write to this register when SD_CON[14] OBIE is cleared to 0 is ignored." end="9" id="OBI_ENABLE" rwaccess="RW" width="1">
    <bitenum description="Enabled" id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="Masked" id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="8" description=" Card interrupt enable. [[br]]A clear of this bit also clears the corresponding status bit. [[br]]During [[br]]1-bit mode, if the interrupt routine does not remove the source of a card interrupt in the SDIO card, the status bit is reasserted when this bit is set to 1. [[br]]This bit must be set to 1 when entering in smart idle mode to enable system to identity wake-up event and to allow controller to clear internal wake-up source. " end="8" id="CIRQ_ENABLE" rwaccess="RW" width="1">
    <bitenum description="Enabled" id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="Masked" id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="7" description=" Card Removal interrupt Enable This bit must be set to 1 when entering in smart idle mode to enable system to identity wake-up event and to allow controller to clear internal wake-up source. [[br]] " end="7" id="CREM_ENABLE" rwaccess="RW" width="1">
    <bitenum description="Enabled" id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="Masked" id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="6" description=" Card Insertion interrupt Enable This bit must be set to 1 when entering in smart idle mode to enable system to identity wake-up event and to allow controller to clear internal wake-up source. [[br]] " end="6" id="CINS_ENABLE" rwaccess="RW" width="1">
    <bitenum description="Enabled" id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="Masked" id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="5" description=" Buffer read ready interrupt enable" end="5" id="BRR_ENABLE" rwaccess="RW" width="1">
    <bitenum description="Enabled" id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="Masked" id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="4" description=" Buffer write ready interrupt enable" end="4" id="BWR_ENABLE" rwaccess="RW" width="1">
    <bitenum description="Enabled" id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="Masked" id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="3" description=" DMA interrupt enable" end="3" id="DMA_ENABLE" rwaccess="RW" width="1">
    <bitenum description="Enable" id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="Masked" id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="2" description=" Block gap event interrupt enable" end="2" id="BGE_ENABLE" rwaccess="RW" width="1">
    <bitenum description="Enabled" id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="Masked" id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="1" description=" Transfer completed interrupt enable" end="1" id="TC_ENABLE" rwaccess="RW" width="1">
    <bitenum description="Enabled" id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="Masked" id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="0" description=" Command completed interrupt enable" end="0" id="CC_ENABLE" rwaccess="RW" width="1">
    <bitenum description="Enabled" id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="Masked" id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
  </register>
  
  
  <register acronym="SD_ISE" description="This register allows you to enable/disable the module to set status bits, on an event-by-event basis. SD_ISE[31:16] = Error Interrupt Signal Enable. SD_ISE[15:0] = Normal Interrupt Signal Enable." id="SD_ISE" offset="0x238" width="32">
    
  <bitfield begin="31" description=" " end="30" id="RESERVED_1" rwaccess="R" width="2"></bitfield>
    
  <bitfield begin="29" description=" Bad access to data space interrupt enable" end="29" id="BADA_SIGEN" rwaccess="RW" width="1">
    <bitenum description="Enabled" id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="Masked" id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="28" description=" Card error interrupt signal status enable" end="28" id="CERR_SIGEN" rwaccess="RW" width="1">
    <bitenum description="Enabled" id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="Masked" id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="27" description=" " end="26" id="RESERVED_2" rwaccess="R" width="2"></bitfield>
    
  <bitfield begin="25" description=" ADMA error signal status enable" end="25" id="ADMA_SIGEN" rwaccess="RW" width="1">
    <bitenum description="Enabled" id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="Masked" id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="24" description=" Auto CMD12 error signal status enable" end="24" id="ACE_SIGEN" rwaccess="RW" width="1">
    <bitenum description="Enabled" id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="Masked" id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="23" description=" " end="23" id="RESERVED_3" rwaccess="R" width="1"></bitfield>
    
  <bitfield begin="22" description=" Data end bit error signal status enable" end="22" id="DEB_SIGEN" rwaccess="RW" width="1">
    <bitenum description="Enabled" id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="Masked" id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="21" description=" Data CRC error signal status enable" end="21" id="DCRC_SIGEN" rwaccess="RW" width="1">
    <bitenum description="Enabled" id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="Masked" id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="20" description=" Data timeout error signal status enable" end="20" id="DTO_SIGEN" rwaccess="RW" width="1">
    <bitenum description="Enabled" id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="Masked. The host controller provides the clock to the card until the card sends the data or the transfer is aborted." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="19" description=" Command index error signal status enable" end="19" id="CIE_SIGEN" rwaccess="RW" width="1">
    <bitenum description="Enabled" id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="Masked" id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="18" description=" Command end bit error signal status enable" end="18" id="CEB_SIGEN" rwaccess="RW" width="1">
    <bitenum description="Enabled" id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="Masked" id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="17" description=" Command CRC error signal status enable" end="17" id="CCRC_SIGEN" rwaccess="RW" width="1">
    <bitenum description="Enabled" id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="Masked" id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="16" description=" Command timeout error signal status enable" end="16" id="CTO_SIGEN" rwaccess="RW" width="1">
    <bitenum description="Enabled" id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="Masked" id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="15" description=" Fixed to 0. [[br]]The host driver shall control error interrupts using the error interrupt signal enable register. [[br]]Writes to this bit are ignored." end="15" id="NULL" rwaccess="R" width="1"></bitfield>
    
  <bitfield begin="14" description=" " end="11" id="RESERVED_4" rwaccess="R" width="4"></bitfield>
    
  <bitfield begin="10" description=" Boot Status signal status enable. [[br]]A write to this register when SD_CON[BOOT] is cleared to 0 is ignored " end="10" id="BSR_SIGEN" rwaccess="RW" width="1">
    <bitenum description="Enabled" id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="Masked" id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="9" description=" Out-of-band interrupt signal status enable. [[br]]A write to this register when SD_CON[14] OBIE is cleared to 0 is ignored. " end="9" id="OBI_SIGEN" rwaccess="RW" width="1">
    <bitenum description="Enabled" id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="Masked" id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="8" description=" Card interrupt signal status enable. [[br]]A clear of this bit also clears the corresponding status bit. [[br]]During [[br]]1-bit mode, if the interrupt routine does not remove the source of a card interrupt in the SDIO card, the status bit is reasserted when this bit is set to 1. [[br]]This bit must be set to 1 when entering in smart idle mode to enable system to identity wake-up event and to allow controller to clear internal wake-up source. [[br]] " end="8" id="CIRQ_SIGEN" rwaccess="RW" width="1">
    <bitenum description="Enabled" id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="Masked" id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="7" description=" Card Removal signal status enable This bit must be set to 1 when entering in smart idle mode to enable system to identity wake-up event and to allow controller to clear internal wake-up source. [[br]] " end="7" id="CREM_SIGEN" rwaccess="RW" width="1">
    <bitenum description="Enabled" id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="Masked" id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="6" description=" Card Insertion signal status enable. [[br]]This bit must be set to 1 when entering in smart idle mode to enable system to identity wake-up event and to allow controller to clear internal wake-up source. [[br]] " end="6" id="CINS_SIGEN" rwaccess="RW" width="1">
    <bitenum description="Enabled" id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="Masked" id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="5" description=" Buffer read ready signal status enable" end="5" id="BRR_SIGEN" rwaccess="RW" width="1">
    <bitenum description="Enabled" id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="Masked" id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="4" description=" Buffer write ready signal status enable" end="4" id="BWR_SIGEN" rwaccess="RW" width="1">
    <bitenum description="Enabled" id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="Masked" id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="3" description=" DMA signal status enable" end="3" id="DMA_SIGEN" rwaccess="RW" width="1">
    <bitenum description="Enabled" id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="Masked" id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="2" description=" Block gap event signal status enable" end="2" id="BGE_SIGEN" rwaccess="RW" width="1">
    <bitenum description="Enabled" id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="Masked" id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="1" description=" Transfer completed signal status enable" end="1" id="TC_SIGEN" rwaccess="RW" width="1">
    <bitenum description="Enabled" id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="Masked" id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="0" description=" Command completed signal status enable" end="0" id="CC_SIGEN" rwaccess="RW" width="1">
    <bitenum description="Enabled" id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="Masked" id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
  </register>
  
  
  <register acronym="SD_AC12" description="The host driver may determine which of the errors cases related to Auto CMD12 has occurred by checking this SD_AC12 register when an auto CMD12 error interrupt occurs. This register is valid only when auto CMD12 is enabled (SD_CMD[2] ACEN bit) and auto CMD12Error (SD_STAT[24] ACE bit) is set to 1. These bits are automatically reset when starting a new adtc command with data." id="SD_AC12" offset="0x23C" width="32">
    
  <bitfield begin="31" description=" " end="8" id="RESERVED_1" rwaccess="R" width="24"></bitfield>
    
  <bitfield begin="7" description=" Command not issue by auto CMD12 error. [[br]]If this bit is set to 1, it means that pending command is not executed due to auto CMD12 error ACEB, ACCE, ACTO, or ACNE. " end="7" id="CNI" rwaccess="R" width="1">
    <bitenum description="Command not issued" id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="Not error" id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="6" description=" " end="5" id="RESERVED_2" rwaccess="R" width="2"></bitfield>
    
  <bitfield begin="4" description=" Auto CMD12 index error. [[br]]This bit is a set to 1 when response index differs from corresponding command auto CMD12 index previously emitted. [[br]]This bit depends on the command index check enable (SD_CMD[20] CICE bit). " end="4" id="ACIE" rwaccess="R" width="1">
    <bitenum description="Auto CMD12 index error" id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="No error" id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="3" description=" Auto CMD12 end bit error. [[br]]This bit is set to 1 when detecting a 0 at the end bit position of auto CMD12 command response. " end="3" id="ACEB" rwaccess="R" width="1">
    <bitenum description="AutoCMD12 end bit error" id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="No error" id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="2" description=" Auto CMD12 CRC error. [[br]]This bit is automatically set to 1 when a CRC7 error is detected in the auto CMD12 command response depending on the enable in the SD_CMD[19] CCCE bit. " end="2" id="ACCE" rwaccess="R" width="1">
    <bitenum description="Auto CMD12 CRC error" id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="No error" id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="1" description=" Auto CMD12 timeout error. [[br]]This bit is set to 1 if no response is received within 64 clock cycles from the end bit of the auto CMD12 command. " end="1" id="ACTO" rwaccess="R" width="1">
    <bitenum description="Auto CMD12 time out" id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="No error" id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="0" description=" Auto CMD12 not executed. [[br]]This bit is set to 1 if multiple block data transfer command has started and if an error occurs in command before auto CMD12 starts. " end="0" id="ACNE" rwaccess="R" width="1">
    <bitenum description="Auto CMD12 not executed" id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="Auto CMD12 executed" id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
  </register>
  
  
  <register acronym="SD_CAPA" description="This register lists the capabilities of the MMC/SD/SDIO host controller." id="SD_CAPA" offset="0x240" width="32">
    
  <bitfield begin="31" description=" " end="29" id="RESERVED_1" rwaccess="R" width="3"></bitfield>
    
  <bitfield begin="28" description=" 64 Bit System Bus Support. [[br]]Setting 1 to this bit indicates that the Host Controller supports [[br]]64-bit address descriptor mode and is connected to [[br]]64-bit address system bus. " end="28" id="BUS_64BIT" rwaccess="RW" width="1">
    <bitenum description="64-bit System bus address" id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="32-bit System bus address" id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="27" description=" " end="27" id="RESERVED_2" rwaccess="R" width="1"></bitfield>
    
  <bitfield begin="26" description=" Voltage support 1.8 V. [[br]]Initialization of this register (via a write access to this register) depends on the system capabilities. [[br]]The host driver shall not modify this register after the initialization. [[br]]This register is only reinitialized by a hard reset (via mmc_RESET signal). " end="26" id="VS18" rwaccess="RW" width="1">
    <bitenum description="1.8 V supported" id="en_4_0x1" token="en_4_0x1" value="0x1"></bitenum>
    <bitenum description="1.8 V supported" id="en_3_0x1" token="en_3_0x1" value="0x1"></bitenum>
    <bitenum description="1.8 V not supported" id="en_2_0x0" token="en_2_0x0" value="0x0"></bitenum>
    <bitenum description="1.8 V not supported" id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="25" description=" Voltage support 3.0V. [[br]]Initialization of this register (via a write access to this register) depends on the system capabilities. [[br]]The host driver shall not modify this register after the initialization. [[br]]This register is only reinitialized by a hard reset (via mmc_RESET signal). " end="25" id="VS30" rwaccess="RW" width="1">
    <bitenum description="3.0 V supported" id="en_4_0x1" token="en_4_0x1" value="0x1"></bitenum>
    <bitenum description="3.0 V supported" id="en_3_0x1" token="en_3_0x1" value="0x1"></bitenum>
    <bitenum description="3.0 V not supported" id="en_2_0x0" token="en_2_0x0" value="0x0"></bitenum>
    <bitenum description="3.0 V not supported" id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="24" description=" Voltage support 3.3V. [[br]]Initialization of this register (via a write access to this register) depends on the system capabilities. [[br]]The host driver shall not modify this register after the initialization. [[br]]This register is only reinitialized by a hard reset (via mmc_RESET signal). " end="24" id="VS33" rwaccess="RW" width="1">
    <bitenum description="3.3 V supported" id="en_4_0x1" token="en_4_0x1" value="0x1"></bitenum>
    <bitenum description="3.3 V supported" id="en_3_0x1" token="en_3_0x1" value="0x1"></bitenum>
    <bitenum description="3.3 V not supported" id="en_2_0x0" token="en_2_0x0" value="0x0"></bitenum>
    <bitenum description="3.3 V not supported" id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="23" description=" Suspend/resume support (SDIO cards only). [[br]]This bit indicates whether the host controller supports Suspend/Resume functionality. " end="23" id="SRS" rwaccess="R" width="1">
    <bitenum description="The Host controller supports suspend/resume functionality." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="The Host controller does not suspend/resume functionality." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="22" description=" DMA support. [[br]]This bit indicates that the Host controller is able to use DMA to transfer data between system memory and the Host controller directly. " end="22" id="DS" rwaccess="R" width="1">
    <bitenum description="DMA supported" id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="DMA not supported" id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="21" description=" High-speed support. [[br]]This bit indicates that the host controller supports high speed operations and can supply an up-to-52 MHz clock to the card. " end="21" id="HSS" rwaccess="R" width="1">
    <bitenum description="DMA supported" id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="DMA not supported" id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="20" description=" " end="20" id="RESERVED_3" rwaccess="R" width="1"></bitfield>
    
  <bitfield begin="19" description=" This bit indicates whether the Host Controller is capable of using ADMA2. [[br]]It depends on setting of generic parameter MADMA_EN. " end="19" id="AD2S" rwaccess="R" width="1">
    <bitenum description="ADMA2 not supported" id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="ADMA2 supported" id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="18" description=" " end="18" id="RESERVED_4" rwaccess="R" width="1"></bitfield>
    
  <bitfield begin="17" description=" Maximum block length. [[br]]This value indicates the maximum block size that the host driver can read and write to the buffer in the host controller. [[br]]The host controller supports 512 bytes and 1024 bytes block transfers. " end="16" id="MBL" rwaccess="R" width="2">
    <bitenum description="2048 bytes" id="en_3_0x2" token="en_3_0x2" value="0x2"></bitenum>
    <bitenum description="1024 bytes" id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="512 bytes" id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="15" description=" " end="14" id="RESERVED_5" rwaccess="R" width="2"></bitfield>
    
  <bitfield begin="13" description=" Base clock frequency for clock provided to the card. [[br]]ARRAY(0x1bfe1b0)" end="8" id="BCF" rwaccess="R" width="6"></bitfield>
    
  <bitfield begin="7" description=" Timeout clock unit. [[br]]This bit shows the unit of base clock frequency used to detect Data Timeout Error (SD_STAT[20] DTO bit). " end="7" id="TCU" rwaccess="R" width="1">
    <bitenum description="MHz" id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="kHz" id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="6" description=" " end="6" id="RESERVED_6" rwaccess="R" width="1"></bitfield>
    
  <bitfield begin="5" description=" Timeout clock frequency. [[br]]The timeout clock frequency is used to detect Data Timeout Error (SD_STAT[20] DTO bit). " end="0" id="TCF" rwaccess="R" width="6">
    <bitenum description="The timeout clock frequency depends on the frequency of the clock provided to the card. The value of the timeout clock frequency is not available in this register." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
  </register>
  
  
  <register acronym="SD_CUR_CAPA" description="This register indicates the maximum current capability for each voltage. The value is meaningful if the voltage support is set in the capabilities register (SD_CAPA). Initialization of this register (via a write access to this register) depends on the system capabilities. The host driver shall not modify this register after the initialization. This register is only reinitialized by a hard reset (via mmc_RESET signal)." id="SD_CUR_CAPA" offset="0x248" width="32">
    
  <bitfield begin="31" description=" " end="24" id="RESERVED_1" rwaccess="R" width="8"></bitfield>
    
  <bitfield begin="23" description=" Maximum current for 1.8 V" end="16" id="CUR_1V8" rwaccess="RW" width="8">
    <bitenum description="The maximum current capability for this voltage is not available. Feature not implemented." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="15" description=" Maximum current for 3.0 V" end="8" id="CUR_3V0" rwaccess="RW" width="8">
    <bitenum description="The maximum current capability for this voltage is not available. Feature not implemented." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="7" description=" Maximum current for 3.3 V" end="0" id="CUR_3V3" rwaccess="RW" width="8">
    <bitenum description="The maximum current capability for this voltage is not available. Feature not implemented." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
  </register>
  
  
  <register acronym="SD_FE" description="The Force Event register is not a physically implemented register. Rather, it is an address at which the Error Interrupt Status register can be written. The effect of a write to this address will be reflected in the Error Interrupt Status Register, if corresponding bit of the Error Interrupt Status Enable Register is set." id="SD_FE" offset="0x250" width="32">
    
  <bitfield begin="31" description=" " end="30" id="RESERVED_1" rwaccess="R" width="2"></bitfield>
    
  <bitfield begin="29" description=" Force Event Bad access to data space." end="29" id="FE_BADA" rwaccess="W" width="1">
    <bitenum description="Interrupt forced." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="No effect; no interrupt" id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="28" description=" Force Event Card error" end="28" id="FE_CERR" rwaccess="W" width="1">
    <bitenum description="Interrupt forced." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="No effect; no interrupt" id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="27" description=" " end="26" id="RESERVED_2" rwaccess="R" width="2"></bitfield>
    
  <bitfield begin="25" description=" Force Event ADMA error" end="25" id="FE_ADMAE" rwaccess="W" width="1">
    <bitenum description="Interrupt forced." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="No effect; no interrupt" id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="24" description=" Force Event Auto CMD12 error." end="24" id="FE_ACE" rwaccess="W" width="1">
    <bitenum description="Interrupt forced." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="No effect; no interrupt" id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="23" description=" " end="23" id="RESERVED_3" rwaccess="R" width="1"></bitfield>
    
  <bitfield begin="22" description=" Force Event Data End Bit error." end="22" id="FE_DEB" rwaccess="W" width="1">
    <bitenum description="Interrupt forced." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="No effect; no interrupt" id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="21" description=" Force Event Data CRC error" end="21" id="FE_DCRC" rwaccess="W" width="1">
    <bitenum description="Interrupt forced." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="No effect; no interrupt" id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="20" description=" Force Event Data timeout error" end="20" id="FE_DTO" rwaccess="W" width="1">
    <bitenum description="Interrupt forced." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="No effect; no interrupt" id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="19" description=" Force Event Command index error" end="19" id="FE_CIE" rwaccess="W" width="1">
    <bitenum description="Interrupt forced." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="No effect; no interrupt" id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="18" description=" Force Event Command end bit error" end="18" id="FE_CEB" rwaccess="W" width="1">
    <bitenum description="Interrupt forced." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="No effect; no interrupt" id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="17" description=" Force Event Comemand CRC error" end="17" id="FE_CCRC" rwaccess="W" width="1">
    <bitenum description="Interrupt forced." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="No effect; no interrupt" id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="16" description=" Force Event Command Timeout error" end="16" id="FE_CTO" rwaccess="W" width="1">
    <bitenum description="Interrupt forced." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="No effect; no interrupt" id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="15" description=" " end="8" id="RESERVED_4" rwaccess="R" width="8"></bitfield>
    
  <bitfield begin="7" description=" Force Event Command not issue by Auto CMD12 error" end="7" id="FE_CNI" rwaccess="W" width="1">
    <bitenum description="Interrupt forced." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="No effect; no interrupt" id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="6" description=" " end="5" id="RESERVED_5" rwaccess="R" width="2"></bitfield>
    
  <bitfield begin="4" description=" Force Event Auto CMD12 index error" end="4" id="FE_ACIE" rwaccess="W" width="1">
    <bitenum description="Interrupt forced." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="No effect; no interrupt" id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="3" description=" Force Event Auto CMD12 end bit error" end="3" id="FE_ACEB" rwaccess="W" width="1">
    <bitenum description="Interrupt forced." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="No effect; no interrupt" id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="2" description=" Force Event Auto CMD12 CRC error" end="2" id="FE_ACCE" rwaccess="W" width="1">
    <bitenum description="Interrupt forced." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="No effect; no interrupt" id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="1" description=" Force Event Auto CMD12 timeout error" end="1" id="FE_ACTO" rwaccess="W" width="1">
    <bitenum description="Interrupt forced." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="No effect; no interrupt" id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="0" description=" Force Event Auto CMD12 not executed." end="0" id="FE_ACNE" rwaccess="W" width="1">
    <bitenum description="Interrupt forced." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="No effect; no interrupt." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
  </register>
  
  
  <register acronym="SD_ADMAES" description="When an ADMA Error Interrupt has occurred, the ADMA Error States field in this register holds the ADMA state and the ADMA System Address Register holds the address around the error descriptor. For recovering the error, the Host Driver requires the ADMA state to identify the error descriptor address as follows: ST_STOP: Previous location set in the ADMA System Address register is the error descriptor address. ST_FDS: Current location set in the ADMA System Address register is the error descriptor address. ST_CADR: This sate is never set because do not generate ADMA error in this state. ST_TFR: Previous location set in the ADMA System Address register is the error descriptor address. In the case of a write operation, the Host Driver should use ACMD22 to get the number of written block rather than using this information, since unwritten data may exist in the Host Controller. The Host Controller generates the ADMA Error Interrupt when it detects invalid descriptor data (Valid = 0) at the ST_FDS state. In this case, ADMA Error State indicates that an error occurs at ST_FDS state. The Host Driver may find that the Valid bit is not set in the error descriptor." id="SD_ADMAES" offset="0x254" width="32">
    
  <bitfield begin="31" description=" " end="3" id="RESERVED_1" rwaccess="R" width="29"></bitfield>
    
  <bitfield begin="2" description=" ADMA Length Mismatch Error: While Block Count Enable is being set, the total data length specified by the Descriptor table is different from that specified by the Block Count and Block Length. [[br]]Total data length cannot be divided by the block length. " end="2" id="LME" rwaccess="W" width="1">
    <bitenum description="Error" id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="No error" id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="1" description=" ADMA Error State. [[br]]This field indicates the state of ADMA when an error occurred during an ADMA data transfer. [[br]]This field never indicates &quot;10&quot; because ADMA never stops in this state. [[br]] " end="0" id="AES" rwaccess="RW" width="2">
    <bitenum description="ST_TFR (Transfer Data). Points to the 'next' of the error descriptor." id="en_4_0x3" token="en_4_0x3" value="0x3"></bitenum>
    <bitenum description="Never set this state. (Not used)" id="en_3_0x2" token="en_3_0x2" value="0x2"></bitenum>
    <bitenum description="ST_STOP (Stop DMA). Points to the error descriptor." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="ST_STOP (Stop DMA). Contents of the SYS_SDR register" id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
  </register>
  
  
  <register acronym="SD_ADMASAL" description="This register holds the byte address of the executing command of the Descriptor table. The 32-bit Address Descriptor uses the lower 32 bits of this register. At the start of ADMA, the Host Driver shall set the start address of the Descriptor table." id="SD_ADMASAL" offset="0x258" width="32">
    
  <bitfield begin="31" description=" The ADMA increments this register address, which points to the next line, whenever fetching a Descriptor line. [[br]]When the ADMA Error Interrupt is generated, this register holds the valid Descriptor address depending on the ADMA state. [[br]]The Host Driver shall program the Descriptor Table on a 32-bit boundary and set the 32-bit boundary address to this register. [[br]]ADMA2 ignores the lower 2 bits of this register and assumes it to be 00b. [[br]]" end="0" id="ADMA_A32B" rwaccess="RW" width="32"></bitfield>
  </register>
  
  
  <register acronym="SD_ADMASAH" description="" id="SD_ADMASAH" offset="0x25C" width="32">
    
  <bitfield begin="31" description=" ADMA_A32B." end="0" id="ADMA_A32B" rwaccess="RW" width="32"></bitfield>
  </register>
  
  
  <register acronym="SD_REV" description="This register contains the hard coded RTL vendor revision number, the version number of SD specification compliancy and a slot status bit. SD_REV[31:16] = Host Controller Version. SD_REV[15:0] = Slot Interrupt Status." id="SD_REV" offset="0x2FC" width="32">
    
  <bitfield begin="31" description=" Vendor Version Number. [[br]]Bits [[br]][7:4] is the major revision, bits [[br]][3:0] is the minor revision. [[br]]Examples: 10h for 1.0 21h for 2.1" end="24" id="VREV" rwaccess="R" width="8"></bitfield>
    
  <bitfield begin="23" description=" Specification Version Number. [[br]]This status indicates the Standard SD Host Controller Specification Version. [[br]]The upper and lower [[br]]4-bits indicate the version. " end="16" id="SREV" rwaccess="R" width="8">
    <bitenum description="SD Host Specification Version 1.0" id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="15" description=" " end="1" id="RESERVED_1" rwaccess="R" width="15"></bitfield>
    
  <bitfield begin="0" description=" Slot Interrupt Status. [[br]]This status bit indicates the inverted state of interrupt signal for the module. [[br]]By a power on reset or by setting a software reset for all (SD_SYSCTL[24] SRA), the interrupt signal shall be deasserted and this status shall read 0. " end="0" id="SIS" rwaccess="R" width="1">
    <bitenum description="Interrupt signal asserted." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="Interrupt signal deasserted." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
  </register>
</module>
