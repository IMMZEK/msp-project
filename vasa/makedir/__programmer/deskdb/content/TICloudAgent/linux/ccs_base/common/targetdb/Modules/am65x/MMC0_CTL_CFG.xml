<module name="MMC0_CTL_CFG" acronym="" XML_version="1.0" HW_revision="n/a" description="">
  <register id="MMCSD0_SDMA_SYS_ADDR_LO" acronym="MMCSD0_SDMA_SYS_ADDR_LO" offset="0x0" width="16" description="This register contains the Lower 16-bit of physical system memory address used for DMA transfers or the second argument for the Auto CMD23 in Host version 3.0 and as 32-bit Block Count in Version 4.10.">
    <bitfield id="SDMA_ADDRESS" width="16" begin="15" end="0" resetval="0x0" description="32-bit Block Count (SDMA System Address) Low When the When the (1) SDMA System Address ( This register contains the system memory address for a SDMA transfer in 32-bit addressing mode. When the Host Controller (HC) stops a SDMA transfer, this register shall point to the system address of the next contiguous data position. It can be accessed only if no transaction is executing (after a transaction has stopped). Reading this register during SDMA transfers may return an invalid value. The Host Driver (HD) shall initialize this register before starting a SDMA transaction. After SDMA has stopped, the next system address of the next contiguous data position can be read from this register. The SDMA transfer waits at the every boundary specified by the (2) 32-bit Block Count ( Host Controller Version 4.10 re-defines this register as 32-bit Block Count. In version 4.00, this register may be used as 32-bit block count only for Auto CMD23 to set the argument of the CMD23 while executing Auto CMD23. The Host Controller would decrement the block count of this register every block transfer and data transfer stops when the count reaches zero." range="" rwaccess="RW"/>
  </register>
  <register id="MMCSD0_SDMA_SYS_ADDR_HI" acronym="MMCSD0_SDMA_SYS_ADDR_HI" offset="0x2" width="16" description="This register contains the Upper 16-bit of physical system memory address used for DMA transfers or the second argument for the Auto CMD23 in Host version 3.0 and as 32-bit Block Count in Version 4.10.">
    <bitfield id="SDMA_ADDRESS" width="16" begin="15" end="0" resetval="0x0" description="32-bit Block Count (SDMA System Address) High This register contains the Upper 16-bit of physical system memory address used for DMA transfers or the second argument for the Auto CMD23 in Host version 3.0 and as 32-bit Block Count in Version 4.10." range="" rwaccess="RW"/>
  </register>
  <register id="MMCSD0_BLOCK_SIZE" acronym="MMCSD0_BLOCK_SIZE" offset="0x4" width="16" description="This register is used to configure the number of bytes in a data block.">
    <bitfield id="RESERVED" width="1" begin="15" end="15" resetval="0x0" description="Reserved" range="" rwaccess="R"/>
    <bitfield id="SDMA_BUF_SIZE" width="3" begin="14" end="12" resetval="0x0" description="Host SDMA Buffer Size To perform long DMA transfer, System Address register ( These bits shall support when the 0h: 4KB (Detects A11 Carry out) 1h: 8KB (Detects A12 Carry out) 2h: 16KB (Detects A13 Carry out) 3h: 32KB (Detects A14 Carry out) 4h: 64KB (Detects A15 Carry out) 5h: 128KB (Detects A16 Carry out) 6h: 256KB (Detects A17 Carry out) 7h: 512KB (Detects A18 Carry out)" range="" rwaccess="RW"/>
    <bitfield id="XFER_BLK_SIZE" width="12" begin="11" end="0" resetval="0x0" description="Transfer Block Size This field specifies the block size for block data transfers for CMD17, CMD18, CMD24, CMD25 and CMD53. It can be accessed only if no transaction is executing (after a transaction has stopped). Read operations during transfer return an invalid value and write operations shall be ignored. 0000h: No Data Transfer 0001h: 1 Byte 0002h: 2 Bytes 0003h: 3 Bytes 0004h: 4 Bytes .... 01FFh: 511 Bytes 0200h: 512 Bytes .... 0800h: 2048 Bytes" range="" rwaccess="RW"/>
  </register>
  <register id="MMCSD0_BLOCK_COUNT" acronym="MMCSD0_BLOCK_COUNT" offset="0x6" width="16" description="This register is used to configure the number of data blocks.">
    <bitfield id="XFER_BLK_CNT" width="16" begin="15" end="0" resetval="0x0" description="16-bit Block Count Host Controller Version 4.10 extends block count to 32-bit. Selection of either 16-bit Block Count register or 32-bit Block Count register is defined as follows: (1) If the (2) If the Use of 16-bit/32-bit Block Count register is enabled when the The Host Driver shall set this register to a value between 1h and the maximum block count. The Host Controller decrements the block count after each block transfer and stops when the count reaches zero. Setting the block count to 0h results in no data blocks is transferred. This register should be accessed only when no transaction is executing (after transactions are stopped). During data transfer, read operations on this register may return an invalid value and write operations are ignored. 0000h: Stop Count 0001h: 1 Block 0002h: 2 Blocks .... FFFFh: 65535 Blocks" range="" rwaccess="RW"/>
  </register>
  <register id="MMCSD0_ARGUMENT1_LO" acronym="MMCSD0_ARGUMENT1_LO" offset="0x8" width="16" description="This register contains Lower bits of SD Command Argument.">
    <bitfield id="CMD_ARG1" width="16" begin="15" end="0" resetval="0x0" description="Command Argument 1 Low The SD Command Argument is specified as bit 23-8 of Command-Format." range="" rwaccess="RW"/>
  </register>
  <register id="MMCSD0_ARGUMENT1_HI" acronym="MMCSD0_ARGUMENT1_HI" offset="0xA" width="16" description="This register contains higher bits of SD Command Argument.">
    <bitfield id="CMD_ARG1" width="16" begin="15" end="0" resetval="0x0" description="Command Argument 1 High The SD Command Argument is specified as bit 39-24 of Command-Format." range="" rwaccess="RW"/>
  </register>
  <register id="MMCSD0_TRANSFER_MODE" acronym="MMCSD0_TRANSFER_MODE" offset="0xC" width="16" description="">
    <bitfield id="RESERVED" width="7" begin="15" end="9" resetval="0x0" description="Reserved" range="" rwaccess="R"/>
    <bitfield id="RESP_INTR_DIS" width="1" begin="8" end="8" resetval="0x0" description="Response Interrupt Disable Host Controller Version 4.00 supports response error check function to avoid overhead of response error check by Host Driver. Only R1 or R5 can be checked. If Host Driver checks response error, sets this bit to 0h and waits Command Complete Interrupt ( If Host Controller checks response error, sets this bit to 1h and sets the 0h: Response Interrupt is enabled 1h: Response Interrupt is disabled" range="" rwaccess="RW"/>
    <bitfield id="RESP_ERR_CHK_ENA" width="1" begin="7" end="7" resetval="0x0" description="Response Error Check Enable Host Controller Version 4.00 supports response error check function to avoid overhead of response error check by Host Driver. Only R1 or R5 can be checked. If Host Driver checks response error, this bit is set to 0h and the If Host Controller checks response error, sets this bit to 1h and sets the Response Interrupt Disable bit to 1h ( The 0h: Response Error Check is disabled 1h: Response Error Check is enabled" range="" rwaccess="RW"/>
    <bitfield id="RESP_TYPE" width="1" begin="6" end="6" resetval="0x0" description="Response Type R1/R5 When response error check is enabled ( Error Statuses Checked in R1: Response Flags Checked in R5: 0h: R1 (Memory) 1h: R5 (SDIO)" range="" rwaccess="RW"/>
    <bitfield id="MULTI_BLK_SEL" width="1" begin="5" end="5" resetval="0x0" description="Multi/Single Block Select This bit enables multiple block data transfers. 0h: Single Block 1h: Multiple Block" range="" rwaccess="RW"/>
    <bitfield id="DATA_XFER_DIR" width="1" begin="4" end="4" resetval="0x0" description="Data Transfer Direction Select This bit defines the direction of data transfers. 0h: Write (Host to Card) 1h: Read (Card to Host)" range="" rwaccess="RW"/>
    <bitfield id="AUTO_CMD_ENA" width="2" begin="3" end="2" resetval="0x0" description="Auto CMD Enable This field determines use of auto command functions. There are three methods to stop Multiple-block read and write operation by CMD23 or CMD12. In the other operations (for example single read/write operation), this field is set to 0h. (1) Auto CMD12 Enable: Multiple-block read and write commands for memory require CMD12 to stop the operation. When this field is set to 1h, the Host Controller issues CMD12 automatically when last block transfer is completed. Auto CMD12 error is indicated to the When When (2) Auto CMD23 Enable: When this bit field is set to 2h, the Host Controller issues a CMD23 automatically before issuing a command specified in the The following conditions are required to use the Auto CMD23: Auto CMD23 Supported (Host Controller Version is 3.00 or later). A memory card that supports CMD23 (SCR[33] = 1h). If DMA is used, it shall be ADMA. Only when CMD18 or CMD25 is issued. Auto CMD23 can be used with or without ADMA. By writing the 32-bit block count value for CMD23 is set to 32-bit Block Count ( (3) Auto CMD Auto Select (Version 4.10): As CMD23 is optional for SD memory card except UHS 104 card, if card supports CMD23, Auto CMD 23 should be used instead of Auto CMD12. Host Controller Version 4.10 defines this 'Auto CMD Auto Select' mode. Selection of Auto CMD depends on setting of the 0h: Auto Command Disabled 1h: Auto CMD12 Enable 2h: Auto CMD23 Enable 3h: Reserved" range="" rwaccess="RW"/>
    <bitfield id="BLK_CNT_ENA" width="1" begin="1" end="1" resetval="0x0" description="Block Count Enable This bit is used to enable the 0h: Disable 1h: Enable" range="" rwaccess="RW"/>
    <bitfield id="DMA_ENA" width="1" begin="0" end="0" resetval="0x0" description="DMA Enable DMA can be enabled only if the 0h: Disable 1h: Enable" range="" rwaccess="RW"/>
  </register>
  <register id="MMCSD0_COMMAND" acronym="MMCSD0_COMMAND" offset="0xE" width="16" description="This register is used to program the Command for host controller.">
    <bitfield id="RESERVED" width="2" begin="15" end="14" resetval="0x0" description="Reserved" range="" rwaccess="R"/>
    <bitfield id="CMD_INDEX" width="6" begin="13" end="8" resetval="0x0" description="Command Index This bit shall be set to the command number (CMD0-63, ACMD0-63)." range="" rwaccess="RW"/>
    <bitfield id="CMD_TYPE" width="2" begin="7" end="6" resetval="0x0" description="Command Type There are three types of special commands. Suspend, Resume and Abort. These bits shall be set to 0h for all other commands. Suspend Command: Resume Command: Abort Command: 0h: Normal 1h: Suspend 2h: Resume 3h: Abort" range="" rwaccess="RW"/>
    <bitfield id="DATA_PRESENT" width="1" begin="5" end="5" resetval="0x0" description="Data Present Select This bit is set to 1h to indicate that data is present and shall be transferred using the DAT line. If is set to 0h for the following: 0h: No Data Present 1h: Data Present" range="" rwaccess="RW"/>
    <bitfield id="CMD_INDEX_CHK_ENA" width="1" begin="4" end="4" resetval="0x0" description="Command Index Check Enable If this bit is set to 1h, the HC shall check the index field in the response to see if it has the same value as the command index. If it is not, it is reported as a Command Index Error. If this bit is set to 0h, the Index field is not checked. 0h: Disable 1h: Enable" range="" rwaccess="RW"/>
    <bitfield id="CMD_CRC_CHK_ENA" width="1" begin="3" end="3" resetval="0x0" description="Command CRC Check Enable If this bit is set to 1h, the HC shall check the CRC field in the response. If an error is detected, it is reported as a Command CRC Error. If this bit is set to 0h, the CRC field is not checked. 0h: Disable 1h: Enable" range="" rwaccess="RW"/>
    <bitfield id="SUB_CMD" width="1" begin="2" end="2" resetval="0x0" description="Sub Command Flag This bit is added from Version 4.10 to distinguish a main command or sub command. When issuing a main command, this bit is set to 0h and when issuing a sub command, this bit is set to 1h. Setting of this bit is checked by the Host Driver manages whether main or sub command. Host Controller does not refer to this bit to issue a command. 0h: Sub Command 1h: Main Command" range="" rwaccess="RW"/>
    <bitfield id="RESP_TYPE_SEL" width="2" begin="1" end="0" resetval="0x0" description="Response Type Select 0h: No Response 1h: Response length 136 2h: Response length 48 3h: Response length 48 check Busy after response" range="" rwaccess="RW"/>
  </register>
  <register id="MMCSD0_RESPONSE_0" acronym="MMCSD0_RESPONSE_0" offset="0x10" width="16" description="This registers is used to store responses from SD Cards.">
    <bitfield id="CMD_RESP" width="16" begin="15" end="0" resetval="0x0" description="Command Response R[] refers to a bit range within the response data as transmitted on the SD Bus, REP[] refers to a bit range within the Response register." range="" rwaccess="R"/>
  </register>
  <register id="MMCSD0_RESPONSE_1" acronym="MMCSD0_RESPONSE_1" offset="0x14" width="16" description="This registers is used to store responses from SD Cards.">
    <bitfield id="CMD_RESP" width="16" begin="15" end="0" resetval="0x0" description="Command Response R[] refers to a bit range within the response data as transmitted on the SD Bus, REP[] refers to a bit range within the Response register." range="" rwaccess="R"/>
  </register>
  <register id="MMCSD0_RESPONSE_2" acronym="MMCSD0_RESPONSE_2" offset="0x18" width="16" description="This registers is used to store responses from SD Cards.">
    <bitfield id="CMD_RESP" width="16" begin="15" end="0" resetval="0x0" description="Command Response R[] refers to a bit range within the response data as transmitted on the SD Bus, REP[] refers to a bit range within the Response register." range="" rwaccess="R"/>
  </register>
  <register id="MMCSD0_RESPONSE_3" acronym="MMCSD0_RESPONSE_3" offset="0x1C" width="16" description="This registers is used to store responses from SD Cards.">
    <bitfield id="CMD_RESP" width="16" begin="15" end="0" resetval="0x0" description="Command Response R[] refers to a bit range within the response data as transmitted on the SD Bus, REP[] refers to a bit range within the Response register." range="" rwaccess="R"/>
  </register>
  <register id="MMCSD0_DATA_PORT" acronym="MMCSD0_DATA_PORT" offset="0x20" width="32" description="This register is used to access internal buffer.">
    <bitfield id="BUF_RD_DATA" width="32" begin="31" end="0" resetval="0xX" description="Buffer Data The Host Controller Buffer can be accessed through this 32-bit Data Port Register." range="" rwaccess="RW"/>
  </register>
  <register id="MMCSD0_RESPONSE_4" acronym="MMCSD0_RESPONSE_4" offset="0x20" width="16" description="This registers is used to store responses from SD Cards.">
    <bitfield id="CMD_RESP" width="16" begin="15" end="0" resetval="0x0" description="Command Response R[] refers to a bit range within the response data as transmitted on the SD Bus, REP[] refers to a bit range within the Response register." range="" rwaccess="R"/>
  </register>
  <register id="MMCSD0_PRESENTSTATE" acronym="MMCSD0_PRESENTSTATE" offset="0x24" width="32" description="The Host Driver can get status of the Host Controller from this 32-bit read-only register.">
    <bitfield id="UHS2_IF_DETECTION" width="1" begin="31" end="31" resetval="0x0" description="UHS-II IF Detection (UHS-II Only) This status indicates whether a card supports UHS-II IF. This status is enabled by setting UHS-II Interface Enable to 1h in the Host Control 2 register ( After UHS-II IF is detected, this bit is cleared by when EIDL is detected on D0 lane, UHS-II Interface Enable is set to 0h ( 1h: UHS-II IF is detected 0h: UHS-II IF is not detected" range="" rwaccess="R"/>
    <bitfield id="UHS2_IF_LANE_SYNC" width="1" begin="30" end="30" resetval="0x0" description="Lane Synchronization (UHS-II Only) This status indicates whether lane is synchronized in UHS-II mode. This status is enabled by setting UHS-II Interface Enable to 1h in the Host Control 2 register ( In case of Version 4.00, this bit indicates completion of Device PHY Initialization by detecting LIDL LSS on D1 lane. From Version 4.10, Host Controller may implement a specific PHY verification method and PHY Initialization Failure can be indicated by keeping this bit to 0h even LIDL LSS is detected on D1 lane. Host Driver detects PHY Initialization Failure by timeout. This bit is cleared by when D0 lane is set to EIDL, UHS-II Interface Enable is set to 0h ( 1h: UHS-II PHY is initialized 0h: UHS-II PHY is not initialized" range="" rwaccess="R"/>
    <bitfield id="UHS2_DORMANT" width="1" begin="29" end="29" resetval="0x0" description="In Dormant State (UHS-II Only) This status indicates whether UHS-II lanes enter Dormant state. This function is enabled by setting UHS-II Interface Enable to 1h in the Host Control 2 register ( RCLK may be stopped in dormant state, by setting SD Clock Enable to 0h in the Clock Control register ( In case of the card enters Hibernate Mode (RCLK is stopped), Host Driver may turn off VDD1 by clearing SD Bus Power for VDD1 bit in the 1h: In DORMANT state 0h: Not in DORMANT state" range="" rwaccess="R"/>
    <bitfield id="SUB_COMMAND_STS" width="1" begin="28" end="28" resetval="0x0" description="Sub Command Status The 1h: Sub Command Status 0h: Main Command Status" range="" rwaccess="R"/>
    <bitfield id="CMD_NOT_ISS_BY_ERR" width="1" begin="27" end="27" resetval="0x0" description="Command Not Issued by Error Setting of this status indicates that a command cannot be issued due to an error except Auto CMD12 error (equivalent error status by Auto CMD12 error is defined as Command Not Issued By Auto CMD12 Error in the 1h: Command cannot be issued 0h: No error for issuing a command" range="" rwaccess="R"/>
    <bitfield id="RESERVED" width="2" begin="26" end="25" resetval="0x0" description="Reserved" range="" rwaccess="R"/>
    <bitfield id="SDIF_CMDIN" width="1" begin="24" end="24" resetval="0x1" description="CMD Line Signal Level (SD Mode Only) This status is used to check CMD line level to recover from errors, and for debugging." range="" rwaccess="R"/>
    <bitfield id="SDIF_DAT3IN" width="1" begin="23" end="23" resetval="0x1" description="DAT[3] Line Signal Level (SD Mode Only) This status is used to check DAT line level to recover from errors, and for debugging. This is especially useful in detecting the busy signal level from DAT[3]. D23 - DAT[3]" range="" rwaccess="R"/>
    <bitfield id="SDIF_DAT2IN" width="1" begin="22" end="22" resetval="0x1" description="DAT[2] Line Signal Level (SD Mode Only) This status is used to check DAT line level to recover from errors, and for debugging. This is especially useful in detecting the busy signal level from DAT[2]. D22 - DAT[2]" range="" rwaccess="R"/>
    <bitfield id="SDIF_DAT1IN" width="1" begin="21" end="21" resetval="0x1" description="DAT[1] Line Signal Level (SD Mode Only) This status is used to check DAT line level to recover from errors, and for debugging. This is especially useful in detecting the busy signal level from DAT[1]. D21 - DAT[1]" range="" rwaccess="R"/>
    <bitfield id="SDIF_DAT0IN" width="1" begin="20" end="20" resetval="0x1" description="DAT[0] Line Signal Level (SD Mode Only) This status is used to check DAT line level to recover from errors, and for debugging. This is especially useful in detecting the busy signal level from DAT[0]. D20 - DAT[0]" range="" rwaccess="R"/>
    <bitfield id="WRITE_PROTECT" width="1" begin="19" end="19" resetval="0x0" description="Write Protect Switch Pin Level The Write Protect Switch is supported for memory and combo cards.This bit reflects the SDWP# pin. 0h: Write protected (SDWP# = 1) 1h: Write enabled (SDWP# = 0)" range="" rwaccess="R"/>
    <bitfield id="CARD_DETECT" width="1" begin="18" end="18" resetval="0x0" description="Card Detect Pin Level This bit reflects the inverse value of the SDCD# pin. 0h: No Card present (SDCD# = 1) 1h: Card present (SDCD# = 0)" range="" rwaccess="R"/>
    <bitfield id="CARD_STATE_STABLE" width="1" begin="17" end="17" resetval="0x0" description="Card State Stable This bit is used for testing. If it is 0h, the Card Detect Pin Level is not stable. If this bit is set to 1h, it means the Card Detect Pin Level is stable. The 0h: Reset of Debouncing 1h: No Card or Inserted" range="" rwaccess="R"/>
    <bitfield id="CARD_INSERTED" width="1" begin="16" end="16" resetval="0x0" description="Card Inserted This bit indicates whether a card has been inserted. Changing from 0h to 1h generates a Card Insertion interrupt in the If a Card is removed while its power is on and its clock is oscillating, the HC shall clear the 0h: Reset or Debouncing or No Card 1h: Card Inserted" range="" rwaccess="R"/>
    <bitfield id="RESERVED" width="4" begin="15" end="12" resetval="0x0" description="Reserved" range="" rwaccess="R"/>
    <bitfield id="BUF_RD_ENA" width="1" begin="11" end="11" resetval="0x0" description="Buffer Read Enable This status is used for non-DMA read transfers. This read only flag indicates that valid data exists in the host side buffer status. If this bit is 1h, readable data exists in the buffer. A change of this bit from 1h to 0h occurs when all the block data is read from the buffer. A change of this bit from 0h to 1h occurs when all the block data is ready in the buffer and generates the Buffer Read Ready Interrupt. 0h: Read Disable 1h: Read Enable" range="" rwaccess="R"/>
    <bitfield id="BUF_WR_ENA" width="1" begin="10" end="10" resetval="0x0" description="Buffer Write Enable This status is used for non-DMA write transfers. This read only flag indicates if space is available for write data. If this bit is 1h, data can be written to the buffer. A change of this bit from 1h to 0h occurs when all the block data is written to the buffer. A change of this bit from 0h to 1h occurs when top of block data can be written to the buffer and generates the Buffer Write Ready Interrupt. 0h: Write Disable 1h: Write Enable" range="" rwaccess="R"/>
    <bitfield id="RD_XFER_ACTIVE" width="1" begin="9" end="9" resetval="0x0" description="Read Transfer Active (SD Mode Only) This status is used for detecting completion of a read transfer. This bit is set to 1h for either of the following conditions: This bit is cleared to 0h for either of the following conditions: 1h: Transferring data 0h: No valid data" range="" rwaccess="R"/>
    <bitfield id="WR_XFER_ACTIVE" width="1" begin="8" end="8" resetval="0x0" description="Write Transfer Active (SD Mode Only) This status indicates a write transfer is active. If this bit is 0h, it means no valid write data exists in the HC. This bit is set in either of the following cases: This bit is cleared in either of the following cases: 1h: Transferring data 0h: No valid data" range="" rwaccess="R"/>
    <bitfield id="SDIF_DAT7IN" width="1" begin="7" end="7" resetval="0x0" description="DAT[7] Line Signal Level (Embedded Only) This status is used to check DAT line level to recover from errors, and for debugging. D07 - DAT[7]" range="" rwaccess="R"/>
    <bitfield id="SDIF_DAT6IN" width="1" begin="6" end="6" resetval="0x0" description="DAT[6] Line Signal Level (Embedded Only) This status is used to check DAT line level to recover from errors, and for debugging. D06 - DAT[6]" range="" rwaccess="R"/>
    <bitfield id="SDIF_DAT5IN" width="1" begin="5" end="5" resetval="0x0" description="DAT[5] Line Signal Level (Embedded Only) This status is used to check DAT line level to recover from errors, and for debugging. D05 - DAT[5]" range="" rwaccess="R"/>
    <bitfield id="SDIF_DAT4IN" width="1" begin="4" end="4" resetval="0x0" description="DAT[4] Line Signal Level (Embedded Only) This status is used to check DAT line level to recover from errors, and for debugging. D04 - DAT[4]" range="" rwaccess="R"/>
    <bitfield id="RETUNING_REQ" width="1" begin="3" end="3" resetval="0x0" description="Re-Tuning Request (UHS-I Only) Host Controller may request Host Driver to execute re-tuning sequence by setting this bit when the data window is shifted by temperature drift and a tuned sampling point does not have a good margin to receive correct data. This bit is cleared when a command is issued with setting the Changing of this bit from 0h to 1h generates Re-Tuning Event. This bit isn't set to 1h if the 1h: Sampling clock needs re-tuning 0h: Fixed or well tuned sampling clock" range="" rwaccess="R"/>
    <bitfield id="DATA_LINE_ACTIVE" width="1" begin="2" end="2" resetval="0x0" description="DAT Line Active (SD Mode Only) This bit indicates whether one of the DAT line on SD bus is in use. 1h: DAT line active 0h: DAT line inactive" range="" rwaccess="R"/>
    <bitfield id="INHIBIT_DAT" width="1" begin="1" end="1" resetval="0x0" description="Command Inhibit (DAT) (SD Mode Only) This status bit is generated if either the DAT Line Active or the Read transfer Active is set to 1h. If this bit is 0h, it indicates the HC can issue the next SD command. Commands with busy signal belong to Command Inhibit (DAT) (for example R1b, R5b type). Changing from 1h to 0h generates a Transfer Complete interrupt in the 1h: Cannot issue command which uses the DAT line 0h: Can issue command which uses the DAT line" range="" rwaccess="R"/>
    <bitfield id="INHIBIT_CMD" width="1" begin="0" end="0" resetval="0x0" description="Command Inhibit (CMD) 1h: Host Controller is not ready to issue a command 0h: Host Controller is ready to issue a command Version 4.10 adds a new control to prevent error statuses from overwriting by receipt of a next command. This status keeps indicating 1h while any of response error statuses is set to 1h, Command Not Issued by Error in this register is set to 1h or the" range="" rwaccess="R"/>
  </register>
  <register id="MMCSD0_RESPONSE_5" acronym="MMCSD0_RESPONSE_5" offset="0x24" width="16" description="This registers is used to store responses from SD Cards.">
    <bitfield id="CMD_RESP" width="16" begin="15" end="0" resetval="0x0" description="Command Response R[] refers to a bit range within the response data as transmitted on the SD Bus, REP[] refers to a bit range within the Response register." range="" rwaccess="R"/>
  </register>
  <register id="MMCSD0_HOST_CONTROL1" acronym="MMCSD0_HOST_CONTROL1" offset="0x28" width="8" description="This register is used to program DMA modes, LED control, data transfer width, High Speed enable, card detect test level and signal selection.">
    <bitfield id="CD_SIG_SEL" width="1" begin="7" end="7" resetval="0x0" description="Card Detect Signal Detection This bit selects source for card detection. 1h: The card detect test level is selected 0h: SDCD# is selected (for normal use)" range="" rwaccess="RW"/>
    <bitfield id="CD_TEST_LEVEL" width="1" begin="6" end="6" resetval="0x0" description="Card Detect Test Level This bit is enabled while the Card Detect Signal Selection is set to 1h and it indicates card inserted or not. Generates (card ins or card removal) interrupt when the normal interrupt status enable bit is set. 1h: Card Inserted 0h: No Card" range="" rwaccess="RW"/>
    <bitfield id="EXT_DATA_WIDTH" width="1" begin="5" end="5" resetval="0x0" description="Extended Data Transfer Width (Embedded and SD Mode Only) This bit controls 8-bit bus width mode for embedded device. Support of this function is indicated in 8-bit Support for Embedded Device in the This bit is not effective when multiple devices are installed on a bus slot (Slot Type is set to 2h in the 1h: 8-bit Bus Width 0h: Bus Width is Selected by Data Transfer Width" range="" rwaccess="RW"/>
    <bitfield id="DMA_SELECT" width="2" begin="4" end="3" resetval="0x0" description="DMA Select This field is used to select DMA type. The Host Driver shall check support of DMA modes by referring the (1) Up to Version 3.00: (2) Version 4.00 or later: Support of 64-bit DMA and 128-bit Descriptor is indicated by the" range="" rwaccess="RW"/>
    <bitfield id="HIGH_SPEED_ENA" width="1" begin="2" end="2" resetval="0x0" description="High Speed Enable (SD Mode Only) This bit is optional. Before setting this bit, the HD shall check the If the 1h: High Speed Mode 0h: Normal Speed Mode" range="" rwaccess="RW"/>
    <bitfield id="DATA_WIDTH" width="1" begin="1" end="1" resetval="0x0" description="Data Transfer Width (SD Mode Only) This bit selects the data width of the HC. The HD shall select it to match the data width of the SD card. This bit is not effective in UHS-II mode. 1h: 4 bit mode 0h: 1 bit mode" range="" rwaccess="RW"/>
    <bitfield id="LED_CONTROL" width="1" begin="0" end="0" resetval="0x0" description="LED Control This bit is used to caution the user not to remove the card while the SD card is being accessed. If the software is going to issue multiple SD commands, this bit can be set during all transactions. It is not necessary to change for each transaction. 1h: LED on 0h: LED off" range="" rwaccess="RW"/>
  </register>
  <register id="MMCSD0_RESPONSE_6" acronym="MMCSD0_RESPONSE_6" offset="0x28" width="16" description="This registers is used to store responses from SD Cards.">
    <bitfield id="CMD_RESP" width="16" begin="15" end="0" resetval="0x0" description="Command Response R[] refers to a bit range within the response data as transmitted on the SD Bus, REP[] refers to a bit range within the Response register." range="" rwaccess="R"/>
  </register>
  <register id="MMCSD0_POWER_CONTROL" acronym="MMCSD0_POWER_CONTROL" offset="0x29" width="8" description="This register is used to program the SD Bus power and voltage level.">
    <bitfield id="UHS2_VOLTAGE" width="3" begin="7" end="5" resetval="0x0" description="SD Bus Voltage Select for VDD2 (UHS-II Only) This field determines supply voltage range to VDD2. This field can be set to 5h if the 111b: Not used 110b: Not used 101b: 1.8 V 100b: Reserved for 1.2 V 011b &#8211; 001b: Reserved 000b: VDD2 Not Supported" range="" rwaccess="RW"/>
    <bitfield id="UHS2_POWER" width="1" begin="4" end="4" resetval="0x0" description="SD Bus Power for VDD2 (UHS-II Only) Setting this bit enables providing VDD2. 1h: Power on 0h: Power off" range="" rwaccess="RW"/>
    <bitfield id="SD_BUS_VOLTAGE" width="3" begin="3" end="1" resetval="0x0" description="SD Bus Voltage Select for VDD1 By setting these bits, the HD selects the voltage level for the SD card. Before setting this register, the HD shall check the voltage support bits in the 111b: 3.3 V (Flattop.) 110b: 3.0 V (Typ.) 101b: 1.8 V (Typ.) for Embedded 100b &#8211; 000b: Reserved" range="" rwaccess="RW"/>
    <bitfield id="SD_BUS_POWER" width="1" begin="0" end="0" resetval="0x0" description="SD Bus Power for VDD1 Before setting this bit, the SD host driver shall set SD Bus Voltage Select ( If this bit is cleared, the Host Controller should immediately stop driving CMD and DAT[3:0] (tri-state), and drive SDCLK to low level. If card is connected to Host Controller, Host Controller shall set these lines to low before stopping to supply VDD1. In UHS-II mode, before clearing this bit, Host Driver shall clear the 1h: Power on 0h: Power off" range="" rwaccess="RW"/>
  </register>
  <register id="MMCSD0_BLOCK_GAP_CONTROL" acronym="MMCSD0_BLOCK_GAP_CONTROL" offset="0x2A" width="8" description="This register is used to program the block gap request, read wait control and interrupt at block gap.">
    <bitfield id="BOOT_ACK_ENA" width="1" begin="7" end="7" resetval="0x1" description="Boot Acknowledge Check To check for the boot acknowledge in boot operation. 1h: Wait for boot ack from eMMC card 0h: Will not wait for boot ack from eMMC card" range="" rwaccess="RW"/>
    <bitfield id="ALT_BOOT_MODE" width="1" begin="6" end="6" resetval="0x0" description="Alternative Boot Mode To start boot code access in alternative mode. 1h: To start alternate boot mode access 0h: To stop alternate boot mode access" range="" rwaccess="RW"/>
    <bitfield id="BOOT_ENABLE" width="1" begin="5" end="5" resetval="0x0" description="Boot Enable To start boot code access. 1h: To start boot code access 0h: To stop boot code access" range="" rwaccess="RW"/>
    <bitfield id="RESERVED" width="1" begin="4" end="4" resetval="0x0" description="Reserved" range="" rwaccess="R"/>
    <bitfield id="INTRPT_AT_BLK_GAP" width="1" begin="3" end="3" resetval="0x0" description="Interrupt At Block Gap (SD Mode Only) This bit is valid only in 4-bit mode of the SDIO card and selects a sample point in the interrupt cycle. Setting to 1h enables interrupt detection at the block gap for a multiple block transfer. If the SD card cannot signal an interrupt during a multiple block transfer, this bit should be set to 0h. When the HD detects an SD card insertion, it shall set this bit according to the CCCR of the SDIO card." range="" rwaccess="RW"/>
    <bitfield id="RDWAIT_CTRL" width="1" begin="2" end="2" resetval="0x0" description="Read Wait Control (SD Mode Only) The read wait function is optional for SDIO cards. If the card supports read wait, set this bit to enable use of the read wait protocol to stop read data using DAT[2] line. Otherwise the HC has to stop the SD clock to hold read data, which restricts commands generation. When the HD detects an SD card insertion, it shall set this bit according to the CCCR of the SDIO card. If the card does not support read wait, this bit shall never be set to 1h otherwise DAT line conflict may occur. If this bit is set to 0h, Suspend/Resume cannot be supported. In UHS-II mode, Read Wait is disabled and DAT[2] line is used for Interrupt Signal from UHS-II Card. 1h: Enable Read Wait Control 0h: Disable Read Wait Control" range="" rwaccess="RW"/>
    <bitfield id="CONTINUE" width="1" begin="1" end="1" resetval="0x0" description="Continue Request This bit is used to restart a transaction which was stopped using the Stop At Block Gap Request. To cancel stop at the block gap, set Stop At block Gap Request to 0h ( The Host Controller automatically clears this bit when the transaction re-starts. If In SD mode, this bit is cleared in either of the following cases: Therefore it is not necessary for Host driver to set this bit to 0h. If 1h: Restart 0h: Ignored" range="" rwaccess="RW"/>
    <bitfield id="STOP_AT_BLK_GAP" width="1" begin="0" end="0" resetval="0x0" description="Stop At Block Gap Request This bit is used to stop executing a transaction at the next block gap for non-DMA, SDMA and ADMA transfers. Until the transfer complete is set to 1h, indicating a transfer completion the HD shall leave this bit set to 1h. Clearing both the In case of UHS-II, a transaction can be stopped at the boundary of DATA Burst (Flow Control basis). Host Controller waits for sending Flow Control MSG until the 1h: Stop 0h: Transfer" range="" rwaccess="RW"/>
  </register>
  <register id="MMCSD0_WAKEUP_CONTROL" acronym="MMCSD0_WAKEUP_CONTROL" offset="0x2B" width="8" description="This register is used to program the wakeup functionality. The register is mandatory for the HC, but wakeup functionality depends on the HC system hardware and software. The HD shall maintain voltage on the SD Bus, by setting the [0] SD_BUS_POWER bit to 1h, when wakeup event via card interrupt is desired.">
    <bitfield id="RESERVED" width="5" begin="7" end="3" resetval="0x0" description="Reserved" range="" rwaccess="R"/>
    <bitfield id="CARD_REMOVAL" width="1" begin="2" end="2" resetval="0x0" description="Wakeup Event Enable On SD Card Removal This bit enables wakeup event via Card removal assertion in the FN_WUS (Wake up Support) in CIS does not affect this bit. 1h: Enable 0h: Disable" range="" rwaccess="RW"/>
    <bitfield id="CARD_INSERTION" width="1" begin="1" end="1" resetval="0x0" description="Wakeup Event Enable On SD Card Insertion This bit enables wakeup event via Card Insertion assertion in the FN_WUS (Wake up Support) in CIS does not affect this bit. 1h: Enable 0h: Disable" range="" rwaccess="RW"/>
    <bitfield id="CARD_INTERRUPT" width="1" begin="0" end="0" resetval="0x0" description="Wakeup Event Enable On Card Interrupt This bit enables wakeup event via Card Interrupt assertion in the This bit can be set to 1h if FN_WUS (Wake Up Support) in CIS is set to 1h. 1h: Enable 0h: Disable" range="" rwaccess="RW"/>
  </register>
  <register id="MMCSD0_CLOCK_CONTROL" acronym="MMCSD0_CLOCK_CONTROL" offset="0x2C" width="16" description="This register is used to program the Clock frequency select, Clock generator select, Clock enable, Internal clock state fields. At the initialization of the HC, the HD shall set the SDCLK Frequency Select ([15-8] SDCLK_FRQSEL) according to the register. This register controls SDCLK in SD Mode and RCLK in UHS-II mode.">
    <bitfield id="SDCLK_FRQSEL" width="8" begin="15" end="8" resetval="0x0" description="SDCLK/RCLK Frequency Select This register is used to select the frequency of the SDCLK pin. The frequency is not programmed directly; rather this register holds the divisor of the Base Clock Frequency For SD clock in the Capabilities register ( Only the following settings are allowed. (1) 8-bit Divided Clock Mode: Setting 00h specifies the highest frequency of the SD Clock. When setting multiple bits, the most significant bit is used as the divisor. But multiple bits should not be set. The three default divider values can be calculated by the frequency that is defined by the 400 KHz divider value 25 MHz divider value 50 MHz divider value According to the Physical Layer Specification, the maximum SD Clock frequency is 25 MHz in normal speed mode and 50 MHz in high speed mode, and shall never exceed this limit. The frequency of SDCLK is set by the following formula: Clock Frequency = (Base Clock) / divisor Thus, choose the smallest possible divisor which results in a clock frequency that is less than or equal to the target frequency. For example, if the (2) 10-bit Divided Clock Mode: (3) Programmable Clock Mode: This field depends on setting of the If If" range="" rwaccess="RW"/>
    <bitfield id="SDCLK_FRQSEL_UPBITS" width="2" begin="7" end="6" resetval="0x0" description="Upper Bits of SDCLK/RCLK Frequency Select This bit field is assigned to the" range="" rwaccess="RW"/>
    <bitfield id="CLKGEN_SEL" width="1" begin="5" end="5" resetval="0x0" description="Clock Generator Select This bit is used to select the clock generator mode in SDCLK/RCLK Frequency Select ( If the Programmable Clock Mode is supported (non-zero value is set to the This bit depends on the setting of the If If 1h: Programmable Clock Mode 0h: Divided Clock Mode" range="" rwaccess="RW"/>
    <bitfield id="RESERVED" width="1" begin="4" end="4" resetval="0x0" description="Reserved" range="" rwaccess="R"/>
    <bitfield id="PLL_ENA" width="1" begin="3" end="3" resetval="0x0" description="PLL Enable This bit is added from Version 4.10 for Host Controller using PLL. This feature allows Host Controller to initialize clock generator in two steps: by Internal Clock Enable ( (1) When (2) When 1h: PLL is enabled 0h: PLL is in low power mode" range="" rwaccess="RW"/>
    <bitfield id="SD_CLK_ENA" width="1" begin="2" end="2" resetval="0x0" description="SD Clock Enable The HC shall stop SDCLK when writing this bit to 0h. The 1h: Enable providing SDCLK or RCLK 0h: Disable providing SDCLK or RCLK" range="" rwaccess="RW"/>
    <bitfield id="INT_CLK_STABLE" width="1" begin="1" end="1" resetval="0x0" description="Internal Clock Stable This bit is set to 1h when SD clock is stable after writing 1h to (1) Internal Clock Stable (when This bit is set to 1h when internal clock is stable after writing 1h to (2) PLL Clock Stable (when Host Controller which supports PLL Enable sets this status to 0h once when PLL Enable is changed 0h to 1h and then this status is set to 1h when PLL is locked (PLL uses an internal clock in stable as a reference clock which is enabled by the 1h: Ready 0h: Not Ready" range="" rwaccess="R"/>
    <bitfield id="INT_CLK_ENA" width="1" begin="0" end="0" resetval="0x0" description="Internal Clock Enable This bit is set to 0h when the HD is not using the HC or the HC awaits a wakeup event. The HC should stop its internal clock to go very low power state. Still, registers shall be able to be read and written. Clock starts to oscillate when this bit is set to 1h. When clock oscillation is stable, the HC shall set the 1h: Oscillate 0h: Stop" range="" rwaccess="RW"/>
  </register>
  <register id="MMCSD0_TIMEOUT_CONTROL" acronym="MMCSD0_TIMEOUT_CONTROL" offset="0x2E" width="8" description="The register sets the data timeout counter value. At the initialization of the HC, the HD shall set the Data Timeout Counter Value according to the register.">
    <bitfield id="RESERVED" width="4" begin="7" end="4" resetval="0x0" description="Reserved" range="" rwaccess="R"/>
    <bitfield id="COUNTER_VALUE" width="4" begin="3" end="0" resetval="0x0" description="Data Timeout Counter Value This value determines the interval by which DAT line time-outs are detected. Refer to the 1111: Reserved 1110: TMCLK &#215; 2 -------------------- -------------------- 0001: TMCLK &#215; 2 0000: TMCLK &#215; 2" range="" rwaccess="RW"/>
  </register>
  <register id="MMCSD0_SOFTWARE_RESET" acronym="MMCSD0_SOFTWARE_RESET" offset="0x2F" width="8" description="This register is used to program the software reset for data, command and for all. A reset pulse is generated when writing 1h to each bit of this register. After completing the reset, the HC shall clear each bit. Because it takes some time to complete software reset, the SD Host Driver shall confirm that these bits are 0h.">
    <bitfield id="RESERVED" width="5" begin="7" end="3" resetval="0x0" description="Reserved" range="" rwaccess="R"/>
    <bitfield id="SWRST_FOR_DAT" width="1" begin="2" end="2" resetval="0x0" description="Software Reset for DAT Line (SD Mode Only) Only part of data circuit is reset. The following registers and bits are cleared by this bit: 1h: Reset 0h: Work" range="" rwaccess="RW"/>
    <bitfield id="SWRST_FOR_CMD" width="1" begin="1" end="1" resetval="0x0" description="Software Reset for CMD Line (SD Mode Only) Only part of command circuit is reset to be able to issue a command. From Version 4.10, this bit is also used to initialize UHS-II command circuit. This reset is effective only command issuing circuit (including response error statuses related to Command Inhibit (CMD) control - The following registers and bits are cleared by this bit: Response error statuses related to Command Inhibit (CMD) - 1h: Reset 0h: Work" range="" rwaccess="RW"/>
    <bitfield id="SWRST_FOR_ALL" width="1" begin="0" end="0" resetval="0x0" description="Software Reset for All This reset affects the entire HC except for the card detection circuit. Register bits of type ROC, RW, RW1C, RWAC are cleared to 0h. During its initialization, the HD shall set this bit to 1h to reset the HC. The HC shall reset this bit to 0h when Capabilities registers are valid and the HD can read them. Additional use of 'Software Reset For All' may not affect the value of the Capabilities registers. If this bit is set to 1h, the SD card shall reset itself and must be re-initialized by the HD. 1h: Reset 0h: Work" range="" rwaccess="RW"/>
  </register>
  <register id="MMCSD0_NORMAL_INTR_STS" acronym="MMCSD0_NORMAL_INTR_STS" offset="0x30" width="16" description="This register gives the status of all the interrupts. The Normal Interrupt Signal Enable (see register) affects read of this register, but Normal Interrupt Signal does not affect these reads. An Interrupt is generated when the Normal Interrupt Signal Enable is enabled and at least one of the status bits is set to 1h. For all bits except Card Interrupt ([8] CARD_INTR) and Error Interrupt ([15] ERROR_INTR), writing 1h to a bit clears it. The [8] CARD_INTR bit is cleared when the card stops asserting the interrupt: that is when the Card Driver services the Interrupt condition.">
    <bitfield id="ERROR_INTR" width="1" begin="15" end="15" resetval="0x0" description="Error Interrupt If any of the bits in the In UHS-II mode is enabled, if any of the bits in the 0h: No Error 1h: Error" range="" rwaccess="R"/>
    <bitfield id="BOOT_COMPLETE" width="1" begin="14" end="14" resetval="0x0" description="Boot Terminate Interrupt This status is set if the boot operation gets terminated. 0h: Boot operation is not terminated 1h: Boot operation is terminated" range="" rwaccess="RW1C"/>
    <bitfield id="RCV_BOOT_ACK" width="1" begin="13" end="13" resetval="0x0" description="Boot Acknowledge Receive This status is set if the boot acknowledge is received from device. 0h: Boot acknowledge is not received 1h: Boot acknowledge is received" range="" rwaccess="RW1C"/>
    <bitfield id="RETUNING_EVENT" width="1" begin="12" end="12" resetval="0x0" description="Re-Tuning Event (UHS-I Only) This status is set if the Host Controller requests Host Driver to perform re-tuning for next data transfer. Current data transfer (not large block count) can be completed without re-tuning. In UHS-II mode, this bit is not effective. 1h: Re-Tuning should be performed 0h: Re-Tuning is not required" range="" rwaccess="R"/>
    <bitfield id="INTC" width="1" begin="11" end="11" resetval="0x0" description="int_c (Embedded) This status is set if INT_C is enabled and INT_C# pin is in low level. Writing this bit to 1h does not clear this bit. It is cleared by resetting the INT_C interrupt factor." range="" rwaccess="R"/>
    <bitfield id="INTB" width="1" begin="10" end="10" resetval="0x0" description="int_b (Embedded) This status is set if INT_B is enabled and INT_B# pin is in low level. Writing this bit to 1h does not clear this bit. It is cleared by resetting the INT_B interrupt factor." range="" rwaccess="R"/>
    <bitfield id="INTA" width="1" begin="9" end="9" resetval="0x0" description="int_a (Embedded) This status is set if INT_A is enabled and INT_A# pin is in low level. Writing this bit to 1h does not clear this bit. It is cleared by resetting the INT_A interrupt factor." range="" rwaccess="R"/>
    <bitfield id="CARD_INTR" width="1" begin="8" end="8" resetval="0x0" description="Card Interrupt When this status has been set and the Host Driver needs to start this interrupt service, the Writing this bit to 1h does not clear this bit. It is cleared by resetting the SD card interrupt factor. (1) DAT[1] Interrupt Input in SD Mode In 1-bit mode, the Host Controller shall detect the Card Interrupt without SD Clock to support wakeup. In 4-bit mode, the card interrupt signal is sampled during the interrupt cycle, so there are some sample delays between the interrupt signal from the SD card and the interrupt to the Host System. Interrupt detected by DAT[1] is supported when there is a card per slot. In case of UHS-I mode, switching time of Interrupt Period is relaxed for 2 clock cycles. Then Host Controller needs to delay start of interrupt sampling at least 2 clocks and should sample interrupt while Interrupt Period is stable. (2) DAT[2] Interrupt Input in UHS-II Mode When the (3) INT MSG in UHS-II Mode INT MSG is enabled by setting the 1h: Generate Card Interrupt 0h: No Card Interrupt" range="" rwaccess="R"/>
    <bitfield id="CARD_REM" width="1" begin="7" end="7" resetval="0x0" description="Card Removal This status is set if the 0h: Card State Stable or Debouncing 1h: Card Removed" range="" rwaccess="RW1C"/>
    <bitfield id="CARD_INS" width="1" begin="6" end="6" resetval="0x0" description="Card Insertion This status is set if the 0h: Card State Stable or Debouncing 1h: Card Inserted" range="" rwaccess="RW1C"/>
    <bitfield id="BUF_RD_READY" width="1" begin="5" end="5" resetval="0x0" description="Buffer Read Ready This status is set if the The In UHS-II mode, this bit is set at FC (Flow Control) unit basis. 0h: Not Ready to read Buffer 1h: Ready to read Buffer" range="" rwaccess="RW1C"/>
    <bitfield id="BUF_WR_READY" width="1" begin="4" end="4" resetval="0x0" description="Buffer Write Ready This status is set if the In UHS-II mode, this bit is set at FC (Flow Control) unit basis. 0h: Not Ready to Write Buffer 1h: Ready to Write Buffer" range="" rwaccess="RW1C"/>
    <bitfield id="DMA_INTERRUPT" width="1" begin="3" end="3" resetval="0x0" description="DMA Interrupt This status is set if the HC detects the Host DMA Buffer Boundary in the 0h: No DMA Interrupt 1h: DMA Interrupt is Generated" range="" rwaccess="RW1C"/>
    <bitfield id="BLK_GAP_EVENT" width="1" begin="2" end="2" resetval="0x0" description="Block Gap Event If the Read Transaction: This bit is set at the falling edge of the DAT Line Active Status (see Write Transaction: This bit is set at the falling edge of Write Transfer Active Status (see 0h: No Block Gap Event 1h: Transaction stopped at Block Gap" range="" rwaccess="RW1C"/>
    <bitfield id="XFER_COMPLETE" width="1" begin="1" end="1" resetval="0x0" description="Transfer Complete This bit is set when a read/write transaction is completed. Read Transaction: This bit is set at the falling edge of Read Transfer Active Status ( There are two cases in which the Interrupt is generated. The first is when a data transfer is completed as specified by data length (after the last data has been read to the Host System). The second is when data has stopped at the block gap and completed the data transfer by setting the Write Transaction: This bit is set at the falling edge of the DAT Line Active Status (see Command with Busy: This bit is set when busy is de-asserted. Refer to DAT Line Active and Command Inhibit (DAT) in the While performing tuning procedure (the 0h: No Data Transfer Complete 1h: Data Transfer Complete This interrupt is generated in following two cases: (a) EBSY Completion (for EBSY supported commands) When the (b) Stop and Continue during DCMD Data Transfer When the Following is for both SD mode and UHS-II mode. The table below shows that the 1h: Command execution is completed 0h: Not complete" range="" rwaccess="RW1C"/>
    <bitfield id="CMD_COMPLETE" width="1" begin="0" end="0" resetval="0x0" description="Command Complete This bit is set when we get the end bit of the command response (Except Auto CMD12 and Auto CMD23). Version 4.00 defines response check function for R1 and R5. If the If the If the 0h: No Command Complete 1h: Command Complete" range="" rwaccess="RW1C"/>
  </register>
  <register id="MMCSD0_ERROR_INTR_STS" acronym="MMCSD0_ERROR_INTR_STS" offset="0x32" width="16" description="This register gives the status of the error interrupts. Status defined in this register can be enabled by the register, but not by the register. The Interrupt is generated when the register is enabled and at least one of the statuses is set to 1h. Writing to 1h clears the bit and writing to 0h keeps the bit unchanged. More than one status can be cleared at the one register write.">
    <bitfield id="RESERVED" width="3" begin="15" end="13" resetval="0x0" description="Reserved" range="" rwaccess="R"/>
    <bitfield id="HOST" width="1" begin="12" end="12" resetval="0x0" description="Target Response Error Occurs when detecting ERROR in m_hresp (DMA transaction) 0h: No error 1h: Error" range="" rwaccess="RW1C"/>
    <bitfield id="RESP" width="1" begin="11" end="11" resetval="0x0" description="Response Error (SD Mode Only) Host Controller Version 4.00 supports response error check function to avoid overhead of response error check by Host Driver during DMA execution. If the 0h: No error 1h: Error" range="" rwaccess="RW1C"/>
    <bitfield id="RESERVED" width="1" begin="10" end="10" resetval="0x0" description="Reserved" range="" rwaccess="R"/>
    <bitfield id="ADMA" width="1" begin="9" end="9" resetval="0x0" description="ADMA Error This bit is set when the Host Controller detects errors during ADMA based data transfer. The state of the ADMA at an error occurrence is saved in the 0h: No error 1h: Error" range="" rwaccess="RW1C"/>
    <bitfield id="AUTO_CMD" width="1" begin="8" end="8" resetval="0x0" description="Auto CMD Error (SD Mode Only) Auto CMD12 and Auto CMD23 use this error status. This bit is set when detecting that any of the bits D00 to D05 in the 0h: No error 1h: Error" range="" rwaccess="RW1C"/>
    <bitfield id="CURR_LIMIT" width="1" begin="7" end="7" resetval="0x0" description="Current Limit Error By setting the 0h: No error 1h: Power Fail" range="" rwaccess="RW1C"/>
    <bitfield id="DATA_ENDBIT" width="1" begin="6" end="6" resetval="0x0" description="Data End Bit Error (SD Mode Only) Occurs when detecting 0 at the end bit position of read data which uses the DAT line or the end bit position of the CRC status. 0h: No error 1h: Error" range="" rwaccess="RW1C"/>
    <bitfield id="DATA_CRC" width="1" begin="5" end="5" resetval="0x0" description="Data CRC Error (SD Mode Only) Occurs when detecting CRC error when transferring read data which uses the DAT line or when detecting the Write CRC Status having a value of other than 2h. 0h: No error 1h: Error" range="" rwaccess="RW1C"/>
    <bitfield id="DATA_TIMEOUT" width="1" begin="4" end="4" resetval="0x0" description="Data Timeout Error (SD Mode Only) Occurs when detecting one of following timeout conditions: 0h: No error 1h: Timeout" range="" rwaccess="RW1C"/>
    <bitfield id="CMD_INDEX" width="1" begin="3" end="3" resetval="0x0" description="Command Index Error (SD Mode Only) Occurs if a Command Index error occurs in the Command Response ( 0h: No error 1h: Error" range="" rwaccess="RW1C"/>
    <bitfield id="CMD_ENDBIT" width="1" begin="2" end="2" resetval="0x0" description="Command End Bit Error (SD Mode Only) Occurs when detecting that the end bit of a command response is 0h. 0h: No error 1h: End Bit Error Generated" range="" rwaccess="RW1C"/>
    <bitfield id="CMD_CRC" width="1" begin="1" end="1" resetval="0x0" description="Command CRC Error (SD Mode Only) Command CRC Error is generated in two cases. 1. If a response is returned and the 2. The HC detects a CMD line conflict by monitoring the CMD line when a command is issued. If the HC drives the CMD line to 1 level, but detects 0 level on the CMD line at the next SDCLK edge, then the HC shall abort the command (Stop driving CMD line) and set this bit to 1h. The 0h: No error 1h: CRC Error Generated" range="" rwaccess="RW1C"/>
    <bitfield id="CMD_TIMEOUT" width="1" begin="0" end="0" resetval="0x0" description="Command Timeout Error (SD Mode Only) Occurs only if the no response is returned within 64 SDCLK cycles from the end bit of the command. If the HC detects a CMD line conflict, in which case the 0h: No error 1h: Timeout" range="" rwaccess="RW1C"/>
  </register>
  <register id="MMCSD0_NORMAL_INTR_STS_ENA" acronym="MMCSD0_NORMAL_INTR_STS_ENA" offset="0x34" width="16" description="This register is used to enable the register fields.">
    <bitfield id="BIT15_FIXED0" width="1" begin="15" end="15" resetval="0x0" description="Fixed to 0 The HC shall control error Interrupts using the" range="" rwaccess="R"/>
    <bitfield id="BOOT_COMPLETE" width="1" begin="14" end="14" resetval="0x0" description="Boot Terminate Interrupt Enable 0h: Masked 1h: Enabled" range="" rwaccess="RW"/>
    <bitfield id="RCV_BOOT_ACK" width="1" begin="13" end="13" resetval="0x0" description="Boot Acknowledge Enable 0h: Masked 1h: Enabled" range="" rwaccess="RW"/>
    <bitfield id="RETUNING_EVENT" width="1" begin="12" end="12" resetval="0x0" description="Re-Tuning Event Status Enable (UHS-I Only) 0h: Masked 1h: Enabled" range="" rwaccess="RW"/>
    <bitfield id="INTC" width="1" begin="11" end="11" resetval="0x0" description="INT_C Status Enable (Embedded) If this bit is set to 0h, the Host Controller shall clear the interrupt request to the System. The Host Driver may clear this bit before servicing the INT_C and may set this bit again after all interrupt requests to INT_C pin are cleared to prevent inadvertent interrupts." range="" rwaccess="RW"/>
    <bitfield id="INTB" width="1" begin="10" end="10" resetval="0x0" description="INT_B Status Enable (Embedded) If this bit is set to 0h, the Host Controller shall clear the interrupt request to the System. The Host Driver may clear this bit before servicing the INT_B and may set this bit again after all interrupt requests to INT_B pin are cleared to prevent inadvertent interrupts." range="" rwaccess="RW"/>
    <bitfield id="INTA" width="1" begin="9" end="9" resetval="0x0" description="INT_A Status Enable (Embedded) If this bit is set to 0h, the Host Controller shall clear the interrupt request to the System. The Host Driver may clear this bit before servicing the INT_A and may set this bit again after all interrupt requests to INT_A pin are cleared to prevent inadvertent interrupts." range="" rwaccess="RW"/>
    <bitfield id="CARD_INTERRUPT" width="1" begin="8" end="8" resetval="0x0" description="Card Interrupt Status Enable If this bit is set to 0h, the HC shall clear Interrupt request to the System. The Card Interrupt detection is stopped when this bit is cleared and restarted when this bit is set to 1h. The HD may clear the By setting this bit to 0h, interrupt input should be masked by implementation so that the interrupt Input is not affected by external signal in any state (for example: floating). 0h: Masked 1h: Enabled" range="" rwaccess="RW"/>
    <bitfield id="CARD_REMOVAL" width="1" begin="7" end="7" resetval="0x0" description="Card Removal Status Enable 0h: Masked 1h: Enabled" range="" rwaccess="RW"/>
    <bitfield id="CARD_INSERTION" width="1" begin="6" end="6" resetval="0x0" description="Card Insertion Status Enable 0h: Masked 1h: Enabled" range="" rwaccess="RW"/>
    <bitfield id="BUF_RD_READY" width="1" begin="5" end="5" resetval="0x0" description="Buffer Read Ready Status Enable 0h: Masked 1h: Enabled" range="" rwaccess="RW"/>
    <bitfield id="BUF_WR_READY" width="1" begin="4" end="4" resetval="0x0" description="Buffer Write Ready Status Enable 0h: Masked 1h: Enabled" range="" rwaccess="RW"/>
    <bitfield id="DMA_INTERRUPT" width="1" begin="3" end="3" resetval="0x0" description="DMA Interrupt Status Enable 0h: Masked 1h: Enabled" range="" rwaccess="RW"/>
    <bitfield id="BLK_GAP_EVENT" width="1" begin="2" end="2" resetval="0x0" description="Block Gap Event Status Enable 0h: Masked 1h: Enabled" range="" rwaccess="RW"/>
    <bitfield id="XFER_COMPLETE" width="1" begin="1" end="1" resetval="0x0" description="Transfer Complete Status Enable 0h: Masked 1h: Enabled" range="" rwaccess="RW"/>
    <bitfield id="CMD_COMPLETE" width="1" begin="0" end="0" resetval="0x0" description="Command Complete Status Enable 0h: Masked 1h: Enabled" range="" rwaccess="RW"/>
  </register>
  <register id="MMCSD0_ERROR_INTR_STS_ENA" acronym="MMCSD0_ERROR_INTR_STS_ENA" offset="0x36" width="16" description="This register is used to enable the register fields.">
    <bitfield id="VENDOR_SPECIFIC" width="4" begin="15" end="12" resetval="0x0" description="Vendor Specific Error Status Enable N/A" range="" rwaccess="RW"/>
    <bitfield id="RESP" width="1" begin="11" end="11" resetval="0x0" description="Response Error Status Enable (SD Mode Only) 0h: Masked 1h: Enabled" range="" rwaccess="RW"/>
    <bitfield id="TUNING" width="1" begin="10" end="10" resetval="0x0" description="Tuning Error Status Enable (UHS-I Only) 0h: Masked 1h: Enabled" range="" rwaccess="RW"/>
    <bitfield id="ADMA" width="1" begin="9" end="9" resetval="0x0" description="ADMA Error Status Enable 0h: Masked 1h: Enabled" range="" rwaccess="RW"/>
    <bitfield id="AUTO_CMD" width="1" begin="8" end="8" resetval="0x0" description="Auto CMD Error Status Enable (SD Mode Only) 0h: Masked 1h: Enabled" range="" rwaccess="RW"/>
    <bitfield id="CURR_LIMIT" width="1" begin="7" end="7" resetval="0x0" description="Current Limit Error Status Enable 0h: Masked 1h: Enabled" range="" rwaccess="RW"/>
    <bitfield id="DATA_ENDBIT" width="1" begin="6" end="6" resetval="0x0" description="Data End Bit Error Status Enable (SD Mode Only) 0h: Masked 1h: Enabled" range="" rwaccess="RW"/>
    <bitfield id="DATA_CRC" width="1" begin="5" end="5" resetval="0x0" description="Data CRC Error Status Enable (SD Mode Only) 0h: Masked 1h: Enabled" range="" rwaccess="RW"/>
    <bitfield id="DATA_TIMEOUT" width="1" begin="4" end="4" resetval="0x0" description="Data Timeout Error Status Enable (SD Mode Only) 0h: Masked 1h: Enabled" range="" rwaccess="RW"/>
    <bitfield id="CMD_INDEX" width="1" begin="3" end="3" resetval="0x0" description="Command Index Error Status Enable (SD Mode Only) 0h: Masked 1h: Enabled" range="" rwaccess="RW"/>
    <bitfield id="CMD_ENDBIT" width="1" begin="2" end="2" resetval="0x0" description="Command End Bit Error Status Enable (SD Mode Only) 0h: Masked 1h: Enabled" range="" rwaccess="RW"/>
    <bitfield id="CMD_CRC" width="1" begin="1" end="1" resetval="0x0" description="Command CRC Error Status Enable (SD Mode Only) 0h: Masked 1h: Enabled" range="" rwaccess="RW"/>
    <bitfield id="CMD_TIMEOUT" width="1" begin="0" end="0" resetval="0x0" description="Command Timeout Error Status Enable (SD Mode Only) 0h: Masked 1h: Enabled" range="" rwaccess="RW"/>
  </register>
  <register id="MMCSD0_NORMAL_INTR_SIG_ENA" acronym="MMCSD0_NORMAL_INTR_SIG_ENA" offset="0x38" width="16" description="Normal Interrupt Signal Enable Register This register is used to select which interrupt status is indicated to the Host System as the Interrupt. These status bits all share the sample 1 bit interrupt line. Setting any of these bits to 1h enables Interrupt generation.">
    <bitfield id="BIT15_FIXED0" width="1" begin="15" end="15" resetval="0x0" description="Fixed to 0 The HD shall control error Interrupts using the" range="" rwaccess="R"/>
    <bitfield id="BOOT_COMPLETE" width="1" begin="14" end="14" resetval="0x0" description="Boot Terminate Interrupt Signal Enable 0h: Masked 1h: Enabled" range="" rwaccess="RW"/>
    <bitfield id="RCV_BOOT_ACK" width="1" begin="13" end="13" resetval="0x0" description="Boot Acknowledge Receive Signal Enable 0h: Masked 1h: Enabled" range="" rwaccess="RW"/>
    <bitfield id="RETUNING_EVENT" width="1" begin="12" end="12" resetval="0x0" description="Re-Tuning Event Signal Enable (UHS-I Only) 0h: Masked 1h: Enabled" range="" rwaccess="RW"/>
    <bitfield id="INTC" width="1" begin="11" end="11" resetval="0x0" description="INT_C Signal Enable (Embedded) 0h: Masked 1h: Enabled" range="" rwaccess="RW"/>
    <bitfield id="INTB" width="1" begin="10" end="10" resetval="0x0" description="INT_B Signal Enable (Embedded) 0h: Masked 1h: Enabled" range="" rwaccess="RW"/>
    <bitfield id="INTA" width="1" begin="9" end="9" resetval="0x0" description="INT_A Signal Enable (Embedded) 0h: Masked 1h: Enabled" range="" rwaccess="RW"/>
    <bitfield id="CARD_INTERRUPT" width="1" begin="8" end="8" resetval="0x0" description="Card Interrupt Signal Enable 0h: Masked 1h: Enabled" range="" rwaccess="RW"/>
    <bitfield id="CARD_REMOVAL" width="1" begin="7" end="7" resetval="0x0" description="Card Removal Signal Enable 0h: Masked 1h: Enabled" range="" rwaccess="RW"/>
    <bitfield id="CARD_INSERTION" width="1" begin="6" end="6" resetval="0x0" description="Card Insertion Signal Enable 0h: Masked 1h: Enabled" range="" rwaccess="RW"/>
    <bitfield id="BUF_RD_READY" width="1" begin="5" end="5" resetval="0x0" description="Buffer Read Ready Signal Enable 0h: Masked 1h: Enabled" range="" rwaccess="RW"/>
    <bitfield id="BUF_WR_READY" width="1" begin="4" end="4" resetval="0x0" description="Buffer Write Ready Signal Enable 0h: Masked 1h: Enabled" range="" rwaccess="RW"/>
    <bitfield id="DMA_INTERRUPT" width="1" begin="3" end="3" resetval="0x0" description="DMA Interrupt Signal Enable 0h: Masked 1h: Enabled" range="" rwaccess="RW"/>
    <bitfield id="BLK_GAP_EVENT" width="1" begin="2" end="2" resetval="0x0" description="Block Gap Event Signal Enable 0h: Masked 1h: Enabled" range="" rwaccess="RW"/>
    <bitfield id="XFER_COMPLETE" width="1" begin="1" end="1" resetval="0x0" description="Transfer Complete Signal Enable 0h: Masked 1h: Enabled" range="" rwaccess="RW"/>
    <bitfield id="CMD_COMPLETE" width="1" begin="0" end="0" resetval="0x0" description="Command Complete Signal Enable 0h: Masked 1h: Enabled" range="" rwaccess="RW"/>
  </register>
  <register id="MMCSD0_ERROR_INTR_SIG_ENA" acronym="MMCSD0_ERROR_INTR_SIG_ENA" offset="0x3A" width="16" description="Error Interrupt Signal Enable Register This register is used to select which interrupt status is notified to the Host System as the Interrupt. These status bits all share the same 1 bit interrupt line. Setting any of these bits to 1h enables Interrupt generation.">
    <bitfield id="VENDOR_SPECIFIC" width="4" begin="15" end="12" resetval="0x0" description="Vendor Specific Error Signal Enable N/A" range="" rwaccess="RW"/>
    <bitfield id="RESP" width="1" begin="11" end="11" resetval="0x0" description="Response Error Signal Enable (SD Mode Only) 0h: Masked 1h: Enabled" range="" rwaccess="RW"/>
    <bitfield id="TUNING" width="1" begin="10" end="10" resetval="0x0" description="Tuning Error Signal Enable (UHS-I Only) 0h: Masked 1h: Enabled" range="" rwaccess="RW"/>
    <bitfield id="ADMA" width="1" begin="9" end="9" resetval="0x0" description="ADMA Error Signal Enable 0h: Masked 1h: Enabled" range="" rwaccess="RW"/>
    <bitfield id="AUTO_CMD" width="1" begin="8" end="8" resetval="0x0" description="Auto CMD Error Signal Enable (SD Mode Only) 0h: Masked 1h: Enabled" range="" rwaccess="RW"/>
    <bitfield id="CURR_LIMIT" width="1" begin="7" end="7" resetval="0x0" description="Current Limit Error Signal Enable 0h: Masked 1h: Enabled" range="" rwaccess="RW"/>
    <bitfield id="DATA_ENDBIT" width="1" begin="6" end="6" resetval="0x0" description="Data End Bit Error Signal Enable (SD Mode Only) 0h: Masked 1h: Enabled" range="" rwaccess="RW"/>
    <bitfield id="DATA_CRC" width="1" begin="5" end="5" resetval="0x0" description="Data CRC Error Signal Enable (SD Mode Only) 0h: Masked 1h: Enabled" range="" rwaccess="RW"/>
    <bitfield id="DATA_TIMEOUT" width="1" begin="4" end="4" resetval="0x0" description="Data Timeout Error Signal Enable (SD Mode Only) 0h: Masked 1h: Enabled" range="" rwaccess="RW"/>
    <bitfield id="CMD_INDEX" width="1" begin="3" end="3" resetval="0x0" description="Command Index Error Signal Enable (SD Mode Only) 0h: Masked 1h: Enabled" range="" rwaccess="RW"/>
    <bitfield id="CMD_ENDBIT" width="1" begin="2" end="2" resetval="0x0" description="Command End Bit Error Signal Enable (SD Mode Only) 0h: Masked 1h: Enabled" range="" rwaccess="RW"/>
    <bitfield id="CMD_CRC" width="1" begin="1" end="1" resetval="0x0" description="Command CRC Error Signal Enable (SD Mode Only) 0h: Masked 1h: Enabled" range="" rwaccess="RW"/>
    <bitfield id="CMD_TIMEOUT" width="1" begin="0" end="0" resetval="0x0" description="Command Timeout Error Signal Enable (SD Mode Only) 0h: Masked 1h: Enabled" range="" rwaccess="RW"/>
  </register>
  <register id="MMCSD0_AUTOCMD_ERR_STS" acronym="MMCSD0_AUTOCMD_ERR_STS" offset="0x3C" width="16" description="This register is used to indicate CMD12 response error of Auto CMD12 and CMD23 response error of Auto CMD23. The Host driver can determine what kind of Auto CMD12/CMD23 errors occur by this register. Auto CMD23 errors are indicated in bit 04-01. This register is valid only when the Auto CMD Error is set.">
    <bitfield id="RESERVED" width="8" begin="15" end="8" resetval="0x0" description="Reserved" range="" rwaccess="R"/>
    <bitfield id="CMD_NOT_ISSUED" width="1" begin="7" end="7" resetval="0x0" description="Command Not Issued By Auto CMD12 Error Setting this bit to 1h means CMD_wo_DAT is not executed due to an Auto CMD12 error (D04- D01) in this register. This bit is set to 0h when Auto CMD Error is generated by Auto CMD23. 0h: No Error 1h: Not Issued" range="" rwaccess="R"/>
    <bitfield id="RESERVED" width="2" begin="6" end="5" resetval="0x0" description="Reserved" range="" rwaccess="R"/>
    <bitfield id="INDEX" width="1" begin="4" end="4" resetval="0x0" description="Auto CMD Index Error Occurs if the Command Index error occurs in response to a command. 0h: No Error 1h: Error" range="" rwaccess="R"/>
    <bitfield id="ENDBIT" width="1" begin="3" end="3" resetval="0x0" description="Auto CMD End Bit Error Occurs when detecting that the end bit of command response is 0h. 0h: No Error 1h: End Bit Error Generated" range="" rwaccess="R"/>
    <bitfield id="CRC" width="1" begin="2" end="2" resetval="0x0" description="Auto CMD CRC Error Occurs when detecting a CRC error in the command response. 0h: No Error 1h: CRC Error Generated" range="" rwaccess="R"/>
    <bitfield id="TIMEOUT" width="1" begin="1" end="1" resetval="0x0" description="Auto CMD Timeout Error Occurs if the no response is returned within 64 SDCLK cycles from the end bit of the command. If this bit is set to 1h, the other error status bits (D04 - D02) are meaningless. 0h: No Error 1h: Timeout" range="" rwaccess="R"/>
    <bitfield id="ACMD12_NOT_EXEC" width="1" begin="0" end="0" resetval="0x0" description="Auto CMD12 not Executed If memory multiple block data transfer is not started due to command error, this bit is not set because it is not necessary to issue Auto CMD12. Setting this bit to 1h means the HC cannot issue Auto CMD12 to stop memory multiple block transfer due to some error. If this bit is set to 1h, other error status bits (D04 - D01) are meaningless. This bit is set to 0h when Auto CMD Error is generated by Auto CMD23. 0h: Executed 1h: Not Executed" range="" rwaccess="R"/>
  </register>
  <register id="MMCSD0_HOST_CONTROL2" acronym="MMCSD0_HOST_CONTROL2" offset="0x3E" width="16" description="This register is used to program UHS Mode Select, Driver Strength Select, Execute Tuning, Sampling Clock Select, Asynchronous Interrupt Enable and Preset Value Enable.">
    <bitfield id="PRESET_VALUE_ENA" width="1" begin="15" end="15" resetval="0x0" description="Preset Value Enable Host Controller Version 3.00 supports this bit. As the operating SDCLK frequency and I/O driver strength depend on the Host System implementation, it is difficult to determine these parameters in the Standard Host Driver. When the If this bit is set to 0h, SDCLK Frequency Select, Clock Generator Select in the If this bit is set to 1h, SDCLK Frequency Select, Clock Generator Select in the 0h: SDCLK and Driver Strength are controlled by Host Driver 1h: Automatic Selection by Preset Value are Enabled" range="" rwaccess="RW"/>
    <bitfield id="ASYNCH_INTR_ENA" width="1" begin="14" end="14" resetval="0x0" description="Asynchronous Interrupt Enable This bit can be set to 1h if a card support asynchronous interrupt and the 0h: Disabled 1h: Enabled" range="" rwaccess="RW"/>
    <bitfield id="BIT64_ADDRESSING" width="1" begin="13" end="13" resetval="0x0" description="64-bit Addressing This field is effective when the Host Controller selects either of 32-bit or 64-bit addressing modes to access system memory. Whether 32-bit or 64-bit is determined by OS installed in a host system. Host Driver sets this bit depends on addressing mode of installed OS. Refer to 64-bit System Address Support in the 0h: 32-bits Addressing 1h: 64-bits Addressing" range="" rwaccess="RW"/>
    <bitfield id="HOST_VER40_ENA" width="1" begin="12" end="12" resetval="0x0" description="Host Version 4 Enable This bit selects either Version 3.00 compatible mode or Version 4.00 mode. In Version 4.00, support of 64-bit System Addressing is modified. All DMAs support 64-bit System Addressing. UHS-II supported Host Driver shall enable this bit. In Version 4.10, supported 32-bit Block Count for all operations. Functions of following fields are modified. SDMA uses the ADMA3 is selected by 128-bit descriptor is used instead of 96-bit descriptor when 64-bit Addressing is set to 1h. Either 32-bit or 64-bit system addressing is selected by 64-bit Addressing bit in this register instead of SDMA System Address register ( 0h: Version 3.00 Compatible Mode 1h: Version 4.Mode" range="" rwaccess="RW"/>
    <bitfield id="CMD23_ENA" width="1" begin="11" end="11" resetval="0x0" description="CMD23 Enable In memory card initialization, Host Driver Version 4.10 checks whether card supports CMD23 by checking a bit SCR[33]. If the card supports CMD23 (SCR[33] = 1h), this bit is set to 1h. This bit is used to select Auto CMD23 or Auto CMD12 for ADMA3 datatransfer. Refer to" range="" rwaccess="RW"/>
    <bitfield id="ADMA2_LEN_MODE" width="1" begin="10" end="10" resetval="0x0" description="ADMA2 Length Mode This bit selects one of ADMA2 Length Modes either 16-bit or 26-bit. 0h: 16-bit Data Length Mode 1h: 26-bit Data Length Mode" range="" rwaccess="RW"/>
    <bitfield id="DRIVER_STRENGTH2" width="1" begin="9" end="9" resetval="0x0" description="Driver Strength Select This is the programmed Drive Strength output and Bit[2] of the sdhccore_drivestrength value." range="" rwaccess="RW"/>
    <bitfield id="UHS2_INTF_ENABLE" width="1" begin="8" end="8" resetval="0x0" description="UHS-II Interface Enable This bit is used to enable UHS-II Interface. Before trying to start UHS-II initialization, this bit shall be set to 1h. Before trying to start SD mode initialization, this bit shall be set to 0h. This bit is used to enable UHS-II IF Detection, Lane Synchronization and In Dormant State in the Host Controller shall not leave unused SD 4-bit Interface lines (CLK, CMD and DAT[3:2]) floating in UHS-II mode by using pull-up or driving to low. When DAT[2] is used as interrupt input in UHS-II mode, DAT[2] of Host Controller is set to input and then DAT[2] of SDIO card is set to output to avoid conflict. 0h: 4-bit SD Interface Enabled 1h: UHS-II Interface Enabled" range="" rwaccess="RW"/>
    <bitfield id="SAMPLING_CLK_SELECT" width="1" begin="7" end="7" resetval="0x0" description="Sampling Clock Select (UHS-I Only) This bit is set by tuning procedure when the 0h: Fixed clock is used to sample data 1h: Tuned clock is used to sample data" range="" rwaccess="RW"/>
    <bitfield id="EXECUTE_TUNING" width="1" begin="6" end="6" resetval="0x0" description="Execute Tuning (UHS-I Only) This bit is set to 1h to start tuning procedure and automatically cleared when tuning procedure is completed. The result of tuning is indicated to the 0h: Not Tuned or Tuning Completed 1h: Execute Tuning" range="" rwaccess="RW"/>
    <bitfield id="DRIVER_STRENGTH1" width="2" begin="5" end="4" resetval="0x0" description="Driver Strength Select (UHS-I Only) Host Controller output driver in 1.8 V signaling is selected by this bit. In 3.3 V signaling, this field is not effective. This field can be set depends on Driver Type A, C and D support bits in the If If 0h: Driver Type B is Selected (Default) 1h: Driver Type A is Selected 2h: Driver Type C is Selected 3h: Driver Type D is Selected" range="" rwaccess="RW"/>
    <bitfield id="V1P8_SIGNAL_ENA" width="1" begin="3" end="3" resetval="0x0" description="1.8 V Signaling Enable (UHS-I Only) This bit controls voltage regulator for I/O cell. 3.3 V is supplied to the card regardless of signaling voltage. Setting this bit from 0h to 1h starts changing signal voltage from 3.3 V to 1.8 V. 1.8 V regulator output shall be stable within 5 ms. Host Controller clears this bit if switching to 1.8 V signaling fails. Clearing this bit from 1h to 0h starts changing signal voltage from 1.8 V to 3.3 V. 3.3 V regulator output shall be stable within 5 ms. Host Driver can set this bit to 1h when Host Controller supports 1.8 V signaling (one of support bits is set to 1h: SDR50, SDR104 or DDR50 in the 0h: 3.3 V Signaling 1h: 1.8 V Signaling" range="" rwaccess="RW"/>
    <bitfield id="UHS_MODE_SELECT" width="3" begin="2" end="0" resetval="0x0" description="UHS Mode Select (UHS-I Only) This field is used to select one of UHS-I modes or UHS-II mode. In case of UHS-I mode, this field is effective when the If the 0h: SDR12 1h: SDR25 2h: SDR50 3h: SDR104 4h: DDR50 5h: HS400 6h: Reserved 7h: UHS-II When SDR50, SDR104 or DDR50 is selected for SDIO card, interrupt detection at the block gap shall not be used. Read Wait timing is changed for these modes. Refer to the SDIO Specification Version 3.00 for more details." range="" rwaccess="RW"/>
  </register>
  <register id="MMCSD0_CAPABILITIES" acronym="MMCSD0_CAPABILITIES" offset="0x40" width="64" description="This register provides the HD with information specific to the HC implementation. The HC may implement these values as fixed or loaded from flash memory during power on initialization.">
    <bitfield id="HS400_SUPPORT" width="1" begin="63" end="63" resetval="0x1" description="HS400 Support 0h: HS400 is Not Supported 1h: HS400 is Supported" range="" rwaccess="R"/>
    <bitfield id="RESERVED" width="2" begin="62" end="61" resetval="0x0" description="Reserved" range="" rwaccess="R"/>
    <bitfield id="VDD2_1P8_SUPPORT" width="1" begin="60" end="60" resetval="0x1" description="1.8 V VDD2 Support This bit indicates that support of VDD2 on Host system. 0h: 1.8 V VDD2 is not supported 1h: 1.8 V VDD2 is supported" range="" rwaccess="R"/>
    <bitfield id="ADMA3_SUPPORT" width="1" begin="59" end="59" resetval="0x1" description="ADMA3 Support This bit indicates that support of ADMA3 on Host Controller. 0h: ADMA3 is not supported 1h: ADMA3 is supported" range="" rwaccess="R"/>
    <bitfield id="RESERVED" width="1" begin="58" end="58" resetval="0x0" description="Reserved" range="" rwaccess="R"/>
    <bitfield id="SPI_BLK_MODE" width="1" begin="57" end="57" resetval="0x0" description="SPI Block Mode This bit indicates whether SPI Block Mode is supported or not. 0h: Not Supported 1h: Supported" range="" rwaccess="R"/>
    <bitfield id="SPI_SUPPORT" width="1" begin="56" end="56" resetval="0x0" description="SPI Mode This bit indicates whether SPI Mode is supported or not. 0h: Not Supported 1h: Supported" range="" rwaccess="R"/>
    <bitfield id="CLOCK_MULTIPLIER" width="8" begin="55" end="48" resetval="0x0" description="Clock Multiplier This field indicates clock multiplier value of programmable clock generator. Refer to the FFh: Clock Multiplier M = 256 ---- 02h: Clock Multiplier M = 3 01h: Clock Multiplier M = 2 00h: Clock Multiplier is Not Supported" range="" rwaccess="R"/>
    <bitfield id="RETUNING_MODES" width="2" begin="47" end="46" resetval="0x0" description="Re-tuning Modes (UHS-I Only) This field defines the re-tuning capability of a Host Controller and how to manage the data transfer length and a Re-Tuning Timer by the Host Driver. 0h: Mode 1 1h: Mode 2 2h: Mode 3 3h: Reserved There are two re-tuning timings: Re-Tuning Request and expiration of a Re-Tuning Timer. By receiving either timing, the Host Driver executes the re-tuning procedure just before a next command issue." range="" rwaccess="R"/>
    <bitfield id="TUNING_FOR_SDR50" width="1" begin="45" end="45" resetval="0x0" description="Use Tuning for SDR50 (UHS-I Only) If this bit is set to 1h, this Host Controller requires tuning to operate SDR50 (tuning is always required to operate SDR104). 0h: SDR50 does not require tuning 1h: SDR50 requires tuning" range="" rwaccess="R"/>
    <bitfield id="RESERVED" width="1" begin="44" end="44" resetval="0x0" description="Reserved" range="" rwaccess="R"/>
    <bitfield id="RETUNING_TIMER_CNT" width="4" begin="43" end="40" resetval="0x4" description="Timer Count for Re-Tuning (UHS-I Only) This field indicates an initial value of the Re-Tuning Timer for Re-Tuning Mode 1 to 3. 0h - Get information via other source 1h = 1 seconds 2h = 2 seconds 3h = 4 seconds 4h = 8 seconds ---- n = 2 ---- Bh = 1024 seconds Fh - Ch = Reserved" range="" rwaccess="R"/>
    <bitfield id="RESERVED" width="1" begin="39" end="39" resetval="0x0" description="Reserved" range="" rwaccess="R"/>
    <bitfield id="DRIVERD_SUPPORT" width="1" begin="38" end="38" resetval="0x0" description="Driver Type D Support (UHS-I Only) This bit indicates support of Driver Type D for 1.8 Signaling. 0h: Driver Type D is Not Supported 1h: Driver Type D is Supported" range="" rwaccess="R"/>
    <bitfield id="DRIVERC_SUPPORT" width="1" begin="37" end="37" resetval="0x0" description="Driver Type C Support (UHS-I Only) This bit indicates support of Driver Type C for 1.8 Signaling. 0h: Driver Type C is Not Supported 1h: Driver Type C is Supported" range="" rwaccess="R"/>
    <bitfield id="DRIVERA_SUPPORT" width="1" begin="36" end="36" resetval="0x0" description="Driver Type A Support (UHS-I Only) This bit indicates support of Driver Type A for 1.8 Signaling. 0h: Driver Type A is Not Supported 1h: Driver Type A is Supported" range="" rwaccess="R"/>
    <bitfield id="UHS2_SUPPORT" width="1" begin="35" end="35" resetval="0x0" description="UHS-II Support (UHS-II Only) This bit indicates whether Host Controller supports UHS-II. If this bit is set to 1h, the 0h: UHS-II is Not Supported 1h: UHS-II is Supported" range="" rwaccess="R"/>
    <bitfield id="DDR50_SUPPORT" width="1" begin="34" end="34" resetval="0x1" description="DDR50 Support (UHS-I Only) This bit indicates whether DDR50 is supported or not. 0h: DDR50 is Not Supported 1h: DDR50 is Supported" range="" rwaccess="R"/>
    <bitfield id="SDR104_SUPPORT" width="1" begin="33" end="33" resetval="0x1" description="SDR104 Support (UHS-I Only) This bit indicates whether SDR104 is supported or not. SDR104 requires tuning. 0h: SDR104 is Not Supported 1h: SDR104 is Supported" range="" rwaccess="R"/>
    <bitfield id="SDR50_SUPPORT" width="1" begin="32" end="32" resetval="0x1" description="SDR50 Support (UHS-I Only) If SDR104 is supported, this bit shall be set to 1h. Bit 40 indicates whether SDR50 requires tuning or not. 0h: SDR50 is Not Supported 1h: SDR50 is Supported" range="" rwaccess="R"/>
    <bitfield id="SLOT_TYPE" width="2" begin="31" end="30" resetval="0x0" description="Slot Type This field indicates usage of a slot by a specific Host System (a host controller register set is defined per slot). Embedded slot for one device (1h) means that only one non-removable device is connected to a SD bus slot. Shared Bus Slot (2h) can be set if Host Controller supports Shared Bus Control register. The Standard Host Driver controls only a removable card or one embedded device is connected to a SD bus slot. If a slot is configured for shared bus (2h), the Standard Host Driver does not control embedded devices connected to a shared bus. Shared bus slot is controlled by a specific host driver developed by a Host System. 0h: Removable Card Slot 1h: Embedded Slot for One Device 2h: Shared Bus Slot (SD Mode) 3h: UHS-II Multiple Embedded Devices" range="" rwaccess="R"/>
    <bitfield id="ASYNCH_INTR_SUPPORT" width="1" begin="29" end="29" resetval="0x1" description="Asynchronous Interrupt Support (SD Mode Only) Refer to SDIO Specification Version 3.00 about asynchronous interrupt. 0h: Asynchronous Interrupt Not Supported 1h: Asynchronous Interrupt Supported" range="" rwaccess="R"/>
    <bitfield id="ADDR_64BIT_SUPPORT_V3" width="1" begin="28" end="28" resetval="0x1" description="64-bit System Address Support for V3 Meaning of this bit is different depends on Versions. Host Controller Version 3.00 and Version 4.10 use this bit as 64-bit System Address support for V3 mode. Host Controller Version 4.00 uses this bit as 64-bit System Address support for both V3 and V4 modes. SDMA cannot be used in 64-bit Addressing in Version 3 mode. If this bit is set to 1h, 64-bit ADMA2 with using 96-bit Descriptor may be enabled as follows: In case of Host Controller Version 3, 64-bit ADMA2 is enabled by 0h: 64-bit System Address for V3 is not Supported 1h: 64-bit System Address for V3 is Supported" range="" rwaccess="R"/>
    <bitfield id="ADDR_64BIT_SUPPORT_V4" width="1" begin="27" end="27" resetval="0x1" description="64-bit System Address Support for V4 This bit is added from Version 4.10. Setting 1h to this bit indicates that the Host Controller supports 64-bit System Addressing of Version 4 mode. When this bit is set to 1h, full or a part of 64-bit address should be used to decode Host Controller Registers so that Host Controller Registers can be placed above system memory area. 64-bit address decode of Host Controller Registers is effective regardless of setting to the If this bit is set to 1h, 64-bit DMA Addressing for Version 4 is enabled by setting 0h: 64-bit System Address for V4 is not Supported 1h: 64-bit System Address for V4 is Supported" range="" rwaccess="R"/>
    <bitfield id="VOLT_1P8_SUPPORT" width="1" begin="26" end="26" resetval="0x1" description="Voltage Support 1.8 V This bit indicates whether the HC supports 1.8 V. 0h: 1.8 V Not Supported 1h: 1.8 V Supported" range="" rwaccess="R"/>
    <bitfield id="VOLT_3P0_SUPPORT" width="1" begin="25" end="25" resetval="0x1" description="Voltage Support 3.0 V This bit indicates whether the HC supports 3.0 V. 0h: 3.0 V Not Supported 1h: 3.0 V Supported" range="" rwaccess="R"/>
    <bitfield id="VOLT_3P3_SUPPORT" width="1" begin="24" end="24" resetval="0x1" description="Voltage Support 3.3 V This bit indicates whether the HC supports 3.3 V. 0h: 3.3 V Not Supported 1h: 3.3 V Supported" range="" rwaccess="R"/>
    <bitfield id="SUSP_RES_SUPPORT" width="1" begin="23" end="23" resetval="0x1" description="Suspend/Resume Support This bit indicates whether the HC supports Suspend/Resume functionality. If this bit is 0h, the Suspend and Resume mechanism are not supported and the HD shall not issue either Suspend/Resume commands. 0h: Not Supported 1h: Supported" range="" rwaccess="R"/>
    <bitfield id="SDMA_SUPPORT" width="1" begin="22" end="22" resetval="0x1" description="SDMA Support This bit indicates whether the HC is capable of using DMA to transfer data between system memory and the HC directly. Version 4.10 Host Controller shall support SDMA if ADMA2 is supported. 0h: SDMA Not Supported 1h: SDMA Supported" range="" rwaccess="R"/>
    <bitfield id="HIGH_SPEED_SUPPORT" width="1" begin="21" end="21" resetval="0x1" description="High Speed Support This bit indicates whether the HC and the Host System support High Speed mode and they can supply SD Clock frequency from 25 MHz to 50 MHz (for SD)/20 MHz to 52 MHz (for MMC). 0h: High Speed Not Supported 1h: High Speed Supported" range="" rwaccess="R"/>
    <bitfield id="RESERVED" width="1" begin="20" end="20" resetval="0x0" description="Reserved" range="" rwaccess="R"/>
    <bitfield id="ADMA2_SUPPORT" width="1" begin="19" end="19" resetval="0x1" description="ADMA2 Support 0h: ADMA2 Not support 1h: ADMA2 support" range="" rwaccess="R"/>
    <bitfield id="BUS_8BIT_SUPPORT" width="1" begin="18" end="18" resetval="0x1" description="8-bit Support for Embedded Device (Embedded) This bit indicates whether the Host Controller is capable of using 8-bit bus width mode. This bit is not effective when the 0h: 8-bit Bus Width Not Supported 1h: 8-bit Bus Width Supported" range="" rwaccess="R"/>
    <bitfield id="MAX_BLK_LENGTH" width="2" begin="17" end="16" resetval="0x0" description="Max Block Length This value indicates the maximum block size that the HD can read and write to the buffer in the HC. The buffer shall transfer this block size without wait cycles. Three sizes can be defined as indicated below. 0h: 512 byte 1h: 1024 byte 2h: 2048 byte 3h: 4096 byte" range="" rwaccess="R"/>
    <bitfield id="BASE_CLK_FREQ" width="8" begin="15" end="8" resetval="0x0" description="Base Clock Frequency for SD Clock (1) 6-bit Base Clock Frequency: This mode is supported by the Host Controller Version 1.00 and 2.00. Upper 2-bit is not effective and always 0. Unit values are 1 MHz. The supported clock range is 10 MHz to 63 MHz. 11xx xxxxb: Not Supported 0011 1111b: 63 MHz 0000 0010b: 2 MHz 0000 0001b: 1 MHz 0000 0000b: Get Information via another method (2) 8-bit Base Clock Frequency: This mode is supported by the Host Controller Version 3.00. Unit values are 1 MHz. The supported clock range is 10 MHz to 255 MHz. FFh: 255 MHz 02h: 2 MHz 01h: 1 MHz 00h: Get Information via another method If the real frequency is 16.5 MHz, the lager value shall be set 0001 0001b (17 MHz) because the Host Driver use this value to calculate the clock divider value (refer to the" range="" rwaccess="R"/>
    <bitfield id="TIMEOUT_CLK_UNIT" width="1" begin="7" end="7" resetval="0x0" description="Timeout Clock Unit This bit shows the unit of base clock frequency used to detect Data Timeout Error ( 0h: KHz 1h: MHz" range="" rwaccess="R"/>
    <bitfield id="RESERVED" width="1" begin="6" end="6" resetval="0x0" description="Reserved" range="" rwaccess="R"/>
    <bitfield id="TIMEOUT_CLK_FREQ" width="6" begin="5" end="0" resetval="0x1" description="Timeout Clock Frequency This bit shows the base clock frequency used to detect Data Timeout Error ( 0h: Get Information via another method Not 0h: 1 KHz to 63 KHz/1 MHz to 63 MHz" range="" rwaccess="R"/>
  </register>
  <register id="MMCSD0_MAX_CURRENT_CAP" acronym="MMCSD0_MAX_CURRENT_CAP" offset="0x48" width="64" description="This register indicates maximum current capability for each voltage.">
    <bitfield id="RESERVED" width="24" begin="63" end="40" resetval="0x0" description="Reserved" range="" rwaccess="R"/>
    <bitfield id="VDD2_1P8V" width="8" begin="39" end="32" resetval="0x0" description="Maximum Current for 1.8 V VDD2" range="" rwaccess="R"/>
    <bitfield id="RESERVED" width="8" begin="31" end="24" resetval="0x0" description="Reserved" range="" rwaccess="R"/>
    <bitfield id="VDD1_1P8V" width="8" begin="23" end="16" resetval="0x0" description="Maximum Current for 1.8 V VDD1" range="" rwaccess="R"/>
    <bitfield id="VDD1_3P0V" width="8" begin="15" end="8" resetval="0x0" description="Maximum Current for 3.0 V VDD1" range="" rwaccess="R"/>
    <bitfield id="VDD1_3P3V" width="8" begin="7" end="0" resetval="0x0" description="Maximum Current for 3.3 V VDD1" range="" rwaccess="R"/>
  </register>
  <register id="MMCSD0_FORCE_EVNT_ACMD_ERR_STS" acronym="MMCSD0_FORCE_EVNT_ACMD_ERR_STS" offset="0x50" width="16" description="This register is not physically implemented, rather it is an address where the register can be written. Writing 1h: set each bit of the register Writing 0h: no effect By setting a bit in this register, the correspondent bit is set in the">
    <bitfield id="RESERVED" width="8" begin="15" end="8" resetval="0x0" description="Reserved" range="" rwaccess="R"/>
    <bitfield id="CMD_NOT_ISS" width="1" begin="7" end="7" resetval="0x0" description="Force Event for Command Not Issued by AUTO CMD12 Error 0h: Not Affected 1h: Command Not Issued By Auto CMD12 Error Status is set" range="" rwaccess="W"/>
    <bitfield id="RESERVED" width="1" begin="6" end="6" resetval="0x0" description="Reserved" range="" rwaccess="R"/>
    <bitfield id="RESP" width="1" begin="5" end="5" resetval="0x0" description="Force Event for AUTO CMD Response Error 0h: Not Affected 1h: Auto CMD Response Error Status is set" range="" rwaccess="W"/>
    <bitfield id="INDEX" width="1" begin="4" end="4" resetval="0x0" description="Force Event for AUTO CMD Index Error 0h: Not Affected 1h: Auto CMD Index Error Status is set" range="" rwaccess="W"/>
    <bitfield id="ENDBIT" width="1" begin="3" end="3" resetval="0x0" description="Force Event for AUTO CMD End Bit Error 0h: Not Affected 1h: Auto CMD End bit Error Status is set" range="" rwaccess="W"/>
    <bitfield id="CRC" width="1" begin="2" end="2" resetval="0x0" description="Force Event for AUTO CMD Timeout Error 0h: Not Affected 1h: Auto CMD CRC Error Status is set" range="" rwaccess="W"/>
    <bitfield id="TIMEOUT" width="1" begin="1" end="1" resetval="0x0" description="Force Event for AUTO CMD Timeout Error 0h: Not Affected 1h: Auto CMD Timeout Error Status is set" range="" rwaccess="W"/>
    <bitfield id="ACMD_NOT_EXEC" width="1" begin="0" end="0" resetval="0x0" description="Force Event for AUTO CMD12 Not Executed 0h: Not Affected 1h: Auto CMD12 Not Executed Status is set" range="" rwaccess="W"/>
  </register>
  <register id="MMCSD0_FORCE_EVNT_ERR_INT_STS" acronym="MMCSD0_FORCE_EVNT_ERR_INT_STS" offset="0x52" width="16" description="This register is not physically implemented, rather it is an address where the register can be written. The register is not a physically implemented register. Rather, it is an address at which the register can be written. The effect of a write to this address will be reflected in the register if the corresponding bit of the register is set. Writing 1h: set each bit of the register Writing 0h: no effect">
    <bitfield id="VEND_SPEC" width="4" begin="15" end="12" resetval="0x0" description="N/A" range="" rwaccess="W"/>
    <bitfield id="RESP" width="1" begin="11" end="11" resetval="0x0" description="Force Event for Response Error 0h: Not Affected 1h: Response Error Status is set" range="" rwaccess="W"/>
    <bitfield id="TUNING" width="1" begin="10" end="10" resetval="0x0" description="Force Event for Tuning Error 0h: Not Affected 1h: Tuning Error Status is set" range="" rwaccess="W"/>
    <bitfield id="ADMA" width="1" begin="9" end="9" resetval="0x0" description="Force Event for ADMA Error 0h: Not Affected 1h: ADMA Error Status is set" range="" rwaccess="W"/>
    <bitfield id="AUTO_CMD" width="1" begin="8" end="8" resetval="0x0" description="Force Event for Auto CMD Error 0h: Not Affected 1h: Auto CMD Error Status is set" range="" rwaccess="W"/>
    <bitfield id="CURR_LIM" width="1" begin="7" end="7" resetval="0x0" description="Force Event for Current Limit Error 0h: Not Affected 1h: Current Limit Error Status is set" range="" rwaccess="W"/>
    <bitfield id="DAT_ENDBIT" width="1" begin="6" end="6" resetval="0x0" description="Force Event for Data End Bit Error 0h: Not Affected 1h: Data End Bit Error Status is set" range="" rwaccess="W"/>
    <bitfield id="DAT_CRC" width="1" begin="5" end="5" resetval="0x0" description="Force Event for Data CRC Error 0h: Not Affected 1h: CRC Error Status is set" range="" rwaccess="W"/>
    <bitfield id="DAT_TIMEOUT" width="1" begin="4" end="4" resetval="0x0" description="Force Event for Data Timeout Error 0h: Not Affected 1h: Timeout Error Status is set" range="" rwaccess="W"/>
    <bitfield id="CMD_INDEX" width="1" begin="3" end="3" resetval="0x0" description="Force Event for Command Index Error 0h: Not Affected 1h: Command Index Error Status is set" range="" rwaccess="W"/>
    <bitfield id="CMD_ENDBIT" width="1" begin="2" end="2" resetval="0x0" description="Force Event for Command End Bit Error 0h: Not Affected 1h: Command End Bit Error Status is set" range="" rwaccess="W"/>
    <bitfield id="CMD_CRC" width="1" begin="1" end="1" resetval="0x0" description="Force Event for Command CRC Error 0h: Not Affected 1h: Command CRC Error Status is set" range="" rwaccess="W"/>
    <bitfield id="CMD_TIMEOUT" width="1" begin="0" end="0" resetval="0x0" description="Force Event for CMD Timeout Error 0h: Not Affected 1h: Command Timeout Error Status is set" range="" rwaccess="W"/>
  </register>
  <register id="MMCSD0_ADMA_ERR_STATUS" acronym="MMCSD0_ADMA_ERR_STATUS" offset="0x54" width="8" description="When the ADMA Error interrupt occur, this register holds the ADMA State ([1-0] ADMA_ERR_STATE) and the register holds address around the error descriptor.">
    <bitfield id="RESERVED" width="5" begin="7" end="3" resetval="0x0" description="Reserved" range="" rwaccess="R"/>
    <bitfield id="ADMA_LENGTH_ERR" width="1" begin="2" end="2" resetval="0x0" description="ADMA Length Mismatch Error This error occurs in the following 2 cases. While the 0h: No Error 1h: Error" range="" rwaccess="R"/>
    <bitfield id="ADMA_ERR_STATE" width="2" begin="1" end="0" resetval="0x0" description="ADMA Error State This field indicates the state of ADMA when error is occurred during ADMA data transfer. This field never indicates '2h' because ADMA never stops in this state. D01 - D00: ADMA Error State when error occurred Contents of SYS_SDR register 0h: ST_STOP (Stop DMA) Points to next of the error descriptor 1h: ST_FDS (Fetch Descriptor) Points to the error descriptor 2h: Never set this state (Not used) 3h: ST_TFR (Transfer Data) Points to the next of the error descriptor" range="" rwaccess="R"/>
  </register>
  <register id="MMCSD0_ADMA_SYS_ADDRESS" acronym="MMCSD0_ADMA_SYS_ADDRESS" offset="0x58" width="64" description="This register contains the physical address used for ADMA data transfer.">
    <bitfield id="ADMA_ADDR" width="64" begin="63" end="0" resetval="0xX" description="ADMA System Address The 32-bit addressing Host Driver uses lower 32-bit of this register (upper 32-bit should be set to 0h) and shall program Descriptor Table on 32-bit boundary and set 32-bit boundary address to this register. DMA2/3 ignores lower 2-bit of this register and assumes it to be 0h. DMA in 64-bit addressing. The 64-bit addressing Host Driver uses all bits of this register and shall program Descriptor Table on 64-bit boundary and set 64-bit boundary address to this register. DMA2/3 ignores lower 3-bit of this register andassumes it to be 0h. If the This register holds byte address of executing command of the Descriptor table. At the start of ADMA2, the Host Driver shall set start address of the Descriptor table. The ADMA increments this register address, which points to next line, when every fetching a Descriptor line. When the ADMA Error Interrupt is generated, this register shall hold the Descriptor address depending on the ADMA state. This register is set by ADMA3. Host Driver is not necessary to set this register. The ADMA3 increments address of this register, which points to next line, when every time fetching a Descriptor line. When Error Interrupt is generated, this register shall hold the Descriptor address depending on the ADMA state. Register Value - Addressing Mode - 32-bit System Address Register Value - xxxxxxxx_xxxxxxxxh Addressing Mode - 64-bit System Address" range="" rwaccess="RW"/>
  </register>
  <register id="MMCSD0_PRESET_VALUE0" acronym="MMCSD0_PRESET_VALUE0" offset="0x60" width="16" description="This register is used to read the SDCLK Frequency Select Value, Clock Generator Select Value, Driver Strength Select Value. When the [15] PRESET_VALUE_ENA bit is set to 1h, SDCLK/RCLK Frequency Select and Clock Generator Select in the register, and Driver Strength Select in the register are automatically set based on the Selected Bus Speed Mode (see ). This means the Host Driver needs not set these fields when preset is enabled. Before starting the initialization sequence, the Host Driver needs to set a clock preset value to SDCLK/RCLK Frequency Select in the register. The [15] PRESET_VALUE_ENA bit can be set after initialization completed. shows the conditions to select one of preset value registers.">
    <bitfield id="DRIVER_STRENGTH_SEL" width="2" begin="15" end="14" resetval="0x0" description="Driver Strength Select Value (UHS-I Only) Driver Strength is supported by 1.8 V signaling bus speed modes. This field is meaningless for 3.3 V signaling. 0h: Driver Type D is Selected 1h: Driver Type C is Selected 2h: Driver Type A is Selected 3h: Driver Type B is Selected" range="" rwaccess="R"/>
    <bitfield id="RESERVED" width="3" begin="13" end="11" resetval="0x0" description="Reserved" range="" rwaccess="R"/>
    <bitfield id="CLOCK_GENSEL" width="1" begin="10" end="10" resetval="0x0" description="Clock Generator Select Value This bit is effective when Host Controller supports programmable clock generator. 0h: Host Controller Version 2.00 Compatible Clock Generator 1h: Programmable Clock Generator" range="" rwaccess="R"/>
    <bitfield id="SDCLK_FRQSEL" width="10" begin="9" end="0" resetval="0x64" description="SDCLK Frequency Select Value 10-bit preset value to set the" range="" rwaccess="R"/>
  </register>
  <register id="MMCSD0_PRESET_VALUE1" acronym="MMCSD0_PRESET_VALUE1" offset="0x62" width="16" description="This register is used to read the SDCLK Frequency Select Value, Clock Generator Select Value, Driver Strength Select Value.">
    <bitfield id="DRIVER_STRENGTH_SEL" width="2" begin="15" end="14" resetval="0x0" description="Driver Strength Select Value (UHS-I Only) Driver Strength is supported by 1.8 V signaling bus speed modes. This field is meaningless for 3.3 V signaling. 0h: Driver Type D is Selected 1h: Driver Type C is Selected 2h: Driver Type A is Selected 3h: Driver Type B is Selected" range="" rwaccess="R"/>
    <bitfield id="RESERVED" width="3" begin="13" end="11" resetval="0x0" description="Reserved" range="" rwaccess="R"/>
    <bitfield id="CLOCK_GENSEL" width="1" begin="10" end="10" resetval="0x0" description="Clock Generator Select Value This bit is effective when Host Controller supports programmable clock generator. 0h: Host Controller Version 2.00 Compatible Clock Generator 1h: Programmable Clock Generator" range="" rwaccess="R"/>
    <bitfield id="SDCLK_FRQSEL" width="10" begin="9" end="0" resetval="0x4" description="SDCLK Frequency Select Value 10-bit preset value to set the" range="" rwaccess="R"/>
  </register>
  <register id="MMCSD0_PRESET_VALUE2" acronym="MMCSD0_PRESET_VALUE2" offset="0x64" width="16" description="This register is used to read the SDCLK Frequency Select Value, Clock Generator Select Value, Driver Strength Select Value.">
    <bitfield id="DRIVER_STRENGTH_SEL" width="2" begin="15" end="14" resetval="0x0" description="Driver Strength Select Value (UHS-I Only) Driver Strength is supported by 1.8 V signaling bus speed modes. This field is meaningless for 3.3 V signaling. 0h: Driver Type D is Selected 1h: Driver Type C is Selected 2h: Driver Type A is Selected 3h: Driver Type B is Selected" range="" rwaccess="R"/>
    <bitfield id="RESERVED" width="3" begin="13" end="11" resetval="0x0" description="Reserved" range="" rwaccess="R"/>
    <bitfield id="CLOCK_GENSEL" width="1" begin="10" end="10" resetval="0x0" description="Clock Generator Select Value This bit is effective when Host Controller supports programmable clock generator. 0h: Host Controller Version 2.00 Compatible Clock Generator 1h: Programmable Clock Generator" range="" rwaccess="R"/>
    <bitfield id="SDCLK_FRQSEL" width="10" begin="9" end="0" resetval="0x2" description="SDCLK Frequency Select Value 10-bit preset value to set the" range="" rwaccess="R"/>
  </register>
  <register id="MMCSD0_PRESET_VALUE3" acronym="MMCSD0_PRESET_VALUE3" offset="0x66" width="16" description="This register is used to read the SDCLK Frequency Select Value, Clock Generator Select Value, Driver Strength Select Value.">
    <bitfield id="DRIVER_STRENGTH_SEL" width="2" begin="15" end="14" resetval="0x0" description="Driver Strength Select Value (UHS-I Only) Driver Strength is supported by 1.8 V signaling bus speed modes. This field is meaningless for 3.3 V signaling. 0h: Driver Type D is Selected 1h: Driver Type C is Selected 2h: Driver Type A is Selected 3h: Driver Type B is Selected" range="" rwaccess="R"/>
    <bitfield id="RESERVED" width="3" begin="13" end="11" resetval="0x0" description="Reserved" range="" rwaccess="R"/>
    <bitfield id="CLOCK_GENSEL" width="1" begin="10" end="10" resetval="0x0" description="Clock Generator Select Value This bit is effective when Host Controller supports programmable clock generator. 0h: Host Controller Version 2.00 Compatible Clock Generator 1h: Programmable Clock Generator" range="" rwaccess="R"/>
    <bitfield id="SDCLK_FRQSEL" width="10" begin="9" end="0" resetval="0x4" description="SDCLK Frequency Select Value 10-bit preset value to set the" range="" rwaccess="R"/>
  </register>
  <register id="MMCSD0_PRESET_VALUE4" acronym="MMCSD0_PRESET_VALUE4" offset="0x68" width="16" description="This register is used to read the SDCLK Frequency Select Value, Clock Generator Select Value, Driver Strength Select Value.">
    <bitfield id="DRIVER_STRENGTH_SEL" width="2" begin="15" end="14" resetval="0x0" description="Driver Strength Select Value (UHS-I Only) Driver Strength is supported by 1.8 V signaling bus speed modes. This field is meaningless for 3.3 V signaling. 0h: Driver Type D is Selected 1h: Driver Type C is Selected 2h: Driver Type A is Selected 3h: Driver Type B is Selected" range="" rwaccess="R"/>
    <bitfield id="RESERVED" width="3" begin="13" end="11" resetval="0x0" description="Reserved" range="" rwaccess="R"/>
    <bitfield id="CLOCK_GENSEL" width="1" begin="10" end="10" resetval="0x0" description="Clock Generator Select Value This bit is effective when Host Controller supports programmable clock generator. 0h: Host Controller Version 2.00 Compatible Clock Generator 1h: Programmable Clock Generator" range="" rwaccess="R"/>
    <bitfield id="SDCLK_FRQSEL" width="10" begin="9" end="0" resetval="0x2" description="SDCLK Frequency Select Value 10-bit preset value to set the" range="" rwaccess="R"/>
  </register>
  <register id="MMCSD0_PRESET_VALUE5" acronym="MMCSD0_PRESET_VALUE5" offset="0x6A" width="16" description="This register is used to read the SDCLK Frequency Select Value, Clock Generator Select Value, Driver Strength Select Value.">
    <bitfield id="DRIVER_STRENGTH_SEL" width="2" begin="15" end="14" resetval="0x0" description="Driver Strength Select Value (UHS-I Only) Driver Strength is supported by 1.8 V signaling bus speed modes. This field is meaningless for 3.3 V signaling. 0h: Driver Type D is Selected 1h: Driver Type C is Selected 2h: Driver Type A is Selected 3h: Driver Type B is Selected" range="" rwaccess="R"/>
    <bitfield id="RESERVED" width="3" begin="13" end="11" resetval="0x0" description="Reserved" range="" rwaccess="R"/>
    <bitfield id="CLOCK_GENSEL" width="1" begin="10" end="10" resetval="0x0" description="Clock Generator Select Value This bit is effective when Host Controller supports programmable clock generator. 0h: Host Controller Version 2.00 Compatible Clock Generator 1h: Programmable Clock Generator" range="" rwaccess="R"/>
    <bitfield id="SDCLK_FRQSEL" width="10" begin="9" end="0" resetval="0x1" description="SDCLK Frequency Select Value 10-bit preset value to set the" range="" rwaccess="R"/>
  </register>
  <register id="MMCSD0_PRESET_VALUE6" acronym="MMCSD0_PRESET_VALUE6" offset="0x6C" width="16" description="This register is used to read the SDCLK Frequency Select Value, Clock Generator Select Value, Driver Strength Select Value.">
    <bitfield id="DRIVER_STRENGTH_SEL" width="2" begin="15" end="14" resetval="0x0" description="Driver Strength Select Value (UHS-I Only) Driver Strength is supported by 1.8 V signaling bus speed modes. This field is meaningless for 3.3 V signaling. 0h: Driver Type D is Selected 1h: Driver Type C is Selected 2h: Driver Type A is Selected 3h: Driver Type B is Selected" range="" rwaccess="R"/>
    <bitfield id="RESERVED" width="3" begin="13" end="11" resetval="0x0" description="Reserved" range="" rwaccess="R"/>
    <bitfield id="CLOCK_GENSEL" width="1" begin="10" end="10" resetval="0x0" description="Clock Generator Select Value This bit is effective when Host Controller supports programmable clock generator. 0h: Host Controller Version 2.00 Compatible Clock Generator 1h: Programmable Clock Generator" range="" rwaccess="R"/>
    <bitfield id="SDCLK_FRQSEL" width="10" begin="9" end="0" resetval="0x0" description="SDCLK Frequency Select Value 10-bit preset value to set the" range="" rwaccess="R"/>
  </register>
  <register id="MMCSD0_PRESET_VALUE7" acronym="MMCSD0_PRESET_VALUE7" offset="0x6E" width="16" description="This register is used to read the SDCLK Frequency Select Value, Clock Generator Select Value, Driver Strength Select Value.">
    <bitfield id="DRIVER_STRENGTH_SEL" width="2" begin="15" end="14" resetval="0x0" description="Driver Strength Select Value (UHS-I Only) Driver Strength is supported by 1.8 V signaling bus speed modes. This field is meaningless for 3.3 V signaling. 0h: Driver Type D is Selected 1h: Driver Type C is Selected 2h: Driver Type A is Selected 3h: Driver Type B is Selected" range="" rwaccess="R"/>
    <bitfield id="RESERVED" width="3" begin="13" end="11" resetval="0x0" description="Reserved" range="" rwaccess="R"/>
    <bitfield id="CLOCK_GENSEL" width="1" begin="10" end="10" resetval="0x0" description="Clock Generator Select Value This bit is effective when Host Controller supports programmable clock generator. 0h: Host Controller Version 2.00 Compatible Clock Generator 1h: Programmable Clock Generator" range="" rwaccess="R"/>
    <bitfield id="SDCLK_FRQSEL" width="10" begin="9" end="0" resetval="0x2" description="SDCLK Frequency Select Value 10-bit preset value to set the" range="" rwaccess="R"/>
  </register>
  <register id="MMCSD0_PRESET_VALUE8" acronym="MMCSD0_PRESET_VALUE8" offset="0x72" width="16" description="This register is used to read the SDCLK Frequency Select Value, Clock Generator Select Value, Driver Strength Select Value.">
    <bitfield id="DRIVER_STRENGTH_SEL" width="2" begin="15" end="14" resetval="0x0" description="Driver Strength Select Value (UHS-I Only) Driver Strength is supported by 1.8 V signaling bus speed modes. This field is meaningless for 3.3 V signaling. 0h: Driver Type D is Selected 1h: Driver Type C is Selected 2h: Driver Type A is Selected 3h: Driver Type B is Selected" range="" rwaccess="R"/>
    <bitfield id="RESERVED" width="3" begin="13" end="11" resetval="0x0" description="Reserved" range="" rwaccess="R"/>
    <bitfield id="CLOCK_GENSEL" width="1" begin="10" end="10" resetval="0x0" description="Clock Generator Select Value This bit is effective when Host Controller supports programmable clock generator. 0h: Host Controller Version 2.00 Compatible Clock Generator 1h: Programmable Clock Generator" range="" rwaccess="R"/>
    <bitfield id="SDCLK_FRQSEL" width="10" begin="9" end="0" resetval="0x1" description="SDCLK Frequency Select Value 10-bit preset value to set the" range="" rwaccess="R"/>
  </register>
  <register id="MMCSD0_PRESET_VALUE10" acronym="MMCSD0_PRESET_VALUE10" offset="0x74" width="16" description="This register is used to read the SDCLK Frequency Select Value, Clock Generator Select Value, Driver Strength Select Value.">
    <bitfield id="DRIVER_STRENGTH_SEL" width="2" begin="15" end="14" resetval="0x0" description="Driver Strength Select Value (UHS-I Only) Driver Strength is supported by 1.8 V signaling bus speed modes. This field is meaningless for 3.3 V signaling. 0h: Driver Type D is Selected 1h: Driver Type C is Selected 2h: Driver Type A is Selected 3h: Driver Type B is Selected" range="" rwaccess="R"/>
    <bitfield id="RESERVED" width="3" begin="13" end="11" resetval="0x0" description="Reserved" range="" rwaccess="R"/>
    <bitfield id="CLOCK_GENSEL" width="1" begin="10" end="10" resetval="0x0" description="Clock Generator Select Value This bit is effective when Host Controller supports programmable clock generator. 0h: Host Controller Version 2.00 Compatible Clock Generator 1h: Programmable Clock Generator" range="" rwaccess="R"/>
    <bitfield id="SDCLK_FRQSEL" width="10" begin="9" end="0" resetval="0x0" description="SDCLK Frequency Select Value 10-bit preset value to set the" range="" rwaccess="R"/>
  </register>
  <register id="MMCSD0_ADMA3_DESC_ADDRESS" acronym="MMCSD0_ADMA3_DESC_ADDRESS" offset="0x78" width="64" description="The start address of Integrated DMA Descriptor is set to this register.">
    <bitfield id="INTG_DESC_ADDR" width="64" begin="63" end="0" resetval="0xX" description="ADMA3 Integrated Descriptor Address The start address of Integrated DMA Descriptor is set to this register. Writing to a specific address starts ADMA3 depends on 32-bit/64-bit address-ing. The ADMA3 fetches one Descriptor Address and increments this field to indicate the next Descriptor address. The 32-bit addressing Host Driver uses lower 32-bit of this register and shall program Descriptor Table on 32-bit boundary. ADMA3 ignores lower 2-bit of this register and assumes it to be 0h. Writing to 07Bh starts ADMA3 data transfer. The 64-bit addressing Host Driver uses all 64-bit of this register and shall program Descriptor Table on 64-bit boundary. ADMA3 ignores lower 3-bit of this register and assumes it to be 0h. Writing to 07Fh starts ADMA3 data transfer. Register Value - Register Value - xxxxxxxx_xxxxxxxxh Addressing Mode - 64-bit System Address" range="" rwaccess="RW"/>
  </register>
  <register id="MMCSD0_UHS2_BLOCK_SIZE" acronym="MMCSD0_UHS2_BLOCK_SIZE" offset="0x80" width="16" description="This register is used to configure the number of bytes in a data block.">
    <bitfield id="RESERVED" width="1" begin="15" end="15" resetval="0x0" description="Reserved" range="" rwaccess="R"/>
    <bitfield id="SDMA_BUF_BOUNDARY" width="3" begin="14" end="12" resetval="0x0" description="UHS-II SDMA Buffer Boundary (SDMA only) When system memory is managed by paging, SDMA data transfer is performed in unit of paging. A page size of system memory management is set to this field. Host Controller generates the DMA Interrupt at the page boundary and requests the Host Driver to update the At the end of transfer, the Host Controller may issue or may not issue DMA Interrupt. In particular, DMA Interrupt shall not be issued after Transfer Complete Interrupt is issued (see These bits shall be supported when the 0h: 4K bytes (Detects A11 carry out) 1h: 8K bytes (Detects A12 carry out) 2h: 16K Bytes (Detects A13 carry out) 3h: 32K Bytes (Detects A14 carry out) 4h: 64K bytes (Detects A15 carry out) 5h: 128K Bytes (Detects A16 carry out) 6h: 256K Bytes (Detects A17 carry out) 7h: 512K Bytes (Detects A18 carry out)" range="" rwaccess="RW"/>
    <bitfield id="XFER_BLK_SIZE" width="12" begin="11" end="0" resetval="0x0" description="UHS-II Block Size This bit field specifies the block size of data packet. SD Memory Card uses a fixed block size of 512 bytes. Variable block size may be used for SDIO. The maximum value is 2048 Bytes because CRC16 covers up to 2048 bytes. This bit field is effective when the 0000h - No data transfer 0001h - 1 Byte 0002h - 2 Bytes 0003h - 3 Bytes ... ... 01FFh - 511 Bytes 0200h - 512 Bytes ... ... 0800h - 2048 Bytes" range="" rwaccess="RW"/>
  </register>
  <register id="MMCSD0_UHS2_BLOCK_COUNT" acronym="MMCSD0_UHS2_BLOCK_COUNT" offset="0x84" width="32" description="This register is used to configure the number of data blocks.">
    <bitfield id="XFER_BLK_COUNT" width="32" begin="31" end="0" resetval="0x0" description="UHS-II Block Count This register is effective when the This register should be accessed only when no transaction is executing (after transactions are stopped). During data transfer, read operations on this register may return an invalid value and write operations are ignored. 00000000h: Stop Count 00000001h: 1 block 00000002h: 2 blocks ... ... FFFFFFFFh: 4G blocks - 1" range="" rwaccess="RW"/>
  </register>
  <register id="MMCSD0_UHS2_COMMAND_PKT_0" acronym="MMCSD0_UHS2_COMMAND_PKT_0" offset="0x88" width="8" description="UHS-II Command Packet image is set to this register. The maximum length is 20 bytes (see ). The command length varies depends on a Command Packet type. The length is specified by the register.">
    <bitfield id="CMD_PKT_BYTE" width="8" begin="7" end="0" resetval="0x0" description="Command Packet Byte UHS-II Command Packet image is set to this register. The command length varies depends on a Command Packet type." range="" rwaccess="RW"/>
  </register>
  <register id="MMCSD0_UHS2_XFER_MODE" acronym="MMCSD0_UHS2_XFER_MODE" offset="0x9C" width="16" description="This register is used to control the operations of data transfers. On issuing a Command Packet, a Command Packet image is set to UHS-II Command Packet register (see - MMCSD0_UHS2_COMMAND_PKT_19) but Host Controller does not analyze the setting of UHS-II Command Packet register. Instead, Host Controller refers setting of this register to issue a Command Packet to make the control easy. Setting of these registers shall be correspondent.">
    <bitfield id="DUPLEX_SELECT" width="1" begin="15" end="15" resetval="0x0" description="Half/Full Select Use of 2 lane half duplex mode is determined by Host Driver. 0h: Full Duplex Mode 1h: 2 Lane Half Duplex Mode" range="" rwaccess="RW"/>
    <bitfield id="EBSY_WAIT" width="1" begin="14" end="14" resetval="0x0" description="EBSY Wait This bit is set when issuing a command which is accompanied by EBSY packet to indicate end of command execution. Busy is expected for CCMD with R1b/R5b type and DCMD with data transfer. If this bit is set to 1h, Host Controller waits receiving of EBSY packet and on receiving EBSY packet, the Setting of the 0h: Issue a command without busy 1h: Wait EBSY" range="" rwaccess="RW"/>
    <bitfield id="RESERVED" width="5" begin="13" end="9" resetval="0x0" description="Reserved" range="" rwaccess="R"/>
    <bitfield id="RESP_INTR_DIS" width="1" begin="8" end="8" resetval="0x0" description="Response Interrupt Disable Host Controller Version 4.00 supports response error check function to avoid overhead of response error check by Host Driver. Only R1 or R5 can be checked. If Host Driver checks response error, sets this bit to 0h and waits the 0h: Response Interrupt is enabled 1h: Response Interrupt is disabled" range="" rwaccess="RW"/>
    <bitfield id="RESP_ERR_CHK_ENA" width="1" begin="7" end="7" resetval="0x0" description="Response Error Check Enable Host Controller Version 4.00 supports response error check function to avoid overhead of response error check by Host Driver. Only R1 or R5 can be checked. If Host Driver checks response error, this bit is set to 0h and the 0h: Response Error Check is disabled 1h: Response Error Check is enabled" range="" rwaccess="RW"/>
    <bitfield id="RESP_TYPE" width="1" begin="6" end="6" resetval="0x0" description="Response Type R1/R5 When response error check is enabled, this bit selects either R1 or R5 response types. Two types of response checks are supported: R1 for memory and R5 for SDIO. Error Statuses Checked in R1: Response Flags Checked in R5: 0h: R1 (Memory) 1h: R5 (SDIO)" range="" rwaccess="RW"/>
    <bitfield id="BYTE_MODE" width="1" begin="5" end="5" resetval="0x0" description="Block/Byte Mode This bit specifies whether data transfer is in byte mode or block mode when the 0h: Block Mode 1h: Byte Mode" range="" rwaccess="RW"/>
    <bitfield id="DATA_XFER_DIR" width="1" begin="4" end="4" resetval="0x0" description="Data Transfer Direction This bit specifies direction of data transfer when the 0h: Read (Card to Host) 1h: Write (Host to Card)" range="" rwaccess="RW"/>
    <bitfield id="RESERVED" width="2" begin="3" end="2" resetval="0x0" description="Reserved" range="" rwaccess="R"/>
    <bitfield id="BLK_CNT_ENA" width="1" begin="1" end="1" resetval="0x0" description="Block Count Enable This bit specifies whether data transfer uses the 0h: Block Count Disabled 1h: Block Count Enabled" range="" rwaccess="RW"/>
    <bitfield id="DMA_ENA" width="1" begin="0" end="0" resetval="0x0" description="DMA Enable This bit selects whether DMA is used or not and is effective to a command with data transfer. One of DMA types is selected by the 0h: DMA is disabled 1h: DMA is enabled" range="" rwaccess="RW"/>
  </register>
  <register id="MMCSD0_UHS2_COMMAND" acronym="MMCSD0_UHS2_COMMAND" offset="0x9E" width="16" description="This register is used to program the Command for host controller.">
    <bitfield id="RESERVED" width="3" begin="15" end="13" resetval="0x0" description="Reserved" range="" rwaccess="R"/>
    <bitfield id="PKT_LENGTH" width="5" begin="12" end="8" resetval="0x0" description="UHS-II Command Packet Length A command packet length, which is set in the UHS-II Command Packet register ( 00011b &#8211; 00000b: 3-0 Bytes (Not used) 00100b: 4 Bytes .... .... 10100b: 20 Bytes 11111b &#8211; 10101b" range="" rwaccess="RW"/>
    <bitfield id="CMD_TYPE" width="2" begin="7" end="6" resetval="0x0" description="Command Type This field is used to distinguish a specific command like abort command. If this field is set to 0h, the UHS-II RES Packet is stored in UHS-II Response register ( 0h: Normal Command 1h: TRANS_ABORT CCMD 3h: CMD12 or SDIO Abort command 4h: Go Dormant Command" range="" rwaccess="RW"/>
    <bitfield id="DATA_PRESENT" width="1" begin="5" end="5" resetval="0x0" description="Data Present This bit specifies whether the command is accompanied by data packet. 0h: No Data Present 1h: Data Present" range="" rwaccess="RW"/>
    <bitfield id="RESERVED" width="2" begin="4" end="3" resetval="0x0" description="Reserved" range="" rwaccess="R"/>
    <bitfield id="SUB_COMMAND" width="1" begin="2" end="2" resetval="0x0" description="Sub Command Flag This bit is added from Version 4.10 to distinguish a main command or sub command. When issuing a main command, this bit is set to 0h and when issuing a sub command, this bit is set to 1h. Setting of this bit is checked by the 0h: Sub Command 1h: Main Command" range="" rwaccess="RW"/>
    <bitfield id="RESERVED" width="2" begin="1" end="0" resetval="0x0" description="Reserved" range="" rwaccess="R"/>
  </register>
  <register id="MMCSD0_UHS2_RESPONSE_0" acronym="MMCSD0_UHS2_RESPONSE_0" offset="0xA0" width="8" description="This register is used to store received UHS-II RES Packet image. Host Controller saves received UHS-II RES Packet image to this register except the response of an abort command, which is specified by setting 1h or 2h to the [7-6] CMD_TYPE bit field. The maximum response length is 20 bytes.">
    <bitfield id="RESP_PKT_BYTE" width="8" begin="7" end="0" resetval="0x0" description="Response Packet Byte Host Controller saves received UHS-II RES Packet image to this register except the response of an abort command." range="" rwaccess="R"/>
  </register>
  <register id="MMCSD0_UHS2_MESSAGE_SELECT" acronym="MMCSD0_UHS2_MESSAGE_SELECT" offset="0xB4" width="8" description="This register is used to access internal buffer.">
    <bitfield id="RESERVED" width="6" begin="7" end="2" resetval="0x0" description="Reserved" range="" rwaccess="R"/>
    <bitfield id="MSG_SEL" width="2" begin="1" end="0" resetval="0x0" description="UHS-II MSG Select Host Controller holds 4 MSG packets in FIFO buffer. One of 4 MSGs can be read from the (assumed for debug usage). 0h: The latest MSG 1h: One MSG before 2h: Two MSGs before 3h: Three MSGs before" range="" rwaccess="RW"/>
  </register>
  <register id="MMCSD0_UHS2_MESSAGE" acronym="MMCSD0_UHS2_MESSAGE" offset="0xB8" width="32" description="This register is used to access internal buffer.">
    <bitfield id="MSG_BYTE3" width="8" begin="31" end="24" resetval="0x0" description="UHS II MSG Host Controller holds 4 MSG packets in FIFO buffer. One of 4 MSGs (length is 4 bytes) can be read from this register by setting the" range="" rwaccess="R"/>
    <bitfield id="MSG_BYTE2" width="8" begin="23" end="16" resetval="0x0" description="UHS II MSG Host Controller holds 4 MSG packets in FIFO buffer. One of 4 MSGs (length is 4 bytes) can be read from this register by setting the" range="" rwaccess="R"/>
    <bitfield id="MSG_BYTE1" width="8" begin="15" end="8" resetval="0x0" description="UHS II MSG Host Controller holds 4 MSG packets in FIFO buffer. One of 4 MSGs (length is 4 bytes) can be read from this register by setting the" range="" rwaccess="R"/>
    <bitfield id="MSG_BYTE0" width="8" begin="7" end="0" resetval="0x0" description="UHS II MSG Host Controller holds 4 MSG packets in FIFO buffer. One of 4 MSGs (length is 4 bytes) can be read from this register by setting the" range="" rwaccess="R"/>
  </register>
  <register id="MMCSD0_UHS2_DEVICE_INTR_STATUS" acronym="MMCSD0_UHS2_DEVICE_INTR_STATUS" offset="0xBC" width="16" description="This register shows receipt of INT MSG from which device.">
    <bitfield id="DEV_INT_STS" width="16" begin="15" end="0" resetval="0x0" description="UHS-II Device Interrupt Status This register shows receipt of INT MSG from which device and is effective when the Writing a bit to 1h clears the status bit (interrupt is treated) and writing a bit to 0h keeps the status value (interrupt is untreated). If the Effective bit range of this register is determined by the D00 - Not used (Reserved) D01 - Setting 1h means INT MSG is received from Device ID 1 D02 - Setting 1h means INT MSG is received from Device ID 2 .... ..... D15 - Setting 1h means INT MSG is received from Device ID 15" range="" rwaccess="RW1C"/>
  </register>
  <register id="MMCSD0_UHS2_DEVICE_SELECT" acronym="MMCSD0_UHS2_DEVICE_SELECT" offset="0xBE" width="8" description="UHS-II Device Select Register.">
    <bitfield id="INT_MSG_ENA" width="1" begin="7" end="7" resetval="0x0" description="INT MSG Enable (Optional) This bit enables receipt of INT MSG. If this bit is set to 1h, receipt of INT MSG is informed by the Support of INT MSG Interrupt is optional. If trying to set this bit to 1h but still this bit is read 0, INT MSG Interrupt is not supported by the Host Controller. In this case, the 0h: Disabled 1h: Enabled" range="" rwaccess="RW"/>
    <bitfield id="RESERVED" width="3" begin="6" end="4" resetval="0x0" description="Reserved" range="" rwaccess="R"/>
    <bitfield id="DEV_SEL" width="4" begin="3" end="0" resetval="0x0" description="UHS-II Device Select Host Controller holds an INT MSG packet per device. One of INT MSGs (up to 15) can be selected by this field and read from the The number of devices implemented in the Host Controller is indicated by the 0h: Unselected (Default) 1h: INT MSG of Device ID 1 is selected 2h: INT MSG of Device ID 2 is selected ..... ..... Fh: INT MSG of Device ID 15 is selected" range="" rwaccess="RW"/>
  </register>
  <register id="MMCSD0_UHS2_DEVICE_INT_CODE" acronym="MMCSD0_UHS2_DEVICE_INT_CODE" offset="0xBF" width="8" description="This register is effective when the [7] INT_MSG_ENA bit is set to 1h.">
    <bitfield id="DEV_INTR" width="8" begin="7" end="0" resetval="0x0" description="UHS II Device Interrupt This register is effective when the The number of the registers to hold INT MSGs is determined by the" range="" rwaccess="R"/>
  </register>
  <register id="MMCSD0_UHS2_SOFTWARE_RESET" acronym="MMCSD0_UHS2_SOFTWARE_RESET" offset="0xC0" width="16" description="UHS-II Software Reset Register.">
    <bitfield id="RESERVED" width="14" begin="15" end="2" resetval="0x0" description="Reserved" range="" rwaccess="R"/>
    <bitfield id="HOST_SDTRAN_RESET" width="1" begin="1" end="1" resetval="0x0" description="Host SD-TRAN Reset Host Driver set this bit to 1h to reset SD-TRAN layer when CMD0 is issued to Device or data transfer error occurs. This bit is cleared automatically at completion of SD-TRAN reset. If CMD0 is issued, SD-TRAN Initialization sequence from CMD8 is required to use UHS-II mode. Assuming that bus power is maintained and CM-TRAN Initialization is not required. Host Controller requires to do followings: (1) SD Clock Enable is maintained (continue to provide RCLK). (2) All setting register is maintained. (3) Internal sequencers are reset to just after power on be able to issue a command. (4) All Interrupt Status, Status Enable and Signal Enable are cleared. (5) Data transfer is terminated and data in buffer is discarded. 0h: Not Affected 1h: Reset SD-TRAN" range="" rwaccess="RW"/>
    <bitfield id="HOST_FULL_RESET" width="1" begin="0" end="0" resetval="0x0" description="Host Full Reset On issuing FULL_RESET CCMD, Host Driver set this bit to 1h to reset Host Controller. This bit is cleared automatically at completion of Host Controller reset. Initialization sequence from PHY Initialization is required to use UHS-II mode. Assuming that bus power is maintained. Host Controller requires to do followings: (1) SD Clock Enable is cleared (internal Clock is still synchronized). (2) All setting register is cleared. (3) Internal sequencers are reset to just after power on. (4) All Interrupt Status, Status Enable and Signal Enable are cleared. 0h: Not Affected 1h: Reset Host Controller" range="" rwaccess="RW"/>
  </register>
  <register id="MMCSD0_UHS2_TIMER_CONTROL" acronym="MMCSD0_UHS2_TIMER_CONTROL" offset="0xC2" width="16" description="UHS-II Timeout Control Register.">
    <bitfield id="RESERVED" width="8" begin="15" end="8" resetval="0x0" description="Reserved" range="" rwaccess="R"/>
    <bitfield id="DEADLOCK_TIMEOUT_CTR" width="4" begin="7" end="4" resetval="0x0" description="Timeout Counter Value for Deadlock This value determines the deadlock period while host expecting to receive a packet (1 second). Timeout clock frequency will be generated by dividing the base clock TMCLK value by this value. When setting this register, prevent inadvertent timeout events by clearing the Timeout for Deadlock (in the Fh: Reserved Eh: TMCLK x 2 .... .... 1h: TMCLK x 2 0h: TMCLK x 2" range="" rwaccess="RW"/>
    <bitfield id="CMDRESP_TIMEOUT_CTR" width="4" begin="3" end="0" resetval="0x0" description="Timeout Counter Value for CMD_RES This value determines the interval between command packet and response packet (5 ms). Timeout clock frequency will be generated by dividing the base clock TMCLK value by this value. When setting this register, prevent inadvertent timeout events by clearing the Timeout for CMD_RES (in the Fh: Reserved Eh: TMCLK x 2 .... .... 1h: TMCLK x 2 0h: TMCLK x 2" range="" rwaccess="RW"/>
  </register>
  <register id="MMCSD0_UHS2_ERR_INTR_STS" acronym="MMCSD0_UHS2_ERR_INTR_STS" offset="0xC4" width="32" description="This register gives the status of all UHS-II interrupts.">
    <bitfield id="VENDOR_SPECFIC_ERR" width="5" begin="31" end="27" resetval="0x0" description="Vendor Specific Error Vendor may use this field for vendor specific error status. 0h: Interrupt is not generated 1h: Vendor Specific Error" range="" rwaccess="RW1C"/>
    <bitfield id="RESERVED" width="9" begin="26" end="18" resetval="0x0" description="Reserved" range="" rwaccess="R"/>
    <bitfield id="DEADLOCK_TIMEOUT" width="1" begin="17" end="17" resetval="0x0" description="Timeout for Deadlock Setting of this bit means that deadlock timeout occurs. Host expects to receive a packet but not received in a specified timeout (1 second). Timeout value is determined by the setting of the 0h: Interrupt is not generated 1h: Deadlock Error" range="" rwaccess="RW1C"/>
    <bitfield id="CMD_RESP_TIMEOUT" width="1" begin="16" end="16" resetval="0x0" description="Timeout for CMD_RES Setting of this bit means that RES Packet timeout occurs. Host expects to receive RES packet but not received in a specified timeout (5 ms). Timeout value is determined by the setting of the 0h: Interrupt is not generated 1h: RES Packet Timeout Error" range="" rwaccess="RW1C"/>
    <bitfield id="ADMA2_ADMA3" width="1" begin="15" end="15" resetval="0x0" description="ADMA2/3 Error Setting of this bit means that ADMA2/3 Error occurs in UHS-II mode. ADMA2/3 Error Status is indicated to the 0h: Interrupt is not generated 1h: ADMA2/3 Error" range="" rwaccess="RW1C"/>
    <bitfield id="RESERVED" width="6" begin="14" end="9" resetval="0x0" description="Reserved" range="" rwaccess="R"/>
    <bitfield id="EBSY" width="1" begin="8" end="8" resetval="0x0" description="EBSY Error On receiving EBSY packet, if the packet indicates an error, this bit is set to 1h. Setting of this bit also sets Error Interrupt and Transfer Completer together in the 0h: Interrupt is not generated 1h: EBSY Error (Backend Error)" range="" rwaccess="RW1C"/>
    <bitfield id="UNRECOVERABLE" width="1" begin="7" end="7" resetval="0x0" description="Unrecoverable Error Setting of this bit means that Unrecoverable Error is set in a packet from a device. 0h: Interrupt is not generated 1h: Device Unrecoverable Error" range="" rwaccess="RW1C"/>
    <bitfield id="RESERVED" width="1" begin="6" end="6" resetval="0x0" description="Reserved" range="" rwaccess="R"/>
    <bitfield id="TID" width="1" begin="5" end="5" resetval="0x0" description="TID Error Setting of this bit means that TID Error occurs. 0h: Interrupt is not generated 1h: TID Error" range="" rwaccess="RW1C"/>
    <bitfield id="FRAMING" width="1" begin="4" end="4" resetval="0x0" description="Framing Error Setting of this bit means that Framing Error occurs during a packet receiving. 0h: Interrupt is not generated 1h: Framing Error" range="" rwaccess="RW1C"/>
    <bitfield id="CRC" width="1" begin="3" end="3" resetval="0x0" description="CRC Error Setting of this bit means that CRC Error occurs during a packet receiving. 0h: Interrupt is not generated 1h: CRC Error" range="" rwaccess="RW1C"/>
    <bitfield id="RETRY_EXPIRED" width="1" begin="2" end="2" resetval="0x0" description="Retry Expired Setting of this bit means that Retry Counter Expired Error occurs during data transfer. If this bit is set, either Framing Error or CRC Error in this register shall be set. 0h: Interrupt is not generated 1h: Retry Expired Error" range="" rwaccess="RW1C"/>
    <bitfield id="RESP_PKT" width="1" begin="1" end="1" resetval="0x0" description="RES Packet Error Host Controller Version 4.00 supports response error check function to avoid overhead of response error check by Host Driver during DMA execution. If the 0h: Interrupt is not generated 1h: RES Packet Error" range="" rwaccess="RW1C"/>
    <bitfield id="HEADER" width="1" begin="0" end="0" resetval="0x0" description="Header Error Setting of this bit means that Header Error occurs in a received packet. 0h: Interrupt is not generated 1h: Header Error" range="" rwaccess="RW1C"/>
  </register>
  <register id="MMCSD0_UHS2_ERR_INTR_STS_ENA" acronym="MMCSD0_UHS2_ERR_INTR_STS_ENA" offset="0xC8" width="32" description="This register is used to enable the register fields.">
    <bitfield id="VENDOR_SPECFIC" width="5" begin="31" end="27" resetval="0x0" description="Vendor Specific Error Setting this bit to 1h enables setting of Vendor Specific Error bit in the 0h: Status is Disabled 1h: Status is Enabled" range="" rwaccess="RW"/>
    <bitfield id="RESERVED" width="9" begin="26" end="18" resetval="0x0" description="Reserved" range="" rwaccess="R"/>
    <bitfield id="DEADLOCK_TIMEOUT" width="1" begin="17" end="17" resetval="0x0" description="Timeout for Deadlock Setting this bit to 1h enables setting of Timeout for Dead lock bit in the 0h: Status is Disabled 1h: Status is Enabled" range="" rwaccess="RW"/>
    <bitfield id="CMD_RESP_TIMEOUT" width="1" begin="16" end="16" resetval="0x0" description="Timeout for CMD_RES Setting this bit to 1h enables setting of Timeout for CMD_RES bit in the 0h: Status is Disabled 1h: Status is Enabled" range="" rwaccess="RW"/>
    <bitfield id="ADMA2_ADMA3" width="1" begin="15" end="15" resetval="0x0" description="ADMA2/3 Error Setting this bit to 1h enables setting of ADMA2/3 Error bit in the 0h: Status is Disabled 1h: Status is Enabled" range="" rwaccess="RW"/>
    <bitfield id="RESERVED" width="6" begin="14" end="9" resetval="0x0" description="Reserved" range="" rwaccess="R"/>
    <bitfield id="EBSY" width="1" begin="8" end="8" resetval="0x0" description="EBSY Error Setting this bit to 1h enables setting of EBSY Error bit in the 0h: Status is Disabled 1h: Status is Enabled" range="" rwaccess="RW"/>
    <bitfield id="UNRECOVERABLE" width="1" begin="7" end="7" resetval="0x0" description="Unrecoverable Error Setting this bit to 1h enables setting of Unrecoverable Error bit in the 0h: Status is Disabled 1h: Status is Enabled" range="" rwaccess="RW"/>
    <bitfield id="RESERVED" width="1" begin="6" end="6" resetval="0x0" description="Reserved" range="" rwaccess="R"/>
    <bitfield id="TID" width="1" begin="5" end="5" resetval="0x0" description="TID Error Setting this bit to 1h enables setting of TID Error bit in the 0h: Status is Disabled 1h: Status is Enabled" range="" rwaccess="RW"/>
    <bitfield id="FRAMING" width="1" begin="4" end="4" resetval="0x0" description="Framing Error Setting this bit to 1h enables setting of Framing Error bit in the 0h: Status is Disabled 1h: Status is Enabled" range="" rwaccess="RW"/>
    <bitfield id="CRC" width="1" begin="3" end="3" resetval="0x0" description="CRC Error Setting this bit to 1h enables setting of CRC Error bit in the 0h: Status is Disabled 1h: Status is Enabled" range="" rwaccess="RW"/>
    <bitfield id="RETRY_EXPIRED" width="1" begin="2" end="2" resetval="0x0" description="Retry Expired Setting this bit to 1h enables setting of Retry Expired bit in the 0h: Status is Disabled 1h: Status is Enabled" range="" rwaccess="RW"/>
    <bitfield id="RESP_PKT" width="1" begin="1" end="1" resetval="0x0" description="RES Packet Error Setting this bit to 1h enables setting of RES Packet Error bit in the 0h: Status is Disabled 1h: Status is Enabled" range="" rwaccess="RW"/>
    <bitfield id="HEADER" width="1" begin="0" end="0" resetval="0x0" description="Header Error Setting this bit to 1h enables setting of Header Error bit in the 0h: Status is Disabled 1h: Status is Enabled" range="" rwaccess="RW"/>
  </register>
  <register id="MMCSD0_UHS2_ERR_INTR_SIG_ENA" acronym="MMCSD0_UHS2_ERR_INTR_SIG_ENA" offset="0xCC" width="32" description="This register is used to generate UHS-II Interrupt signals.">
    <bitfield id="VENDOR_SPECFIC" width="5" begin="31" end="27" resetval="0x0" description="Vendor Specific Error Setting of a bit to 1h in this field enables generating interrupt signal when correspondent bit of Vendor Specific Error is set in the 0h: Interrupt Signal is Disabled 1h: Interrupt Signal is Enabled" range="" rwaccess="RW"/>
    <bitfield id="RESERVED" width="9" begin="26" end="18" resetval="0x0" description="Reserved" range="" rwaccess="R"/>
    <bitfield id="DEADLOCK_TIMEOUT" width="1" begin="17" end="17" resetval="0x0" description="Timeout for Deadlock Setting this bit to 1h enables generating interrupt signal when Timeout for Dead lock bit is set in the 0h: Interrupt Signal is Disabled 1h: Interrupt Signal is Enabled" range="" rwaccess="RW"/>
    <bitfield id="CMD_RESP_TIMEOUT" width="1" begin="16" end="16" resetval="0x0" description="Timeout for CMD_RES Setting this bit to 1h enables generating interrupt signal when Timeout for CMD_RES bit is set in the 0h: Interrupt Signal is Disabled 1h: Interrupt Signal is Enabled" range="" rwaccess="RW"/>
    <bitfield id="ADMA2_ADMA3" width="1" begin="15" end="15" resetval="0x0" description="ADMA2/3 Error Setting this bit to 1h enables generating interrupt signal when ADMA2/3 Error bit is set in the 0h: Interrupt Signal is Disabled 1h: Interrupt Signal is Enabled" range="" rwaccess="RW"/>
    <bitfield id="RESERVED" width="6" begin="14" end="9" resetval="0x0" description="Reserved" range="" rwaccess="R"/>
    <bitfield id="EBSY" width="1" begin="8" end="8" resetval="0x0" description="EBSY Error Setting this bit to 1h enables generating interrupt signal when EBSY Error bit is set in the 0h: Interrupt Signal is Disabled 1h: Interrupt Signal is Enabled" range="" rwaccess="RW"/>
    <bitfield id="UNRECOVERABLE" width="1" begin="7" end="7" resetval="0x0" description="Unrecoverable Error Setting this bit to 1h enables generating interrupt signal when Unrecoverable Error bit is set in the 0h: Interrupt Signal is Disabled 1h: Interrupt Signal is Enabled" range="" rwaccess="RW"/>
    <bitfield id="RESERVED" width="1" begin="6" end="6" resetval="0x0" description="Reserved" range="" rwaccess="R"/>
    <bitfield id="TID" width="1" begin="5" end="5" resetval="0x0" description="TID Error Setting this bit to 1h enables generating interrupt signal when TID Error bit is set in the 0h: Interrupt Signal is Disabled 1h: Interrupt Signal is Enabled" range="" rwaccess="RW"/>
    <bitfield id="FRAMING" width="1" begin="4" end="4" resetval="0x0" description="Framing Error Setting this bit to 1h enables generating interrupt signal when Framing Error bit is set in the 0h: Interrupt Signal is Disabled 1h: Interrupt Signal is Enabled" range="" rwaccess="RW"/>
    <bitfield id="CRC" width="1" begin="3" end="3" resetval="0x0" description="CRC Error Setting this bit to 1h enables generating interrupt signal when CRC Error bit is set in the 0h: Interrupt Signal is Disabled 1h: Interrupt Signal is Enabled" range="" rwaccess="RW"/>
    <bitfield id="RETRY_EXPIRED_SIG_ENA" width="1" begin="2" end="2" resetval="0x0" description="Retry Expired Setting this bit to 1h enables generating interrupt signal when Retry Expired bit is set in the 0h: Interrupt Signal is Disabled 1h: Interrupt Signal is Enabled" range="" rwaccess="RW"/>
    <bitfield id="RESP_PKT" width="1" begin="1" end="1" resetval="0x0" description="RES Packet Error Setting this bit to 1h enables generating interrupt signal when RES Packet Error bit is set in the 0h: Interrupt Signal is Disabled 1h: Interrupt Signal is Enabled" range="" rwaccess="RW"/>
    <bitfield id="HEADER" width="1" begin="0" end="0" resetval="0x0" description="Header Error Setting this bit to 1h enables generating interrupt signal when Header Error bit is set in the 0h: Interrupt Signal is Disabled 1h: Interrupt Signal is Enabled" range="" rwaccess="RW"/>
  </register>
  <register id="MMCSD0_UHS2_SETTINGS_PTR" acronym="MMCSD0_UHS2_SETTINGS_PTR" offset="0xE0" width="16" description="This register is pointer for UHS-II settings.">
    <bitfield id="UHS2_SETTINGS_PTR" width="16" begin="15" end="0" resetval="0x64" description="Pointer for UHS-II Settings Register" range="" rwaccess="R"/>
  </register>
  <register id="MMCSD0_UHS2_CAPABILITIES_PTR" acronym="MMCSD0_UHS2_CAPABILITIES_PTR" offset="0xE2" width="16" description="This register is pointer for UHS-II Capabilities Register.">
    <bitfield id="UHS2_CAPABILITIES_PTR" width="16" begin="15" end="0" resetval="0x6E" description="Pointer for UHS-II Capabilities Register" range="" rwaccess="R"/>
  </register>
  <register id="MMCSD0_UHS2_TEST_PTR" acronym="MMCSD0_UHS2_TEST_PTR" offset="0xE4" width="16" description="This register is pointer for UHS-II Test Register.">
    <bitfield id="UHS2_TEST_PTR" width="16" begin="15" end="0" resetval="0x78" description="Pointer for UHS-II Test Register" range="" rwaccess="R"/>
  </register>
  <register id="MMCSD0_SHARED_BUS_CTRL_PTR" acronym="MMCSD0_SHARED_BUS_CTRL_PTR" offset="0xE6" width="16" description="This register is pointer for UHS-II Shared Bus Control Register.">
    <bitfield id="SHARED_BUS_CTRL_PTR" width="16" begin="15" end="0" resetval="0x82" description="Pointer for Shared Bus Control Register" range="" rwaccess="R"/>
  </register>
  <register id="MMCSD0_VENDOR_SPECFIC_PTR" acronym="MMCSD0_VENDOR_SPECFIC_PTR" offset="0xE8" width="16" description="This register is pointer for UHS-II Vendor Specific Register.">
    <bitfield id="VENDOR_SPECFIC_PTR" width="16" begin="15" end="0" resetval="0x8C" description="Pointer for Vendor Specific Area" range="" rwaccess="R"/>
  </register>
  <register id="MMCSD0_BOOT_TIMEOUT_CONTROL" acronym="MMCSD0_BOOT_TIMEOUT_CONTROL" offset="0xF4" width="32" description="This is used to program the boot timeout value counter.">
    <bitfield id="DATA_TIMEOUT_CNT" width="32" begin="31" end="0" resetval="0x0" description="Boot Data Timeout Counter Value This value determines the interval by which DAT line timeouts are detected during boot operation for eMMC4.4 card. The value is in number of SD clock." range="" rwaccess="RW"/>
  </register>
  <register id="MMCSD0_VENDOR_REGISTER" acronym="MMCSD0_VENDOR_REGISTER" offset="0xF8" width="32" description="Vendor register added for Auto Gate SD CLK, CMD11 Power Down Timer, Enhanced Strobe and eMMC Hardware Reset.">
    <bitfield id="RESERVED" width="15" begin="31" end="17" resetval="0x0" description="Reserved" range="" rwaccess="R"/>
    <bitfield id="AUTOGATE_SDCLK" width="1" begin="16" end="16" resetval="0x0" description="Auto Gate SD CLK If this bit is set, SD CLK will be gated automatically when there is no transfer. This is applicable only for Embedded Device. 0h: Disable 1h: Enable" range="" rwaccess="RW"/>
    <bitfield id="CMD11_PD_TIMER" width="14" begin="15" end="2" resetval="0x56C" description="CMD11 Power Down Timer Value" range="" rwaccess="RW"/>
    <bitfield id="EMMC_HW_RESET" width="1" begin="1" end="1" resetval="0x0" description="eMMC Hardware Reset Hardware reset signal is generared for eMMC card when this bit is set. 0h: De-sassert hardware reset pin 1h: Drives the hardware reset pin as ZERO (Active LOW to eMMC card)" range="" rwaccess="RW"/>
    <bitfield id="ENHANCED_STROBE" width="1" begin="0" end="0" resetval="0x0" description="Enhanced Strobe This bit enables the enhanced strobe logic of the Host Controller." range="" rwaccess="RW"/>
  </register>
  <register id="MMCSD0_SLOT_INT_STS" acronym="MMCSD0_SLOT_INT_STS" offset="0xFC" width="16" description="This register is used to read the interrupt signal for each slot.">
    <bitfield id="RESERVED" width="8" begin="15" end="8" resetval="0x0" description="Reserved" range="" rwaccess="R"/>
    <bitfield id="INTR_SIG" width="8" begin="7" end="0" resetval="0x0" description="Interrupt Signal for Slot#0 These status bits indicate the logical OR of Interrupt signal and Wakeup signal for each slot." range="" rwaccess="R"/>
  </register>
  <register id="MMCSD0_HOST_CONTROLLER_VER" acronym="MMCSD0_HOST_CONTROLLER_VER" offset="0xFE" width="16" description="This register is used to read the vendor version number and specification version number.">
    <bitfield id="VEN_VER_NUM" width="8" begin="15" end="8" resetval="0xA" description="Vendor Version Number The Vendor Version Number is set to 10h (1.0)" range="" rwaccess="R"/>
    <bitfield id="SPEC_VER_NUM" width="8" begin="7" end="0" resetval="0x4" description="Specification Version Number This status indicates the Host Controller Specification Version. The upper and lower 4-bits indicate the version. 0h: SD Host Controller Specification Version 1.00 1h: SD Host Controller Specification Version 2.00 Including the feature of the ADMA and Test Register 2h: SD Host Controller Specification Version 3.00 3h: SD Host Controller Specification Version 4.00 4h: SD Host Controller Specification Version 4.10 Others: Reserved" range="" rwaccess="R"/>
  </register>
  <register id="MMCSD0_UHS2_GEN_SETTINGS" acronym="MMCSD0_UHS2_GEN_SETTINGS" offset="0x100" width="32" description="Start Address of General settings is pointed by the Register.">
    <bitfield id="RESERVED" width="18" begin="31" end="14" resetval="0x0" description="Reserved" range="" rwaccess="R"/>
    <bitfield id="NUMLANES" width="6" begin="13" end="8" resetval="0x0" description="Number of Lanes and Functionalities The lane configuration of a Host System is set to this field depends on the capability among Host Controller and connected devices. 2 Lanes FD mode is mandatory and the others modes are optional. 0h: 2 Lanes FD or 2L-HD 1h: Not Used 2h: 3 Lanes 2D1U-FD (Embedded) 3h: 3 Lanes 1D2U-FD (Embedded) 4h: 4 Lanes 2D2U-FD (Embedded) Others: Reserved" range="" rwaccess="RW"/>
    <bitfield id="RESERVED" width="7" begin="7" end="1" resetval="0x0" description="Reserved" range="" rwaccess="R"/>
    <bitfield id="POWER_MODE" width="1" begin="0" end="0" resetval="0x0" description="Power Mode This field determines either Fast mode or Low Power mode. Host and all devices connected to the host shall be set to the same mode. 0h: Fast Mode 1h: Low Power Mode" range="" rwaccess="RW"/>
  </register>
  <register id="MMCSD0_UHS2_PHY_SETTINGS" acronym="MMCSD0_UHS2_PHY_SETTINGS" offset="0x104" width="32" description="Start Address of PHY settings is pointed by the Register.">
    <bitfield id="RESERVED" width="8" begin="31" end="24" resetval="0x0" description="Reserved" range="" rwaccess="R"/>
    <bitfield id="N_LSS_DIR" width="4" begin="23" end="20" resetval="0x0" description="Host N_LSS_DIR The largest value of N_LSS_DIR capabilities among the Host Controller and Connected Devices is set to this field. 0h: 8 x 16 LSS 1h: 8 x 1 LSS 2h: 8 x 2 LSS 3h: 8 x 3 LSS .... .... Fh: 8 x 15 LSS" range="" rwaccess="RW"/>
    <bitfield id="N_LSS_SYN" width="4" begin="19" end="16" resetval="0x0" description="Host N_LSS_SYN The largest value of N_LSS_SYN capabilities among the Host Controller and Connected Devices is set to this field. 0h: 4 x 16 LSS 1h: 4 x 1 LSS 2h: 4 x 2 LSS 3h - 4 x 3 LSS .... .... Fh: 4 x 15 LSS" range="" rwaccess="RW"/>
    <bitfield id="HIBERNATE_ENA" width="1" begin="15" end="15" resetval="0x0" description="Hibernate Enable After checking card capability of Hibernate mode, if all devices support Hibernate mode, this bit may be set. This bit determines whether Host remains in Dormant state or goes to Hibernate state. In Hibernate mode, VDD1 Power may be off. 0h: Hibernate Disabled 1h: Hibernate Enabled" range="" rwaccess="RW"/>
    <bitfield id="RESERVED" width="7" begin="14" end="8" resetval="0x0" description="Reserved" range="" rwaccess="R"/>
    <bitfield id="SPEED_RANGE" width="2" begin="7" end="6" resetval="0x0" description="Speed Range PLL multiplier is selected by this field. Change of PLL Multiplier is not effective immediately and is applied from exiting Dormant State. 0h: Range A (Defalt) 1h: Range B 2h: Reserved 3h: Reserved" range="" rwaccess="RW"/>
    <bitfield id="RESERVED" width="6" begin="5" end="0" resetval="0x0" description="Reserved" range="" rwaccess="R"/>
  </register>
  <register id="MMCSD0_UHS2_LNK_TRN_SETTINGS" acronym="MMCSD0_UHS2_LNK_TRN_SETTINGS" offset="0x108" width="64" description="Start Address of LINK/TRAN settings is pointed by the Register.">
    <bitfield id="RESERVED" width="24" begin="63" end="40" resetval="0x0" description="Reserved" range="" rwaccess="R"/>
    <bitfield id="N_DATA_GAP" width="8" begin="39" end="32" resetval="0x0" description="Host N_DATA_GAP The largest value of N_DATA_GAP capabilities among the Host Controller and Connected Devices is set to this field. 00h: No Gap 01h: 1 LSS 02h: 2 LSS 03h: 3 LSS .... .... FFh: 255 LSS" range="" rwaccess="RW"/>
    <bitfield id="RESERVED" width="14" begin="31" end="18" resetval="0x0" description="Reserved" range="" rwaccess="R"/>
    <bitfield id="RETRY_COUNT" width="2" begin="17" end="16" resetval="0x0" description="Retry Count Data Burst retry count is set to this field. 00h: Retry Disabled 01h: 1 time 02h: 2 times 03h: 3 times" range="" rwaccess="RW"/>
    <bitfield id="HOST_NFCU" width="8" begin="15" end="8" resetval="0x0" description="Host N_FCU Host Driver sets the number of blocks in Data Burst (Flow Control) to this field. The value shall be smaller than or equal to N_FCU capabilities among the Host Controller and connected card and devices. Setting 1 to 4 blocks is recommended considering buffer size. 00h: 256 Blocks 01h: 1 Block 02h: 2 Blocks 03h: 3 Blocks .... .... FFh: 255 Blocks" range="" rwaccess="RW"/>
    <bitfield id="RESERVED" width="8" begin="7" end="0" resetval="0x0" description="Reserved" range="" rwaccess="R"/>
  </register>
  <register id="MMCSD0_UHS2_GEN_CAP" acronym="MMCSD0_UHS2_GEN_CAP" offset="0x110" width="32" description="Start Address of General Capabilities is pointed by the Register.">
    <bitfield id="RESERVED" width="8" begin="31" end="24" resetval="0x0" description="Reserved" range="" rwaccess="R"/>
    <bitfield id="CORECFG_UHS2_BUS_TOPLOGY" width="2" begin="23" end="22" resetval="0x0" description="Bus Topology This field indicates one of bus topologies configured by a Host system. 0h: P2P Connection 1h: Ring Connection 2h: HUB Connection 3h: HUB is Connected in Ring" range="" rwaccess="R"/>
    <bitfield id="CORECFG_UHS2_MAX_DEVICES" width="4" begin="21" end="18" resetval="0x0" description="Number of Devices Supported This field indicates the maximum number of devices supported by the Host Controller. 0h: Not used 1h: 1 Devices 2h: 2 Devices .... .... Fh: 15 Devices" range="" rwaccess="R"/>
    <bitfield id="DEVICE_TYPE" width="2" begin="17" end="16" resetval="0x0" description="Removable/Embedded This field indicates device type configured by a Host system. 0h: Removable Card (P2P) 1h: Embedded Devices 2h: Embedded Devices + Removable Card 3h: Reserved" range="" rwaccess="R"/>
    <bitfield id="RESERVED" width="1" begin="15" end="15" resetval="0x0" description="Reserved" range="" rwaccess="R"/>
    <bitfield id="CFG_64BIT_ADDRESSING" width="1" begin="14" end="14" resetval="0x1" description="64-bit Addressing This field indicates support of 64-bit addressing by the Host Controller. 0h: 32-bit Addressing is supported 1h: 32-bit and 64-bit Addressing is supported" range="" rwaccess="R"/>
    <bitfield id="NUM_LANES" width="6" begin="13" end="8" resetval="0x0" description="Number of Lanes and Functionalities This field indicates support of lanes by the Host Controller. 0 mean not supported and 1 means supported. D08: 2L-HD D09: 2D1U-FD D10: 1D2U-FD D11: 2D2U-FD D12: Reserved D13: Reserved" range="" rwaccess="R"/>
    <bitfield id="GAP" width="4" begin="7" end="4" resetval="0x0" description="GAP (Group Allocation Power) This field indicates the maximum capability of host power supply for a group configured by a Host system. This field is used to set the argument of DEVICE_INIT CCM. 0h: Not used 1h: 360 mW 2h: 720 mW .... .... Fh: 360 x 15 mW" range="" rwaccess="R"/>
    <bitfield id="DAP" width="4" begin="3" end="0" resetval="0x0" description="DAP (Device Allocation Power) This field indicates the maximum capability of host power supply for a device configured by a Host system. This field is used to set the argument of DEVICE_INIT CCMD. 0h: 360 mW (Default) 1h: 360 mW 2h: 720 mW .... .... Fh: 360 x 15 mW" range="" rwaccess="R"/>
  </register>
  <register id="MMCSD0_UHS2_PHY_CAP" acronym="MMCSD0_UHS2_PHY_CAP" offset="0x114" width="32" description="Start Address of PHY Capabilities is pointed by the Register.">
    <bitfield id="RESERVED" width="8" begin="31" end="24" resetval="0x0" description="Reserved" range="" rwaccess="R"/>
    <bitfield id="N_LSS_DIR" width="4" begin="23" end="20" resetval="0x0" description="Host N_LSS_DIR This field indicates the minimum N_LSS_DIR required by the Host Controller. 0h: 4 x 16 LSS 1h: 4 x 1 LSS 2h: 4 x 2 LSS 3h: 4 x 3 LSS .... .... Fh: 4 x 15 LSS" range="" rwaccess="R"/>
    <bitfield id="N_LSS_SYN" width="4" begin="19" end="16" resetval="0x0" description="Host N_LSS_SYN This field indicates the minimum N_LSS_SYN required by the Host Controller. 0h: 4 x 16 LSS 1h: 4 x 1 LSS 2h: 4 x 2 LSS 3h: 4 x 3 LSS .... .... Fh: 4 x 15 LSS" range="" rwaccess="R"/>
    <bitfield id="RESERVED" width="8" begin="15" end="8" resetval="0x0" description="Reserved" range="" rwaccess="R"/>
    <bitfield id="SPEED_RANGE" width="2" begin="7" end="6" resetval="0x0" description="Speed Range This field indicates supported Speed Range by the Host Controller. 0h: Range A (Default) 1h: Range A and Range B 2h: Reserved 3h: Reserved" range="" rwaccess="R"/>
    <bitfield id="RESERVED" width="6" begin="5" end="0" resetval="0x0" description="Reserved" range="" rwaccess="R"/>
  </register>
  <register id="MMCSD0_UHS2_LNK_TRN_CAP" acronym="MMCSD0_UHS2_LNK_TRN_CAP" offset="0x118" width="64" description="Start Address of LINK/TRAN settings is pointed by the Register.">
    <bitfield id="RESERVED" width="24" begin="63" end="40" resetval="0x0" description="Reserved" range="" rwaccess="R"/>
    <bitfield id="N_DATA_GAP" width="8" begin="39" end="32" resetval="0x0" description="Host N_DATA_GAP This field indicates the minimum number of data gap (DIDL) supported by the Host Controller. 00h: No Gap 01h: 1 LSS 02h: 2 LSS 03h: 3 LSS .... .... FFh: 255 LSS" range="" rwaccess="R"/>
    <bitfield id="MAX_BLK_LENGTH" width="12" begin="31" end="20" resetval="0x0" description="Host Maximum Block Length This field indicates maximum block length by the Host Controller. 000h: Not Used 001h: 1 byte 002h: 2 bytes .... .... 200h: 512 bytes .... .... 800h: 2048 bytes 801h - FFFh: Not Used" range="" rwaccess="R"/>
    <bitfield id="RESERVED" width="4" begin="19" end="16" resetval="0x0" description="Reserved" range="" rwaccess="R"/>
    <bitfield id="N_FCU" width="8" begin="15" end="8" resetval="0x0" description="Host N_FCU This field indicates maximum the number of blocks in a Flow Control unit by the Host Controller. This value is determined by supported buffer size. 00h: 256 Blocks 01h: 1 Block 02h: 2 Block 03h: 3 Block .... .... FFh: 255 Blocks" range="" rwaccess="R"/>
    <bitfield id="RESERVED" width="8" begin="7" end="0" resetval="0x0" description="Reserved" range="" rwaccess="R"/>
  </register>
  <register id="MMCSD0_FORCE_UHSII_ERR_INT_STS" acronym="MMCSD0_FORCE_UHSII_ERR_INT_STS" offset="0x120" width="32" description="This register is not physically implemented, rather it is an address where the register can be written.">
    <bitfield id="VENDOR_SPECIFIC" width="5" begin="31" end="27" resetval="0x0" description="Force Event for Vendor Specific Error 0h: Not Affected 1h: Vendor Specific Error Status is set" range="" rwaccess="W"/>
    <bitfield id="RESERVED" width="9" begin="26" end="18" resetval="0x0" description="Reserved" range="" rwaccess="R"/>
    <bitfield id="TIMEOUT_DEADLOCK" width="1" begin="17" end="17" resetval="0x0" description="Force Event for Timeout for Deadlock Setting this bit forces the Host Controller to set Timeout for Deadlock in the 0h: Not affected 1h: Timeout for Deadlock Error status is set" range="" rwaccess="W"/>
    <bitfield id="TIMEOUT_CMD_RES" width="1" begin="16" end="16" resetval="0x0" description="Force Event for Timeout for CMD_RES Setting this bit forces the Host Controller to set Timeout for CMD_RES in the 0h: Not affected 1h: Timout for CMD_RES Status is set" range="" rwaccess="W"/>
    <bitfield id="ADMA" width="1" begin="15" end="15" resetval="0x0" description="Force Event for ADMA Error Setting this bit forces the Host Controller to set ADMA Error in the 0h: Not affected 1h: ADMA Error Status is set" range="" rwaccess="W"/>
    <bitfield id="RESERVED" width="6" begin="14" end="9" resetval="0x0" description="Reserved" range="" rwaccess="R"/>
    <bitfield id="EBSY" width="1" begin="8" end="8" resetval="0x0" description="Force Event for EBSY Error Setting this bit forces the Host Controller to set EBSY Error in the 0h: Not affected 1h: EBSY Error Status is set" range="" rwaccess="W"/>
    <bitfield id="UNRECOVERABLE" width="1" begin="7" end="7" resetval="0x0" description="Force Event for Unrecoverable Error Setting this bit forces the Host Controller to set Unrecoverable Error in the 0h: Not affected 1h: Unrecoverable Error Status is set" range="" rwaccess="W"/>
    <bitfield id="RESERVED" width="1" begin="6" end="6" resetval="0x0" description="Reserved" range="" rwaccess="R"/>
    <bitfield id="TID" width="1" begin="5" end="5" resetval="0x0" description="Force Event for TID Error Setting this bit forces the Host Controller to set TID Error in the 0h: Not affected 1h: TID Error Status is set" range="" rwaccess="W"/>
    <bitfield id="FRAMING" width="1" begin="4" end="4" resetval="0x0" description="Force Event for Framing Error Setting this bit forces the Host Controller to set Framing Error in the 0h: Not affected 1h: Framing Error Status is set" range="" rwaccess="W"/>
    <bitfield id="CRC" width="1" begin="3" end="3" resetval="0x0" description="Force Event for CRC Error Setting this bit forces the Host Controller to set CRC Error in the 0h: Not affected 1h: CRC Error Status is set" range="" rwaccess="W"/>
    <bitfield id="RETRY_EXPIRED" width="1" begin="2" end="2" resetval="0x0" description="Force Event for Retry Expired Setting this bit forces the Host Controller to set Retry Expired in the 0h: Not affected 1h: Retry expired error status is set" range="" rwaccess="W"/>
    <bitfield id="RES_PKT" width="1" begin="1" end="1" resetval="0x0" description="Force Event for RES Packet Error Setting this bit forces the Host Controller to set RES Packet Error in the 0h: Not affected 1h: RES packet error status is set" range="" rwaccess="W"/>
    <bitfield id="HEADER" width="1" begin="0" end="0" resetval="0x0" description="Force Event for Header Error Setting this bit forces the Host Controller to set Header Error in the 0h: Not affected 1h: Header error status is set" range="" rwaccess="W"/>
  </register>
  <register id="MMCSD0_CQ_VERSION" acronym="MMCSD0_CQ_VERSION" offset="0x200" width="32" description="This register provides information about the version of the eMMC CQ (Command Queueing) standard which is 285 implemented by the CQE, in BCD format. The current version is rev 5.1. The following table describes the CQBASE+00h: Command Queueing Version.">
    <bitfield id="RESERVED" width="20" begin="31" end="12" resetval="0x0" description="Reserved" range="" rwaccess="R"/>
    <bitfield id="EMMC_MAJOR_VER_NUM" width="4" begin="11" end="8" resetval="0x5" description="eMMC Major Version Number (digit left of decimal point), in BCD format" range="" rwaccess="R"/>
    <bitfield id="EMMC_MINOR_VER_NUM" width="4" begin="7" end="4" resetval="0x1" description="eMMC Minor Version Number (digit right of decimal point), in BCD format" range="" rwaccess="R"/>
    <bitfield id="EMMC_VERSION_SUFFIX" width="4" begin="3" end="0" resetval="0x0" description="eMMC Version Suffix (2nd digit right of decimal point), in BCD format" range="" rwaccess="R"/>
  </register>
  <register id="MMCSD0_CQ_CAPABILITIES" acronym="MMCSD0_CQ_CAPABILITIES" offset="0x204" width="32" description="This register is reserved for capability indication.">
    <bitfield id="RESERVED" width="16" begin="31" end="16" resetval="0x0" description="Reserved" range="" rwaccess="R"/>
    <bitfield id="CF_MUL" width="4" begin="15" end="12" resetval="0x3" description="ITCFMUL and ITCFVAL indicate the frequency of the clock used for interrupt coalescing timer and for determining the SQS polling period. See ITCFVAL definition for details ( Field Value Description: 0h: 0.001 MHz 1h: 0.01 MHz 2h: 0.1 MHz 3h: 1 MHz 4h: 10 MHz Other values are reserved" range="" rwaccess="R"/>
    <bitfield id="RESERVED" width="2" begin="11" end="10" resetval="0x0" description="Reserved" range="" rwaccess="R"/>
    <bitfield id="CF_VAL" width="10" begin="9" end="0" resetval="0x0" description="ITCFMUL and ITCFVAL indicate the frequency of the clock used for interrupt coalescing timer and for determining the polling period when using periodic SEND_QUEUE_STATUS (CMD13) polling. The clock frequency is calculated as ITCFVAL &#215; ITCFMUL. For example, to encode 19.2 MHz ITCFVAL shall be 192 &#215; 0.1 MHz = 19.2 MHz" range="" rwaccess="R"/>
  </register>
  <register id="MMCSD0_CQ_CONFIG" acronym="MMCSD0_CQ_CONFIG" offset="0x208" width="32" description="This register controls CQE behavior affecting the general operation of command queueing 290 module or operation of multiple tasks in the same time.">
    <bitfield id="RESERVED" width="19" begin="31" end="13" resetval="0x0" description="Reserved" range="" rwaccess="R"/>
    <bitfield id="DCMD_ENA" width="1" begin="12" end="12" resetval="0x0" description="This bit indicates to the hardware whether the Task Descriptor in slot #31 of the TDL is a Data Transfer Task Descriptor, or a Direct Command Task Descriptor. CQE uses this bit when a task is issued in slot #31, to determine how to decode the Task Descriptor. Bit Value Description 0h: Task descriptor in slot #31 is a Data Transfer Task Descriptor 1h: Task descriptor in slot #31 is a DCMD Task Descriptor" range="" rwaccess="RW"/>
    <bitfield id="RESERVED" width="3" begin="11" end="9" resetval="0x0" description="Reserved" range="" rwaccess="R"/>
    <bitfield id="TASK_DESC_SIZE" width="1" begin="8" end="8" resetval="0x0" description="This bit indicates whether the task descriptor size is 128 bits or 64 bits. This bit can only be configured when the Bit Value Description 0h: Task descriptor size is 64 bits 1h: Task descriptor size is 128 bits" range="" rwaccess="RW"/>
    <bitfield id="RESERVED" width="7" begin="7" end="1" resetval="0x0" description="Reserved" range="" rwaccess="R"/>
    <bitfield id="CQ_ENABLE" width="1" begin="0" end="0" resetval="0x0" description="Software shall write 1h to this bit when in order to enable command queueing mode (enable CQE). When this bit is 0h, CQE is disabled and software controls the eMMC bus using the legacy eMMC host controller. Before software writes 1h to this bit, software shall verify that the eMMC host controller is in idle state and there are no commands or data transfers ongoing. When software wants to exit command queueing mode, it shall clear all previous tasks if such exist before setting this bit to 0h." range="" rwaccess="RW"/>
  </register>
  <register id="MMCSD0_CQ_CONTROL" acronym="MMCSD0_CQ_CONTROL" offset="0x20C" width="32" description="This register controls CQE behavior affecting the general operation of command queueing 293 module or operation of multiple tasks in the same time.">
    <bitfield id="RESERVED" width="23" begin="31" end="9" resetval="0x0" description="Reserved" range="" rwaccess="R"/>
    <bitfield id="CLEAR_ALL_TASKS" width="1" begin="8" end="8" resetval="0x0" description="Software shall write 1h to this bit when it wants to clear all the tasks sent to the device. This bit can only be written when CQE is in halt state (Halt bit is 1h). When software writes 1h, the value of the register is updated to 1h, and CQE shall reset the Software should poll on this bit until it is set to back 0 and may then resume normal operation, by clearing the Halt bit. CQE does not communicate to the device that the tasks were cleared. It is softwares responsibility to order the device to discard the tasks in its queue using CMDQ_TASK_MGMT command. Writing 0h to this register shall have no effect." range="" rwaccess="RW"/>
    <bitfield id="RESERVED" width="7" begin="7" end="1" resetval="0x0" description="Reserved" range="" rwaccess="R"/>
    <bitfield id="HALT_BIT" width="1" begin="0" end="0" resetval="0x0" description="Host software shall write 1h to the bit when it wants to acquire software control over the eMMC bus and disable CQE from issuing commands on the bus. For example, issuing a Discard Task command (CMDQ_TASK_MGMT). When software writes 1h, CQE shall complete the ongoing task if such a task is in progress. Once the task is completed and CQE is in idle state, CQE shall not issue new commands and shall indicate so to software by setting this bit to 1h. Software may poll on this bit until it is set to 1h, and may only then send commands on the eMMC bus. In order to exit halt state (resume CQE activity), software shall clear this bit (write 0h). Writing 0h when the value is already 0h shall have no effect." range="" rwaccess="RW"/>
  </register>
  <register id="MMCSD0_CQ_INTR_STS" acronym="MMCSD0_CQ_INTR_STS" offset="0x210" width="32" description="This register indicates pending interrupts that require service. Each bit in this registers is asserted 296 in response a specific event, only if the respective bit is set in the register.">
    <bitfield id="RESERVED" width="27" begin="31" end="5" resetval="0x0" description="Reserved" range="" rwaccess="R"/>
    <bitfield id="TASK_ERROR" width="1" begin="4" end="4" resetval="0x0" description="This bit is asserted when task error is detected due to invalid task descriptor." range="" rwaccess="RW1C"/>
    <bitfield id="TASK_CLEARED" width="1" begin="3" end="3" resetval="0x0" description="This status bit is asserted (if" range="" rwaccess="RW1C"/>
    <bitfield id="RESP_ERR_DET" width="1" begin="2" end="2" resetval="0x0" description="This status bit is asserted (if Software uses the" range="" rwaccess="RW1C"/>
    <bitfield id="TASK_COMPLETE" width="1" begin="1" end="1" resetval="0x0" description="This status bit is asserted (if (1) A task is completed and the INT bit is set in its Task Descriptor (2) Interrupt caused by Interrupt Coalescing logic" range="" rwaccess="RW1C"/>
    <bitfield id="HALT_COMPLETE" width="1" begin="0" end="0" resetval="0x0" description="This status bit is asserted (if" range="" rwaccess="RW1C"/>
  </register>
  <register id="MMCSD0_CQ_INTR_STS_ENA" acronym="MMCSD0_CQ_INTR_STS_ENA" offset="0x214" width="32" description="This register enables and disables the reporting of the corresponding interrupt to host software in 299 register. When a bit is set (1h) and the corresponding interrupt condition is active, then the 300 bit in the register is asserted. Interrupt sources that are disabled (0h) are not indicated in the 301 register. This register is bit-index matched to the register.">
    <bitfield id="RESERVED" width="27" begin="31" end="5" resetval="0x0" description="Reserved" range="" rwaccess="R"/>
    <bitfield id="TASK_ERROR" width="1" begin="4" end="4" resetval="0x0" description="1h: 0h:" range="" rwaccess="RW"/>
    <bitfield id="TASK_CLEARED" width="1" begin="3" end="3" resetval="0x0" description="1h: 0h:" range="" rwaccess="RW"/>
    <bitfield id="RESP_ERR_DET" width="1" begin="2" end="2" resetval="0x0" description="1h: 0h:" range="" rwaccess="RW"/>
    <bitfield id="TASK_COMPLETE" width="1" begin="1" end="1" resetval="0x0" description="1h: 0h:" range="" rwaccess="RW"/>
    <bitfield id="HALT_COMPLETE" width="1" begin="0" end="0" resetval="0x0" description="1h: 0h:" range="" rwaccess="RW"/>
  </register>
  <register id="MMCSD0_CQ_INTR_SIG_ENA" acronym="MMCSD0_CQ_INTR_SIG_ENA" offset="0x218" width="32" description="This register enables and disables the generation of interrupts to host software. When a bit is set 304 (1h) and the corresponding bit in the register is set, then an interrupt is generated. Interrupt sources 305 that are disabled (0h) are still indicated in the register. This register is bit-index matched 306 to the register.">
    <bitfield id="RESERVED" width="27" begin="31" end="5" resetval="0x0" description="Reserved" range="" rwaccess="R"/>
    <bitfield id="TASK_ERROR" width="1" begin="4" end="4" resetval="0x0" description="When set and the" range="" rwaccess="RW"/>
    <bitfield id="TASK_CLEARED" width="1" begin="3" end="3" resetval="0x0" description="When set and the" range="" rwaccess="RW"/>
    <bitfield id="RESP_ERR_DET" width="1" begin="2" end="2" resetval="0x0" description="When set and the" range="" rwaccess="RW"/>
    <bitfield id="TASK_COMPLETE" width="1" begin="1" end="1" resetval="0x0" description="When set and the" range="" rwaccess="RW"/>
    <bitfield id="HALT_COMPLETE" width="1" begin="0" end="0" resetval="0x0" description="When set and the" range="" rwaccess="RW"/>
  </register>
  <register id="MMCSD0_CQ_INTR_COALESCING" acronym="MMCSD0_CQ_INTR_COALESCING" offset="0x21C" width="32" description="This register controls the interrupt coalescing feature.">
    <bitfield id="CQINTCOALESC_ENABLE" width="1" begin="31" end="31" resetval="0x0" description="When set to 0h by software, command responses are neither counted nor timed. Interrupts are still triggered by completion of tasks with INT = 1 in the Task Descriptor. When set to 1h, the interrupt coalescing mechanism is enabled and coalesced interrupts are generated." range="" rwaccess="RW"/>
    <bitfield id="RESERVED" width="10" begin="30" end="21" resetval="0x0" description="Reserved" range="" rwaccess="R"/>
    <bitfield id="IC_STATUS" width="1" begin="20" end="20" resetval="0x0" description="This bit indicates to software whether any tasks (with INT = 0) have completed and counted towards interrupt coalescing (ICSB is set if and only if IC counter &amp;amp;gt; 0). Bit Value Description 0h: No task completions have occurred since last counter reset (IC counter = 0) 1h: At least one task completion has been counted (IC counter &amp;amp;gt; 0)" range="" rwaccess="R"/>
    <bitfield id="RESERVED" width="7" begin="19" end="13" resetval="0x0" description="Reserved" range="" rwaccess="R"/>
    <bitfield id="CTR_THRESHOLD" width="5" begin="12" end="8" resetval="0x0" description="Software uses this field to configure the number of task completions (only tasks with INT = 0 in the Task Descriptor) which are required in order to generate an interrupt. Counter Operation: As data transfer tasks with INT = 0 complete, they are counted by CQE. The counter is reset by software during the interrupt service routine. The counter stops counting when it reaches the value configured in ICCTH. The maximum allowed value is 31." range="" rwaccess="RW"/>
    <bitfield id="RESERVED" width="1" begin="7" end="7" resetval="0x0" description="Reserved" range="" rwaccess="R"/>
    <bitfield id="TIMEOUT_VAL" width="7" begin="6" end="0" resetval="0x0" description="Software uses this field to configure the maximum time allowed between the completion of a task on the bus and the generation of an interrupt. Timer Operation: The timer is reset by software during the interrupt service routine. It starts running when a data transfer task with INT = 0 is completed, after the timer was reset. When the timer reaches the value configured in ICTOVAL field it generates an interrupt and stops. The timers unit is equal to 1024 clock periods of the clock whose frequency is specified in the Internal Timer Clock Frequency field in the The minimum value is 1h (1024 clock periods) and the maximum value is 7Fh (127 &#215; 1024 clock periods). For example, a" range="" rwaccess="RW"/>
  </register>
  <register id="MMCSD0_CQ_TDL_BASE_ADDR" acronym="MMCSD0_CQ_TDL_BASE_ADDR" offset="0x220" width="32" description="This register is used for configuring the lower 32 bits of the byte address of the head of the Task 312 Descriptor List in the host memory.">
    <bitfield id="CQTDLBA_LO" width="32" begin="31" end="0" resetval="0x0" description="This register stores the LSB bits (bits 31-0) of the byte address of the head of the Task Descriptor List in system memory. The size of the task descriptor list is 32 &#215; (Task Descriptor size + Transfer Descriptor size) as configured by Host driver. This address shall be set on Byte1 KByte boundary. The lower 10 bits of this register shall be set to 0h by software and shall be ignored by CQE." range="" rwaccess="RW"/>
  </register>
  <register id="MMCSD0_CQ_TDL_BASE_ADDR_UPBITS" acronym="MMCSD0_CQ_TDL_BASE_ADDR_UPBITS" offset="0x224" width="32" description="This register is used for configuring the upper 32 bits of the byte address of the head of the Task 316 Descriptor List in the host memory.">
    <bitfield id="CQTDLBA_HI" width="32" begin="31" end="0" resetval="0x0" description="This register stores the MSB bits (bits 63-32) of the byte address of the head of the Task Descriptor List in system memory. The size of the task descriptor list is 32 &#215; (Task Descriptor size + Transfer Descriptor size) as configured by Host driver. This register is reserved when using 32-bit addressing mode." range="" rwaccess="RW"/>
  </register>
  <register id="MMCSD0_CQ_TASK_DOOR_BELL" acronym="MMCSD0_CQ_TASK_DOOR_BELL" offset="0x228" width="32" description="Using this register, software triggers CQE to process a new task.">
    <bitfield id="CQTDB_VAL" width="32" begin="31" end="0" resetval="0x0" description="Software shall configure the Writing 1h to bit n of this register triggers CQE to start processing the task encoded in slot n of the TDL. CQE always processes tasks in-order according to the order submitted to the list by the CQE processes Data Transfer tasks by reading the Task Descriptor and sending QUEUED_TASK_PARAMS (CMD44) and QUEUED_TASK_ADDRESS (CMD45) commands to the device. CQE processes DCMD tasks (in slot #31, when enabled) by reading the Task Descriptor, and generating the command encoded by its index and argument. The corresponding bit is cleared to 0h by CQE in one of the following events: (a) When a task execution is completed (with success or error) (b) The task is cleared using (c) All tasks are cleared using (d) CQE is disabled using Software may initiate multiple tasks at the same time (batch submission) by writing 1h to multiple bits of this register in the same transaction. In the case of batch submission: CQE shall process the tasks in order of the task index, starting with the lowest index. If one or more tasks in the batch are marked with QBR, the ordering of execution will be based on said processing order. Writing 0h by software shall have no impact on the hardware, and will not change the value of the register bit." range="" rwaccess="W1S"/>
  </register>
  <register id="MMCSD0_CQ_TASK_COMP_NOTIF" acronym="MMCSD0_CQ_TASK_COMP_NOTIF" offset="0x22C" width="32" description="This register is used by CQE to notify software about completed tasks.">
    <bitfield id="CQTCN_VAL" width="32" begin="31" end="0" resetval="0x0" description="CQE shall set bit n of this register (at the same time it clears bit n of the When receiving interrupt for task completion, software may read this register to know which tasks have finished. After reading this register, software may clear the relevant bit fields by writing 1h to the corresponding bits." range="" rwaccess="RW1C"/>
  </register>
  <register id="MMCSD0_CQ_DEV_QUEUE_STATUS" acronym="MMCSD0_CQ_DEV_QUEUE_STATUS" offset="0x230" width="32" description="This register stores the most recent value of the device's queue status.">
    <bitfield id="CQDQ_STS" width="32" begin="31" end="0" resetval="0x0" description="Every time the Host controller receives a queue status register (QSR) from the device, it updates this register with the response of status command (the device's queue status)." range="" rwaccess="R"/>
  </register>
  <register id="MMCSD0_CQ_DEV_PENDING_TASKS" acronym="MMCSD0_CQ_DEV_PENDING_TASKS" offset="0x234" width="32" description="This register indicates to software which tasks are queued in the device, awaiting execution.">
    <bitfield id="CQDP_TSKS" width="32" begin="31" end="0" resetval="0x0" description="Bit n of this register is set if and only if QUEUED_TASK_PARAMS (CMD44) and QUEUED_TASK_ADDRESS (CMD45) were sent for this specific task and if this task hasnt been executed yet. CQE shall set this bit after receiving a successful response for CMD45. CQE shall clear this bit after the task has completed execution. Software needs to read this register in the task-discard procedure, when the controller is halted, to determine if the task is queued in the device. If the task is queued, the driver sends a CMDQ_TASK_MGMT (CMD48) to the device ordering it to discard the task. Then software clears the task in the CQE. Only then the software orders CQE to resume its operation using" range="" rwaccess="R"/>
  </register>
  <register id="MMCSD0_CQ_TASK_CLEAR" acronym="MMCSD0_CQ_TASK_CLEAR" offset="0x238" width="32" description="This register is used for removing an outstanding task in the CQE 327. The register should be used only when CQE is in Halt state.">
    <bitfield id="CQTCLR" width="32" begin="31" end="0" resetval="0x0" description="Writing 1h to bit n of this register orders CQE to clear a task which software has previously issued. This bit can only be written when CQE is in Halt state as indicated in the When software writes 1h to a bit in this register, CQE updates the value to 1h, and starts clearing the data structures related to the task. CQE clears the bit fields (sets a value of 0h) in the Software should poll on the Writing to this register only clears the task in the CQE and does not have impact on the device. In order to discard the task in the device, host software shall send CMDQ_TASK _MGMT while CQE is still in Halt state. Host driver is not allowed to use this register to clear multiple tasks at the same time. Clearing multiple tasks can be done using Writing 0h to a register bit shall have no impact." range="" rwaccess="RW"/>
  </register>
  <register id="MMCSD0_CQ_SEND_STS_CONFIG1" acronym="MMCSD0_CQ_SEND_STS_CONFIG1" offset="0x240" width="32" description="The register controls when the SEND_QUEUE_STATUS commands are sent.">
    <bitfield id="RESERVED" width="12" begin="31" end="20" resetval="0x0" description="Reserved" range="" rwaccess="R"/>
    <bitfield id="CMD_BLK_CNTR" width="4" begin="19" end="16" resetval="0x1" description="This field indicates to CQE when to send SEND_QUEUE_STATUS (CMD13) command to inquire the status of the devices task queue. A value of n means CQE shall send status command on the CMD line, during the transfer of data block A value of 0h means that SEND_QUEUE_STATUS (CMD13) command shall not be sent during the transaction. Instead it will be sent only when the data lines are idle. A value of 1 means that STATUS command is to be sent during the last block of the transaction." range="" rwaccess="RW"/>
    <bitfield id="CMD_IDLE_TIMER" width="16" begin="15" end="0" resetval="0x3E8" description="This field indicates to CQE the polling period to use when using periodic SEND_QUEUE_STATUS (CMD13) polling. Periodic polling is used when tasks are pending in the device, but no data transfer is in progress. When a SEND_QUEUE_STATUS response indicating that no task is ready for execution, CQE counts the configured time until it issues the next SEND_QUEUE_STATUS. Timer units are clock periods of theclock whose frequency is specified in the Internal Timer Clock Frequency field in the The minimum value is 1h (1 clock period) and the maximum value is FFFFh (65535 clock periods). Default interval is: 4096 clock periods. For example, a" range="" rwaccess="RW"/>
  </register>
  <register id="MMCSD0_CQ_SEND_STS_CONFIG2" acronym="MMCSD0_CQ_SEND_STS_CONFIG2" offset="0x244" width="32" description="This register is used for 333 configuring RCA field in SEND_QUEUE_STATUS command argument.">
    <bitfield id="RESERVED" width="16" begin="31" end="16" resetval="0x0" description="Reserved" range="" rwaccess="R"/>
    <bitfield id="QUEUE_RCA" width="16" begin="15" end="0" resetval="0x0" description="This field provides CQE with the contents of the 16-bit RCA field in SEND_QUEUE_STATUS (CMD13) command argument. CQE shall copy this field to bits 31-16 of the argument when transmitting SEND_QUEUE_STATUS (CMD13) command." range="" rwaccess="RW"/>
  </register>
  <register id="MMCSD0_CQ_DCMD_RESPONSE" acronym="MMCSD0_CQ_DCMD_RESPONSE" offset="0x248" width="32" description="This register is used for passing the response of a DCMD task to software.">
    <bitfield id="LAST_RESP" width="32" begin="31" end="0" resetval="0x0" description="This register contains the response of the command generated by the last direct command (DCMD) task which was sent. CQE shall update this register when it receives the response for a DCMD task. This register is considered valid only after bit 31 of the" range="" rwaccess="R"/>
  </register>
  <register id="MMCSD0_CQ_RESP_ERR_MASK" acronym="MMCSD0_CQ_RESP_ERR_MASK" offset="0x250" width="32" description="This register controls the generation of Response Error Detection (RED) interrupt.">
    <bitfield id="CQRMEM" width="32" begin="31" end="0" resetval="0x0" description="This bit is used as in interrupt mask on the device status field which is received in R1/R1b responses. Bit Value Description (for any bit i): 1h: When a R1/R1b response is received, with bit i in the device status set, a RED interrupt is generated 0h: When a R1/R1b response is received, bit i in the device status is ignored The reset value of this register is set to trigger an interrupt on all 'Error' type bits in the device status." range="" rwaccess="R"/>
  </register>
  <register id="MMCSD0_CQ_TASK_ERR_INFO" acronym="MMCSD0_CQ_TASK_ERR_INFO" offset="0x254" width="32" description="This register is updated by CQE when an error occurs on data or command related to a task activity. When such error is detected by CQE or indicated by the eMMC controller CQE stores in the register the task IDs and the command indices of the commands which were executed on the 343 command line and data lines when the error occurred. Software is expected to use this information in the error recovery procedure.">
    <bitfield id="DATERR_VALID" width="1" begin="31" end="31" resetval="0x0" description="This bit is updated when an error is detected by CQE, or indicated by eMMC controller. If a data transfer is in progress when the error is detected/indicated, the bit is set to 1h. If a no data transfer is in progress when the error is detected/indicated, the bit is cleared to 0h." range="" rwaccess="R"/>
    <bitfield id="RESERVED" width="2" begin="30" end="29" resetval="0x0" description="Reserved" range="" rwaccess="R"/>
    <bitfield id="DATERR_TASK_ID" width="5" begin="28" end="24" resetval="0x0" description="This field indicates the ID of the task which was executed on the data lines when an error occurred. The field is updated if a data transfer is in progress when an error is detected by CQE, or indicated by eMMC controller." range="" rwaccess="R"/>
    <bitfield id="RESERVED" width="2" begin="23" end="22" resetval="0x0" description="Reserved" range="" rwaccess="R"/>
    <bitfield id="DATERR_CMD_INDEX" width="6" begin="21" end="16" resetval="0x0" description="This field indicates the index of the command which was executed on the data lines when an error occurred. The index shall be set to EXECUTE_READ_TASK (CMD46) or EXECUTE_WRITE_TASK (CMD47) according to the data direction. The field is updated if a data transfer is in progress when an error is detected by CQE, or indicated by eMMC controller." range="" rwaccess="R"/>
    <bitfield id="RESP_MODE_VALID" width="1" begin="15" end="15" resetval="0x0" description="This bit is updated when an error is detected by CQE, or indicated by eMMC controller. If a command transaction is in progress when the error is detected/indicated, the bit is set to 1h. If a no command transaction is in progress when the error is detected/indicated, the bit is cleared to 0h." range="" rwaccess="R"/>
    <bitfield id="RESERVED" width="2" begin="14" end="13" resetval="0x0" description="Reserved" range="" rwaccess="R"/>
    <bitfield id="RESP_MODE_TASK_ID" width="5" begin="12" end="8" resetval="0x0" description="This field indicates the ID of the task which was executed on the command line when an error occurred. The field is updated if a command transaction is in progress when an error is detected by CQE, or indicated by eMMC controller." range="" rwaccess="R"/>
    <bitfield id="RESERVED" width="2" begin="7" end="6" resetval="0x0" description="Reserved" range="" rwaccess="R"/>
    <bitfield id="RESP_MODE_CMD_INDEX" width="6" begin="5" end="0" resetval="0x0" description="This field indicates the index of the command which was executed on the command line when an error occurred. The field is updated if a command transaction is in progress when an error is detected by CQE, or indicated by eMMC controller." range="" rwaccess="R"/>
  </register>
  <register id="MMCSD0_CQ_CMD_RESP_INDEX" acronym="MMCSD0_CQ_CMD_RESP_INDEX" offset="0x258" width="32" description="This register stores the index of the last received command response.">
    <bitfield id="RESERVED" width="26" begin="31" end="6" resetval="0x0" description="Reserved" range="" rwaccess="R"/>
    <bitfield id="LAST_CRI" width="6" begin="5" end="0" resetval="0x0" description="This field stores the index of the last received command response. CQE shall update the value every time a command response is received." range="" rwaccess="R"/>
  </register>
  <register id="MMCSD0_CQ_CMD_RESP_ARG" acronym="MMCSD0_CQ_CMD_RESP_ARG" offset="0x25C" width="32" description="This register stores the index of the last received command response.">
    <bitfield id="LAST_CRA" width="32" begin="31" end="0" resetval="0x0" description="This field stores the argument of the last received command. CQE shall update the value every time a command response is received." range="" rwaccess="R"/>
  </register>
  <register id="MMCSD0_CQ_ERROR_TASK_ID" acronym="MMCSD0_CQ_ERROR_TASK_ID" offset="0x260" width="32" description="CQ Error Task ID Register">
    <bitfield id="RESERVED" width="27" begin="31" end="5" resetval="0x0" description="Reserved" range="" rwaccess="R"/>
    <bitfield id="TERR_ID" width="5" begin="4" end="0" resetval="0x0" description="Task Error ID" range="" rwaccess="R"/>
  </register>
</module>
