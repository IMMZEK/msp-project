/******************************************************************************
 * Copyright (c) 2012-2016 Texas Instruments Incorporated - http://www.ti.com
 * 
 *  Redistribution and use in source and binary forms, with or without 
 *  modification, are permitted provided that the following conditions 
 *
 *  are met:
 *
 *    Redistributions of source code must retain the above copyright 
 *    notice, this list of conditions and the following disclaimer.
 *
 *
 *    Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the     
 *    documentation and/or other materials provided with the   
 *
 *    distribution.
 *
 *
 *    Neither the name of Texas Instruments Incorporated nor the names of
 *    its contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
 *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
 *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
 *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
 *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
 *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
 *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 * 
 *****************************************************************************
 *
 *  Filename: 		evmk2e.gel
 *  Description:	Utility GEL for use with the K2E EVM. This GEL has 
 *			functions that initialize the chip PLL's and the DDR3A  interfaces. 
 *					
 *			It also includes general utilities that are useful for EVM development
 *	                  
 *	            	More functions will be added as needed. 
 *	  
 *	Author: Randy Rosales                 
 *	Revision History: 
 *
 *	Rev 1.0
 * 		- Initial revision.
 *	Rev 1.1
 *		- Addition of Ethernet 1GB mode.
 *	Rev 1.2
 *		- Addition of 1GB PHY init routine -  Tinku Mannan 
 *	Rev 1.3 
 *		- Addition of DSP out-of-reset routine - Lalindra Jayatilleke
 *
 ---------------------------------------------------------------------------*/

#define GEL_VERSION         1.3

// Timeout definitions
int _GEL_Global_Timeout1 = 0;

#define TIMEOUT_ID 10
// Global timeout value
#define GTIMEOUT 2000
//*****************************************************
// Power definitions
#define PSC_BASE            0x02350000
#define PSC_PTCMD           *( unsigned int* )( PSC_BASE+0x120 )
#define PSC_PTSTAT          *( unsigned int* )( PSC_BASE+0x128 )
#define PSC_PDCTL_BASE      ( PSC_BASE+0x300 )
#define PSC_MDSTAT_BASE     ( PSC_BASE+0x800 )
#define PSC_MDCTL_BASE      ( PSC_BASE+0xA00 )

// Modules on power domain 0
// Always on
// Modules on power domain 0
#define LPSC_TSIP      (4)	
// Modules on power domain 1
#define LPSC_DEBUG     (5)
#define LPSC_TETB      (6)	

// Modules on power domain 2
#define LPSC_PA        (7)
#define LPSC_SGMII     (8)
#define LPSC_SA        (9)

// Modules on power domain 3
#define LPSC_PCIE      (10)


// Modules on power domain 5
#define LPSC_HYPERLINK     (12)

// Modules on power domain 6
#define LPSC_SR     (13)

// Modules on power domain 7
#define LPSC_MSMCRAM   (14)

// Modules on power domain 8
#define LPSC_C66X_COREPAC_0   (15)

// Modules on power domain 16
#define LPSC_DDR3_0      (23)

// Modules on power domain 18
#define LPSC_PCIE_1	  (27)

// Modules on power domain 29
#define LPSC_XGE     (50)		

// Modules on power domain 31
#define LPSC_ARM    (52)


// Power domains definitions
#define PD0         (0)     // Power Domain-0
#define PD1         (1)     // Power Domain-1
#define PD2         (2)     // Power Domain-2
#define PD3         (3)     // Power Domain-3
#define PD5         (5)     // Power Domain-5
#define PD6         (6)     // Power Domain-6
#define PD7         (7)     // Power Domain-7
#define PD8         (8)     // Power Domain-8
#define PD16        (16)    // Power Domain-16
#define PD18        (18)    // Power Domain-18
#define PD29        (29)    // Power Domain-29
#define PD31        (31)    // Power Domain-31

#define PSC_SYNCRESET (0x1)
#define PSC_DISABLE   (0x2)
#define PSC_ENABLE    (0x3)

#define CHIP_LEVEL_REG              0x02620000

/******************* PLL registers **********************************/
/*Boot cfg registers*/
#define KICK0                       *(unsigned int*)(CHIP_LEVEL_REG + 0x0038)
#define KICK1                       *(unsigned int*)(CHIP_LEVEL_REG + 0x003C)
#define KICK0_UNLOCK                (0x83E70B13)
#define KICK1_UNLOCK                (0x95A4F1E0)
#define KICK_LOCK                   0
#define TINPSEL                     *(unsigned int*)(CHIP_LEVEL_REG + 0x0300)
#define TOUTPSEL                    *(unsigned int*)(CHIP_LEVEL_REG + 0x0304)
#define MAINPLLCTL0                 *(unsigned int*)(CHIP_LEVEL_REG + 0x0350) 
#define MAINPLLCTL1                 *(unsigned int*)(CHIP_LEVEL_REG + 0x0354) 
#define MAIN_PLLD_OFFSET            0
#define MAIN_PLLD_MASK              0xFFFFFFC0
#define MAIN_PLLM_OFFSET            12
#define MAIN_PLLM_MASK              0xFFF80FFF
#define MAIN_BWADJ0_OFFSET          24
#define MAIN_BWADJ0_MASK            0x00FFFFFF
#define MAIN_ENSAT_OFFSET           6
#define MAIN_ENSAT_MASK             0xFFFFFFBF
#define MAIN_BWADJ1_OFFSET          0
#define MAIN_BWADJ1_MASK            0xFFFFFFF0

#define OBSCLKCTL                   *(unsigned int*)(CHIP_LEVEL_REG + 0x0C80)	//TODO: Reserved in K2H datashet

/* PA PLL Registers */
#define BYPASS_BIT_SHIFT 23
#define CLKF_BIT_SHIFT   6
#define CLKD_BIT_SHIFT   0
#define DEVSTAT    (*((unsigned int *) 0x02620020))
#define PAPLLCTL0                 *(unsigned int*)(CHIP_LEVEL_REG + 0x0358) 
#define PAPLLCTL1                 *(unsigned int*)(CHIP_LEVEL_REG + 0x035C) 
#define PASSCLKSEL_MASK    (1 << 17)    /* Tells the configuration of the PASSCLKSEL pin */
#define PA_PLL_BYPASS_MASK (1 << BYPASS_BIT_SHIFT)    /* Tells whether the PA PLL is in BYPASS mode or not */
#define PA_PLL_CLKOD_MASK  (0x00780000) /* Tells the output divider value for the PA PLL */
#define PA_PLL_CLKF_MASK   (0x0007FFC0) /* Tells the multiplier value for the PA PLL */
#define PA_PLL_CLKR_MASK   (0x0000003F) /* Tells the divider value for the PA PLL */
#define PA_PLL_RESET_MASK  (0x00004000)


#define CHIP_MISC1                  *(unsigned int*)(CHIP_LEVEL_REG + 0x0C7C)
#define ARMPLL_ENABLE_OFFSET        13


#define DDR3APLLCTL0  			*(unsigned int*)(CHIP_LEVEL_REG + 0x0360)
#define DDR3APLLCTL1  			*(unsigned int*)(CHIP_LEVEL_REG + 0x0364)

//******************************************************
// PLL 1 definitions (DSP and ARM clock and subsystems)
#define PLL1_BASE                   0x02310000
#define PLL1_PLLCTL                 (*(unsigned int*)(PLL1_BASE + 0x100))   // PLL1 Control
#define PLL1_SECCTL                 (*(unsigned int*)(PLL1_BASE + 0x108))   // PLL1 Secondary Control
#define PLL1_PLLM                   (*(unsigned int*)(PLL1_BASE + 0x110))   // PLL1 Multiplier
#define PLL1_DIV1                   (*(unsigned int*)(PLL1_BASE + 0x118))   // DIV1 divider
#define PLL1_DIV2                   (*(unsigned int*)(PLL1_BASE + 0x11C))   // DIV2 divider
#define PLL1_DIV3                   (*(unsigned int*)(PLL1_BASE + 0x120))   // DIV3 divider
#define PLL1_CMD                    (*(unsigned int*)(PLL1_BASE + 0x138))   // CMD control
#define PLL1_STAT                   (*(unsigned int*)(PLL1_BASE + 0x13C))   // STAT control
#define PLL1_ALNCTL                 (*(unsigned int*)(PLL1_BASE + 0x140))   // ALNCTL control
#define PLL1_DCHANGE                (*(unsigned int*)(PLL1_BASE + 0x144))   // DCHANGE status
#define PLL1_CKEN                   (*(unsigned int*)(PLL1_BASE + 0x148))   // CKEN control
#define PLL1_CKSTAT                 (*(unsigned int*)(PLL1_BASE + 0x14C))   // CKSTAT status
#define PLL1_SYSTAT                 (*(unsigned int*)(PLL1_BASE + 0x150))   // SYSTAT status
#define PLL1_DIV4                   (*(unsigned int*)(PLL1_BASE + 0x160))   // DIV4 divider
#define PLL1_DIV5                   (*(unsigned int*)(PLL1_BASE + 0x164))   // DIV5 divider
#define PLL1_DIV6                   (*(unsigned int*)(PLL1_BASE + 0x168))   // DIV6 divider
#define PLL1_DIV7                   (*(unsigned int*)(PLL1_BASE + 0x16C))   // DIV7 divider
#define PLL1_DIV8                   (*(unsigned int*)(PLL1_BASE + 0x170))   // DIV8 divider
#define PLL1_DIV9                   (*(unsigned int*)(PLL1_BASE + 0x174))   // DIV9 divider
#define PLL1_DIV10                  (*(unsigned int*)(PLL1_BASE + 0x178))   // DIV10 divider
#define PLL1_DIV11                  (*(unsigned int*)(PLL1_BASE + 0x17C))   // DIV11 divider
#define PLL1_DIV12                  (*(unsigned int*)(PLL1_BASE + 0x180))   // DIV12 divider
#define PLL1_DIV13                  (*(unsigned int*)(PLL1_BASE + 0x184))   // DIV13 divider
#define PLL1_DIV14                  (*(unsigned int*)(PLL1_BASE + 0x188))   // DIV14 divider
#define PLL1_DIV15                  (*(unsigned int*)(PLL1_BASE + 0x18C))   // DIV15 divider
#define PLL1_DIV16                  (*(unsigned int*)(PLL1_BASE + 0x190))   // DIV16 divider
#define PLLPWRDN_OFFSET             1
#define PLLPWRDN_MASK               0xFFFFFFFD
#define PLLRST_OFFSET               3
#define PLLRST_MASK                 0xFFFFFFF7
#define PLLENSRC_OFFSET             5
#define PLLENSRC_MASK               0xFFFFFFDF
#define PLLEN_OFFSET                0
#define PLLEN_MASK                  0xFFFFFFFE
#define OUTPUT_DIVIDE_OFFSET        19
#define OUTPUT_DIVIDE_MASK          0xFF87FFFF    
#define BYPASS_OFFSET               23
#define BYPASS_MASK                 0xFF7FFFFF
#define PLLM_OFFSET                 0
#define PLLM_MASK                   0xFFFFFFC0
#define GOSET_OFFSET                0
#define GOSET_MASK                  0xFFFFFFFE
#define GOSTAT_OFFSET               0
#define GOSTAT_MASK                 0xFFFFFFFE

#define OUTPUT_DIVIDE_OFFSET        19
#define OUTPUT_DIVIDE_MASK          0xFF87FFFF   

// ARMPLL definitions
#define SEC_PLLCTL0_PLLM_OFFSET     6
#define SEC_PLLCTL0_PLLM_MASK       0xFFFF003F
#define SEC_PLLCTL0_BWADJ_OFFSET    24
#define SEC_PLLCTL0_BWADJ_MASK      0x00FFFFFF
#define SEC_PLLCTL0_OD_OFFSET       19
#define SEC_PLLCTL0_OD_MASK         0xFF87FFFF
#define SEC_PLLCTL0_BYPASS_OFFSET   23
#define SEC_PLLCTL0_BYPASS_MASK     0xFF7FFFFF
#define SEC_PLLCTL1_RESET_OFFSET    14
#define SEC_PLLCTL1_RESET_MASK      0xFFFFBFFF
#define SEC_PLLCTL1_PWRDWN_OFFSET   15
#define SEC_PLLCTL1_PWRDWN_MASK     0xFFFF7FFF
#define SEC_PLLCTL1_ENSTAT_OFFSET   6
#define SEC_PLLCTL1_ENSTAT_MASK     0xFFFFFFBF

/*----------------DDR3A Register definition---------------------*/

#define DDR3A_BASE_ADDR (0x21010000)
#define DDR3A_STATUS   (*(int*)(DDR3A_BASE_ADDR + 0x00000004))
#define DDR3A_SDCFG    (*(int*)(DDR3A_BASE_ADDR + 0x00000008))
#define DDR3A_SDRFC    (*(int*)(DDR3A_BASE_ADDR + 0x00000010))
#define DDR3A_SDTIM1   (*(int*)(DDR3A_BASE_ADDR + 0x00000018))
#define DDR3A_SDTIM2   (*(int*)(DDR3A_BASE_ADDR + 0x0000001C))
#define DDR3A_SDTIM3   (*(int*)(DDR3A_BASE_ADDR + 0x00000020))
#define DDR3A_SDTIM4   (*(int*)(DDR3A_BASE_ADDR + 0x00000028))
#define DDR3A_ZQCFG    (*(int*)(DDR3A_BASE_ADDR + 0x000000C8))
#define DDR3A_TMPALRT  (*(int*)(DDR3A_BASE_ADDR + 0x000000CC))
#define DDR3A_DDRPHYC  (*(int*)(DDR3A_BASE_ADDR + 0x000000E4))

#define DDR3A_PHY_CFG_BASE (0x02329000)
#define DDR3A_PIR    (*(int*)(DDR3A_PHY_CFG_BASE + 0x00000004))
#define DDR3A_PGCR0  (*(int*)(DDR3A_PHY_CFG_BASE + 0x00000008))
#define DDR3A_PGCR1  (*(int*)(DDR3A_PHY_CFG_BASE + 0x0000000C))
#define DDR3A_PGCR2  (*(int*)(DDR3A_PHY_CFG_BASE + 0x0000008C))
#define DDR3A_PGSR0  (*(int*)(DDR3A_PHY_CFG_BASE + 0x00000010))
#define DDR3A_PGSR1  (*(int*)(DDR3A_PHY_CFG_BASE + 0x00000014))
#define DDR3A_PLLCR  (*(int*)(DDR3A_PHY_CFG_BASE + 0x00000018))
#define DDR3A_PTR0   (*(int*)(DDR3A_PHY_CFG_BASE + 0x0000001C))
#define DDR3A_PTR1   (*(int*)(DDR3A_PHY_CFG_BASE + 0x00000020))
#define DDR3A_PTR2   (*(int*)(DDR3A_PHY_CFG_BASE + 0x00000024))
#define DDR3A_PTR3   (*(int*)(DDR3A_PHY_CFG_BASE + 0x00000028))
#define DDR3A_PTR4   (*(int*)(DDR3A_PHY_CFG_BASE + 0x0000002C))
#define DDR3A_DSGCR  (*(int*)(DDR3A_PHY_CFG_BASE + 0x00000040))
#define DDR3A_DCR    (*(int*)(DDR3A_PHY_CFG_BASE + 0x00000044))
#define DDR3A_MR0    (*(int*)(DDR3A_PHY_CFG_BASE + 0x00000054))
#define DDR3A_MR1    (*(int*)(DDR3A_PHY_CFG_BASE + 0x00000058))
#define DDR3A_MR2    (*(int*)(DDR3A_PHY_CFG_BASE + 0x0000005C))
#define DDR3A_DTCR   (*(int*)(DDR3A_PHY_CFG_BASE + 0x00000068))
#define DDR3A_DTPR0  (*(int*)(DDR3A_PHY_CFG_BASE + 0x00000048))
#define DDR3A_DTPR1  (*(int*)(DDR3A_PHY_CFG_BASE + 0x0000004C))
#define DDR3A_DTPR2  (*(int*)(DDR3A_PHY_CFG_BASE + 0x00000050))

#define DDR3A_ZQ0CR1  (*(int*)(DDR3A_PHY_CFG_BASE + 0x00000184))
#define DDR3A_ZQ1CR1  (*(int*)(DDR3A_PHY_CFG_BASE + 0x00000194))
#define DDR3A_ZQ2CR1  (*(int*)(DDR3A_PHY_CFG_BASE + 0x000001A4))
#define DDR3A_ZQ3CR1  (*(int*)(DDR3A_PHY_CFG_BASE + 0x000001B4))

#define DDR3A_DATX8_8 (*(int*)(DDR3A_PHY_CFG_BASE + 0x000003C0))


#define DDR3_TEST_START_ADDRESS (*(int*)(0x80000000))

#define IODDRM_MASK            0x00000180  
#define ZCKSEL_MASK            0x01800000
#define CL_MASK				   0x00000072
#define WR_MASK				   0x00000E00
#define BL_MASK				   0x00000003
#define RRMODE_MASK            0x00040000
#define UDIMM_MASK             0x20000000
#define BYTEMASK_MASK          0x0000FC00
#define MPRDQ_MASK             0x00000080
#define PDQ_MASK               0x00000070
#define NOSRA_MASK             0x08000000
#define ECC_MASK               0x00000001
#define RRMODE_MASK            0x00040000

#define DDR3A_DX0GSR0 (*(int*)(DDR3A_PHY_CFG_BASE + 0x000001C4)) //0x71
#define DDR3A_DX1GSR0 (*(int*)(DDR3A_PHY_CFG_BASE + 0x00000204)) //0x81
#define DDR3A_DX2GSR0 (*(int*)(DDR3A_PHY_CFG_BASE + 0x00000244)) //0x91
#define DDR3A_DX3GSR0 (*(int*)(DDR3A_PHY_CFG_BASE + 0x00000284)) //0xA1
#define DDR3A_DX4GSR0 (*(int*)(DDR3A_PHY_CFG_BASE + 0x000002C4)) //0xB1
#define DDR3A_DX5GSR0 (*(int*)(DDR3A_PHY_CFG_BASE + 0x00000304)) //0xC1
#define DDR3A_DX6GSR0 (*(int*)(DDR3A_PHY_CFG_BASE + 0x00000344)) //0xD1
#define DDR3A_DX7GSR0 (*(int*)(DDR3A_PHY_CFG_BASE + 0x00000384)) //0xE1
#define DDR3A_DX8GSR0 (*(int*)(DDR3A_PHY_CFG_BASE + 0x000003C4)) //0xF1

#define DDR3A_TEST_START_ADDRESS (0x80000000)

#define DDR3A_TEST_END_ADDRESS   (DDR3A_TEST_START_ADDRESS + (4 * 100))
#define DDR3A_BASE_ADDRESS        0x80000000



#define TETRIS_BASE                 0x01E80000

#define TETRIS_CPU0_PTCMD           *(unsigned int*)(TETRIS_BASE + 0x0400)
#define TETRIS_CPU0_PDSTAT          *(unsigned int*)(TETRIS_BASE + 0x0404)
#define TETRIS_CPU0_PDCTL           *(unsigned int*)(TETRIS_BASE + 0x0408)

#define TETRIS_CPU1_PTCMD           *(unsigned int*)(TETRIS_BASE + 0x040C)
#define TETRIS_CPU1_PDSTAT          *(unsigned int*)(TETRIS_BASE + 0x0410)
#define TETRIS_CPU1_PDCTL           *(unsigned int*)(TETRIS_BASE + 0x0414)

#define TETRIS_CPU2_PTCMD           *(unsigned int*)(TETRIS_BASE + 0x0418)
#define TETRIS_CPU2_PDSTAT          *(unsigned int*)(TETRIS_BASE + 0x041C)
#define TETRIS_CPU2_PDCTL           *(unsigned int*)(TETRIS_BASE + 0x0420)

#define TETRIS_CPU3_PTCMD           *(unsigned int*)(TETRIS_BASE + 0x0424)
#define TETRIS_CPU3_PDSTAT          *(unsigned int*)(TETRIS_BASE + 0x0428)
#define TETRIS_CPU3_PDCTL           *(unsigned int*)(TETRIS_BASE + 0x042C)

#define SECPLLCTL0                  *(unsigned int*)(CHIP_LEVEL_REG + 0x0370)
#define SECPLLCTL1                  *(unsigned int*)(CHIP_LEVEL_REG + 0x0374)
unsigned int read_val;

/*----------Out-of-reset definitions-----------*/

#define WR_MEM_32(addr, data)   *(unsigned int*)(addr) =(unsigned int)(data)
#define RD_MEM_32(addr)         *(unsigned int*)(addr)
#define uint32_t                unsigned int

/*******************************************************************************
        KS2 Registers Map Defines
*******************************************************************************/
/***** Power Domain Definitions *****/
#define KS2_PDCTL5  0x02350314
#define KS2_PDCTL8  0x02350320
#define KS2_PDCTL9  0x02350324
#define KS2_PDCTL10 0x02350328
#define KS2_PDCTL11 0x0235032C
#define KS2_PDCTL12 0x02350330
#define KS2_PDCTL13 0x02350334
#define KS2_PDCTL14 0x02350338
#define KS2_PDCTL15 0x0235033C

/***** Module Control Register Definitions *****/
#define KS2_MDCTL5  0x02350A14
#define KS2_MDCTL15 0x02350A3C
#define KS2_MDCTL16 0x02350A40
#define KS2_MDCTL17 0x02350A44
#define KS2_MDCTL18 0x02350A48
#define KS2_MDCTL19 0x02350A4C
#define KS2_MDCTL20 0x02350A50
#define KS2_MDCTL21 0x02350A54
#define KS2_MDCTL22 0x02350A58

/****************************************************************************
 *
 * NAME
 *      OnTargetConnect
 *
 * PURPOSE:
 *      Setup almost everything ready for a new debug session:
 *      DSP modules and EVM board modules, at target connection.
 *      Do nothing if target is in realtime mode.
 *      This routine is called when you connect to the target board.
 *
 *      IMPORTANT: this routine won't attempt to connect to the target
 *      if the target is not in real-time mode and that the dsp boot
 *      mode switches are not set in emulation boot mode.
 *
 * USAGE
 *      This routine is a callback routine and called by CCS only.
 *
 * RETURN VALUE
 *      NONE
 *
 * REFERENCE
 *
 ****************************************************************************/
OnTargetConnect()
{
	/*------------------------------------------------------*/
	/* GEL_Reset() is used to deal with the worst case      */
	/* senario of unknown target state.  If for some reason */
	/* a reset is not desired upon target connection,       */
	/* GEL_Reset() may be removed and replaced with         */
	/* something "less brutal" like a cache initialization  */
	/* function.                                            */
	/*------------------------------------------------------*/
	//GEL_Reset();
	//xmc_setup();
	//ddr3_setup();

	GEL_TextOut("\nConnecting Target...\n");

	// Check if target is not in real-time mode. If it is in stop mode,
	// initialize everything. In real-time mode, do nothing to connect
	// unobtrusively...
	if (!GEL_IsInRealtimeMode())
	{
		// Validates if emulation boot mode
		if (DEVSTAT & 0x0000000E)
		{
			GEL_TextOut("No initialization performed since bootmode = %x \n",,,,,(DEVSTAT >> 1 ) & 0xF);
			GEL_TextOut("You can manually initialize with GlobalDefaultSetup\n");
		}
		else
		{
			// Comment the following line at production application test
			// when the application need to initialize everything, but not the
			// GEL file.
			Global_Default_Setup_Silent();
		}
	} else {
		GEL_TextOut("No initialization performed in real time mode\n");
	}
}

/*--------------------------------------------------------------*/
/* OnReset()                                                    */
/* This function is called by CCS when you do Debug->Resest.    */
/* The goal is to put the C6x into a known good state with      */
/* respect to cache, edma and interrupts.                       */
/*--------------------------------------------------------------*/
OnReset( int nErrorCode )
{
}

/*--------------------------------------------------------------*/
/* xmc_setup()                                                  */
/* XMC MPAX register setting to access DDR3 config space        */
/*--------------------------------------------------------------*/

#define XMC_BASE_ADDR (0x08000000)
#define XMPAX2_L     (*(int*)(XMC_BASE_ADDR + 0x00000010))
#define XMPAX2_H     (*(int*)(XMC_BASE_ADDR + 0x00000014))

xmc_setup()
{
	/* mapping for ddr emif registers XMPAX*2 */

	XMPAX2_L =  0x121010FF;  /* replacement addr + perm */
	XMPAX2_H =  0x2101000B;    /* base addr + seg size (64KB)*/	//"1B"-->"B" by xj
	GEL_TextOut("XMC setup complete.\n");
}

/****************************************************************************
 *
 * NAME
 *      Global_Default_Setup_Silent
 *
 * PURPOSE:
 *      Setup almost everything ready for a new debug session:
 *      DSP modules and EVM board modules.
 *
 * USAGE
 *      This routine can be called as:
 *
 *      Global_Default_Setup_Silent()
 *
 * RETURN VALUE
 *      NONE
 *
 * REFERENCE
 *
 ****************************************************************************/
Global_Default_Setup_Silent()
{
	float gel_ver = GEL_VERSION;

	// Set DSP cache to pre defined values...
	GEL_TextOut( "TCI6636K2E GEL file Ver is %f \n",,,,, (float) (gel_ver/1.0));

	//Set_DSP_Cache();

	// Only core 0 can set these
	if (DNUM == 0)
	{
		// Setup main PLL DSP @ 1 GHz
		Set_Pll1(3); // call Set_Pll1 with index = 3 -> 100 MHz to 1 GHz operation

		// Setup all Power Domains on
		Set_Psc_All_On();

		// Setup PA PLL
		PaPllConfig();

		GEL_TextOut("DDR begin\n");
		xmc_setup();
		ddr3A_64bit_DDR1600_setup();
		GEL_TextOut("DDR done\n");

		GEL_TextOut("Setup PHY begin 1GB\n");
		setupPhy1GbSlave();
		GEL_TextOut("Setup PHY done 1GB\n");
	}
}

/****************************************************************************
 *
 * NAME
 *      Set_PSC_State
 *
 * PURPOSE:
 *      Set a new power state for the specified domain id in a power controler
 *      domain. Wait for the power transition to complete.
 *
 * USAGE
 *      This routine can be called as:
 *
 *      Set_PSC_State(unsigned int pd,unsigned int id,unsigned int state)
 *
 *      pd    - (i) power domain.
 *
 *      id    - (i) module id to use for module in the specified power domain
 *
 *      state - (i) new state value to set
 *                  0 = RESET
 *                  1 = SYNC RESET
 *                  2 = DISABLE
 *                  3 = ENABLE
 *
 * RETURN VALUE
 *      0 if ok, !=0 for error
 *
 * REFERENCE
 *
 ****************************************************************************/
Set_PSC_State(unsigned int pd,unsigned int id,unsigned int state)
{
	unsigned int* mdctl;
	unsigned int* mdstat;
	unsigned int* pdctl;
	int ret=0;

	// Only core0 can set PSC
	if (DNUM == 0)
	{
		mdctl = ( unsigned int* )(PSC_MDCTL_BASE + ( 4 * id ));
		mdstat = ( unsigned int* )( PSC_MDSTAT_BASE + ( 4 * id ));
		pdctl = ( unsigned int* )(PSC_PDCTL_BASE + ( 4 * pd ));

		// If state is already set, do nothing
		if ( ( *mdstat & 0x1f ) == state )
		{
			return(0);
		}

		// Wait for GOSTAT to clear
		Set_Timeout(GTIMEOUT);
		while( Get_Timeout() && (PSC_PTSTAT & (0x1 << pd)) != 0 );

		// Check if we got timeout error while waiting
		if (!Get_Timeout())
		{
			GEL_TextOut( "Set_PSC_State... Timeout Error #01 pd=%d, md=%d!\n",,2,,,pd,id);
			ret=1;
		}
		else
		{
			// Set power domain control
			*pdctl = (*pdctl) | 0x00000001;

			// Set MDCTL NEXT to new state
			*mdctl = ((*mdctl) & ~(0x1f)) | state;

			// Start power transition by setting PTCMD GO to 1
			PSC_PTCMD = (PSC_PTCMD) | (0x1<<pd);

			// Wait for PTSTAT GOSTAT to clear
			Set_Timeout(GTIMEOUT);
			while( Get_Timeout() && (PSC_PTSTAT & (0x1 << pd)) != 0 );

			// Check if we got timeout error while waiting
			if (!Get_Timeout())
			{
				GEL_TextOut( "Set_PSC_State... Timeout Error #02 pd=%d, md=%d!\n",,2,,,pd,id);
				ret=2;
			}
			else
			{
				// Verify state changed
				Set_Timeout(GTIMEOUT);
				while(Get_Timeout() && ( *mdstat & 0x1f ) != state );

				// Check if we got timeout error while waiting
				if (!Get_Timeout())
				{
					GEL_TextOut( "Set_PSC_State... Timeout Error #03 pd=%d, md=%d!\n",,2,,,pd,id);
					ret=3;
				}
			}
		}

		// Kill the currently running timeout
		Kill_Timeout();
	}
	else
	{
		GEL_TextOut("DSP core #%d cannot set PSC.\n",,2,,,DNUM);
	}

	return(ret);
}

/****************************************************************************

 *
 * NAME
 *      K2E_out_of_reset
 *
 * PURPOSE:
 *	This routine brings the C66x core out of reset after booting Linux, or at the u-boot prompt. 
 *	These steps are necessary in to order to load an application on the C66x core, 
 *	without interfering with the operation of Linux running on the A15.
 *
 * USAGE
 *      This routine can be called as:
 *
 *      K2E_out_of_reset();
 *
 *
 * RETURN VALUE
 *      NONE
 *
 * REFERENCE
 *

 ****************************************************************************/
K2E_out_of_reset()
{
	GEL_TextOut("\nTaking K2E DSP 0 out of reset\n");
	WR_MEM_32(KS2_PDCTL8, 0x1);
   	WR_MEM_32(KS2_MDCTL15, 0x103);
	GEL_TextOut("\nDone taking K2E DSP 0 out of reset!\n");
}

/****************************************************************************
 *
 * NAME
 *      Set_Timeout
 *
 * PURPOSE:
 *      Starts a timeout period of msec. The running timeout period can be
 *      query with Get_Timeout. To kill a running timeout before the end,
 *      call Kill_Timeout. Only one timeout period can be used at any time.
 *      A timeout period can be used to measure a period of time while doing
 *      anything else. Not accurate, sets timer at least as big as desired.
 *
 * USAGE
 *      This routine can be called as:
 *
 *      Set_Timeout(msec)
 *
 *      msec - (i) timeout period in msec (not very precise < sec range)
 *
 * RETURN VALUE
 *      NONE
 *
 * REFERENCE
 *
 ****************************************************************************/
Set_Timeout(msec)
{
	// Cancel the current timer if not already expired
	GEL_CancelTimer(TIMEOUT_ID);

	// Starts the timeout period
	_GEL_Global_Timeout1=1;

	// Setup a callback routine with specified timeout
	GEL_SetTimer(msec, TIMEOUT_ID, "_Timeout_Callback()");
}

/****************************************************************************
 *
 * NAME
 *      Get_Timeout
 *
 * PURPOSE:
 *      Query the running state of a timeout period started by Set_Timeout.
 *      (see Set_Timeout for more info).
 *
 * USAGE
 *      This routine can be called as:
 *
 *      Get_Timeout()
 *
 * RETURN VALUE
 *      0:expired, 1:running
 *
 * REFERENCE
 *
 ****************************************************************************/
Get_Timeout()
{
	if (!_GEL_Global_Timeout1)
	{
		// Cancel the current timer
		GEL_CancelTimer(TIMEOUT_ID);
	}

	// Return the global timeout status 1=running, 0=expired
	return _GEL_Global_Timeout1;
}

/****************************************************************************
 *
 * NAME
 *      Kill_Timeout
 *
 * PURPOSE:
 *      Cancel a running timeout period before it expires
 *      (see Set_Timeout for more info).
 *
 * USAGE
 *      This routine can be called as:
 *
 *      Kill_Timeout()
 *
 * RETURN VALUE
 *      NONE
 *
 * REFERENCE
 *
 ****************************************************************************/
Kill_Timeout()
{
	// Cancel the current timer
	GEL_CancelTimer(TIMEOUT_ID);

	// The timeout period is expired
	_GEL_Global_Timeout1=0;
}

/****************************************************************************
 *
 * NAME
 *      _Timeout_Callback
 *
 * PURPOSE:
 *      Internal Callback function used by Set_timeout
 *      (see Set_Timeout for more info).
 *
 * USAGE
 *      This routine must not be called by itself.
 *
 * RETURN VALUE
 *      NONE
 *
 * REFERENCE
 *
 ****************************************************************************/
_Timeout_Callback()
{
	// The timeout period is expired
	_GEL_Global_Timeout1=0;
}


/****************************************************************************
 *
 * NAME
 *      Set_Psc_All_On
 *
 * PURPOSE:
 *      Enable all PSC modules and DSP power domains on ALWAYSON, and wait
 *      for these power transitions to complete.
 *
 * USAGE
 *      This routine can be called as:
 *
 *      Set_Psc_All_On()
 *
 * RETURN VALUE
 *      NONE
 *
 * REFERENCE
 *
 ****************************************************************************/
hotmenu Set_Psc_All_On( )
{
	unsigned int i=0;

	// Only core0 can set PSC
	if (DNUM == 0)
	{
		GEL_TextOut( "Power on all PSC modules and DSP domains... \n");

		Set_PSC_State(PD0, LPSC_TSIP, PSC_ENABLE);
		Set_PSC_State(PD1, LPSC_DEBUG, PSC_ENABLE);
		Set_PSC_State(PD1, LPSC_TETB, PSC_ENABLE);
		Set_PSC_State(PD2, LPSC_PA, PSC_ENABLE);
		Set_PSC_State(PD2, LPSC_SGMII, PSC_ENABLE);
		Set_PSC_State(PD2, LPSC_SA, PSC_ENABLE);
		Set_PSC_State(PD3, LPSC_PCIE, PSC_ENABLE);
		Set_PSC_State(PD5, LPSC_HYPERLINK, PSC_ENABLE);
		Set_PSC_State(PD6, LPSC_SR, PSC_ENABLE);
		Set_PSC_State(PD7, LPSC_MSMCRAM, PSC_ENABLE);
		Set_PSC_State(PD8, LPSC_C66X_COREPAC_0, PSC_ENABLE);
		Set_PSC_State(PD16, LPSC_DDR3_0, PSC_ENABLE);
		Set_PSC_State(PD18, LPSC_PCIE_1, PSC_ENABLE);
		Set_PSC_State(PD29, LPSC_XGE, PSC_ENABLE);
		Set_PSC_State(PD31, LPSC_ARM, PSC_ENABLE);

		GEL_TextOut( "Power on all PSC modules and DSP domains... Done.\n" );
	}
	else
	{
		GEL_TextOut("DSP core #%d cannot set PSC.\n",,2,,,DNUM);
	}
}


//********************************************************************************************************************************
//********************************************************************************************************************************
/*
   Set_Pll1() - This function executes the main PLL initialization 
   sequence needed to get the main PLL up after coming out of an initial power up 
   before it is locked or after it is already locked.

   Index value determines multiplier, divier used and clock reference assumed for 
   output display. 
 */
Set_Pll1(int index)
{
	int i, TEMP;
	unsigned int BYPASS_val;     
	unsigned int BWADJ_val;     
	unsigned int OD_val;            

	float CLKIN_val;
	unsigned int PLLM_val;
	unsigned int PLLD_val;
	unsigned int PLLDIV3_val; //example value for SYSCLK2 (from 6614 spec) Default /2 - Fast Peripherals, (L2, MSMC, DDR3 EMIF, EDMA0...)
	unsigned int PLLDIV4_val; //example value for SYSCLK3 (from 6614 spec) Default /3 - Switch Fabric
	unsigned int PLLDIV7_val; //example value for SYSCLK6 (from 6614 spec) Defualt /6 - Slow Peripherals (UART, SPI, I2C, GPIO...)

	unsigned int debug_info_on;
	unsigned int delay;

	if(index == 1){           	 // 100 MHz -> 614.28 MHz
		CLKIN_val   = 100;       // setup CLKIN to 614.28 MHz
		PLLM_val    = 43;        // setup PLLM (PLL multiplier) to x43
		PLLD_val    = 1;         // setup PLLD (reference divider) to /1
		OD_val      = 7;         // setup OD to /7
	}
	else if(index == 2){             // 100MHz -> 737.5 MHz
		CLKIN_val   = 100;       // setup CLKIN to 100 MHz
		PLLM_val    = 59;        // setup PLLM (PLL multiplier) to x59
		PLLD_val    = 1;         // setup PLLD (reference divider) to /1
		OD_val      = 8;         // setup OD to  /8
	}

	else if(index == 3){             // 100MHz -> 1 GHz
		CLKIN_val   = 100;       // setup CLKIN to 100 MHz
		PLLM_val    = 20;        // setup PLLM (PLL multiplier) to x20
		PLLD_val    = 1;         // setup PLLD (reference divider) to /1
		OD_val      = 2;         // setup OD to  /2
	}

	else if(index == 4){             // 100 MHz -> 1.2 GHz
		CLKIN_val   = 100;       // setup CLKIN to 100 MHz
		PLLM_val    = 24;        // setup PLLM (PLL multiplier) to x24
		PLLD_val    = 1;         // setup PLLD (reference divider) to /1
		OD_val      = 2;         // setup OD to  /2
	}
	else if(index == 5){             // 100 MHz -> 1.35 GHz
		CLKIN_val   = 100;       // setup CLKIN to 100 MHz
		PLLM_val    = 27;        // setup PLLM (PLL multiplier) to x27
		PLLD_val    = 1;         // setup PLLD (reference divider) to /1
		OD_val      = 2;            // setup OD to /2
	}




	PLLDIV3_val = 3;            // setup PLL output divider 3 to /3
	PLLDIV4_val = 5;            // setup PLL output divider 4 to /3
	PLLDIV7_val = 6;            // setup PLL output divider 7 to /6

	BYPASS_val      = PLL1_SECCTL & ~BYPASS_MASK;   // get value of the BYPASS field
	BWADJ_val       = (PLLM_val) >> 1;              // setup BWADJ to be 1/2 the value of PLLM
	//OD_val          = 2;                            // setup OD to a fixed /2

	debug_info_on   = 1;
	delay           = 1000; // fix this!

	/* Step 1: Unlock Boot Config Registers */
	KICK0 = KICK0_UNLOCK;
	KICK1 = KICK1_UNLOCK;

	/* Step 2: Check if SECCTL bypass is low or high indicating what state the Main PLL is currently in. if 
       the Main PLL is in bypass still (not yet setup) execute the following steps.  */

	if(BYPASS_val != 0x00000000){ // PLL bypass enabled - Execute PLL setup for PLL fresh out of power on reset
		if(debug_info_on){
			GEL_TextOut("Detected PLL bypass enabled: SECCTL[BYPASS] = %x\n",,,,, BYPASS_val);
		}
		/* Step 2a: Set MAINPLLCTL1[ENSAT] = 1 - This enables proper biasing of PLL analog circuitry */            
		MAINPLLCTL1 |= (1 << MAIN_ENSAT_OFFSET); 
		if(debug_info_on){
			GEL_TextOut("(2a) MAINPLLCTL1 = %x\n",,,,, MAINPLLCTL1);
		}        

		/* Step 2b: Set PLLCTL[PLLEN] = 0 This enables bypass in PLL controller MUX */        
		PLL1_PLLCTL &= ~(1 << PLLEN_OFFSET);        
		if(debug_info_on){    
			GEL_TextOut("(2b) PLLCTL = %x\n",,,,, PLL1_PLLCTL);
		}    

		/* Step 2c: Set PLLCTL[PLLENSRC] = 0 - This enables PLLEN to control PLL controller MUX */    
		PLL1_PLLCTL &= ~(1 << PLLENSRC_OFFSET);
		if(debug_info_on){    
			GEL_TextOut("(2c) PLLCTL = %x\n",,,,, PLL1_PLLCTL);
		}    

		/* Step 2d: Wait 4 reference clock cycles (slowest of ALTCORE or SYSCLK) to make sure 
           that the PLL controller MUX switches properly to bypass. */
		if(debug_info_on){    
			GEL_TextOut("(2d) Delay...\n",,,,,);
		}        
		for(i = 0; i < delay; i++); // this delay is much more than required         

		/* Step 2e: Set SECCTL[BYPASS] = 1 - enables bypass in PLL MUX */    
		PLL1_SECCTL |= (1 << BYPASS_OFFSET);        
		if(debug_info_on){    
			GEL_TextOut("(2e) SECCTL = %x\n",,,,, PLL1_SECCTL);
		}    

		/* Step 2f: Set PLLCTL[PLLPWRDN] = 1 - power down the PLL */        
		PLL1_PLLCTL |= (1 << PLLPWRDN_OFFSET);
		if(debug_info_on){    
			GEL_TextOut("(2f) PLLCTL = %x\n",,,,, PLL1_PLLCTL);
		}    

		/* Step 2g: Wait for at least 5us for the PLL to power down */
		if(debug_info_on){    
			GEL_TextOut("(2g) Delay...\n",,,,,);
		}    
		for(i = 0; i < delay; i++); // this delay is much more than required 

		/* Step 2h: Set PLLCTL[PLLPWRDN] = 0 - Power the PLL back up */    
		PLL1_PLLCTL &= ~(1 << PLLPWRDN_OFFSET);
		if(debug_info_on){    
			GEL_TextOut("(2h) PLLCTL = %x\n",,,,, PLL1_PLLCTL);
		}            

	}
	else{ // PLL bypass disabled - Execute PLL setup for PLL that has previously been locked (skip to Step 3)
		if(debug_info_on){    
			GEL_TextOut("Detected PLL bypass disabled: SECCTL[BYPASS] = %x\n",,,,, BYPASS_val);
		}

		/* Step 3a: Set PLLCTL[PLLEN] = 0 This enables bypass in PLL controller MUX */        
		PLL1_PLLCTL &= ~(1 << PLLEN_OFFSET);        
		if(debug_info_on){    
			GEL_TextOut("(3a) PLLCTL = %x\n",,,,, PLL1_PLLCTL);
		}    

		/* Step 3b: Set PLLCTL[PLLENSRC] = 0 - This enables PLLEN to control PLL controller MUX */    
		PLL1_PLLCTL &= ~(1 << PLLENSRC_OFFSET);
		if(debug_info_on){    
			GEL_TextOut("(3b) PLLCTL = %x\n",,,,, PLL1_PLLCTL);
		}

		/* Step 3c: Wait 4 reference clock cycles (slowest of ALTCORE or SYSCLK) to make sure 
           that the PLL controller MUX switches properly to bypass. */
		if(debug_info_on){    
			GEL_TextOut("(3c) Delay...\n",,,,,);
		}        
		for(i = 0; i < delay; i++); // this delay is much more than required       

	}


	/* Step 4: Programming PLLM[5:0] in the PLLM register of the PLL controller and
       programming PLLM[12:6] in the MAINPLLCTL0 register */        
	PLL1_PLLM &= PLLM_MASK;             // clear the PLLM[5:0] bit field
	PLL1_PLLM |= ~PLLM_MASK & (PLLM_val - 1);   // set the PLLM[5:0] bit field to the 6 LSB of PLLM_val

	if(debug_info_on){
		GEL_TextOut("(4)PLLM[PLLM] = %x\n",,,,, PLL1_PLLM);
	}    

	MAINPLLCTL0 &= MAIN_PLLM_MASK;      // clear the PLLM[12:6] bit field
	MAINPLLCTL0 |= ~MAIN_PLLM_MASK & (( (PLLM_val - 1) >> 6) << MAIN_PLLM_OFFSET);  // set the PLLM[12:6] bit field to the 7 MSB of PLL_val

	if(debug_info_on){
		GEL_TextOut("MAINPLLCTL0 = %x\n",,,,, MAINPLLCTL0);
	}

	/* Step 5: Programming BWADJ[7:0] in the MAINPLLCTL0 register and BWADJ[11:8] in MAINPLLCTL1 register */            
	MAINPLLCTL0 &= MAIN_BWADJ0_MASK;    // clear the MAIN_BWADJ0 bit field
	MAINPLLCTL0 |= ~MAIN_BWADJ0_MASK & ((BWADJ_val - 1) << MAIN_BWADJ0_OFFSET); // set the MAIN_BWADJ[7:0] bit field to the 8 LSB of BWADJ_val

	if(debug_info_on){
		GEL_TextOut("(5) MAINPLLCTL0 = %x\n",,,,, MAINPLLCTL0);
	}

	MAINPLLCTL1 &= MAIN_BWADJ1_MASK;    // clear the MAIN_BWADJ1 bit field
	MAINPLLCTL1 |= ~MAIN_BWADJ1_MASK & (( (BWADJ_val - 1) >> 8) << MAIN_BWADJ1_OFFSET); // set the MAIN_BWADJ[11:8] bit field to the 4 MSB of BWADJ_val

	if(debug_info_on){
		GEL_TextOut("(5) MAINPLLCTL1 = %x\n",,,,, MAINPLLCTL1);
	}

	/* Step 6: Programming PLLD[5:0] in the MAINPLLCTL0 register */            
	MAINPLLCTL0 &= MAIN_PLLD_MASK;      // clear the PLLD bit field
	MAINPLLCTL0 |= ~MAIN_PLLD_MASK & (PLLD_val - 1);    // set the PLLD[5:0] bit field of PLLD to PLLD_val

	if(debug_info_on){
		GEL_TextOut("(6) MAINPLLCTL0 = %x\n",,,,, MAINPLLCTL0);
	}

	/* Step 7: Programming OD[3:0] in the SECCTL register */            
	PLL1_SECCTL &= OUTPUT_DIVIDE_MASK;  // clear the OD bit field
	PLL1_SECCTL |= ~OUTPUT_DIVIDE_MASK & (OD_val - 1) << OUTPUT_DIVIDE_OFFSET;  // set the OD[3:0] bit field of PLLD to OD_val    

	if(debug_info_on){
		GEL_TextOut("(7) SECCTL = %x\n",,,,, PLL1_SECCTL);
	}

	/* Step 8: Following steps are needed to change the default output dividers */            

	/* Step 8a: Check that the GOSTAT bit in PLLSTAT is cleared to show that no GO
       operation is currently in progress*/
	if(debug_info_on){    
		GEL_TextOut("(8a) Delay...\n",,,,,);
	}    
	while((PLL1_STAT) & 0x00000001);

	/* Step 8b: Program the RATIO field in PLLDIVn to the desired new divide-down rate.
       If RATIO field is changed, the PLL controller will flag the change in the
       corresponding bit of DCHANGE*/
	PLL1_DIV3 = (PLLDIV3_val-1) | 0x8000;  //Set PLLDIV3
	PLL1_DIV4 = (PLLDIV4_val-1) | 0x8000;  //Set PLLDIV4
	PLL1_DIV7 = (PLLDIV7_val-1) | 0x8000;  //Set PLLDIV7

	if(debug_info_on){
		GEL_TextOut("PLL1_DIV3 = %x\n",,,,, PLL1_DIV3);
		GEL_TextOut("PLL1_DIV4 = %x\n",,,,, PLL1_DIV4);
		GEL_TextOut("PLL1_DIV7 = %x\n",,,,, PLL1_DIV7);
	}

	/* Step 8c: Set GOSET bit in PLLCMD to initiate the GO operation to change the divide
       values and align the SYSCLKs as programmed */
	PLL1_CMD |= 0x00000001;

	/*Step 8d/e: Read the GOSTAT bit in PLLSTAT to make sure the bit returns to 0 to
      indicate that the GO operation has completed */
	if(debug_info_on){    
		GEL_TextOut("(8d/e) Delay...\n",,,,,);
	}    
	while((PLL1_STAT) & 0x00000001);

	/* Step 9: Set PLLCTL[PLLRST] = 1 - Assert PLL reset (Previously Step 3)*/        
	PLL1_PLLCTL |= (1 << PLLRST_OFFSET);

	/* Step 10: Wait for the at least 7us for the PLL reset properly (128 CLKIN1 cycles) */        
	if(debug_info_on){    
		GEL_TextOut("(10) Delay...\n",,,,,);
	}    
	for(i=0;i<delay;i++);

	/* Step 11: Set PLLCTL[PLLRST] = 0 - De-Assert PLL reset */        
	PLL1_PLLCTL &= ~(1 << PLLRST_OFFSET);

	/* Step 12: Wait for PLL to lock (2000 CLKIN1 cycles) */
	if(debug_info_on){    
		GEL_TextOut("(12) Delay...\n",,,,,);
	}    
	for(i=0;i<delay;i++);

	/* Step 13: In SECCTL, write BYPASS = 0 (enable PLL mux to switch to PLL mode) */
	PLL1_SECCTL &= ~(1 << BYPASS_OFFSET);        
	if(debug_info_on){    
		GEL_TextOut("(13) SECCTL = %x\n",,,,, PLL1_SECCTL);
	}    
	if(debug_info_on){    
		GEL_TextOut("(Delay...\n",,,,,);
	}    
	for(i=0;i<delay;i++);
	if(debug_info_on){    
		GEL_TextOut("(Delay...\n",,,,,);
	}    
	for(i=0;i<delay;i++);

	/* Step 14: In PLLCTL, write PLLEN = 1 to enable PLL mode */
	PLL1_PLLCTL |= (1 << PLLEN_OFFSET);        
	if(debug_info_on){    
		GEL_TextOut("(14) PLLCTL = %x\n",,,,, PLL1_PLLCTL);
	}    

	/* Step 15: Lock Boot Config Registers */
	KICK0 = 0x00000000;
	KICK1 = 0x00000000;

	GEL_TextOut("PLL has been configured (CLKIN * PLLM / PLLD / PLLOD = PLLOUT):\n",,,,,);
	GEL_TextOut("PLL has been configured (%f MHz * %d / %d / %d = %f MHz)\n",,,,, CLKIN_val, PLLM_val, PLLD_val,OD_val,(CLKIN_val * PLLM_val / PLLD_val / OD_val) );

}


//TODO: May need to change, as currently information is not available
Set_Tetris_Pll(int index)
{

	unsigned int BWADJ_val;     
	unsigned int OD_val;            
	unsigned int PLLM_val;
	float CLKIN_val;
	int i;

	GEL_TextOut("Switching on ARM Core 0\n",,,,,);
	TETRIS_CPU0_PDCTL   = 0x00000000;
	TETRIS_CPU0_PTCMD   = 0x00000001;    

	GEL_TextOut("Switching on ARM Core 1\n",,,,,);
	TETRIS_CPU1_PDCTL   = 0x00000000;
	TETRIS_CPU1_PTCMD   = 0x00000001;    

	GEL_TextOut("Switching on ARM Core 2\n",,,,,);
	TETRIS_CPU2_PDCTL   = 0x00000000;
	TETRIS_CPU2_PTCMD   = 0x00000001;    

	GEL_TextOut("Switching on ARM Core 3\n",,,,,);
	TETRIS_CPU3_PDCTL   = 0x00000000;
	TETRIS_CPU3_PTCMD   = 0x00000001;

	if(index == 1){              // 100 MHz -> 1.0 GHz
		CLKIN_val   = 125;          // setup CLKIN to 125 MHz
		PLLM_val    = 16;           // setup PLLM (PLL multiplier) to x20
		OD_val      = 2;            // setup OD to a fixed /2
	}
	else if(index == 2){            // 100 MHz -> 1.4 GHz
		CLKIN_val   = 125;          // setup CLKIN to 125 MHz
		PLLM_val    = 22;           // setup PLLM (PLL multiplier) to x28
		OD_val      = 2;            // setup OD to a fixed /2
	}
	else if(index == 3){            // 174.825MHz -> 1.4 GHz		//TODO: From where this freq will be available? Not shown in schematic.

		CLKIN_val   = 174.825;      // setup CLKIN to 174.825 MHz
		PLLM_val    = 16;           // setup PLLM (PLL multiplier) to x16
		OD_val      = 2;            // setup OD to a fixed /2
	}

	BWADJ_val       = (PLLM_val-1) >> 1;            // setup BWADJ to be 1/2 the value of PLLM
	OD_val          = 2;                            // setup OD to a fixed /2

	/* Step 1: Unlock Boot Config Registers */
	KICK0 = KICK0_UNLOCK;
	KICK1 = KICK1_UNLOCK;

	//Step 1 : Assert SEC PLL Reset
	SECPLLCTL1 = ((1 << SEC_PLLCTL1_RESET_OFFSET) | (1 << SEC_PLLCTL1_ENSTAT_OFFSET));

	//Step 2 : Change CLKF/OD/BWADJ etc. for SEC PLL
	SECPLLCTL0 = ((BWADJ_val << SEC_PLLCTL0_BWADJ_OFFSET) |
			((OD_val-1) << SEC_PLLCTL0_OD_OFFSET)|
			((PLLM_val-1) << SEC_PLLCTL0_PLLM_OFFSET));

	//Step 3 : Make sure the resets are held for 5us
	for(i = 0; i < 200000; i++);

	//Step 4 : Remove SEC PLL reset
	SECPLLCTL1 = (1 << SEC_PLLCTL1_ENSTAT_OFFSET);

	//Step 5 : Wait for PLL to lock (4000 CLKIN1 cycles)
	for(i = 0; i < 4000; i++);

	//Step 6 : Get the PLL out of Bypass
	//SECPLLCTL0 &= ~(1 << SEC_PLLCTL0_BYPASS_OFFSET);
	CHIP_MISC1 |= (1 << ARMPLL_ENABLE_OFFSET); 


	//Step 6 : Lock Boot Config Registers
	KICK0 = 0x00000000;
	KICK1 = 0x00000000;

	GEL_TextOut("ARM PLL has been configured (%f MHz * %d / %d = %f MHz)\n",,,,, CLKIN_val, PLLM_val, OD_val, (CLKIN_val * PLLM_val)/OD_val);

}


/* Set the desired PA PLL configuration */
PaPllConfig()
{
	unsigned int passclksel = (DEVSTAT & PASSCLKSEL_MASK);
	unsigned int papllctl0val_orig = PAPLLCTL0;
	unsigned int papllctl1val_orig = PAPLLCTL1;
	unsigned int papllctl0val_final;
	unsigned int papllctl1val_final;
	unsigned int papllclkf = 19; //204; // 204; 20 (if PASSREFCLK == 100mhz) Multiply by clkf + 1
	unsigned int papllclkd = 0;  //11;  // 11;   1 (if PASSREFCLK == 100mhz) Divide by clkd + 1
	unsigned int i = 0;

	if (passclksel != PASSCLKSEL_MASK) GEL_TextOut("WARNING: SYSCLK is the input to the PA PLL.\n");

	/* Unlock Chip Level Registers */
	KICK0 = KICK0_UNLOCK;
	KICK1 = KICK1_UNLOCK;

	// PAPLLCTL1 = PAPLLCTL1 | 0x00000040; //Set ENSAT = 1; Set PLL Select to 0 (for SYCLK0 as input of PASS)
	PAPLLCTL1 = PAPLLCTL1 | 0x00002040; //Set ENSAT = 1; Set PLL Select to 1 (for PA PLL as input of PASS)  

	/*in PAPLLCTL0, clear bypass bit to set the PA PLL in Bypass Mode*/
	//PAPLLCTL0 &= ~(1<<BYPASS_BIT_SHIFT); // Not setting Bypass bit
	PAPLLCTL0 |=  (1<<BYPASS_BIT_SHIFT); // Actually setting bypass bit

	/*Wait 4 cycles for the slowest of PLLOUT or reference clock source (CLKIN)*/
	for(i=0;i<100;i++);

	/*In PAPLLCTL1, write PLL reset bit to put the PLL in reset*/
	PAPLLCTL1 |= PA_PLL_RESET_MASK;

	/* Program the multiplier value */
	PAPLLCTL0 &= (~PA_PLL_CLKF_MASK);          //clear multiplier value
	PAPLLCTL0 &= (~PA_PLL_CLKR_MASK);          //clear divider value
	PAPLLCTL0 |= (papllclkf<<CLKF_BIT_SHIFT);  // set PLLM
	PAPLLCTL0 |= (papllclkd<<CLKD_BIT_SHIFT);  // set PLLD


	PAPLLCTL0 &= 0x00FFFFFF;
	PAPLLCTL0 |= ((((papllclkf + 1)>>1)-1)<<24);

	//PAPLLCTL1 = PAPLLCTL1 | 0x00002000;

	/*Wait for PLL to properly reset (128 CLKIN1 cycles) */
	for(i=0;i<1000;i++);

	/* take the PA PLL out of reset */
	PAPLLCTL1 &= (~PA_PLL_RESET_MASK);

	/*Wait for PLL to lock (2000 CLKIN1 cycles) */
	for(i=0;i<5000;i++);

	/* enable PLL mode */
	PAPLLCTL0 &= ~(1<<BYPASS_BIT_SHIFT); // actually setting PLL MODE

	for(i=0;i<4000;i++);

	/* Lock Chip Level Registers */
	KICK0 = KICK_LOCK;
	KICK1 = KICK_LOCK;

	papllctl0val_final = PAPLLCTL0;
	papllctl1val_final = PAPLLCTL1;

	GEL_TextOut("Completed PA PLL Setup\n");
	GEL_TextOut("PAPLLCTL0 - before: 0x%x\t after: 0x%x\n",,,,, papllctl0val_orig, papllctl0val_final);
	GEL_TextOut("PAPLLCTL1 - before: 0x%x\t after: 0x%x\n",,,,, papllctl1val_orig, papllctl1val_final);

	if ((papllctl0val_final != 0x09080500) || (papllctl1val_final != 0x00002040))
	{
		return 1;
	}

	return 0;

}

//*************************************************************************************************
//*************************************************************************************************
//*************************************************************************************************
//*************************************************************************************************
//*************************************************************************************************
//*************************************************************************************************

//--------DDR3A Memory test----------------------

ddr3A_memory_test ()
{
	unsigned int index, value;

	GEL_TextOut( "DDR3A memory test... Started\n" );

	/* Write a pattern */
	for (index = DDR3A_TEST_START_ADDRESS; index < DDR3A_TEST_END_ADDRESS; index += 4) {
		*index = index;
	}

	/* Read and check the pattern */
	for (index = DDR3A_TEST_START_ADDRESS; index < DDR3A_TEST_END_ADDRESS; index += 4) {

		value = *index;

		if (value  != index) {
			GEL_TextOut( "DDR3A memory test... Failed\n" );
			return -1;
		}
	}

	/* Write a pattern for complementary values */
	for (index = DDR3A_TEST_START_ADDRESS; index < DDR3A_TEST_END_ADDRESS; index += 4) {
		*index = ~index;
	}

	/* Read and check the pattern */
	for (index = DDR3A_TEST_START_ADDRESS; index < DDR3A_TEST_END_ADDRESS; index += 4) {

		value = *index;

		if (value  != ~index) {
			GEL_TextOut( "DDR3A memory test... Failed\n" );
			return -1;
		}
	}

	GEL_TextOut( "DDR3A memory test... Passed\n" );
	return 0;

}



/****************************************************************************
 *
 * NAME
 *      Setup_Memory_Map
 *
 * PURPOSE:
 *      Setup the Memory Map for EVMC6678L.
 *      Defined memory location avoid debugger access outside these locations.
 *
 * USAGE
 *      This routine can be called as:
 *
 *      Setup_Memory_Map()
 *
 * RETURN VALUE
 *      NONE
 *
 * REFERENCE
 *      Based on TMS320C6678 datasheet.
 *
 ****************************************************************************/
hotmenu Setup_Memory_Map( )
{
	GEL_TextOut("Setup_Memory_Map...\n",,);

	GEL_MapOn( );
	GEL_MapReset( );

	GEL_MapAddStr( 0x00000000, 0, 0x21400000, "R|W|AS4", 0 );   // 
	GEL_MapAddStr( 0x21400000,0, 0x00000080, "R|W|AS4", 0 );   // Hyperlink Config (remote)	
	//GEL_MapAddStr( 0x21400080,0, 0x00000080, "R|W|AS4", 0 );   // Hyperlink Config (remote)
	GEL_MapAddStr( 0x21400200, 0, 0xdebffe00, "R|W|AS4", 0 );   // 
	GEL_TextOut( "Setup_Memory_Map... Done.\n" );
}

/*----------------------------------------------------- DDR3A : DDR800, 32bit--------------------------------------------------------------------------*/
ddr3A_32bit_DDR800_setup()
{
	unsigned int multiplier = 3;
	unsigned int divider = 0;
	int temp;
	unsigned int OD_val = 2;
	KICK0 = 0x83E70B13;
	KICK1 = 0x95A4F1E0;


	//1.	Poll for IDONE=1 in the PHY General Status Register 0 (address offset 0x010).
	do { 
		read_val = DDR3A_PGSR0;
	} while ((read_val&0x00000001) != 0x00000001);

	//4.	Clocks are enabled and frequency is stable---------------------------------------
	//DDR3A PLL setup	
	GEL_TextOut ( "DDR3 PLL (PLL2) Setup ... \n");
	//DDR3APLLCTL0 = DDR3APLLCTL0 & 0xFF7FFFFF;
	//	Set ENSAT = 1
	DDR3APLLCTL1 |= 0x00000040;
	// Put the PLL in PLL Mode  
	DDR3APLLCTL0 |= 0x00800000;
	// In PLL Controller, reset the PLL (bit 13 in DDR3APLLCTL1 register) 
	DDR3APLLCTL1 |= 0x00002000;
	// Program the necessary multipliers/dividers and BW adjustments            
	// Set the divider values 
	DDR3APLLCTL0 &= ~(0x0000003F);
	DDR3APLLCTL0 |= (divider & 0x0000003F);
	/* Step 7: Programming OD[3:0] in the SECCTL register */            
	DDR3APLLCTL0 &= OUTPUT_DIVIDE_MASK;  // clear the OD bit field
	DDR3APLLCTL0 |= ~OUTPUT_DIVIDE_MASK & (OD_val - 1) << OUTPUT_DIVIDE_OFFSET;  // set the OD[3:0] bit field of PLLD to OD_val    

	/* Set the Multipler values */
	DDR3APLLCTL0 &= ~(0x0007FFC0);
	DDR3APLLCTL0 |= ((multiplier << 6) & 0x0007FFC0 );
	temp = ((multiplier + 1) >> 1) - 1;
	DDR3APLLCTL0 &= ~(0xFF000000); 
	DDR3APLLCTL0 |= ((temp << 24) & 0xFF000000);
	DDR3APLLCTL1 &= ~(0x0000000F);
	DDR3APLLCTL1 |= ((temp >> 8) & 0x0000000F);
	//In DDR3PLLCTL1, write PLLRST = 0 to bring PLL out of reset 
	DDR3APLLCTL1 &= ~(0x00002000);
	// Put the PLL in PLL Mode  
	DDR3APLLCTL0 &= ~(0x00800000); // ReSet the Bit 23
	GEL_TextOut( "DDR3 PLL Setup complete, DDR3A clock now running at 400MHz.\n" );
	//DDR3A PLL setup complete ---------------------------------------

	/*------------------------- Start PHY Configuration -------------------------------*/

	//DDR3A_PGCR1 = 0x0280C487;

	//5.a	Program FRQSEL in the PLL Control Register (address offset 0x018).
	DDR3A_PLLCR = 0xDC000; //Set FRQSEL=11, for ctl_clk between 166-275MHz

	//5.b.	Program WLSTEP=1, IODDRM=1, and ZCKSEL in the PHY General Configuration Register 1 (address offset 0x00C). 
	DDR3A_PGCR1 |= (1 << 2); //WLSTEP = 1

	DDR3A_PGCR1 &= ~(IODDRM_MASK);
	DDR3A_PGCR1 |= (( 1 << 7) & IODDRM_MASK);


	DDR3A_PGCR1 &= ~(ZCKSEL_MASK);
	DDR3A_PGCR1 |= (( 1 << 23) & ZCKSEL_MASK);


	//5.c.	Program PHY Timing Parameters Register 0-4 (address offset 0x01C - 0x02C).

	DDR3A_PTR0 = 0x42C21590;

	DDR3A_PTR1 = 0xCFC712B3;

	// Maintaining default values of Phy Timing Parameters Register 2 in PUB

	DDR3A_PTR3 = 0x04430D40;//0x18061A80; 

	DDR3A_PTR4 = 0x06413880;//0x0AAE7100;

	//5.d.	Program PDQ, MPRDQ, and BYTEMASK in the DRAM Configuration Register (address offset 0x044). 
	//		All other fields must be left at their default values.

	DDR3A_DCR &= ~(PDQ_MASK); //PDQ = 0
	DDR3A_DCR &= ~(MPRDQ_MASK); //MPRDQ = 0

	DDR3A_DCR &= ~(BYTEMASK_MASK);
	DDR3A_DCR |= (( 1 << 10) & BYTEMASK_MASK);


	DDR3A_DCR &= ~(NOSRA_MASK);
	DDR3A_DCR |= (( 1 << 27) & NOSRA_MASK);


	DDR3A_DCR &= ~(UDIMM_MASK);
	DDR3A_DCR |= (( 1 << 29) & UDIMM_MASK);


	//5.e.	Program DRAM Timing Parameters Register 0-2 (address offset 0x048 - 0x050). 

	DDR3A_DTPR0 = 0x008F6633; //0x50CE6644;
	DDR3A_DTPR1 = 0x12820180;
	DDR3A_DTPR2 = 0x50022A00;

	//5.f.	Program BL=0, CL, WR, and PD=1 in the Mode Register 0 (address offset 0x054). 
	//All other fields must be left at their default values.

	DDR3A_MR0 = 0x00001620;


	//5.g.	Program DIC, RTT, and TDQS in the Mode Register 1 (address offset 0x058). 
	//All other fields must be left at their default values.

	DDR3A_MR1 = 0x00000006;


	//---------------------------------------------------------------------------------------------------------					

	//5.h.	Program Mode Register 2 (address offset 0x05C).
	// Maintaining default values of Program Mode Register 2
	DDR3A_MR2 = 0x00000040;

	//5.i.	Program DTMPR=1, DTEXD, DTEXG, RANKEN=1 or 3, and RFSHDT=7 in the Data Training Configuration Register (address offset 0x068). 
	//All other fields must be left at their default values.
	DDR3A_DTCR = 0x710035C7; //0x710035C7;

	//5.j.	Program tREFPRD=(5*tREFI/ddr_clk_period) in the PHY General Configuration Register 2 (address offset 0x08C). 
	//All other fields must be left at their default values.

	DDR3A_PGCR2 = 0x00F03D09; //NOBUB = 0, FXDLAT = 0 	
	//DDR3A_PGCR2 = 0x00F83D09; //NOBUB = 0, FXDLAT = 1 

	//Set Impedence Register	
	DDR3A_ZQ0CR1 = 0x0000007B; 
	DDR3A_ZQ1CR1 = 0x0000007B;
	DDR3A_ZQ2CR1 = 0x0000007B;


	//6.	Re-trigger PHY initialization in DDR PHY through the VBUSP interface.
	//6.a.	Program 0x00000033 to the PHY Initialization Register (address offset 0x004) to re-trigger PLL, ZCAL, and DCAL initialization.

	DDR3A_PIR = 0x00000033;

	//6.b.	Poll for IDONE=1 in the PHY General Status Register 0 (address offset 0x010).
	do { 
		read_val = DDR3A_PGSR0;
	} while ((read_val&0x00000001) != 0x00000001);

	//---------------------------------------------------------------------------------------------------------					



	// 7.	Trigger DDR3 initialization and leveling/training in DDR PHY through the VBUSP interface.
	// a.	If using a 16-bit wide DDR interface, program DXEN=0 in the DATX8 2-7 General Configuration Registers (address offsets 0x240, 0x280, 0x2C0, 0x300, 0x340, and 0x380) to disable the leveling/training for the upper byte lanes.
	// b.	If using a 32-bit wide DDR interface, program DXEN=0 in the DATX8 4-7 General Configuration Registers (address offsets 0x2C0, 0x300, 0x340, and 0x380) to disable the leveling/training for the upper byte lanes.
	// c.	If ECC is not required, program DXEN=0 in the DATX8 8 General Configuration Register (address offset 0x3C0) to disable the leveling/training for the ECC byte lane.
	// NOTE: Setup supports 64-bit by default,  ECC enable by default.

	//7.d.	Program 0x0000XF81 to the PHY Initialization Register (address offset 0x004) to trigger DDR3 initialization and leveling/training sequences 

	DDR3A_PIR = 0x0000FF81; //WLADJ - ON
	//DDR3A_PIR = 0x00000781;  //WLADJ - OFF

	//---------------------------------------------------------------------------------------------------------					

	//7.e.	Poll for IDONE=1 in the PHY General Status Register 0 (address offset 0x010).
	do {              
		read_val = DDR3A_PGSR0;
	} while ((read_val&0x00000001) != 0x00000001);


	/* End PHY Configuration */		
	//---------------------------------------------------------------------------------------------------------					
	/* START EMIF INITIALIZATION
  ++++++++++++++++++SDCFG Register Calculation+++++++++++++++++++
  | 31 - 29  | 28 |27 - 25 | 24   | 23 - 22| 21 - 17 |
  |SDRAM_TYPE|Rsvd|DDR_TERM| DDQS | DYN_ODT|  Rsvd   |
  |  0x011   |  0 | 0x011  | 0x1  |   0x00 |   0x0   |

  | 16-14 |13 - 12 |  11 - 8 |  7   |6 - 5 |  4  |  3  |  2  |  1 - 0  |
  |   CWL | NM     |   CL    | Rsvd |IBANK | Rsvd|EBANK| Rsvd|PAGE_SIZE|
  |  0x11 | 0x00   |  0x1110 |  0x0 | 0x11 | 0x0 |  0  |  0  |   0x10  |
  SDCFG = 0x0110 0011 0010 0010 0011 0011 1011 0010
  SDCFG = 0x6700486A;//0x63223332

  SDRAM_TYPE = 3
  DDR_TERM = 3 (RZQ/4 = 1; RZQ/6=3)
  DDQS = 1 
  DYN_ODT = 0 

  CWL = 3 (CWL5=0; CWL6=1; CWL7=2; CWL8=3)
  NM = 0 (64-bit=0, 32-bit=1, 16-bit=2)
  CL = 14 (CL5=2; CL6=4; CL7=6; CL8=8; CL9=10; CL10=12; CL11=14)
  IBANK = 3 (8bank)
  EBANK = 0 (0 - pad_cs_o_n[0] , 1 - pad_cs_o_n[1:0])
  PAGE_SIZE = 2 (1024page-size=2; 2048page-size=3)
	 */
	/* Start DDR3A EMIF Configuration */
	//8.	Configure the EMIF through the VBUSM interface.
	//8.a.	Program all EMIF MMR\92s.
	DDR3A_SDCFG    = 0x62001462	; //0x6200046A

	DDR3A_SDTIM1   = 0x0A385022;
	DDR3A_SDTIM2   = 0x00001CA5;
	DDR3A_SDTIM3   = 0x210DFF22;
	DDR3A_SDTIM4   = 0x533F03FF;

	DDR3A_ZQCFG    = 0x70073200; 	
	//8.b.	Program reg_initref_dis=0 in the SDRAM Refresh Control Register (address offset 0x10).
	DDR3A_SDRFC = 0x00000C34;

	GEL_TextOut("DDR3A initialization complete \n");
	/* End  DDR3A EMIF Configuration */

}	


/*----------------------------------------------------- DDR3A : DDR1066, 32bit--------------------------------------------------------------------------*/
ddr3A_32bit_DDR1066_setup()
{

	unsigned int multiplier = 15;
	unsigned int divider = 0;
	int temp;
	unsigned int OD_val = 6;
	KICK0 = 0x83E70B13;
	KICK1 = 0x95A4F1E0;


	//1.	Poll for IDONE=1 in the PHY General Status Register 0 (address offset 0x010).
	do { 
		read_val = DDR3A_PGSR0;
	} while ((read_val&0x00000001) != 0x00000001);

	//4.	Clocks are enabled and frequency is stable---------------------------------------
	//DDR3A PLL setup	
	GEL_TextOut ( "DDR3 PLL (PLL2) Setup ... \n");
	//DDR3APLLCTL0 = DDR3APLLCTL0 & 0xFF7FFFFF;
	//	Set ENSAT = 1
	DDR3APLLCTL1 |= 0x00000040;
	// Put the PLL in PLL Mode  
	DDR3APLLCTL0 |= 0x00800000;
	// In PLL Controller, reset the PLL (bit 13 in DDR3APLLCTL1 register) 
	DDR3APLLCTL1 |= 0x00002000;
	// Program the necessary multipliers/dividers and BW adjustments            
	// Set the divider values 
	DDR3APLLCTL0 &= ~(0x0000003F);
	DDR3APLLCTL0 |= (divider & 0x0000003F);
	/* Step 7: Programming OD[3:0] in the SECCTL register */            
	DDR3APLLCTL0 &= OUTPUT_DIVIDE_MASK;  // clear the OD bit field
	DDR3APLLCTL0 |= ~OUTPUT_DIVIDE_MASK & (OD_val - 1) << OUTPUT_DIVIDE_OFFSET;  // set the OD[3:0] bit field of PLLD to OD_val    

	/* Set the Multipler values */
	DDR3APLLCTL0 &= ~(0x0007FFC0);
	DDR3APLLCTL0 |= ((multiplier << 6) & 0x0007FFC0 );
	temp = ((multiplier + 1) >> 1) - 1;
	DDR3APLLCTL0 &= ~(0xFF000000); 
	DDR3APLLCTL0 |= ((temp << 24) & 0xFF000000);
	DDR3APLLCTL1 &= ~(0x0000000F);
	DDR3APLLCTL1 |= ((temp >> 8) & 0x0000000F);
	//In DDR3PLLCTL1, write PLLRST = 0 to bring PLL out of reset 
	DDR3APLLCTL1 &= ~(0x00002000);
	// Put the PLL in PLL Mode  
	DDR3APLLCTL0 &= ~(0x00800000); // ReSet the Bit 23
	GEL_TextOut( "DDR3 PLL Setup complete, DDR3A clock now running at 533MHz.\n" );
	//DDR3A PLL setup complete ---------------------------------------

	/*------------------------- Start PHY Configuration -------------------------------*/

	//DDR3A_PGCR1 = 0x0280C487;

	//5.a	Program FRQSEL in the PLL Control Register (address offset 0x018).
	DDR3A_PLLCR = 0xDC000; //Set FRQSEL=11, for ctl_clk between 166-275MHz

	//5.b.	Program WLSTEP=1, IODDRM=1, and ZCKSEL in the PHY General Configuration Register 1 (address offset 0x00C). 
	DDR3A_PGCR1 |= (1 << 2); //WLSTEP = 1

	DDR3A_PGCR1 &= ~(IODDRM_MASK);
	DDR3A_PGCR1 |= (( 1 << 7) & IODDRM_MASK);


	DDR3A_PGCR1 &= ~(ZCKSEL_MASK);
	DDR3A_PGCR1 |= (( 1 << 23) & ZCKSEL_MASK);


	//5.c.	Program PHY Timing Parameters Register 0-4 (address offset 0x01C - 0x02C).

	DDR3A_PTR0 = 0x426213CF;

	DDR3A_PTR1 = 0xCFC712B3;	

	// Maintaining default values of Phy Timing Parameters Register 2 in PUB

	DDR3A_PTR3 = 0x05B411AA;//0x09041104;//0x18061A80; 

	DDR3A_PTR4 = 0x0855A0AA;//0x0AAE7100;

	//5.d.	Program PDQ, MPRDQ, and BYTEMASK in the DRAM Configuration Register (address offset 0x044). 
	//		All other fields must be left at their default values.

	DDR3A_DCR &= ~(PDQ_MASK); //PDQ = 0

	DDR3A_DCR &= ~(MPRDQ_MASK); //MPRDQ = 0

	DDR3A_DCR &= ~(BYTEMASK_MASK);
	DDR3A_DCR |= (( 1 << 10) & BYTEMASK_MASK);


	DDR3A_DCR &= ~(NOSRA_MASK);
	DDR3A_DCR |= (( 1 << 27) & NOSRA_MASK);

	//DDR3A_DCR &= ~(UDIMM_MASK);
	//DDR3A_DCR |= (( 1 << 29) & UDIMM_MASK);

	//RRMODE
	//DDR3A_DSGCR &= ~(RRMODE_MASK); //RR_MODE = 0

	//DDR3A_DSGCR &= ~(RRMODE_MASK); //RR_MODE = 1
	//DDR3A_DSGCR |= (( 1 << 18) & RRMODE_MASK);


	//5.e.	Program DRAM Timing Parameters Register 0-2 (address offset 0x048 - 0x050). 

	DDR3A_DTPR0 = 0x54D47744;//0x6D148844;     //0x6D148844; 0x69137764 ---changed in rev 1.3

	DDR3A_DTPR1 = 0x1282AA00;//0x12845A00;
	DDR3A_DTPR2 = 0x50023200;

	//5.f.	Program BL=0, CL, WR, and PD=1 in the Mode Register 0 (address offset 0x054). 
	//All other fields must be left at their default values.

	DDR3A_MR0 = 0x00001830;    //0x00001870; 


	//5.g.	Program DIC, RTT, and TDQS in the Mode Register 1 (address offset 0x058). 
	//All other fields must be left at their default values.

	DDR3A_MR1 =  0x00000006; //0x00000044;  ---changed in rev 1.3


	//---------------------------------------------------------------------------------------------------------					

	//5.h.	Program Mode Register 2 (address offset 0x05C).
	// Maintaining default values of Program Mode Register 2
	DDR3A_MR2 = 0x00000048;  //18   ---changed in rev 1.3


	//5.i.	Program DTMPR=1, DTEXD, DTEXG, RANKEN=1 or 3, and RFSHDT=7 in the Data Training Configuration Register (address offset 0x068). 
	//All other fields must be left at their default values.
	DDR3A_DTCR = 0x710035C7; //0x730035C7;

	//5.j.	Program tREFPRD=(5*tREFI/ddr_clk_period) in the PHY General Configuration Register 2 (address offset 0x08C). 
	//All other fields must be left at their default values.

	DDR3A_PGCR2 = 0x00F05161; //NOBUB = 0, FXDLAT = 0 	
	//DDR3A_PGCR2 = 0x00F83D09; //NOBUB = 0, FXDLAT = 1 


	//Set Impedence Register	
	DDR3A_ZQ0CR1 = 0x0000007B; 
	DDR3A_ZQ1CR1 = 0x0000007B;
	DDR3A_ZQ2CR1 = 0x0000007B;



	//6.	Re-trigger PHY initialization in DDR PHY through the VBUSP interface.
	//6.a.	Program 0x00000033 to the PHY Initialization Register (address offset 0x004) to re-trigger PLL, ZCAL, and DCAL initialization.

	DDR3A_PIR = 0x00000033;

	//6.b.	Poll for IDONE=1 in the PHY General Status Register 0 (address offset 0x010).
	do { 
		read_val = DDR3A_PGSR0;
	} while ((read_val&0x00000001) != 0x00000001);

	//---------------------------------------------------------------------------------------------------------					



	// 7.	Trigger DDR3 initialization and leveling/training in DDR PHY through the VBUSP interface.
	// a.	If using a 16-bit wide DDR interface, program DXEN=0 in the DATX8 2-7 General Configuration Registers (address offsets 0x240, 0x280, 0x2C0, 0x300, 0x340, and 0x380) to disable the leveling/training for the upper byte lanes.
	// b.	If using a 32-bit wide DDR interface, program DXEN=0 in the DATX8 4-7 General Configuration Registers (address offsets 0x2C0, 0x300, 0x340, and 0x380) to disable the leveling/training for the upper byte lanes.
	// c.	If ECC is not required, program DXEN=0 in the DATX8 8 General Configuration Register (address offset 0x3C0) to disable the leveling/training for the ECC byte lane.
	// NOTE: Setup supports 64-bit by default,  ECC enable by default.

	//7.d.	Program 0x0000XF81 to the PHY Initialization Register (address offset 0x004) to trigger DDR3 initialization and leveling/training sequences 

	DDR3A_PIR = 0x0000FF81; //WLADJ - ON
	//DDR3A_PIR = 0x00000781;  //WLADJ - OFF


	//---------------------------------------------------------------------------------------------------------					

	//7.e.	Poll for IDONE=1 in the PHY General Status Register 0 (address offset 0x010).
	do {              
		read_val = DDR3A_PGSR0;
	} while ((read_val&0x00000001) != 0x00000001);


	/* End PHY Configuration */		
	//---------------------------------------------------------------------------------------------------------					
	/* START EMIF INITIALIZATION
  ++++++++++++++++++SDCFG Register Calculation+++++++++++++++++++
  | 31 - 29  | 28 |27 - 25 | 24   | 23 - 22| 21 - 17 |
  |SDRAM_TYPE|Rsvd|DDR_TERM| DDQS | DYN_ODT|  Rsvd   |
  |  0x011   |  0 | 0x011  | 0x1  |   0x00 |   0x0   |

  | 16-14 |13 - 12 |  11 - 8 |  7   |6 - 5 |  4  |  3  |  2  |  1 - 0  |
  |   CWL | NM     |   CL    | Rsvd |IBANK | Rsvd|EBANK| Rsvd|PAGE_SIZE|
  |  0x11 | 0x00   |  0x1110 |  0x0 | 0x11 | 0x0 |  0  |  0  |   0x10  |
  SDCFG = 0x0110 0011 0010 0010 0011 0011 1011 0010
  SDCFG = 0x6700486A;//0x63223332

  SDRAM_TYPE = 3
  DDR_TERM = 3 (RZQ/4 = 1; RZQ/6=3)
  DDQS = 1 
  DYN_ODT = 0 

  CWL = 3 (CWL5=0; CWL6=1; CWL7=2; CWL8=3)
  NM = 0 (64-bit=0, 32-bit=1, 16-bit=2)
  CL = 14 (CL5=2; CL6=4; CL7=6; CL8=8; CL9=10; CL10=12; CL11=14)
  IBANK = 3 (8bank)
  EBANK = 0 (0 - pad_cs_o_n[0] , 1 - pad_cs_o_n[1:0])
  PAGE_SIZE = 2 (1024page-size=2; 2048page-size=3)
	 */
	/* Start DDR3A EMIF Configuration */
	//8.	Configure the EMIF through the VBUSM interface.
	//8.a.	Program all EMIF MMR\92s.
	DDR3A_SDCFG    = 0x62005662; //0x62005662;
	DDR3A_SDTIM1   = 0x0E4C6833; //0x0E4C6833;//0x0E4C6833;
	DDR3A_SDTIM2   = 0x00001CC6;  //0x00001CE7;
	DDR3A_SDTIM3   = 0x3169FF32; //0x323DFF32;
	DDR3A_SDTIM4   = 0x533F054F; //0x533F08AF;

	DDR3A_ZQCFG    = 0x70073200;//0xF0073200; 	
	//8.b.	Program reg_initref_dis=0 in the SDRAM Refresh Control Register (address offset 0x10).
	DDR3A_SDRFC = 0x00001045;

	GEL_TextOut("DDR3A initialization complete \n");
	/* End  DDR3A EMIF Configuration */

}

/*--------------------------------------------------
	 		DDR3A : DDR1333,32bit  
---------------------------------------------------*/

ddr3A_32bit_DDR1333_setup()	
{
	unsigned int multiplier = 19;
	unsigned int divider = 0;
	int temp;
	unsigned int OD_val = 6;
	KICK0 = 0x83E70B13;
	KICK1 = 0x95A4F1E0;


	//1.	Poll for IDONE=1 in the PHY General Status Register 0 (address offset 0x010).
	do { 
		read_val = DDR3A_PGSR0;
	} while ((read_val&0x00000001) != 0x00000001);

	//4.	Clocks are enabled and frequency is stable---------------------------------------
	//DDR3A PLL setup	
	GEL_TextOut ( "DDR3 PLL (PLL2) Setup ... \n");
	//DDR3APLLCTL0 = DDR3APLLCTL0 & 0xFF7FFFFF;
	//	Set ENSAT = 1
	DDR3APLLCTL1 |= 0x00000040;
	// Put the PLL in PLL Mode  
	DDR3APLLCTL0 |= 0x00800000;
	// In PLL Controller, reset the PLL (bit 13 in DDR3APLLCTL1 register) 
	DDR3APLLCTL1 |= 0x00002000;
	// Program the necessary multipliers/dividers and BW adjustments            
	// Set the divider values 
	DDR3APLLCTL0 &= ~(0x0000003F);
	DDR3APLLCTL0 |= (divider & 0x0000003F);
	/* Step 7: Programming OD[3:0] in the SECCTL register */            
	DDR3APLLCTL0 &= OUTPUT_DIVIDE_MASK;  // clear the OD bit field
	DDR3APLLCTL0 |= ~OUTPUT_DIVIDE_MASK & (OD_val - 1) << OUTPUT_DIVIDE_OFFSET;  // set the OD[3:0] bit field of PLLD to OD_val    

	/* Set the Multipler values */
	DDR3APLLCTL0 &= ~(0x0007FFC0);
	DDR3APLLCTL0 |= ((multiplier << 6) & 0x0007FFC0 );
	temp = ((multiplier + 1) >> 1) - 1;
	DDR3APLLCTL0 &= ~(0xFF000000); 
	DDR3APLLCTL0 |= ((temp << 24) & 0xFF000000);
	DDR3APLLCTL1 &= ~(0x0000000F);
	DDR3APLLCTL1 |= ((temp >> 8) & 0x0000000F);
	//In DDR3PLLCTL1, write PLLRST = 0 to bring PLL out of reset 
	DDR3APLLCTL1 &= ~(0x00002000);
	// Put the PLL in PLL Mode  
	DDR3APLLCTL0 &= ~(0x00800000); // ReSet the Bit 23
	GEL_TextOut( "DDR3 PLL Setup complete, DDR3A clock now running at 666 MHz.\n" );
	//DDR3A PLL setup complete ---------------------------------------

	/*------------------------- Start PHY Configuration -------------------------------*/

	//DDR3A_PGCR1 = 0x0280C487;

	//5.a	Program FRQSEL in the PLL Control Register (address offset 0x018).
	DDR3A_PLLCR = 0x0005C000; //Set FRQSEL=01, for ctl_clk between 225-385MHz

	//5.b.	Program WLSTEP=1, IODDRM=1, and ZCKSEL in the PHY General Configuration Register 1 (address offset 0x00C). 
	DDR3A_PGCR1 |= (1 << 2); //WLSTEP = 1

	DDR3A_PGCR1 &= ~(IODDRM_MASK);
	DDR3A_PGCR1 |= (( 1 << 7) & IODDRM_MASK);


	DDR3A_PGCR1 &= ~(ZCKSEL_MASK);
	DDR3A_PGCR1 |= (( 1 << 23) & ZCKSEL_MASK);


	//5.c.	Program PHY Timing Parameters Register 0-4 (address offset 0x01C - 0x02C).

	DDR3A_PTR0 = 0x426213CF;

	DDR3A_PTR1 = 0xCFC712B3;

	// Maintaining default values of Phy Timing Parameters Register 2 in PUB

	DDR3A_PTR3 = 0x07151615;//0x072515C2; //0x0B4515C2;//0x18061A80; 

	DDR3A_PTR4 = 0x0A6A08D5;//0x0AAE7100;

	//5.d.	Program PDQ, MPRDQ, and BYTEMASK in the DRAM Configuration Register (address offset 0x044). 
	//		All other fields must be left at their default values.

	DDR3A_DCR &= ~(PDQ_MASK); //PDQ = 0

	DDR3A_DCR &= ~(MPRDQ_MASK); //MPRDQ = 0

	DDR3A_DCR &= ~(BYTEMASK_MASK);
	DDR3A_DCR |= (( 1 << 10) & BYTEMASK_MASK);


	DDR3A_DCR &= ~(NOSRA_MASK);
	DDR3A_DCR |= (( 1 << 27) & NOSRA_MASK);


	//DDR3A_DCR &= ~(UDIMM_MASK);
	//DDR3A_DCR |= (( 1 << 29) & UDIMM_MASK);


	//5.e.	Program DRAM Timing Parameters Register 0-2 (address offset 0x048 - 0x050). 

	DDR3A_DTPR0 = 0xAD189955;//0x85589975;//0x8558AA55;
	DDR3A_DTPR1 = 0x12835A80;//0x12835A80;//0x12857280;
	DDR3A_DTPR2 = 0x5002C200;

	//5.f.	Program BL=0, CL, WR, and PD=1 in the Mode Register 0 (address offset 0x054). 
	//All other fields must be left at their default values.

	DDR3A_MR0 = 0x00001A60; //50


	//5.g.	Program DIC, RTT, and TDQS in the Mode Register 1 (address offset 0x058). 
	//All other fields must be left at their default values.

	DDR3A_MR1 = 0x00000006;


	//---------------------------------------------------------------------------------------------------------					

	//5.h.	Program Mode Register 2 (address offset 0x05C).
	// Maintaining default values of Program Mode Register 2
	DDR3A_MR2 = 0x00000050;

	//5.i.	Program DTMPR=1, DTEXD, DTEXG, RANKEN=1 or 3, and RFSHDT=7 in the Data Training Configuration Register (address offset 0x068). 
	//All other fields must be left at their default values.
	DDR3A_DTCR = 0x710035C7; //0x730035C7;

	//5.j.	Program tREFPRD=(5*tREFI/ddr_clk_period) in the PHY General Configuration Register 2 (address offset 0x08C). 
	//All other fields must be left at their default values.

	DDR3A_PGCR2 = 0x00F065B9; //NOBUB = 0, FXDLAT = 0 	
	//DDR3A_PGCR2 = 0x00F83D09; //NOBUB = 0, FXDLAT = 1 

	//Set Impedence Register	
	DDR3A_ZQ0CR1 = 0x0000007B; 
	DDR3A_ZQ1CR1 = 0x0000007B;
	DDR3A_ZQ2CR1 = 0x0000007B;
	//DDR3A_ZQ3CR1 = 0x0000005D;

	//6.	Re-trigger PHY initialization in DDR PHY through the VBUSP interface.
	//6.a.	Program 0x00000033 to the PHY Initialization Register (address offset 0x004) to re-trigger PLL, ZCAL, and DCAL initialization.

	DDR3A_PIR = 0x00000033;

	//6.b.	Poll for IDONE=1 in the PHY General Status Register 0 (address offset 0x010).
	do { 
		read_val = DDR3A_PGSR0;
	} while ((read_val&0x00000001) != 0x00000001);

	//---------------------------------------------------------------------------------------------------------					



	// 7.	Trigger DDR3 initialization and leveling/training in DDR PHY through the VBUSP interface.
	// a.	If using a 16-bit wide DDR interface, program DXEN=0 in the DATX8 2-7 General Configuration Registers (address offsets 0x240, 0x280, 0x2C0, 0x300, 0x340, and 0x380) to disable the leveling/training for the upper byte lanes.
	// b.	If using a 32-bit wide DDR interface, program DXEN=0 in the DATX8 4-7 General Configuration Registers (address offsets 0x2C0, 0x300, 0x340, and 0x380) to disable the leveling/training for the upper byte lanes.
	// c.	If ECC is not required, program DXEN=0 in the DATX8 8 General Configuration Register (address offset 0x3C0) to disable the leveling/training for the ECC byte lane.
	// NOTE: Setup supports 64-bit by default,  ECC enable by default.

	//7.d.	Program 0x0000XF81 to the PHY Initialization Register (address offset 0x004) to trigger DDR3 initialization and leveling/training sequences 

	DDR3A_PIR = 0x0000FF81; //WLADJ - ON
	//DDR3A_PIR = 0x00000781;  //WLADJ - OFF


	//---------------------------------------------------------------------------------------------------------					

	//7.e.	Poll for IDONE=1 in the PHY General Status Register 0 (address offset 0x010).
	do {              
		read_val = DDR3A_PGSR0;
	} while ((read_val&0x00000001) != 0x00000001);


	/* End PHY Configuration */		
	//---------------------------------------------------------------------------------------------------------					
	/* START EMIF INITIALIZATION
  ++++++++++++++++++SDCFG Register Calculation+++++++++++++++++++
  | 31 - 29  | 28 |27 - 25 | 24   | 23 - 22| 21 - 17 |
  |SDRAM_TYPE|Rsvd|DDR_TERM| DDQS | DYN_ODT|  Rsvd   |
  |  0x011   |  0 | 0x011  | 0x1  |   0x00 |   0x0   |

  | 16-14 |13 - 12 |  11 - 8 |  7   |6 - 5 |  4  |  3  |  2  |  1 - 0  |
  |   CWL | NM     |   CL    | Rsvd |IBANK | Rsvd|EBANK| Rsvd|PAGE_SIZE|
  |  0x11 | 0x00   |  0x1110 |  0x0 | 0x11 | 0x0 |  0  |  0  |   0x10  |
  SDCFG = 0x0110 0011 0010 0010 0011 0011 1011 0010
  SDCFG = 0x6700486A;//0x63223332

  SDRAM_TYPE = 3
  DDR_TERM = 3 (RZQ/4 = 1; RZQ/6=3)
  DDQS = 1 
  DYN_ODT = 0 

  CWL = 3 (CWL5=0; CWL6=1; CWL7=2; CWL8=3)
  NM = 0 (64-bit=0, 32-bit=1, 16-bit=2)
  CL = 14 (CL5=2; CL6=4; CL7=6; CL8=8; CL9=10; CL10=12; CL11=14)
  IBANK = 3 (8bank)
  EBANK = 0 (0 - pad_cs_o_n[0] , 1 - pad_cs_o_n[1:0])
  PAGE_SIZE = 2 (1024page-size=2; 2048page-size=3)
	 */
	/* Start DDR3A EMIF Configuration */
	//8.	Configure the EMIF through the VBUSM interface.
	//8.a.	Program all EMIF MMR\92s.
	DDR3A_SDCFG    = 0x62009C62; // 9A62//0x62008C62	;//0x6600CE62=single rank,0x6600CE6A=dual rank

	DDR3A_SDTIM1   = 0x125C7C44;
	DDR3A_SDTIM2   = 0x00001D08;
	DDR3A_SDTIM3   = 0x31C1FF43;
	DDR3A_SDTIM4   = 0x543F06AF;

	DDR3A_ZQCFG    = 0x70073200; 	
	//8.b.	Program reg_initref_dis=0 in the SDRAM Refresh Control Register (address offset 0x10).
	DDR3A_SDRFC = 0x00001457;

	GEL_TextOut("DDR3A initialization complete \n");
	/* End  DDR3A EMIF Configuration */
}


/*--------------------------------------------------
	 		DDR3A : DDR1600,64bit  
---------------------------------------------------*/

ddr3A_64bit_DDR1600_setup()	
{
	unsigned int multiplier = 7;
	unsigned int divider = 0;
	int temp;
	unsigned int OD_val = 2;
	KICK0 = 0x83E70B13;
	KICK1 = 0x95A4F1E0;


	//1.	Poll for IDONE=1 in the PHY General Status Register 0 (address offset 0x010).
	do { 
		read_val = DDR3A_PGSR0;
	} while ((read_val&0x00000001) != 0x00000001);

	//4.	Clocks are enabled and frequency is stable---------------------------------------
	//DDR3A PLL setup	
	GEL_TextOut ( "DDR3 PLL (PLL2) Setup ... \n");
	//DDR3APLLCTL0 = DDR3APLLCTL0 & 0xFF7FFFFF;
	//	Set ENSAT = 1
	DDR3APLLCTL1 |= 0x00000040;
	// Put the PLL in PLL Mode  
	DDR3APLLCTL0 |= 0x00800000;
	// In PLL Controller, reset the PLL (bit 13 in DDR3APLLCTL1 register) 
	DDR3APLLCTL1 |= 0x00002000;
	// Program the necessary multipliers/dividers and BW adjustments            
	// Set the divider values 
	DDR3APLLCTL0 &= ~(0x0000003F);
	DDR3APLLCTL0 |= (divider & 0x0000003F);
	/* Step 7: Programming OD[3:0] in the SECCTL register */            
	DDR3APLLCTL0 &= OUTPUT_DIVIDE_MASK;  // clear the OD bit field
	DDR3APLLCTL0 |= ~OUTPUT_DIVIDE_MASK & (OD_val - 1) << OUTPUT_DIVIDE_OFFSET;  // set the OD[3:0] bit field of PLLD to OD_val    

	/* Set the Multipler values */
	DDR3APLLCTL0 &= ~(0x0007FFC0);
	DDR3APLLCTL0 |= ((multiplier << 6) & 0x0007FFC0 );
	temp = ((multiplier + 1) >> 1) - 1;
	DDR3APLLCTL0 &= ~(0xFF000000); 
	DDR3APLLCTL0 |= ((temp << 24) & 0xFF000000);
	DDR3APLLCTL1 &= ~(0x0000000F);
	DDR3APLLCTL1 |= ((temp >> 8) & 0x0000000F);
	//In DDR3PLLCTL1, write PLLRST = 0 to bring PLL out of reset 
	DDR3APLLCTL1 &= ~(0x00002000);
	// Put the PLL in PLL Mode  
	DDR3APLLCTL0 &= ~(0x00800000); // ReSet the Bit 23
	GEL_TextOut( "DDR3 PLL Setup complete, DDR3A clock now running at 800 MHz.\n" );
	//DDR3A PLL setup complete ---------------------------------------

	/*------------------------- Start PHY Configuration -------------------------------*/

	//DDR3A_PGCR1 = 0x0280C487;

	//5.a	Program FRQSEL in the PLL Control Register (address offset 0x018).
	DDR3A_PLLCR = 0x1C000; //Set FRQSEL=00, for ctl_clk between 335-533MHz

	//5.b.	Program WLSTEP=1, IODDRM=1, and ZCKSEL in the PHY General Configuration Register 1 (address offset 0x00C). 
	DDR3A_PGCR1 |= (1 << 2); //WLSTEP = 1

	DDR3A_PGCR1 &= ~(IODDRM_MASK);
	DDR3A_PGCR1 |= (( 1 << 7) & IODDRM_MASK);


	DDR3A_PGCR1 &= ~(ZCKSEL_MASK);
	DDR3A_PGCR1 |= (( 1 << 23) & ZCKSEL_MASK);


	//5.c.	Program PHY Timing Parameters Register 0-4 (address offset 0x01C - 0x02C).

	DDR3A_PTR0 = 0x426213CF;

	DDR3A_PTR1 = 0xCFC712B3;

	// Maintaining default values of Phy Timing Parameters Register 2 in PUB

	DDR3A_PTR3 = 0x08861A80;//0x072515C2; //0x0B4515C2;//0x18061A80; 

	DDR3A_PTR4 = 0x0C827100;//0x0AAE7100;

	//5.d.	Program PDQ, MPRDQ, and BYTEMASK in the DRAM Configuration Register (address offset 0x044). 
	//		All other fields must be left at their default values.

	DDR3A_DCR &= ~(PDQ_MASK); //PDQ = 0

	DDR3A_DCR &= ~(MPRDQ_MASK); //MPRDQ = 0

	DDR3A_DCR &= ~(BYTEMASK_MASK);
	DDR3A_DCR |= (( 1 << 10) & BYTEMASK_MASK);


	DDR3A_DCR &= ~(NOSRA_MASK);
	DDR3A_DCR |= (( 1 << 27) & NOSRA_MASK);


	//DDR3A_DCR &= ~(UDIMM_MASK);
	//DDR3A_DCR |= (( 1 << 29) & UDIMM_MASK);


	//5.e.	Program DRAM Timing Parameters Register 0-2 (address offset 0x048 - 0x050). 

	DDR3A_DTPR0 = 0x011CBB66;//0x85589975;//0x8558AA55;
	DDR3A_DTPR1 = 0x12840300;//0x12835A80;//0x12857280;
	DDR3A_DTPR2 = 0x5002CE00;

	//5.f.	Program BL=0, CL, WR, and PD=1 in the Mode Register 0 (address offset 0x054). 
	//All other fields must be left at their default values.

	DDR3A_MR0 = 0x00001C70; //50


	//5.g.	Program DIC, RTT, and TDQS in the Mode Register 1 (address offset 0x058). 
	//All other fields must be left at their default values.

	DDR3A_MR1 = 0x00000006;


	//---------------------------------------------------------------------------------------------------------					

	//5.h.	Program Mode Register 2 (address offset 0x05C).
	// Maintaining default values of Program Mode Register 2
	DDR3A_MR2 = 0x00000058;

	//5.i.	Program DTMPR=1, DTEXD, DTEXG, RANKEN=1 or 3, and RFSHDT=7 in the Data Training Configuration Register (address offset 0x068). 
	//All other fields must be left at their default values.
	DDR3A_DTCR = 0x710035C7; //0x730035C7;

	//5.j.	Program tREFPRD=(5*tREFI/ddr_clk_period) in the PHY General Configuration Register 2 (address offset 0x08C). 
	//All other fields must be left at their default values.

	DDR3A_PGCR2 = 0x00F07A12; //NOBUB = 0, FXDLAT = 0 	
	//DDR3A_PGCR2 = 0x00F83D09; //NOBUB = 0, FXDLAT = 1 

	//Set Impedence Register	
	DDR3A_ZQ0CR1 = 0x0000007B; 
	DDR3A_ZQ1CR1 = 0x0000007B;
	DDR3A_ZQ2CR1 = 0x0000007B;
	//DDR3A_ZQ3CR1 = 0x0000005D;

	//6.	Re-trigger PHY initialization in DDR PHY through the VBUSP interface.
	//6.a.	Program 0x00000033 to the PHY Initialization Register (address offset 0x004) to re-trigger PLL, ZCAL, and DCAL initialization.

	DDR3A_PIR = 0x00000033;

	//6.b.	Poll for IDONE=1 in the PHY General Status Register 0 (address offset 0x010).
	do { 
		read_val = DDR3A_PGSR0;
	} while ((read_val&0x00000001) != 0x00000001);

	//---------------------------------------------------------------------------------------------------------					



	// 7.	Trigger DDR3 initialization and leveling/training in DDR PHY through the VBUSP interface.
	// a.	If using a 16-bit wide DDR interface, program DXEN=0 in the DATX8 2-7 General Configuration Registers (address offsets 0x240, 0x280, 0x2C0, 0x300, 0x340, and 0x380) to disable the leveling/training for the upper byte lanes.
	// b.	If using a 32-bit wide DDR interface, program DXEN=0 in the DATX8 4-7 General Configuration Registers (address offsets 0x2C0, 0x300, 0x340, and 0x380) to disable the leveling/training for the upper byte lanes.
	// c.	If ECC is not required, program DXEN=0 in the DATX8 8 General Configuration Register (address offset 0x3C0) to disable the leveling/training for the ECC byte lane.
	// NOTE: Setup supports 64-bit by default,  ECC enable by default.

	//7.d.	Program 0x0000XF81 to the PHY Initialization Register (address offset 0x004) to trigger DDR3 initialization and leveling/training sequences 

	DDR3A_PIR = 0x0000FF81; //WLADJ - ON
	//DDR3A_PIR = 0x00000781;  //WLADJ - OFF


	//---------------------------------------------------------------------------------------------------------					

	//7.e.	Poll for IDONE=1 in the PHY General Status Register 0 (address offset 0x010).
	do {              
		read_val = DDR3A_PGSR0;
	} while ((read_val&0x00000001) != 0x00000001);


	/* End PHY Configuration */		
	//---------------------------------------------------------------------------------------------------------					
	/* START EMIF INITIALIZATION
  ++++++++++++++++++SDCFG Register Calculation+++++++++++++++++++
  | 31 - 29  | 28 |27 - 25 | 24   | 23 - 22| 21 - 17 |
  |SDRAM_TYPE|Rsvd|DDR_TERM| DDQS | DYN_ODT|  Rsvd   |
  |  0x011   |  0 | 0x011  | 0x1  |   0x00 |   0x0   |

  | 16-14 |13 - 12 |  11 - 8 |  7   |6 - 5 |  4  |  3  |  2  |  1 - 0  |
  |   CWL | NM     |   CL    | Rsvd |IBANK | Rsvd|EBANK| Rsvd|PAGE_SIZE|
  |  0x11 | 0x00   |  0x1110 |  0x0 | 0x11 | 0x0 |  0  |  0  |   0x10  |
  SDCFG = 0x0110 0011 0010 0010 0011 0011 1011 0010
  SDCFG = 0x6700486A;//0x63223332

  SDRAM_TYPE = 3
  DDR_TERM = 3 (RZQ/4 = 1; RZQ/6=3)
  DDQS = 1 
  DYN_ODT = 0 

  CWL = 3 (CWL5=0; CWL6=1; CWL7=2; CWL8=3)
  NM = 0 (64-bit=0, 32-bit=1, 16-bit=2)
  CL = 14 (CL5=2; CL6=4; CL7=6; CL8=8; CL9=10; CL10=12; CL11=14)
  IBANK = 3 (8bank)
  EBANK = 0 (0 - pad_cs_o_n[0] , 1 - pad_cs_o_n[1:0])
  PAGE_SIZE = 2 (1024page-size=2; 2048page-size=3)
	 */
	/* Start DDR3A EMIF Configuration */
	//8.	Configure the EMIF through the VBUSM interface.
	//8.a.	Program all EMIF MMR\92s.
	DDR3A_SDCFG    = 0x6200CE62; // 9A62//0x62008C62	;//0x6600CE62=single rank,0x6600CE6A=dual rank

	DDR3A_SDTIM1   = 0x166C9455;
	DDR3A_SDTIM2   = 0x00001D4A;
	DDR3A_SDTIM3   = 0x321DFF53;
	DDR3A_SDTIM4   = 0x543F07FF;

	DDR3A_ZQCFG    = 0x70073200; 	
	//8.b.	Program reg_initref_dis=0 in the SDRAM Refresh Control Register (address offset 0x10).
	DDR3A_SDRFC = 0x00001869;

	GEL_TextOut("DDR3A initialization complete \n");
	/* End  DDR3A EMIF Configuration */
}


/*--------------------------------------------------
	 		DDR3A : DDR1600,32bit  
---------------------------------------------------*/

ddr3A_32bit_DDR1600_setup()	
{
	unsigned int multiplier = 7;
	unsigned int divider = 0;
	int temp;
	unsigned int OD_val = 2;
	KICK0 = 0x83E70B13;
	KICK1 = 0x95A4F1E0;


	//1.	Poll for IDONE=1 in the PHY General Status Register 0 (address offset 0x010).
	do { 
		read_val = DDR3A_PGSR0;
	} while ((read_val&0x00000001) != 0x00000001);

	//4.	Clocks are enabled and frequency is stable---------------------------------------
	//DDR3A PLL setup	
	GEL_TextOut ( "DDR3 PLL (PLL2) Setup ... \n");
	//DDR3APLLCTL0 = DDR3APLLCTL0 & 0xFF7FFFFF;
	//	Set ENSAT = 1
	DDR3APLLCTL1 |= 0x00000040;
	// Put the PLL in PLL Mode  
	DDR3APLLCTL0 |= 0x00800000;
	// In PLL Controller, reset the PLL (bit 13 in DDR3APLLCTL1 register) 
	DDR3APLLCTL1 |= 0x00002000;
	// Program the necessary multipliers/dividers and BW adjustments            
	// Set the divider values 
	DDR3APLLCTL0 &= ~(0x0000003F);
	DDR3APLLCTL0 |= (divider & 0x0000003F);
	/* Step 7: Programming OD[3:0] in the SECCTL register */            
	DDR3APLLCTL0 &= OUTPUT_DIVIDE_MASK;  // clear the OD bit field
	DDR3APLLCTL0 |= ~OUTPUT_DIVIDE_MASK & (OD_val - 1) << OUTPUT_DIVIDE_OFFSET;  // set the OD[3:0] bit field of PLLD to OD_val    

	/* Set the Multipler values */
	DDR3APLLCTL0 &= ~(0x0007FFC0);
	DDR3APLLCTL0 |= ((multiplier << 6) & 0x0007FFC0 );
	temp = ((multiplier + 1) >> 1) - 1;
	DDR3APLLCTL0 &= ~(0xFF000000); 
	DDR3APLLCTL0 |= ((temp << 24) & 0xFF000000);
	DDR3APLLCTL1 &= ~(0x0000000F);
	DDR3APLLCTL1 |= ((temp >> 8) & 0x0000000F);
	//In DDR3PLLCTL1, write PLLRST = 0 to bring PLL out of reset 
	DDR3APLLCTL1 &= ~(0x00002000);
	// Put the PLL in PLL Mode  
	DDR3APLLCTL0 &= ~(0x00800000); // ReSet the Bit 23
	GEL_TextOut( "DDR3 PLL Setup complete, DDR3A clock now running at 666 MHz.\n" );
	//DDR3A PLL setup complete ---------------------------------------

	/*------------------------- Start PHY Configuration -------------------------------*/

	//DDR3A_PGCR1 = 0x0280C487;

	//5.a	Program FRQSEL in the PLL Control Register (address offset 0x018).
	DDR3A_PLLCR = 0x1C000; //Set FRQSEL=00, for ctl_clk between 335-533MHz

	//5.b.	Program WLSTEP=1, IODDRM=1, and ZCKSEL in the PHY General Configuration Register 1 (address offset 0x00C). 
	DDR3A_PGCR1 |= (1 << 2); //WLSTEP = 1

	DDR3A_PGCR1 &= ~(IODDRM_MASK);
	DDR3A_PGCR1 |= (( 1 << 7) & IODDRM_MASK);


	DDR3A_PGCR1 &= ~(ZCKSEL_MASK);
	DDR3A_PGCR1 |= (( 1 << 23) & ZCKSEL_MASK);


	//5.c.	Program PHY Timing Parameters Register 0-4 (address offset 0x01C - 0x02C).

	DDR3A_PTR0 = 0x426213CF;

	DDR3A_PTR1 = 0xCFC712B3;

	// Maintaining default values of Phy Timing Parameters Register 2 in PUB

	DDR3A_PTR3 = 0x08861A80;//0x072515C2; //0x0B4515C2;//0x18061A80; 

	DDR3A_PTR4 = 0x0C827100;//0x0AAE7100;

	//5.d.	Program PDQ, MPRDQ, and BYTEMASK in the DRAM Configuration Register (address offset 0x044). 
	//		All other fields must be left at their default values.

	DDR3A_DCR &= ~(PDQ_MASK); //PDQ = 0

	DDR3A_DCR &= ~(MPRDQ_MASK); //MPRDQ = 0

	DDR3A_DCR &= ~(BYTEMASK_MASK);
	DDR3A_DCR |= (( 1 << 10) & BYTEMASK_MASK);


	DDR3A_DCR &= ~(NOSRA_MASK);
	DDR3A_DCR |= (( 1 << 27) & NOSRA_MASK);


	//DDR3A_DCR &= ~(UDIMM_MASK);
	//DDR3A_DCR |= (( 1 << 29) & UDIMM_MASK);


	//5.e.	Program DRAM Timing Parameters Register 0-2 (address offset 0x048 - 0x050). 

	DDR3A_DTPR0 = 0x011CBB66;//0x85589975;//0x8558AA55;
	DDR3A_DTPR1 = 0x12840300;//0x12835A80;//0x12857280;
	DDR3A_DTPR2 = 0x5002CE00;

	//5.f.	Program BL=0, CL, WR, and PD=1 in the Mode Register 0 (address offset 0x054). 
	//All other fields must be left at their default values.

	DDR3A_MR0 = 0x00001C70; //50


	//5.g.	Program DIC, RTT, and TDQS in the Mode Register 1 (address offset 0x058). 
	//All other fields must be left at their default values.

	DDR3A_MR1 = 0x00000006;


	//---------------------------------------------------------------------------------------------------------					

	//5.h.	Program Mode Register 2 (address offset 0x05C).
	// Maintaining default values of Program Mode Register 2
	DDR3A_MR2 = 0x00000058;

	//5.i.	Program DTMPR=1, DTEXD, DTEXG, RANKEN=1 or 3, and RFSHDT=7 in the Data Training Configuration Register (address offset 0x068). 
	//All other fields must be left at their default values.
	DDR3A_DTCR = 0x710035C7; //0x730035C7;

	//5.j.	Program tREFPRD=(5*tREFI/ddr_clk_period) in the PHY General Configuration Register 2 (address offset 0x08C). 
	//All other fields must be left at their default values.

	DDR3A_PGCR2 = 0x00F07A12; //NOBUB = 0, FXDLAT = 0 	
	//DDR3A_PGCR2 = 0x00F83D09; //NOBUB = 0, FXDLAT = 1 

	//Set Impedence Register	
	DDR3A_ZQ0CR1 = 0x0000007B; 
	DDR3A_ZQ1CR1 = 0x0000007B;
	DDR3A_ZQ2CR1 = 0x0000007B;
	//DDR3A_ZQ3CR1 = 0x0000005D;

	//6.	Re-trigger PHY initialization in DDR PHY through the VBUSP interface.
	//6.a.	Program 0x00000033 to the PHY Initialization Register (address offset 0x004) to re-trigger PLL, ZCAL, and DCAL initialization.

	DDR3A_PIR = 0x00000033;

	//6.b.	Poll for IDONE=1 in the PHY General Status Register 0 (address offset 0x010).
	do { 
		read_val = DDR3A_PGSR0;
	} while ((read_val&0x00000001) != 0x00000001);

	//---------------------------------------------------------------------------------------------------------					



	// 7.	Trigger DDR3 initialization and leveling/training in DDR PHY through the VBUSP interface.
	// a.	If using a 16-bit wide DDR interface, program DXEN=0 in the DATX8 2-7 General Configuration Registers (address offsets 0x240, 0x280, 0x2C0, 0x300, 0x340, and 0x380) to disable the leveling/training for the upper byte lanes.
	// b.	If using a 32-bit wide DDR interface, program DXEN=0 in the DATX8 4-7 General Configuration Registers (address offsets 0x2C0, 0x300, 0x340, and 0x380) to disable the leveling/training for the upper byte lanes.
	// c.	If ECC is not required, program DXEN=0 in the DATX8 8 General Configuration Register (address offset 0x3C0) to disable the leveling/training for the ECC byte lane.
	// NOTE: Setup supports 64-bit by default,  ECC enable by default.

	//7.d.	Program 0x0000XF81 to the PHY Initialization Register (address offset 0x004) to trigger DDR3 initialization and leveling/training sequences 

	DDR3A_PIR = 0x0000FF81; //WLADJ - ON
	//DDR3A_PIR = 0x00000781;  //WLADJ - OFF


	//---------------------------------------------------------------------------------------------------------					

	//7.e.	Poll for IDONE=1 in the PHY General Status Register 0 (address offset 0x010).
	do {              
		read_val = DDR3A_PGSR0;
	} while ((read_val&0x00000001) != 0x00000001);


	/* End PHY Configuration */		
	//---------------------------------------------------------------------------------------------------------					
	/* START EMIF INITIALIZATION
  ++++++++++++++++++SDCFG Register Calculation+++++++++++++++++++
  | 31 - 29  | 28 |27 - 25 | 24   | 23 - 22| 21 - 17 |
  |SDRAM_TYPE|Rsvd|DDR_TERM| DDQS | DYN_ODT|  Rsvd   |
  |  0x011   |  0 | 0x011  | 0x1  |   0x00 |   0x0   |

  | 16-14 |13 - 12 |  11 - 8 |  7   |6 - 5 |  4  |  3  |  2  |  1 - 0  |
  |   CWL | NM     |   CL    | Rsvd |IBANK | Rsvd|EBANK| Rsvd|PAGE_SIZE|
  |  0x11 | 0x00   |  0x1110 |  0x0 | 0x11 | 0x0 |  0  |  0  |   0x10  |
  SDCFG = 0x0110 0011 0010 0010 0011 0011 1011 0010
  SDCFG = 0x6700486A;//0x63223332

  SDRAM_TYPE = 3
  DDR_TERM = 3 (RZQ/4 = 1; RZQ/6=3)
  DDQS = 1 
  DYN_ODT = 0 

  CWL = 3 (CWL5=0; CWL6=1; CWL7=2; CWL8=3)
  NM = 0 (64-bit=0, 32-bit=1, 16-bit=2)
  CL = 14 (CL5=2; CL6=4; CL7=6; CL8=8; CL9=10; CL10=12; CL11=14)
  IBANK = 3 (8bank)
  EBANK = 0 (0 - pad_cs_o_n[0] , 1 - pad_cs_o_n[1:0])
  PAGE_SIZE = 2 (1024page-size=2; 2048page-size=3)
	 */
	/* Start DDR3A EMIF Configuration */
	//8.	Configure the EMIF through the VBUSM interface.
	//8.a.	Program all EMIF MMR\92s.
	DDR3A_SDCFG    = 0x6200DE62; // 9A62//0x62008C62	;//0x6600CE62=single rank,0x6600CE6A=dual rank

	DDR3A_SDTIM1   = 0x166C9455;
	DDR3A_SDTIM2   = 0x00001D4A;
	DDR3A_SDTIM3   = 0x321DFF53;
	DDR3A_SDTIM4   = 0x543F07FF;

	DDR3A_ZQCFG    = 0x70073200; 	
	//8.b.	Program reg_initref_dis=0 in the SDRAM Refresh Control Register (address offset 0x10).
	DDR3A_SDRFC = 0x00001869;

	GEL_TextOut("DDR3A initialization complete \n");
	/* End  DDR3A EMIF Configuration */
}

/*--------------------------------------------------------------*/
/* TCI66x MENU                                              */
/*--------------------------------------------------------------*/

menuitem "TCI66x Functions";

/****************************************************************************
 *
 * NAME
 *      Global_Default_Setup
 *
 * PURPOSE:
 *      Setup almost everything ready for a new debug session:
 *      DSP modules and EVM board modules.
 *
 * USAGE
 *      This routine can be called as:
 *
 *      Global_Default_Setup()
 *
 * RETURN VALUE
 *      NONE
 *
 * REFERENCE
 *
 ****************************************************************************/
hotmenu Global_Default_Setup()
{
	GEL_TextOut( "Global Default Setup...\n" );
	Global_Default_Setup_Silent();
	GEL_TextOut( "Global Default Setup... Done.\n" );
}

hotmenu Reset()
{
	GEL_Reset();
}

hotmenu InitXMC()
{
	xmc_setup();
}

hotmenu CORE_PLL_INIT_100MHZ_to_614_28MHz()
{
	Set_Pll1(1); // call Set_Pll1 with index = 1 -> 100 MHz to 614.28 MHz operation 
}

hotmenu CORE_PLL_INIT_100MHZ_to_737_5MHz()
{
	Set_Pll1(2); // call Set_Pll1 with index = 2 -> 100 MHz to 737.5 MHz operation 
}

hotmenu CORE_PLL_INIT_100MHZ_to_1GHz()
{
	Set_Pll1(3); // call Set_Pll1 with index = 3 -> 100 MHz to 1 GHz operation 
}

hotmenu CORE_PLL_INIT_100MHZ_to_1_2GHz()
{
	Set_Pll1(4); // call Set_Pll1 with index = 4 -> 100 MHz  to 1.2 GHz operation 
}


hotmenu CORE_PLL_INIT_100MHZ_to_1_35Gz()
{
	Set_Pll1(5); // call Set_Pll1 with index = 5 -> 100 MHz  to 1.35 GHz operation 
}

hotmenu TETRIS_POWERUP_AND_PLL_INIT_100MHZ_to_1000MHz()
{
	Set_Tetris_Pll(1); // 100 MHz to 1.0 GHz operation 
}

hotmenu TETRIS_POWERUP_AND_PLL_INIT_100MHZ_to_1400MHz()
{
	Set_Tetris_Pll(2); // 100 MHz to 1.4 GHz operation 
}

hotmenu TETRIS_POWERUP_AND_PLL_INIT_175MHZ_to_1400MHz()
{
	Set_Tetris_Pll(3); // 175 MHz to 1.4 GHz operation 
}


hotmenu PA_PLL_COnfig()
{
	PaPllConfig();
}

hotmenu InitDDR3A_32bit_DDR800()
{
	ddr3A_32bit_DDR800_setup();
}   

hotmenu InitDDR3A_32bit_DDR1066()
{
	ddr3A_32bit_DDR1066_setup();
} 
hotmenu InitDDR3A_32bit_DDR1333()
{
	ddr3A_32bit_DDR1333_setup();
}   

hotmenu InitDDR3A_32bit_DDR1600()
{
	ddr3A_32bit_DDR1600_setup();
} 
hotmenu InitDDR3A_64bit_DDR1600()
{
	ddr3A_64bit_DDR1600_setup();
} 
///* Function to enable CORE PLL observation clock for PLL output *///
hotmenu ENABLE_CORE_PLL_OBSCLK()
{
	/* Unlock Chip Level Registers */
	KICK0 = KICK0_UNLOCK;
	KICK1 = KICK1_UNLOCK;

	/* set bit 1 to enable power to the CORE PLL observation clock, clear bit 0 to view the CORE PLL observation (output) clock */
	OBSCLKCTL |= (1 << 1);  /* set bit 1 to enable power to the observation clock */
	OBSCLKCTL &= ~(1 << 0); /* clear bit 0 to view the CORE PLL clock */ 

	/* Lock Chip Level Registers */
	KICK0 = 0x00000000;
	KICK1 = 0x00000000;

	GEL_TextOut("CORE PLL observation clock enabled and configured to show CORE PLL output\n");
}

/* Function to enable DDR PLL observation clock for PLL output */
hotmenu ENABLE_DDR_PLL_OBSCLK ()
{
	/* Unlock Chip Level Registers */
	KICK0 = KICK0_UNLOCK;
	KICK1 = KICK1_UNLOCK;

	/* set bit 1 to enable power to the CORE PLL observation clock, clear bit 0 to view the CORE PLL observation (output) clock */
	OBSCLKCTL |= (1 << 3);  /* set bit 3 to enable power to the observation clock */
	OBSCLKCTL |= (1 << 2);  /* set bit 2 to view the DDR PLL clock */ 

	/* Lock Chip Level Registers */
	//KICK0 = 0x00000000;
	// KICK1 = 0x00000000;

	GEL_TextOut("DDR PLL observation clock enabled and configured to show DDR PLL output\n");
}

hotmenu ENABLE_ARM_PLL_OBSCLK ()
{
	/* Unlock Chip Level Registers */
	KICK0 = KICK0_UNLOCK;
	KICK1 = KICK1_UNLOCK;

	/* set bit 1 to enable power to the CORE PLL observation clock, clear bit 0 to view the CORE PLL observation (output) clock */
	//OBSCLKCTL |= (1 << 3);  /* set bit 3 to enable power to the observation clock */
	OBSCLKCTL |= (1 << 6);  /* set bit 2 to view the DDR PLL clock */ 

	/* Lock Chip Level Registers */
	KICK0 = 0x00000000;
	KICK1 = 0x00000000;

	GEL_TextOut("DDR PLL observation clock enabled and configured to show DDR PLL output\n");
}

hotmenu ENABLE_PA_PLL_OBSCLK ()
{
	/* Unlock Chip Level Registers */
	KICK0 = KICK0_UNLOCK;
	KICK1 = KICK1_UNLOCK;

	/* set bit 1 to enable power to the CORE PLL observation clock, clear bit 0 to view the CORE PLL observation (output) clock */
	OBSCLKCTL |= (1 << 4);  /* set bit 3 to enable power to the observation clock */
	OBSCLKCTL |= (1 << 5);  /* set bit 2 to view the DDR PLL clock */ 

	/* Lock Chip Level Registers */
	KICK0 = 0x00000000;
	KICK1 = 0x00000000;

	GEL_TextOut("DDR PLL observation clock enabled and configured to show DDR PLL output\n");
}

hotmenu ddr3A_write_read_test()
{
	//int data_set[4];
	//= {0xAAAAAAAA, 0x55555555, 0xFFFFFFFF, 0x00000000};
	unsigned int write_data = 0xAAAAAAAA;
	unsigned int read_data = 0x0;
	unsigned int errors = 0;
	int dw;
	unsigned int i, mem_start, mem_size, mem_location;
	mem_start = DDR3A_BASE_ADDRESS + (DNUM * 0x01000000);
	mem_size = 0x100;
	for(dw=0;dw<4;dw++)
	{
		if (dw == 0) write_data = 0xAAAAAAAA;
		if (dw == 1) write_data = 0x55555555;
		if (dw == 2) write_data = 0xFFFFFFFF;
		if (dw == 3) write_data = 0x00000000;
		mem_location = mem_start;
		GEL_TextOut( "Memory Test Write Core: %d, Mem Start: 0x%x, Mem Size: 0x%x, value: 0x%x ...\n",,2,,,DNUM,mem_start,mem_size,write_data);
		for(i=0;i<mem_size;i++)
		{
			*( unsigned int* )(mem_location) = write_data;
			mem_location += 4;
		}
		mem_location = mem_start;
		GEL_TextOut( "Memory Test Read Core: %d, Mem Start: 0x%x, Mem Size: 0x%x ...\n",,2,,,DNUM,mem_start,mem_size);
		for (i=0;i<mem_size;i++)
		{
			read_data = *( unsigned int* )(mem_location);
			if (read_data != write_data)
			{
				GEL_TextOut("DDR3 Data Error: DSP Core: %d, Mem Addr: 0x%x, read: 0x%x, expected: 0x%x \n",,2,,,DNUM,(DDR3_BASE_ADDRESS + (i * 4)),read_data,write_data);
				errors++;
			}
			mem_location += 4;
		}
		if (errors == 0)
		{
			GEL_TextOut( "Memory Test Done, no errors found.\n" );
		}
		else
		{
			GEL_TextOut("Memory Test Done, %d errors were encounterd. \n",,2,,,errors);
		}
	}
	GEL_TextOut( "All Memory Test Completed on core: %d with %d errors.\n",,2,,,DNUM,errors);

}

menuitem "DSP CLOCK Estimation";

#define TIMER_TSC             (1)    // The timer used for polling TSCH/TSCL  
#define TIMER_TSC_POLL_PERIOD (10)   // Every 10 seconds
unsigned int gPollPeriod = TIMER_TISC_POLL_PERIOD;
unsigned int gTSCL = 0;
unsigned int gTSCH = 0;              // Global var for holding previous read of TSCL/H
unsigned int gNumberPoll=0;          // Number of pulling */
unsigned int gLoopCount=0;



hotmenu dspEnableTsc()
{
	//GEL_TextOut( "dspEnableTsc - write a value to TSCL to enable it\n" );
	if( GEL_IsHalted() ) {
		TSCL = 0;  // A write to TSCL will enable TSC (timestamp counter)
		GEL_Run();
	} else {
		GEL_Halt();
		TSCL = 0;
		GEL_Run();
	}
}


hotmenu dspDumpTsc()
{
	unsigned int tscl, tsch;
	tscl = TSCL;  /* note: need to read TSCL first */
	tsch = TSCH;
	GEL_TextOut( "dspEnableTsc - TSCH=%x, TSCL=%x\n",,,,, tscl, tsch );
}


dspPollTsc()
{
	unsigned int tscl, tsch;
	unsigned long long tsc1, tsc2;

	if( gLoopCount <= gNumberPoll) { 
		//GEL_EnableRealtime();
		GEL_Halt();
		tscl = TSCL;            /* The read time can be considered as variations */
		tsch = TSCH;            /* The read won't cause variation */
		//GEL_DisableRealtime();
		GEL_Run();
		tsc2  = (((unsigned long long) tsch)<<32) +  tscl;
		tsc1  = (((unsigned long long)gTSCH)<<32) + gTSCL;
		gTSCL = tscl;
		gTSCH = tsch;

		//tsc1 = (tsc2-tsc1)/TIMER_TSC_POLL_PERIOD;
		tsc1 = (tsc2-tsc1)/gPollPeriod;

		GEL_TextOut( "dspPollTsc - [TSCH,TSCL] = [%x, %x], freq=%dhz, i=%d\n",,,,,
				gTSCH, gTSCL, (tsc1), gLoopCount);
	}

	if( gLoopCount>=gNumberPoll ) {
		dspCancelTscTimer();
	} else {  
		gLoopCount++;
	}
}


//
// To cancel the Timer - TIMER_TSC, after using it. Otherwise, it will continue running.
//
hotmenu dspCancelTscTimer()
{
	GEL_TextOut( "dspCancelTscTimer\n");
	GEL_CancelTimer( TIMER_TSC );
}


//
// To poll the DSP clock.
//
dialog dspPollDSPClockFreq(
		pollPeriod   "Polling period (sec) - the longer, the more accurate!",
		numberOfPoll "Number of Polls" )
{
	gPollPeriod = pollPeriod;

	GEL_TextOut( "dspPollDSPClockFreq with - pollPeriod=%dsec, numberOfPoll=%d\n"
			,,,,, gPollPeriod, numberOfPoll);

	gNumberPoll = numberOfPoll-1;
	gLoopCount  = 0;
	dspEnableTsc();

	// Get the initial value of TSC
	//GEL_EnableRealtime();
	GEL_Halt();
	gTSCL = TSCL;            /* The read time can be considered as variations */
	gTSCH = TSCH;            /* The read won't cause variation */
	//GEL_DisableRealtime();
	GEL_Run();

	GEL_SetTimer( gPollPeriod*1000, TIMER_TSC, "dspPollTsc()");

}



#define MDIO_VERSION_REG            (*(unsigned int *) (0x24200F00 + 0x00))
/* mdio_user_access_reg */
#define MDIO_USER_ACCESS_REG            (*(unsigned int *) (0x24200F00 + 0x80))
#define MDIO_USER_CONTROL_REG            (*(unsigned int *) (0x24200F00 + 0x04))
#define MDIO_USER_INT_MASK_REG            (*(unsigned int *) (0x24200F00 + 0x28))

/* shift and mask for MDIO_USER_ACCESS_REG */
#define CSL_MDIO_USER_ACCESS_REG_DATA_MASK (0x0000FFFFu)
#define CSL_MDIO_USER_ACCESS_REG_DATA_SHIFT (0x00000000u)
#define CSL_MDIO_USER_ACCESS_REG_DATA_RESETVAL (0x00000000u)

#define CSL_MDIO_USER_ACCESS_REG_PHYADR_MASK (0x001F0000u)
#define CSL_MDIO_USER_ACCESS_REG_PHYADR_SHIFT (0x00000010u)
#define CSL_MDIO_USER_ACCESS_REG_PHYADR_RESETVAL (0x00000000u)

#define CSL_MDIO_USER_ACCESS_REG_REGADR_MASK (0x03E00000u)
#define CSL_MDIO_USER_ACCESS_REG_REGADR_SHIFT (0x00000015u)
#define CSL_MDIO_USER_ACCESS_REG_REGADR_RESETVAL (0x00000000u)

#define CSL_MDIO_USER_ACCESS_REG_ACK_MASK (0x20000000u)
#define CSL_MDIO_USER_ACCESS_REG_ACK_SHIFT (0x0000001Du)
#define CSL_MDIO_USER_ACCESS_REG_ACK_RESETVAL (0x00000000u)

#define CSL_MDIO_USER_ACCESS_REG_WRITE_MASK (0x40000000u)
#define CSL_MDIO_USER_ACCESS_REG_WRITE_SHIFT (0x0000001Eu)
#define CSL_MDIO_USER_ACCESS_REG_WRITE_RESETVAL (0x00000000u)

#define CSL_MDIO_USER_ACCESS_REG_GO_MASK (0x80000000u)
#define CSL_MDIO_USER_ACCESS_REG_GO_SHIFT (0x0000001Fu)
#define CSL_MDIO_USER_ACCESS_REG_GO_RESETVAL (0x00000000u)

/*
#define CSL_FMK(PER_REG_FIELD, val)                                         \
    (((val) << CSL_##PER_REG_FIELD##_SHIFT) & CSL_##PER_REG_FIELD##_MASK)

#define CSL_FEXT(reg, PER_REG_FIELD)                                        \
    (((reg) & CSL_##PER_REG_FIELD##_MASK) >> CSL_##PER_REG_FIELD##_SHIFT)
#endif
 */

/* the Field MaKe macro */
#define CSL_FMK(SHIFT, MASK, val) 		(((val) << SHIFT) & MASK)

/* the Field EXTract macro */
#define CSL_FEXT(reg, SHIFT, MASK) 		(((reg) & MASK) >> SHIFT)


#define PHY_REG_PAGE_ADDR 22

phy_hwwrite(unsigned short phy_addr, unsigned short addr, unsigned short val)
{
	unsigned int retVal=1;
	unsigned int i, delay=2000;
	
	MDIO_USER_ACCESS_REG   =  CSL_FMK (CSL_MDIO_USER_ACCESS_REG_GO_SHIFT, CSL_MDIO_USER_ACCESS_REG_GO_MASK, 1u) |
			CSL_FMK (CSL_MDIO_USER_ACCESS_REG_WRITE_SHIFT, CSL_MDIO_USER_ACCESS_REG_WRITE_MASK, 1) |
			CSL_FMK (CSL_MDIO_USER_ACCESS_REG_REGADR_SHIFT, CSL_MDIO_USER_ACCESS_REG_REGADR_MASK, addr) |
			CSL_FMK (CSL_MDIO_USER_ACCESS_REG_PHYADR_SHIFT, CSL_MDIO_USER_ACCESS_REG_PHYADR_MASK, phy_addr) |
			CSL_FMK (CSL_MDIO_USER_ACCESS_REG_DATA_SHIFT, CSL_MDIO_USER_ACCESS_REG_DATA_MASK, val);

	
	while(1)
	{
		retVal=CSL_FEXT(MDIO_USER_ACCESS_REG, CSL_MDIO_USER_ACCESS_REG_GO_SHIFT, CSL_MDIO_USER_ACCESS_REG_GO_MASK);
		if(retVal == 0)
			break;

		for(i = 0; i < delay; i++); // this delay is much more than required   

	}
}

phy_hwread(unsigned short phy_addr, unsigned short addr, unsigned short *val)
{

	MDIO_USER_ACCESS_REG =  CSL_FMK (CSL_MDIO_USER_ACCESS_REG_GO_SHIFT, CSL_MDIO_USER_ACCESS_REG_GO_MASK, 1u) |
			CSL_FMK (CSL_MDIO_USER_ACCESS_REG_REGADR_SHIFT, CSL_MDIO_USER_ACCESS_REG_REGADR_MASK, addr) |
			CSL_FMK (CSL_MDIO_USER_ACCESS_REG_PHYADR_SHIFT, CSL_MDIO_USER_ACCESS_REG_PHYADR_MASK, phy_addr);

	PHYREG0_waitResultsAck(*val, ack);

	if(!ack)
		GEL_TextOut("Reg read error for PHY: %d\n",,,,, phy_addr);
}

#define PHYREG0_waitResultsAck( results, ack ) {                                        \
		results = CSL_FEXT( MDIO_USER_ACCESS_REG, CSL_MDIO_USER_ACCESS_REG_DATA_SHIFT, CSL_MDIO_USER_ACCESS_REG_DATA_MASK);        \
		ack = CSL_FEXT( MDIO_USER_ACCESS_REG, CSL_MDIO_USER_ACCESS_REG_ACK_SHIFT, CSL_MDIO_USER_ACCESS_REG_ACK_MASK); }

phy_miiread (unsigned short phyaddr, unsigned short page, unsigned int addr, unsigned short *val)
{
	phy_hwwrite(phyaddr, PHY_REG_PAGE_ADDR, page);
	phy_hwread(phyaddr, addr, val);
}

phy_miiwrite(unsigned short phyaddr, unsigned short page, unsigned short addr, unsigned short val)
{
	phy_hwwrite(phyaddr, PHY_REG_PAGE_ADDR, page);
	phy_hwwrite(phyaddr, addr, val);
}

_setupPhy100MbMaster(unsigned short phyaddr)
{
	unsigned short val;

	GEL_TextOut("Staring Setup for PHY: %d\n",,,,, phyaddr);

	/* Register settings as per RN section 3.1 */
	phy_hwwrite(phyaddr, 22, 0x00ff);
	phy_hwwrite(phyaddr, 17, 0x214B);
	phy_hwwrite(phyaddr, 16, 0x2144);
	phy_hwwrite(phyaddr, 17, 0x0C28);
	phy_hwwrite(phyaddr, 16, 0x2146);
	phy_hwwrite(phyaddr, 17, 0xB233);
	phy_hwwrite(phyaddr, 16, 0x214D);
	phy_hwwrite(phyaddr, 17, 0xCC0C);
	phy_hwwrite(phyaddr, 16, 0x2159);
	phy_hwwrite(phyaddr, 22, 0x0000);
	phy_hwwrite(phyaddr, 9, 0x1800); //Set master
	GEL_TextOut("Misc register done for PHY: %d\n",,,,, phyaddr);

	/* Set SGMII to Copper mode Page 18, Reg 20.2:0 = 1  */
	phy_hwwrite(phyaddr, 22, 18);
	phy_hwwrite(phyaddr, 20, 0x1);
	/* PHY Reset Page 18, Reg 20.15 = 1  */
	phy_hwwrite(phyaddr, 20, 0x8201);
	phy_hwwrite(phyaddr, 22, 00);

	GEL_TextOut("Waiting for copper link up for PHY: %d\n",,,,, phyaddr);

}

hotmenu setupPhy100MbMaster()
{
	GEL_TextOut("Reading MDIO_VERSION_REG.\n");
	GEL_TextOut("MDIO_VERSION_REG: %x\n",,,,, MDIO_VERSION_REG);
	MDIO_USER_CONTROL_REG = (1 << 30) | 0xFA;
	MDIO_USER_INT_MASK_REG = 0x00;
	_setupPhy100MbMaster(0);
	//_setupPhy(1);
}

_setupPhy1GbSlave(unsigned short phyaddr)
{
        unsigned short val;

        GEL_TextOut("Staring Setup for PHY: %d\n",,,,, phyaddr);

        /* Register settings as per RN section 3.1 */
        phy_hwwrite(phyaddr, 22, 0x00ff);
        phy_hwwrite(phyaddr, 17, 0x214B);
        phy_hwwrite(phyaddr, 16, 0x2144);
        phy_hwwrite(phyaddr, 17, 0x0C28);
        phy_hwwrite(phyaddr, 16, 0x2146);
        phy_hwwrite(phyaddr, 17, 0xB233);
        phy_hwwrite(phyaddr, 16, 0x214D);
        phy_hwwrite(phyaddr, 17, 0xCC0C);
        phy_hwwrite(phyaddr, 16, 0x2159);
        phy_hwwrite(phyaddr, 22, 0x0000);
        phy_hwwrite(phyaddr, 9, 0x1B00); //Set Slave
        GEL_TextOut("Misc register done for PHY: %d\n",,,,, phyaddr);

        /* Set SGMII to Copper mode Page 18, Reg 20.2:0 = 1  */
        phy_hwwrite(phyaddr, 22, 18);
        phy_hwwrite(phyaddr, 20, 0x1);
        /* PHY Reset Page 18, Reg 20.15 = 1  */
        phy_hwwrite(phyaddr, 20, 0x8201);
        phy_hwwrite(phyaddr, 22, 00);

        GEL_TextOut("Waiting for copper link up for PHY: %d\n",,,,, phyaddr);

}

hotmenu setupPhy1GbSlave()
{
        GEL_TextOut("Reading MDIO_VERSION_REG.\n");
        GEL_TextOut("MDIO_VERSION_REG: %x\n",,,,, MDIO_VERSION_REG);
        MDIO_USER_CONTROL_REG = (1 << 30) | 0xFA;
        MDIO_USER_INT_MASK_REG = 0x00;
        _setupPhy1GbSlave(0);
	_setupPhy1GbSlave(1);
        //_setupPhy(1);
}

hotmenu K2E_TakeDSPOutofReset()
{
	K2E_out_of_reset();
}

