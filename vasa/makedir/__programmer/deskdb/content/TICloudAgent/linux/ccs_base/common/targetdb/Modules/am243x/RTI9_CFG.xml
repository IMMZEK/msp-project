<module name="RTI9_CFG" acronym="" XML_version="1.0" HW_revision="n/a" description="">
	<register id="CFG_GCTRL" acronym="CFG_GCTRL" offset="0x0" width="32" description="">
		<bitfield id="NTUSEL" width="4" begin="19" end="16" resetval="0x0" description="  These bits determine which NTU input signal is used as external timebase. There are up to  four inputs supported with four valid selection combinations. Any invalid selection value  written to the NTUSEL bit-field will result in a TIED LOW being used as the NTU signal. The  NTU signal will also be TIED LOW in case of a single-bit flip as it will result in an invalid  combination of NTUSEL.  User and privilege mode (read):  0000 = NTU0  0101 = NTU1  1010 = NTU2  1111 = NTU3  other = tied to '0'  Privilege mode (write):  0000 = NTU0  0101 = NTU1  1010 = NTU2  1111 = NTU3  other = tied to '0' " range="19 - 16" rwaccess="R/W"/> 
		<bitfield id="COS" width="1" begin="15" end="15" resetval="0x0" description="  This bit determines if both counters are stopped when the device goes into debug mode or  if they continue counting.  User and privilege mode (read):  0 = counters are stopped while in debug mode  1 = counters are running while in debug mode  Privilege mode (write):  0 = stop counters in debug mode  1 = continue counting in debug mode" range="15" rwaccess="R/W"/> 
		<bitfield id="CNT1EN" width="1" begin="1" end="1" resetval="0x0" description="  The CNT1EN bit starts and stops the operation of counter block 1 (UC1 and FRC1).  User and privilege mode (read):  0 = counters are stopped  1 = counters are running  Privilege mode (write):  0 = stop counters  1 = start counters " range="1" rwaccess="R/W"/> 
		<bitfield id="CNT0EN" width="1" begin="0" end="0" resetval="0x0" description="  The CNT0EN bit starts and stops the operation of counter block 0 (UC0 and FRC0).  User and privilege mode (read):  0 = counters are stopped  1 = counters are running  Privilege mode (write):  0 = stop counters  1 = start counters" range="0" rwaccess="R/W"/>
	</register>
	<register id="CFG_TBCTRL" acronym="CFG_TBCTRL" offset="0x4" width="32" description="">
		<bitfield id="INC" width="1" begin="1" end="1" resetval="0x0" description="  This bit determines wether the Free Running Counter 0 is automatically incremented if a  failing clock on the NTUx signal is detected.  User and privilege mode (read):  0 = FRC0 will not be incremented  1 = FRC0 will be incremented  Privilege mode (write):  0 = Do not increment FRC0 on failing external clock  1 = Increment FRC0 on failing external clock " range="1" rwaccess="R/W"/> 
		<bitfield id="TBEXT" width="1" begin="0" end="0" resetval="0x0" description="  The Timebase External bit selects whether the Free Running Counter 0 is clocked by the  internal Up Counter 0 or from the external signal NTUx. Since setting the TBEXT bit to 1  resets Up Counter 0, Free Running Counter 0 will not be incremented in this occurence.  The only source which is able to increment Free Running Counter 0 is NTUx.  When the Timebase Supervisor circuit detects a missing clockedge, then the TBEXT bit is  reset.  The selection if the external signal should be used, can only be done by software.  User and privilege mode (read):  0 = UC0 clocks FRC0  1 = NTUx clocks FRC0  Privilege mode (write):  0 = MUX is switched to internal UC0 clocking scheme  1 = MUX is switched to external NTUx clocking scheme" range="0" rwaccess="R/W"/>
	</register>
	<register id="CFG_CAPCTRL" acronym="CFG_CAPCTRL" offset="0x8" width="32" description="">
		<bitfield id="CAPCNTR1" width="1" begin="1" end="1" resetval="0x0" description="  This bit determines, which external interrupt source triggers a capture event of both UC1  and FRC1.  User and privilege mode (read):  0 = capture event is triggered by Capture Event Source 0  1 = capture event is triggered by Capture Event Source 1  Privilege mode (write):  0 = enable capture event triggered by Capture Event Source 0  1 = enable capture event triggered by Capture Event Source 1 " range="1" rwaccess="R/W"/> 
		<bitfield id="CAPCNTR0" width="1" begin="0" end="0" resetval="0x0" description="  This bit determines, which external interrupt source triggers a capture event of both UC0  and FRC0.  User and privilege mode (read):  0 = capture event is triggered by Capture Event Source 0  1 = capture event is triggered by Capture Event Source 1  Privilege mode (write):  0 = enable capture event triggered by Capture Event Source 0  1 = enable capture event triggered by Capture Event Source 1" range="0" rwaccess="R/W"/>
	</register>
	<register id="CFG_COMPCTRL" acronym="CFG_COMPCTRL" offset="0xC" width="32" description="">
		<bitfield id="COMPSEL3" width="1" begin="12" end="12" resetval="0x0" description="  This bit determines the counter with which the compare value hold in compare register 3 is  compared.  User and privilege mode (read):  0 = value will be compared with FRC 0  1 = value will be compared with FRC 1  Privilege mode (write):  0 = enable compare with FRC 0  1 = enable compare with FRC 1 " range="12" rwaccess="R/W"/> 
		<bitfield id="COMPSEL2" width="1" begin="8" end="8" resetval="0x0" description="  This bit determines the counter with which the compare value hold in compare register 2 is  compared.  User and privilege mode (read):  0 = value will be compared with FRC 0  1 = value will be compared with FRC 1  Privilege mode (write):  0 = enable compare with FRC 0  1 = enable compare with FRC 1 " range="8" rwaccess="R/W"/> 
		<bitfield id="COMPSEL1" width="1" begin="4" end="4" resetval="0x0" description="  This bit determines the counter with which the compare value hold in compare register 1 is  compared. User and privilege mode (read):  0 = value will be compared with FRC 0  1 = value will be compared with FRC 1  Privilege mode (write):  0 = enable compare with FRC 0  1 = enable compare with FRC 1 " range="4" rwaccess="R/W"/> 
		<bitfield id="COMPSEL0" width="1" begin="0" end="0" resetval="0x0" description="  This bit determines the counter with which the compare value hold in compare register 0 is  compared.  User and privilege mode (read):  0 = value will be compared with FRC 0  1 = value will be compared with FRC 1  Privilege mode (write):  0 = enable compare with FRC 0  1 = enable compare with FRC 1" range="0" rwaccess="R/W"/>
	</register>
	<register id="CFG_FRC0" acronym="CFG_FRC0" offset="0x10" width="32" description="">
		<bitfield id="FRC0" width="32" begin="31" end="0" resetval="0x0" description="  This registers holds the current value of the Free Running Counter 0 and will be updated  continuously.  User and privilege mode (read):  current value of the counter  Privilege mode (write):  The counter can be preset by writing to this register. The counter increments then from this  written value upwards.  Note: Presetting counters  If counters have to be preset, they have to be stopped from counting in the RTIGCTRL  register in order to ensure consistency between RTIUC0 and RTIFRC0." range="31 - 0" rwaccess="R/W"/>
	</register>
	<register id="CFG_UC0" acronym="CFG_UC0" offset="0x14" width="32" description="">
		<bitfield id="UC0" width="32" begin="31" end="0" resetval="0x0" description="  This registers holds the current value of the Up Counter 0 and prescales the RTI clock. It  will be only updated by a previous read of Free Running Counter 0. This gives effectively a  64 bit read of both counters, without having the problem of a counter being updated  between two consecutive reads on Up Counter 0 and Free Running Counter 0.  User and privilege mode (read):  value of the counter when the Free Running Counter 0 was read  Privilege mode (write):  the counter can be preset by writing to this register. The counter increments then from this  written value upwards.  Note: Presetting counters  If counters have to be preset, they have to be stopped from counting in the RTIGCTRL  register in order to ensure consistency between RTIUC0 and RTIFRC0.  Note: Preset value concern  If the preset value is bigger than the compare value stored in register RTICPUC0 then  it can take a long time until a compare matches, since RTIUC0 has to count up until  it overflows." range="31 - 0" rwaccess="R/W"/>
	</register>
	<register id="CFG_CPUC0" acronym="CFG_CPUC0" offset="0x18" width="32" description="">
		<bitfield id="CPUC0" width="32" begin="31" end="0" resetval="0x0" description="  This registers holds the compare value, which is compared with the Up Counter 0. When  the compare matches, Free Running counter 0 is incremented. The Up Counter is set to  zero when the counter value matches the CPUC0 value. The value set in this prescales the  RTI clock.  If CPUC0 = 0: fFRC0 = R-----T---I---C----L----K--  232  If CPUC0 0: fFRC0 = ----R----T----I--C-----L---K-------  CPUC0 + 1  User and privilege mode (read):  current compare value  Privilege mode (write when TBEXT = 0):  the compare value is updated  Privilege mode (write when TBEXT = 1):  the compare value is not changed" range="31 - 0" rwaccess="R/W"/>
	</register>
	<register id="CFG_CAFRC0" acronym="CFG_CAFRC0" offset="0x20" width="32" description="">
		<bitfield id="CAFRC0" width="32" begin="31" end="0" resetval="0x0" description="  This registers captures the current value of the Free Running Counter 0 when a event  occurs, controlled by the external capture control block.  User and privilege mode (read):  value of Free Running Counter 0 on a capture event" range="31 - 0" rwaccess="R"/>
	</register>
	<register id="CFG_CAUC0" acronym="CFG_CAUC0" offset="0x24" width="32" description="">
		<bitfield id="CAUC0" width="32" begin="31" end="0" resetval="0x0" description="  This registers captures the current value of the Up Counter 0 when a event occurs,  controlled by the external capture control block. The read sequence has to be the same as  with Up Counter 0 and Free Running Counter 0. So the RTICAFRC0 register has to be  read first, before the RTICAUC0 register is read. This sequence ensures that the value of  the RTICAUC0 register is the corresponding value to the RTICAFRC0 register, even if  another capture event happens in between the two reads.  User and privilege mode (read):  value of Up Counter 0 on a capture event" range="31 - 0" rwaccess="R"/>
	</register>
	<register id="CFG_FRC1" acronym="CFG_FRC1" offset="0x30" width="32" description="">
		<bitfield id="FRC1" width="32" begin="31" end="0" resetval="0x0" description="  This registers holds the current value of the Free Running Counter 1 and will be updated  continuously.  User and privilege mode (read):  current value of the counter  Privilege mode (write):  the counter can be preset by writing to this register. The counter increments then from this  written value upwards.  Note: Presetting counters  If counters have to be preset, they have to be stopped from counting in the RTIGCTRL  register in order to ensure consistency between UC1 and FRC1." range="31 - 0" rwaccess="R/W"/>
	</register>
	<register id="CFG_UC1" acronym="CFG_UC1" offset="0x34" width="32" description="">
		<bitfield id="UC1" width="32" begin="31" end="0" resetval="0x0" description="  This registers holds the current value of the Up Counter 1 and prescales the RTI clock. It  will be only updated by a previous read of Free Running Counter 1. This gives effectively a  64 bit read of both counters, without having the problem of a counter being updated  between two consecutive reads on Up Counter 1 and Free Running Counter 1.  User and privilege mode (read):  value of the counter when the Free Running Counter 1 was read  Privilege mode (write):  the counter can be preset by writing to this register. The counter increments then from this  written value upwards.  Note: Presetting counters  If counters have to be preset, they have to be disabled in the RTIGCTRL register in  order to ensure consistency between UC1 and FRC1.  Note: Preset value concern  If the preset value is bigger than the compare value stored in register RTICPUC1 then  it can take a long time until a compare matches, since UC1 has to count up until it  overflows." range="31 - 0" rwaccess="R/W"/>
	</register>
	<register id="CFG_CPUC1" acronym="CFG_CPUC1" offset="0x38" width="32" description="">
		<bitfield id="CPUC1" width="32" begin="31" end="0" resetval="0x0" description="  This registers holds the compare value, which is compared with the Up Counter 1. When  the compare matches, Free Running Counter 1 is incremented. The Up Counter is set to  zero when the counter value matches the CPUC1 value. The value set in this prescales the  RTI clock.  If CPUC1 = 0: fFRC1 = R-----T---I---C----L----K--  232  If CPUC1 0: fFRC1 = ----R----T----I--C-----L---K-------  CPUC1 + 1  User and privilege mode (read):  current compare value  Privilege mode (write):  the compare value is updated" range="31 - 0" rwaccess="R/W"/>
	</register>
	<register id="CFG_CAFRC1" acronym="CFG_CAFRC1" offset="0x40" width="32" description="">
		<bitfield id="CAFRC1" width="32" begin="31" end="0" resetval="0x0" description="  This registers captures the current value of the Free Running Counter 1 when a event  occurs, controlled by the external capture control block.  User and privilege mode (read):  value of Free Running Counter 1 on a capture event" range="31 - 0" rwaccess="R"/>
	</register>
	<register id="CFG_CAUC1" acronym="CFG_CAUC1" offset="0x44" width="32" description="">
		<bitfield id="CAUC1" width="32" begin="31" end="0" resetval="0x0" description="  This registers captures the current value of the Up Counter 1 when a event occurs,  controlled by the external capture control block. The read sequence has to be the same as  with Up Counter 1 and Free Running Counter 1. So the RTICAFRC1 register has to be  read first, before the RTICAUC1 register is read. This sequence ensures that the value of  the RTICAUC0 register is the corresponding value to the RTICAFRC0 register, even if  another capture event happens in between the two reads.  User and privilege mode (read):  value of Up Counter 1 on a capture event" range="31 - 0" rwaccess="R"/>
	</register>
	<register id="CFG_COMP0" acronym="CFG_COMP0" offset="0x50" width="32" description="">
		<bitfield id="COMP0" width="32" begin="31" end="0" resetval="0x0" description="  This registers holds a compare value, which is compared with the counter selected in the  compare control logic. If the Free Running Counter matches the compare value, an  interrupt is flagged. With this register it is also possible to initiate a DMA request.  User and privilege mode (read):  current compare value  Privilege mode (write):  update of the compare register with a new compare value  Note: Reset behavior  A reset does not generate a compare match, since the compare logic will only be  active, when the associated counter block is enabled." range="31 - 0" rwaccess="R/W"/>
	</register>
	<register id="CFG_UDCP0" acronym="CFG_UDCP0" offset="0x54" width="32" description="">
		<bitfield id="UDCP0" width="32" begin="31" end="0" resetval="0x0" description="  This registers holds a value, which is added to the value in the compare 0 register each  time a compare matches. This gives the possibility to generate periodic interrupts without  software intervention.  User and privilege mode (read):  value to be added to the compare 0 register on the next compare match  Privilege mode (write):  new update value" range="31 - 0" rwaccess="R/W"/>
	</register>
	<register id="CFG_COMP1" acronym="CFG_COMP1" offset="0x58" width="32" description="">
		<bitfield id="COMP1" width="32" begin="31" end="0" resetval="0x0" description="  This registers holds a compare value, which is compared with the counter selected in the  compare control logic. If the Free Running Counter matches the compare value, an  interrupt is flagged. With this register it is also possible to initiate a DMA request.  User and privilege mode (read):  current compare value  Privilege mode (write):  update of the compare register with a new compare value  Note: Reset behavior  A reset does not generate a compare match, since the compare logic will only be  active, when the associated counter block is enabled." range="31 - 0" rwaccess="R/W"/>
	</register>
	<register id="CFG_UDCP1" acronym="CFG_UDCP1" offset="0x5C" width="32" description="">
		<bitfield id="UDCP1" width="32" begin="31" end="0" resetval="0x0" description="  This registers holds a value, which is added to the value in the compare 1 register each  time a compare matches. This gives the possibility to generate periodic interrupts without  software intervention.  User and privilege mode (read):  value to be added to the compare 1 register on the next compare match  Privilege mode (write):  new update value" range="31 - 0" rwaccess="R/W"/>
	</register>
	<register id="CFG_COMP2" acronym="CFG_COMP2" offset="0x60" width="32" description="">
		<bitfield id="COMP2" width="32" begin="31" end="0" resetval="0x0" description="  This registers holds a compare value, which is compared with the counter selected in the  compare control logic. If the Free Running Counter matches the compare value, an  interrupt is flagged. With this register it is also possible to initiate a DMA request.  User and privilege mode (read):  current compare value  Privilege mode (write):  update of the compare register with a new compare value  Note: Reset behavior  A reset does not generate a compare match, since the compare logic will only be  active, when the associated counter block is enabled." range="31 - 0" rwaccess="R/W"/>
	</register>
	<register id="CFG_UDCP2" acronym="CFG_UDCP2" offset="0x64" width="32" description="">
		<bitfield id="UDCP2" width="32" begin="31" end="0" resetval="0x0" description="  This registers holds a value, which is added to the value in the compare 2 register each  time a compare matches. This gives the possibility to generate periodic interrupts without  software intervention.  User and privilege mode (read):  value to be added to the compare 2 register on the next compare match  Privilege mode (write):  new update value" range="31 - 0" rwaccess="R/W"/>
	</register>
	<register id="CFG_COMP3" acronym="CFG_COMP3" offset="0x68" width="32" description="">
		<bitfield id="COMP3" width="32" begin="31" end="0" resetval="0x0" description="  This registers holds a compare value, which is compared with the counter selected in the  compare control logic. If the Free Running Counter matches the compare value, an  interrupt is flagged. With this register it is also possible to initiate a DMA request.  User and privilege mode (read):  current compare value  Privilege mode (write):  update of the compare register with a new compare value  Note: Reset behavior  A reset does not generate a compare match, since the compare logic will only be  active, when the associated counter block is enabled." range="31 - 0" rwaccess="R/W"/>
	</register>
	<register id="CFG_UDCP3" acronym="CFG_UDCP3" offset="0x6C" width="32" description="">
		<bitfield id="UDCP3" width="32" begin="31" end="0" resetval="0x0" description="  This registers holds a value, which is added to the value in the compare 3 register each  time a compare matches. This gives the possibility to generate periodic interrupts without  software intervention.  User and privilege mode (read):  value to be added to the compare 3 register on the next compare match  Privilege mode (write):  new update value" range="31 - 0" rwaccess="R/W"/>
	</register>
	<register id="CFG_TBLCOMP" acronym="CFG_TBLCOMP" offset="0x70" width="32" description="">
		<bitfield id="TBLCOMP" width="32" begin="31" end="0" resetval="0x0" description="  This value determines when the edge detection circuit starts monitoring the NTUx signal. It  will be compared with Up Counter 0.  User and privilege mode (read):  current compare value  Privilege mode (write when TBEXT = 0):  the compare value is updated  Privilege mode (write when TBEXT = 1):  the compare value is not changed  Note: Reset behavior  A reset does not generate a compare match." range="31 - 0" rwaccess="R/W"/>
	</register>
	<register id="CFG_TBHCOMP" acronym="CFG_TBHCOMP" offset="0x74" width="32" description="">
		<bitfield id="TBHCOMP" width="32" begin="31" end="0" resetval="0x0" description="  This value determines when the edge detection circuit will stop monitoring the NTUx signal.  It will be compared with Up Counter 0.  RTITBHCOMP has to be less than RTICPUC0, since RTIUC0 will be reset when  RTICPUC0 is reached.  Example:  The NTUx edge detection circuit should be active +/- 10 RTICLK cycles around RTICPUC0.  RTICPUC0 = 0x00000050  RTITBLCOMP = 0x000046  RTITBHCOMP = 0x00000009  User and privilege mode (read):  current compare value  Privilege mode (write when TBEXT = 0):  the compare value is updated  Privilege mode (write when TBEXT = 1):  the compare value is not changed  Note: Reset behavior  A reset does not generate a compare match." range="31 - 0" rwaccess="R/W"/>
	</register>
	<register id="CFG_SETINT" acronym="CFG_SETINT" offset="0x80" width="32" description="">
		<bitfield id="SETOVL1INT" width="1" begin="18" end="18" resetval="0x0" description="  User and privilege mode (read):  0 = interrupt is disabled  1 = interrupt is enabled  Privilege mode (write):  0 = leaves the corresponding bit unchanged  1 = enable interrupt " range="18" rwaccess="R/W1TS"/> 
		<bitfield id="SETOVL0INT" width="1" begin="17" end="17" resetval="0x0" description="  User and privilege mode (read):  0 = interrupt is disabled  1 = interrupt is enabled  Privilege mode (write):  0 = leaves the corresponding bit unchanged  1 = enable interrupt " range="17" rwaccess="R/W1TS"/> 
		<bitfield id="SETTBINT" width="1" begin="16" end="16" resetval="0x0" description="  User and privilege mode (read):  0 = interrupt is disabled  1 = interrupt is enabled  Privilege mode (write):  0 = leaves the corresponding bit unchanged  1 = enable interrupt " range="16" rwaccess="R/W1TS"/> 
		<bitfield id="SETDMA3" width="1" begin="11" end="11" resetval="0x0" description="  User and privilege mode (read):  0 = DMA request is disabled  1 = DMA request is enabled  Privilege mode (write):  0 = leaves the corresponding bit unchanged  1 = enable DMA request " range="11" rwaccess="R/W1TS"/> 
		<bitfield id="SETDMA2" width="1" begin="10" end="10" resetval="0x0" description="  User and privilege mode (read):  0 = DMA request is disabled  1 = DMA request is enabled  Privilege mode (write):  0 = leaves the corresponding bit unchanged  1 = enable DMA request " range="10" rwaccess="R/W1TS"/> 
		<bitfield id="SETDMA1" width="1" begin="9" end="9" resetval="0x0" description="  User and privilege mode (read):  0 = DMA request is disabled  1 = DMA request is enabled  Privilege mode (write):  0 = leaves the corresponding bit unchanged  1 = enable DMA request " range="9" rwaccess="R/W1TS"/> 
		<bitfield id="SETDMA0" width="1" begin="8" end="8" resetval="0x0" description="  User and privilege mode (read):  0 = DMA request is disabled  1 = DMA request is enabled  Privilege mode (write):  0 = leaves the corresponding bit unchanged  1 = enable DMA request " range="8" rwaccess="R/W1TS"/> 
		<bitfield id="SETINT3" width="1" begin="3" end="3" resetval="0x0" description="  User and privilege mode (read):  0 = interrupt is disabled  1 = interrupt is enabled  Privilege mode (write):  0 = leaves the corresponding bit unchanged  1 = enable interrupt " range="3" rwaccess="R/W1TS"/> 
		<bitfield id="SETINT2" width="1" begin="2" end="2" resetval="0x0" description="  User and privilege mode (read):  0 = interrupt is disabled  1 = interrupt is enabled  Privilege mode (write):  0 = leaves the corresponding bit unchanged  1 = enable interrupt " range="2" rwaccess="R/W1TS"/> 
		<bitfield id="SETINT1" width="1" begin="1" end="1" resetval="0x0" description="  User and privilege mode (read):  0 = interrupt is disabled  1 = interrupt is enabled  Privilege mode (write):  0 = leaves the corresponding bit unchanged  1 = enable interrupt " range="1" rwaccess="R/W1TS"/> 
		<bitfield id="SETINT0" width="1" begin="0" end="0" resetval="0x0" description="  User and privilege mode (read):  0 = interrupt is disabled  1 = interrupt is enabled  Privilege mode (write):  0 = leaves the corresponding bit unchanged  1 = enable interrupt" range="0" rwaccess="R/W1TS"/>
	</register>
	<register id="CFG_CLEARINT" acronym="CFG_CLEARINT" offset="0x84" width="32" description="">
		<bitfield id="CLEAROVL1INT" width="1" begin="18" end="18" resetval="0x0" description="  User and privilege mode (read):  0 = interrupt is disabled  1 = interrupt is enabled  Privilege mode (write):  0 = leaves the corresponding bit unchanged  1 = disable interrupt " range="18" rwaccess="R/W1TC"/> 
		<bitfield id="CLEAROVL0INT" width="1" begin="17" end="17" resetval="0x0" description="  User and privilege mode (read):  0 = interrupt is disabled  1 = interrupt is enabled  Privilege mode (write):  0 = leaves the corresponding bit unchanged  1 = disable interrupt " range="17" rwaccess="R/W1TC"/> 
		<bitfield id="CLEARTBINT" width="1" begin="16" end="16" resetval="0x0" description="  User and privilege mode (read):  0 = interrupt is disabled  1 = interrupt is enabled  Privilege mode (write):  0 = leaves the corresponding bit unchanged  1 = disable interrupt" range="16" rwaccess="R/W1TC"/> 
		<bitfield id="CLEARDMA3" width="1" begin="11" end="11" resetval="0x0" description="  User and privilege mode (read):  0 = DMA request is disabled  1 = DMA request is enabled  Privilege mode (write):  0 = leaves the corresponding bit unchanged  1 = disable DMA request " range="11" rwaccess="R/W1TC"/> 
		<bitfield id="CLEARDMA2" width="1" begin="10" end="10" resetval="0x0" description="  User and privilege mode (read):  0 = DMA request is disabled  1 = DMA request is enabled  Privilege mode (write):  0 = leaves the corresponding bit unchanged  1 = disable DMA request " range="10" rwaccess="R/W1TC"/> 
		<bitfield id="CLEARDMA1" width="1" begin="9" end="9" resetval="0x0" description="  User and privilege mode (read):  0 = DMA request is disabled  1 = DMA request is enabled  Privilege mode (write):  0 = leaves the corresponding bit unchanged  1 = disable DMA request " range="9" rwaccess="R/W1TC"/> 
		<bitfield id="CLEARDMA0" width="1" begin="8" end="8" resetval="0x0" description="  User and privilege mode (read):  0 = DMA request is disabled  1 = DMA request is enabled  Privilege mode (write):  0 = leaves the corresponding bit unchanged  1 = disable DMA request " range="8" rwaccess="R/W1TC"/> 
		<bitfield id="CLEARINT3" width="1" begin="3" end="3" resetval="0x0" description="  User and privilege mode (read):  0 = interrupt is disabled  1 = interrupt is enabled  Privilege mode (write):  0 = leaves the corresponding bit unchanged  1 = disable interrupt " range="3" rwaccess="R/W1TC"/> 
		<bitfield id="CLEARINT2" width="1" begin="2" end="2" resetval="0x0" description="  User and privilege mode (read):  0 = interrupt is disabled  1 = interrupt is enabled  Privilege mode (write):  0 = leaves the corresponding bit unchanged  1 = disable interrupt " range="2" rwaccess="R/W1TC"/> 
		<bitfield id="CLEARINT1" width="1" begin="1" end="1" resetval="0x0" description="  User and privilege mode (read):  0 = interrupt is disabled  1 = interrupt is enabled  Privilege mode (write):  0 = leaves the corresponding bit unchanged  1 = disable interrupt " range="1" rwaccess="R/W1TC"/> 
		<bitfield id="CLEARINT0" width="1" begin="0" end="0" resetval="0x0" description="  User and privilege mode (read):  0 = interrupt is disabled  1 = interrupt is enabled  Privilege mode (write):  0 = leaves the corresponding bit unchanged  1 = disable interrupt" range="0" rwaccess="R/W1TC"/>
	</register>
	<register id="CFG_INTFLAG" acronym="CFG_INTFLAG" offset="0x88" width="32" description="">
		<bitfield id="OVL1INT" width="1" begin="18" end="18" resetval="0x0" description="  User and privilege mode (read):  determines if an interrupt is pending  0 = no interrupt pending  1 = interrupt pending  Privilege mode (write):  0 = leaves the bit unchanged  1 = set the bit to 0 " range="18" rwaccess="R/W1TC"/> 
		<bitfield id="OVL0INT" width="1" begin="17" end="17" resetval="0x0" description="  User and privilege mode (read):  determines if an interrupt is pending  0 = no interrupt pending  1 = interrupt pending  Privilege mode (write):  0 = leaves the bit unchanged  1 = set the bit to 0 " range="17" rwaccess="R/W1TC"/> 
		<bitfield id="TBINT" width="1" begin="16" end="16" resetval="0x0" description="  User and privilege mode (read):  this flag is set when the TBEXT bit is cleared by detection of a missing external clockedge.  It will not be set by clearing TBEXT by software.  determines if an interrupt is pending  0 = no interrupt pending  1 = interrupt pending  Privilege mode (write):  0 = leaves the bit unchanged  1 = set the bit to 0 " range="16" rwaccess="R/W1TC"/> 
		<bitfield id="INT3" width="1" begin="3" end="3" resetval="0x0" description="  User and privilege mode (read):  determines if a interrupt is pending  0 = no interrupt pending  1 = interrupt pending  Privilege mode (write):  0 = leaves the bit unchanged  1 = set the bit to 0 " range="3" rwaccess="R/W1TC"/> 
		<bitfield id="INT2" width="1" begin="2" end="2" resetval="0x0" description="  User and privilege mode (read):  determines if a interrupt is pending  0 = no interrupt pending  1 = interrupt pending  Privilege mode (write):  0 = leaves the bit unchanged  1 = set the bit to 0 " range="2" rwaccess="R/W1TC"/> 
		<bitfield id="INT1" width="1" begin="1" end="1" resetval="0x0" description="  User and privilege mode (read):  determines if a interrupt is pending  0 = no interrupt pending  1 = interrupt pending  Privilege mode (write):  0 = leaves the bit unchanged  1 = set the bit to 0 " range="1" rwaccess="R/W1TC"/> 
		<bitfield id="INT0" width="1" begin="0" end="0" resetval="0x0" description="  User and privilege mode (read):  determines if a interrupt is pending  0 = no interrupt pending  1 = interrupt pending  Privilege mode (write):  0 = leaves the bit unchanged  1 = set the bit to 0" range="0" rwaccess="R/W1TC"/>
	</register>
	<register id="CFG_DWDCTRL" acronym="CFG_DWDCTRL" offset="0x90" width="32" description="">
		<bitfield id="DWDCTRL" width="32" begin="31" end="0" resetval="0x1393732845" description="  User and priviledge mode (read):  0x5312ACED = DWD counter is disabled. This is the default value.  0xA98559DA = DWD counter is enabled  Any other value = DWD counter state is unchanged (enabled or disabled)  Priviledge mode (write):  0xA98559DA = DWD counter is enabled  Any other value = State of DWD counter is unchanged (stays enabled or disabled)  Note: One-Write Functionality of DWDCTRL Register  The RTIDWDCTRL register implements a one-write functionality, such that the  application cannot write to this registermore than once. Writing the default value will  not enable the watchdog as described above. Writing the enable value will start the  watchdog counters. A write to RTIDWDCTRL will only be enabled after a system reset  again." range="31 - 0" rwaccess="R/W"/>
	</register>
	<register id="CFG_DWDPRLD" acronym="CFG_DWDPRLD" offset="0x94" width="32" description="">
		<bitfield id="DWDPRLD" width="12" begin="11" end="0" resetval="0x4095" description="  User and priviledge mode (read):  A read from this register in any CPU mode returns the current preload value.  Priviledge mode (write):  If the DWD is always enabled after reset is released:  The DWD starts counting down from the reset value of the counter, that is, 0x002DFFFF.  The application can configure the DWD preload register any time before this down counter  expires.  When the application services the DWD, the preload register contents are copied left-  justified into the DWD down counter and it starts counting down from that value.  If the DWD is implemented such that the down counter is enabled by software:  The DWD preload register can be configured only when the DWD is disabled. Therefore,  the application can only configure the DWD preload register before it enables the DWD  down counter.  The expiration time of the DWD Down Counter can be determined with following equation:  texp = (RTIDWDPRLD+1) x 213 / RTICLK1  where: RTIDWDPRLD = 0...4095" range="11 - 0" rwaccess="R/W"/>
	</register>
	<register id="CFG_WDSTATUS" acronym="CFG_WDSTATUS" offset="0x98" width="32" description="">
		<bitfield id="DWWD" width="1" begin="5" end="5" resetval="0x0" description="  This bit denotes whether the time-window defined by the windowed watchdog configuration  has been violated, or if a wrong key or key sequence was written to service the watchdog.  User and priviledge mode (read):  0 = no time-window violation has occurred.  1 = a time-window violation has occurred. The watchdog will generate either a system  reset or a non-maskable interrupt to the CPU in this case.  Priviledge mode (write):  0 = leaves the current value unchanged.  1 = clears the bit to 0. This will also clear all other status flags in the RTIWDSTATUS reg-  ister except for the AWD ST flag. Clearing of the status flags will deassert the non-  maskable interrupt generated due to violation of the DWWD. " range="5" rwaccess="R/W1TC"/> 
		<bitfield id="END" width="1" begin="4" end="4" resetval="0x0" description="  This bit denotes whether the end-time defined by the windowed watchdog configuration  has been violated. This bit is effectively a copy of the DWD ST status flag.  User and priviledge mode (read):  0 = no end-time window violation has occurred.  1 = the end-time defined by the windowed watchdog configuration has been violated.  Priviledge mode (write):  0 = leaves the current value unchanged.  1 = clears the bit to 0. " range="4" rwaccess="R/W1TC"/> 
		<bitfield id="START" width="1" begin="3" end="3" resetval="0x0" description="  This bit denotes whether the start-time defined by the windowed watchdog configuration  has been violated. This indicates that the WWD was serviced before the service window  was opened.  User and priviledge mode (read):  0 = no start-time window violation has occurred.  1 = the start-time defined by the windowed watchdog configuration has been violated.  Priviledge mode (write):  0 = leaves the current value unchanged.  1 = clears the bit to 0. " range="3" rwaccess="R/W1TC"/> 
		<bitfield id="KEYST" width="1" begin="2" end="2" resetval="0x0" description="This bit denotes a reset generated by a wrong key or a wrong key-sequence written to the  RTIWDKEY register.  User and priviledge mode (read):  0 = no wrong key or key-sequence written  1 = wrong key or key-sequence written to RTIWDKEY register  Priviledge mode (write):  0 = leaves the current value unchanged  1 = clears the bit to 0 " range="2" rwaccess="R/W1TC"/> 
		<bitfield id="DWDST" width="1" begin="1" end="1" resetval="0x0" description="  status flag and is maintained for compatibility reasons.  User and priviledge mode (read):  0 = DWD timeout period not expired  1 = DWD timeout period has expired  Priviledge mode (write):  0 = leaves the current value unchanged  1 = clears the bit to 0 " range="1" rwaccess="R/W1TC"/> 
		<bitfield id="AWDST" width="1" begin="0" end="0" resetval="0x0" description="User and priviledge mode (read):  0 = AWD pin 0 > 1 threshold not exceeded  1 = AWD pin 0 > 1 threshold exceeded  Priviledge mode (write):  0 = leaves the current value unchanged  1 = clears the bit to 0" range="0" rwaccess="R/W1TC"/>
	</register>
	<register id="CFG_WDKEY" acronym="CFG_WDKEY" offset="0x9C" width="32" description="">
		<bitfield id="WDKEY" width="16" begin="15" end="0" resetval="0x41820" description="  User and privilege mode reads are indeterminate.  Privilege mode (write):  A write of 0xE51A followed by 0xA35C in two separate write operations defines the Key  Sequence and discharges the watchdog capacitor. This also causes the upper 12 bits of  the DWD down counter to be reloaded with the contents of the DWD preload register and  the lower 13 bits to become all 1's. Writing any other value causes a digital watchdog reset,  as shown in Table 1-3.  Note: Register write access time precaution  The user has to take into account that the write to the register takes 3 VCLK cycle.  This needs to be considered for the AWD/DWD expiration calculation.  Table 2. Example of a WDKEY sequence  Value written to  Step WDKEY Result  1 0x0A35C No Action  2 0x0A35C No Action  3 0x0E51A WDKEY is enabled for reset by next 0x0A35C  4 0x0E51A WDKEY is enabled for reset by next 0x0A35C  5 0x0E51A WDKEY is enabled for reset by next 0x0A35C  6 0x0A35C Watchdog is reset  7 0x0A35C No Action  8 0x0E51A WDKEY is enabled for reset by next 0x0A35C  9 0x0A35C Watchdog is reset  10 0x0E51A WDKEY is enabled for reset by next 0x0A35C  11 0x02345 System reset; incorrect value written to WDKEY" range="15 - 0" rwaccess="R/W"/>
	</register>
	<register id="CFG_DWDCNTR" acronym="CFG_DWDCNTR" offset="0xA0" width="32" description="">
		<bitfield id="DWDCNTR" width="25" begin="24" end="0" resetval="0x33554431" description="  The value of the DWDCNTR after a system reset is 0x002D_FFFF. When the DWD is  enabled and the DWD counter starts counting down from this value with an RTICLK1 time  base of 3MHz, a watchdog reset will be generated in 1 second.  User and privilege mode (read):  Reads return the current counter value.  Privilege mode (write):  Writes don't have an effect." range="24 - 0" rwaccess="R"/>
	</register>
	<register id="CFG_WWDRXNCTRL" acronym="CFG_WWDRXNCTRL" offset="0xA4" width="32" description="">
		<bitfield id="WWDRXN" width="4" begin="3" end="0" resetval="0x5" description="  User and privilege mode (read), privileged mode (write):  0x5 = This is the default value. The windowed watchdog will cause a reset if the watchdog  is serviced outside the time window defined by the configuration, or if the watchdog is not  serviced at all.  0xA = The windowed watchdog will generate a non-maskable interrupt to the CPU if the  watchdog is serviced outside the time window defined by the configuration, or if the  watchdog is not serviced at all.  Writing any other value will cause a system reset if the watchdog is serviced outside the  time window defined by the configuration, or if the watchdog is not serviced at all.  Note: Configuration of DWWD Reaction  The DWWD reaction can be selected by the application even when the DWWD  counter is already enabled.  If a change to the WWDRXN is made before the watchdog service window is opened,  then the change in the configuration takes effect immediately.  If a change to the WWDRXN is made when the watchdog service window is already  open, then the change in configuration takes effect only after the watchdog is  serviced." range="3 - 0" rwaccess="R/W"/>
	</register>
	<register id="CFG_WWDSIZECTRL" acronym="CFG_WWDSIZECTRL" offset="0xA8" width="32" description="">
		<bitfield id="WWDSIZE" width="32" begin="31" end="0" resetval="0x5" description="  User and privilege mode (read), privileged mode (write):  Table 3. Windowed Watchdog Window Size Configuration  Value written to  WWDSIZE Window Size  0x00000005 100% (The functionality is the same as the standard  time-out digital watchdog.)  0x00000050 50%  0x00000500 25%  0x00005000 12.5%  0x00050000 6.25%  0x00500000 3.125%  Any other 3.125%  value  Note: Incorrect value being written to watchdog window size control register  If an incorerct value is written to the WWDSIZE field, or if a system disturbance  causes the WWDSIZE field to have a value other than 0x5, 0x50, 0x500, 0x5000,  0x50000, or 0x500000, then the window size will be configured to be 3.125%. This  increases the chances of getting a reset due to the windowed watchdog, which  enables the system to handle the cause for the incorrect configuration.  Note: Configuration of DWWD Window Size  The DWWD window size can be selected by the application even when the DWWD  counter is already enabled.  If a change to the WWDSIZE is made before the watchdog service window is opened,  then the change in the configuration takes effect immediately.  If a change to the WWDSIZE is made when the watchdog service window is already  open, then the change in configuration takes effect only after the watchdog is  serviced." range="31 - 0" rwaccess="R/W"/>
	</register>
	<register id="CFG_INTCLRENABLE" acronym="CFG_INTCLRENABLE" offset="0xAC" width="32" description="">
		<bitfield id="INTCLRENABLE3" width="4" begin="27" end="24" resetval="0x5" description="  Enables the auto-clear functionality on the compare 3 interrupt.  User and Privileged mode (read):  0x5 = Auto-clear for compare 3 interrupt is disabled.  Any other value = Auto-clear for compare 3 interrupt is enabled.  Privileged mode (write):  0x5 = Disables the auto-clear functionality on the compare 3 interrupt.  Any other value = Enables the auto-clear functionality on the compare 3 interrupt. " range="27 - 24" rwaccess="R/W"/> 
		<bitfield id="INTCLRENABLE2" width="4" begin="19" end="16" resetval="0x5" description="  Enables the auto-clear functionality on the compare 2 interrupt.  User and Privileged mode (read):  0x5 = Auto-clear for compare 2 interrupt is disabled.  Any other value = Auto-clear for compare 2 interrupt is enabled.  Privileged mode (write):  0x5 = Disables the auto-clear functionality on the compare 2 interrupt.  Any other value = Enables the auto-clear functionality on the compare 2 interrupt. " range="19 - 16" rwaccess="R/W"/> 
		<bitfield id="INTCLRENABLE1" width="4" begin="11" end="8" resetval="0x5" description="  Enables the auto-clear functionality on the compare 1 interrupt.  User and Privileged mode (read):  0x5 = Auto-clear for compare 1 interrupt is disabled.  Any other value = Auto-clear for compare 1 interrupt is enabled.  Privileged mode (write):  0x5 = Disables the auto-clear functionality on the compare 1 interrupt.  Any other value = Enables the auto-clear functionality on the compare 1 interrupt. " range="11 - 8" rwaccess="R/W"/> 
		<bitfield id="INTCLRENABLE0" width="4" begin="3" end="0" resetval="0x5" description="  Enables the auto-clear functionality on the compare 0 interrupt.  User and Privileged mode (read):  0x5 = Auto-clear for compare 0 interrupt is disabled.  Any other value = Auto-clear for compare 0 interrupt is enabled.  Privileged mode (write):  0x5 = Disables the auto-clear functionality on the compare 0 interrupt.  Any other value = Enables the auto-clear functionality on the compare 0 interrupt.  Note: Hook-up of Compare Interrupt to a device pin  The RTI module generates up to 4 compare interrupts. The connection between one  or more of these compare interrupt(s) to a device pin is completely device-dependent.  Refer to the device datasheet to identify the actual pin(s) that connects to the compare  interrupt(s)." range="3 - 0" rwaccess="R/W"/>
	</register>
	<register id="CFG_COMP0CLR" acronym="CFG_COMP0CLR" offset="0xB0" width="32" description="">
		<bitfield id="COMP0CLR" width="32" begin="31" end="0" resetval="0x0" description="  This registers holds a compare value, which is compared with the counter selected in the  compare control logic. If the Free Running Counter matches the compare value, the  compare 0 interrupt or DMA request line is cleared.  User and privilege mode (read):  current compare value  Privilege mode (write):  update of the compare register with a new compare value  Note: Reset behavior  A reset does not generate a compare match, since the compare logic will only be  active, when the associated counter block is enabled." range="31 - 0" rwaccess="R/W"/>
	</register>
	<register id="CFG_COMP1CLR" acronym="CFG_COMP1CLR" offset="0xB4" width="32" description="">
		<bitfield id="COMP1CLR" width="32" begin="31" end="0" resetval="0x0" description="  This registers holds a compare value, which is compared with the counter selected in the  compare control logic. If the Free Running Counter matches the compare value, the  compare 1 interrupt or DMA request line is cleared.  User and privilege mode (read):  current compare value  Privilege mode (write):  update of the compare register with a new compare value  Note: Reset behavior  A reset does not generate a compare match, since the compare logic will only be  active, when the associated counter block is enabled." range="31 - 0" rwaccess="R/W"/>
	</register>
	<register id="CFG_COMP2CLR" acronym="CFG_COMP2CLR" offset="0xB8" width="32" description="">
		<bitfield id="COMP2CLR" width="32" begin="31" end="0" resetval="0x0" description="  This registers holds a compare value, which is compared with the counter selected in the  compare control logic. If the Free Running Counter matches the compare value, the  compare 2 interrupt or DMA request line is cleared.  User and privilege mode (read):  current compare value  Privilege mode (write):  update of the compare register with a new compare value  Note: Reset behavior  A reset does not generate a compare match, since the compare logic will only be  active, when the associated counter block is enabled." range="31 - 0" rwaccess="R/W"/>
	</register>
	<register id="CFG_COMP3CLR" acronym="CFG_COMP3CLR" offset="0xBC" width="32" description="">
		<bitfield id="COMP3CLR" width="32" begin="31" end="0" resetval="0x0" description="  This registers holds a compare value, which is compared with the counter selected in the  compare control logic. If the Free Running Counter matches the compare value, the  compare 3 interrupt or DMA request line is cleared.  User and privilege mode (read):  current compare value  Privilege mode (write):  update of the compare register with a new compare value  Note: Reset behavior  A reset does not generate a compare match, since the compare logic will only be  active, when the associated counter block is enabled." range="31 - 0" rwaccess="R/W"/>
	</register>
</module>