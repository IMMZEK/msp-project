<module name="VPAC0_COMMON_0_IVPAC_TOP_0_CFG_SLV_PAR_VPAC_LDC0_S_VBUSP_MMR_VBUSP" acronym="" XML_version="1.0" HW_revision="n/a" description="">
	<register id="IVPAC_TOP_0__CFG_SLV__PAR_VPAC_LDC0__S_VBUSP__MMR__VBUSP__REGS_REVISION_REG" acronym="IVPAC_TOP_0__CFG_SLV__PAR_VPAC_LDC0__S_VBUSP__MMR__VBUSP__REGS_REVISION_REG" offset="0x0" width="32" description="LDC PID">
		<bitfield id="SCHEME" width="2" begin="31" end="30" resetval="0x1" description="Used to  distinguish between old scheme and new scheme. Spare bit to encode future schemes" range="31 - 30" rwaccess="R"/> 
		<bitfield id="BU" width="2" begin="29" end="28" resetval="0x2" description="BU indicator DSPS ==> 0x0  WTBU ==> 0x1  Processors ==> 0x2" range="29 - 28" rwaccess="R"/> 
		<bitfield id="FUNC" width="12" begin="27" end="16" resetval="0x1222" description="Function indicates a software compatible module family. If there is no level of software compatibility a new FUNC number, and hence PID, should be assigned." range="27 - 16" rwaccess="R"/> 
		<bitfield id="RTL" width="5" begin="15" end="11" resetval="0x0" description="RTL Version.  R as described in PDR with additional clarifications and definitions below.  Must be easily ECO-able or controlled during fabrication.  Ideally through a top level metal mask or e-fuse. This number is maintained/owned by IP design owner.   RTL follows a numbering such as X.Y.R.Z which are explained in this table.   R changes ONLY when:  (1) PDS uploads occur which may have been due to spec changes  (2) Bug fixes occur  (3) Resets to '0' when X or Y changes.   Design team has an internal 'Z' (customer invisible) number which increments on every drop that happens due to DV and RTL updates. Z resets to 0 when R increments. " range="15 - 11" rwaccess="R"/> 
		<bitfield id="MAJOR" width="3" begin="10" end="8" resetval="0x0" description="Major Revision.   X as described in PDR with additional clarifications/definitions below. This number is owned/maintained by IP specification owner. X is part of IP numbering X.Y.R.Z.  X changes ONLY when:  (1) There is a major feature addition. An example would be adding Master Mode to Utopia Level2. The Func field (or Class/Type in old PID format) will remain the same.   X does NOT change due to:  (1) Bug fixes  (2) Change in feature parameters. " range="10 - 8" rwaccess="R"/> 
		<bitfield id="CUSTOM" width="2" begin="7" end="6" resetval="0x0" description="Indicates a special version for a particular device.  Consequence of use may avoid use of standard Chip Support Library (CSL) / Drivers.   0 if non-custom. " range="7 - 6" rwaccess="R"/> 
		<bitfield id="MINOR" width="6" begin="5" end="0" resetval="0x2" description="Minor Revision.   Y as described in PDR with additional clarifications/definitions below.  This number is owned/maintained by IP specification owner.   Y changes ONLY when:  (1) Features are scaled (up or down). Flexibility exists in that this feature scalability may either be represented in the Y change or a specific register in the IP that indicates which features are exactly available.  (2) When feature creeps from Is-Not list to Is list. But this may not be the case once it sees silicon - in which case X will change.   Y does NOT change due to:  (1) Bug fixes  (2) Typos or clarifications  (3) major functional/feature change/addition/deletion. Instead these changes may be reflected via R, S, X as applicable.   Spec owner maintains a customer-invisible number 'S' which changes due to:  (1) Typos/clarifications  (2) Bug documentation. Note that this bug is not due to a spec change but due to implementation. Nevertheless, the spec tracks the IP bugs. An RTL release (say for silicon PG1.1) that occurs due to bug fix should document the corresponding spec number (X.Y.S) in its release notes. " range="5 - 0" rwaccess="R"/>
	</register>
	<register id="IVPAC_TOP_0__CFG_SLV__PAR_VPAC_LDC0__S_VBUSP__MMR__VBUSP__REGS_PRIVATE_MEMSIZE" acronym="IVPAC_TOP_0__CFG_SLV__PAR_VPAC_LDC0__S_VBUSP__MMR__VBUSP__REGS_PRIVATE_MEMSIZE" offset="0x4" width="32" description="Memory size mentioned is for both ping and pong combined. 
 Error interrupts are generated based on the memory size available.">
		<bitfield id="MESH" width="8" begin="23" end="16" resetval="0x10" description="Mesh Private pixel memory size in KBytes" range="23 - 16" rwaccess="R"/> 
		<bitfield id="CHROMA" width="8" begin="15" end="8" resetval="0x42" description="Chroma Private pixel memory size in KBytes" range="15 - 8" rwaccess="R"/> 
		<bitfield id="LUMA" width="8" begin="7" end="0" resetval="0x42" description="Luma Private pixel memory size in KBytes" range="7 - 0" rwaccess="R"/>
	</register>
	<register id="IVPAC_TOP_0__CFG_SLV__PAR_VPAC_LDC0__S_VBUSP__MMR__VBUSP__REGS_CTRL" acronym="IVPAC_TOP_0__CFG_SLV__PAR_VPAC_LDC0__S_VBUSP__MMR__VBUSP__REGS_CTRL" offset="0x8" width="32" description="Control Register to Enable/Disable and select modes of operation">
		<bitfield id="HYBD_ADDREN" width="1" begin="24" end="24" resetval="0x0" description="Hybrid addressing scheme Enable. Enabled when part of the data stored in circular buffer and rest in Linear addressing buffers. When enabled, IP_CIRCEN should be high and can only be enabled in frame mode." range="24" rwaccess="R/W"/> 
		<bitfield id="CH_IP_DFMT" width="2" begin="18" end="17" resetval="0x1" description="Chroma Input pixel data format. Valid only independent chroma channel control is enbaled (CH_CHANCTRL_EN=1).   0: 8-bit format   1: 12-bit packed format   2: 12-bit unpacked format   3: Reserved" range="18 - 17" rwaccess="R/W"/> 
		<bitfield id="CH_CHANCTRL_EN" width="1" begin="16" end="16" resetval="0x0" description="Enable for Independent Chroma Channel parameters. Can be enabled only when chroma data is in separate buffer. When enabled, Chroma channel parameters - Input Data Format/Line Offset/Circular buffer size/hybrid addressing parameters should be programmed" range="16" rwaccess="R/W"/> 
		<bitfield id="REGMODE_EN" width="1" begin="14" end="14" resetval="0x0" description="Enables for Frame division into multiple regions. Needs to be enabled only when more than one region per frame.   0 - Disable   1 - Enable   When enabled, LDC provides option to configure independent block size parameters for each region" range="14" rwaccess="R/W"/> 
		<bitfield id="OP_DATAMODE" width="1" begin="13" end="13" resetval="0x1" description="Output Pixel Data Mode; Used when input is YUV422* mode.   0: YUV422 mode   1: convert to YUV420 output data; " range="13" rwaccess="R/W"/> 
		<bitfield id="IP_HTS_ROWSYNC" width="1" begin="12" end="12" resetval="0x0" description="Enables control of Input Fetch with HTS at Block Row level.   0 - Disable   1 - Enable   When enabled, input fetch of first block in row is gated with corresponding HTS Tstart number. This allows synchronization between VISS and LDC or/and mesh data sync at row level.   This can't be enabled when Region mode is enabled" range="12" rwaccess="R/W"/> 
		<bitfield id="IP_CIRCEN" width="1" begin="11" end="11" resetval="0x0" description="Enables circular addressing mode on input pixel fetch. Can only be enabled in Frame mode.   0 - Disable circular addressing for input data.   1 - Enable circular addressing." range="11" rwaccess="R/W"/> 
		<bitfield id="ALIGN_12BIT" width="1" begin="10" end="10" resetval="0x0" description="Alignment of 12-bit pixel in 16-bit unpacked data format on input pixel data. Common for both Luma and Chroma channels.   0 - LSB Aligned    1 - MSB Aligned " range="10" rwaccess="R/W"/> 
		<bitfield id="PWARPEN" width="1" begin="9" end="9" resetval="0x0" description="Perspective warp transform Enable. Set to 1 to enable use of PWARP_GH.G and PWARP_GH.H " range="9" rwaccess="R/W"/> 
		<bitfield id="IP_DFMT" width="2" begin="8" end="7" resetval="0x1" description="Input Pixel Data Format   0: 8-bit format   1: 12-bit packed format   2: 12-bit unpacked format   3: Reserved" range="8 - 7" rwaccess="R/W"/> 
		<bitfield id="IP_DATAMODE" width="4" begin="6" end="3" resetval="0x2" description="Input Pixel Data Mode   0: YUV422 UYVY Interleaved data   1: YUV420_Y Luma Data Only   2: YUV420 Data   3: YUV420_UV Chroma Data Only.   4: YUV422_SP Semi-Planar Data.   5: Y1_Y2 - 2 independent channel data at full resolution in separate buffers.   6: Y1_Y2Y3 - 3 independent channel data at full resolution in 2 separate buffers. Y2Y3 data is interleaved.   Program frame/block size as in full resolution frame mode" range="6 - 3" rwaccess="R/W"/> 
		<bitfield id="BUSY" width="1" begin="2" end="2" resetval="0x0" description="Idle/Busy Status,   0: Idle   1: Busy   Set on hts_init when LDC_EN is high, cleared on Frame completion" range="2" rwaccess="R"/> 
		<bitfield id="LDMAPEN" width="1" begin="1" end="1" resetval="0x0" description="Distortion Back Mapping Enable.   1: Enabled   0: Disabled" range="1" rwaccess="R/W"/> 
		<bitfield id="LDC_EN" width="1" begin="0" end="0" resetval="0x0" description="Write 1 to enable LDC function. Auto cleared by HW at the end of Frame in OneShoft mode. In continuous mode, needs to cleared by SW at the end to enter Idle condition" range="0" rwaccess="R/W"/>
	</register>
	<register id="IVPAC_TOP_0__CFG_SLV__PAR_VPAC_LDC0__S_VBUSP__MMR__VBUSP__REGS_CFG" acronym="IVPAC_TOP_0__CFG_SLV__PAR_VPAC_LDC0__S_VBUSP__MMR__VBUSP__REGS_CFG" offset="0xC" width="32" description="LDC Configuration register. 
 YINT_TYP parameter is used The YINT_TYP parameter only applies to the Y component (Luma).  If YINT_TYP = 0, Y pixels are processed using bicubic interpolation, which requires 2 cycles per pixel to process.  If YINT_TYP = 1, Y pixels are processed using bilinear interpolation, which requires 1 cycle per pixel to process. This allows a tradeoff between performance versus quality.  CbCr (Chroma) pixels are always processed using bilinear interpolation.  Thus, the overall performance of pixel processing is based on the Y interpolation type setting. Y1_Y2 &#38; Y1_Y2Y3 modes only bi-linear is allowed.">
		<bitfield id="YINT_TYP" width="1" begin="6" end="6" resetval="0x0" description="Interpolation type for Y data.   0: bicubic    1: bilinear" range="6" rwaccess="R/W"/> 
		<bitfield id="CNTU_MODE" width="1" begin="2" end="2" resetval="0x0" description="Continuous mode enable. When enabled, LDC HW won't disable at the end of frame and will start frame processing on hts_init.    0: One Shot mode (default) - LDC enable is cleared at the end of frame    1: Continous mode - LDC will continue to be enabled once set   When enabled, LDC_EN needs to be cleared for LDC to go into Idle state" range="2" rwaccess="R/W"/> 
		<bitfield id="CLKCG_OVERIDE" width="1" begin="1" end="1" resetval="0x0" description="Clock gating override control for memory clock gating for Pbist config testing" range="1" rwaccess="R/W"/>
	</register>
	<register id="IVPAC_TOP_0__CFG_SLV__PAR_VPAC_LDC0__S_VBUSP__MMR__VBUSP__REGS_MESHTABLE_CFG" acronym="IVPAC_TOP_0__CFG_SLV__PAR_VPAC_LDC0__S_VBUSP__MMR__VBUSP__REGS_MESHTABLE_CFG" offset="0x10" width="32" description="Defines the down-sampling factors used for the mesh offset tables">
		<bitfield id="M" width="3" begin="2" end="0" resetval="0x0" description="Mesh table down-sampling factor (by 2^M in both horizontal and Vertical).   0: 1 - no down-sampling   1: 2 - 2x down-sampling    2: 4    3: 8   4: 16   5: 32   6: 64   7:128" range="2 - 0" rwaccess="R/W"/>
	</register>
	<register id="IVPAC_TOP_0__CFG_SLV__PAR_VPAC_LDC0__S_VBUSP__MMR__VBUSP__REGS_MESH_FRSZ" acronym="IVPAC_TOP_0__CFG_SLV__PAR_VPAC_LDC0__S_VBUSP__MMR__VBUSP__REGS_MESH_FRSZ" offset="0x14" width="32" description="Mesh data mapping is available for this Frame size. Actual number of mesh data entires depend Mesh Frame size and Mesh sampling factor. This Frame size is independent from COMPUTE_FRSZ">
		<bitfield id="H" width="14" begin="29" end="16" resetval="0x0" description="Mesh Frame height in Lines" range="29 - 16" rwaccess="R/W"/> 
		<bitfield id="W" width="14" begin="13" end="0" resetval="0x0" description="Mesh Frame Width" range="13 - 0" rwaccess="R/W"/>
	</register>
	<register id="IVPAC_TOP_0__CFG_SLV__PAR_VPAC_LDC0__S_VBUSP__MMR__VBUSP__REGS_COMPUTE_FRSZ" acronym="IVPAC_TOP_0__CFG_SLV__PAR_VPAC_LDC0__S_VBUSP__MMR__VBUSP__REGS_COMPUTE_FRSZ" offset="0x18" width="32" description="H corresponds to the total number of lines to process.  W corresponds to the number of pixels to process in each line. This parameters must be loaded as actual pixel counts, NOT pixel counts - 1. 
 W and H must both be less than or equal to 8192.  The hardware does not support output coordinates larger than 8192.  Therefore, COMPUTE_FRSZ.W + INITXY.INITX must be no larger than 8192.  Also COMPUTE_FRSZ.H + INITXY.INITY must be no larger than 8192.">
		<bitfield id="H" width="14" begin="29" end="16" resetval="0x0" description="Output Frame height in Lines. Must be even" range="29 - 16" rwaccess="R/W"/> 
		<bitfield id="W" width="14" begin="13" end="0" resetval="0x0" description="Output Frame Width. Must be even" range="13 - 0" rwaccess="R/W"/>
	</register>
	<register id="IVPAC_TOP_0__CFG_SLV__PAR_VPAC_LDC0__S_VBUSP__MMR__VBUSP__REGS_INITXY" acronym="IVPAC_TOP_0__CFG_SLV__PAR_VPAC_LDC0__S_VBUSP__MMR__VBUSP__REGS_INITXY" offset="0x1C" width="32" description="LDC Initial Output Co-ordinate to process">
		<bitfield id="INITY" width="13" begin="28" end="16" resetval="0x0" description="Output starting Y-coordinate. must be even" range="28 - 16" rwaccess="R/W"/> 
		<bitfield id="INITX" width="13" begin="12" end="0" resetval="0x0" description="Output starting X-coordinate. must be even" range="12 - 0" rwaccess="R/W"/>
	</register>
	<register id="IVPAC_TOP_0__CFG_SLV__PAR_VPAC_LDC0__S_VBUSP__MMR__VBUSP__REGS_INPUT_FRSZ" acronym="IVPAC_TOP_0__CFG_SLV__PAR_VPAC_LDC0__S_VBUSP__MMR__VBUSP__REGS_INPUT_FRSZ" offset="0x20" width="32" description="Defines the total input frame size">
		<bitfield id="H" width="14" begin="29" end="16" resetval="0x0" description="Input Frame height in Lines. Must be even" range="29 - 16" rwaccess="R/W"/> 
		<bitfield id="W" width="14" begin="13" end="0" resetval="0x0" description="Input Frame Width in Pixels. Must be even" range="13 - 0" rwaccess="R/W"/>
	</register>
	<register id="IVPAC_TOP_0__CFG_SLV__PAR_VPAC_LDC0__S_VBUSP__MMR__VBUSP__REGS_OUT_BLKSZ" acronym="IVPAC_TOP_0__CFG_SLV__PAR_VPAC_LDC0__S_VBUSP__MMR__VBUSP__REGS_OUT_BLKSZ" offset="0x24" width="32" description="LDC Output Block parameter registers. These parameters represent actual pixel counts, NOT pixel counts - 1. OBW must be greater than 0 and less than or equal to frame width (COMPUTE_FRSZ.W).  OBH must be greater than 0 and less than or equal to frame height (COMPUTE_FRSZ.H). ">
		<bitfield id="PIXPAD" width="4" begin="19" end="16" resetval="0x0" description="Pixel pad" range="19 - 16" rwaccess="R/W"/> 
		<bitfield id="OBH" width="8" begin="15" end="8" resetval="0x0" description="Output block height must be >0 and even" range="15 - 8" rwaccess="R/W"/> 
		<bitfield id="OBW" width="8" begin="7" end="0" resetval="0x0" description="Output block width, must be >0 and multiple of 8" range="7 - 0" rwaccess="R/W"/>
	</register>
	<register id="IVPAC_TOP_0__CFG_SLV__PAR_VPAC_LDC0__S_VBUSP__MMR__VBUSP__REGS_AFF_AB" acronym="IVPAC_TOP_0__CFG_SLV__PAR_VPAC_LDC0__S_VBUSP__MMR__VBUSP__REGS_AFF_AB" offset="0x28" width="32" description="LDC Affine Transwarp A/B">
		<bitfield id="B" width="16" begin="31" end="16" resetval="0x0" description="Affine transwarp B (S16Q12)" range="31 - 16" rwaccess="R/W"/> 
		<bitfield id="A" width="16" begin="15" end="0" resetval="0x4096" description="Affine transwarp A (S16Q12)" range="15 - 0" rwaccess="R/W"/>
	</register>
	<register id="IVPAC_TOP_0__CFG_SLV__PAR_VPAC_LDC0__S_VBUSP__MMR__VBUSP__REGS_AFF_CD" acronym="IVPAC_TOP_0__CFG_SLV__PAR_VPAC_LDC0__S_VBUSP__MMR__VBUSP__REGS_AFF_CD" offset="0x2C" width="32" description="LDC Affine Transwarp C/D">
		<bitfield id="D" width="16" begin="31" end="16" resetval="0x0" description="Affine transwarp D (S16Q12)" range="31 - 16" rwaccess="R/W"/> 
		<bitfield id="C" width="16" begin="15" end="0" resetval="0x0" description="Affine transwarp C (S16Q3)" range="15 - 0" rwaccess="R/W"/>
	</register>
	<register id="IVPAC_TOP_0__CFG_SLV__PAR_VPAC_LDC0__S_VBUSP__MMR__VBUSP__REGS_AFF_EF" acronym="IVPAC_TOP_0__CFG_SLV__PAR_VPAC_LDC0__S_VBUSP__MMR__VBUSP__REGS_AFF_EF" offset="0x30" width="32" description="LDC Affine Transwarp E/F">
		<bitfield id="F" width="16" begin="31" end="16" resetval="0x0" description="Affine transwarp F (S16Q3)" range="31 - 16" rwaccess="R/W"/> 
		<bitfield id="E" width="16" begin="15" end="0" resetval="0x4096" description="Affine transwarp E (S16Q12)" range="15 - 0" rwaccess="R/W"/>
	</register>
	<register id="IVPAC_TOP_0__CFG_SLV__PAR_VPAC_LDC0__S_VBUSP__MMR__VBUSP__REGS_PWARP_GH" acronym="IVPAC_TOP_0__CFG_SLV__PAR_VPAC_LDC0__S_VBUSP__MMR__VBUSP__REGS_PWARP_GH" offset="0x34" width="32" description="LDC Perspective Transformation Parameters, G and H">
		<bitfield id="H" width="16" begin="31" end="16" resetval="0x0" description="Perspective Transformation H (S16Q23)" range="31 - 16" rwaccess="R/W"/> 
		<bitfield id="G" width="16" begin="15" end="0" resetval="0x0" description="Perspective Transformation H (S16Q23)" range="15 - 0" rwaccess="R/W"/>
	</register>
	<register id="IVPAC_TOP_0__CFG_SLV__PAR_VPAC_LDC0__S_VBUSP__MMR__VBUSP__REGS_MESH_BASE_H" acronym="IVPAC_TOP_0__CFG_SLV__PAR_VPAC_LDC0__S_VBUSP__MMR__VBUSP__REGS_MESH_BASE_H" offset="0x38" width="32" description="Higher 16-bit of Mesh Table Base Address">
		<bitfield id="ADDR" width="16" begin="15" end="0" resetval="0x0" description="Higher 16-bit of Read Base address for mesh offset table" range="15 - 0" rwaccess="R/W"/>
	</register>
	<register id="IVPAC_TOP_0__CFG_SLV__PAR_VPAC_LDC0__S_VBUSP__MMR__VBUSP__REGS_MESH_BASE_L" acronym="IVPAC_TOP_0__CFG_SLV__PAR_VPAC_LDC0__S_VBUSP__MMR__VBUSP__REGS_MESH_BASE_L" offset="0x3C" width="32" description="Lower 32-bit of Mesh Table Base Address">
		<bitfield id="ADDR" width="32" begin="31" end="0" resetval="0x0" description="Lower 32-bit of Read Base address for mesh offset table. Must be 16-byte aligned so four LSB are coded to 0" range="31 - 0" rwaccess="R/W"/>
	</register>
	<register id="IVPAC_TOP_0__CFG_SLV__PAR_VPAC_LDC0__S_VBUSP__MMR__VBUSP__REGS_MESH_OFST" acronym="IVPAC_TOP_0__CFG_SLV__PAR_VPAC_LDC0__S_VBUSP__MMR__VBUSP__REGS_MESH_OFST" offset="0x40" width="32" description="Defines the stride between rows for the Mesh table in bytes.">
		<bitfield id="OFST" width="16" begin="15" end="0" resetval="0x0" description="LDC Mesh table line offset, must be 16-byte aligned so four LSB are coded to 0" range="15 - 0" rwaccess="R/W"/>
	</register>
	<register id="IVPAC_TOP_0__CFG_SLV__PAR_VPAC_LDC0__S_VBUSP__MMR__VBUSP__REGS_RD_BASE_H" acronym="IVPAC_TOP_0__CFG_SLV__PAR_VPAC_LDC0__S_VBUSP__MMR__VBUSP__REGS_RD_BASE_H" offset="0x44" width="32" description="Higher 16-bit of Input Frame Base Address">
		<bitfield id="ADDR" width="16" begin="15" end="0" resetval="0x0" description="Higher 16-bit of Input Frame Base Address" range="15 - 0" rwaccess="R/W"/>
	</register>
	<register id="IVPAC_TOP_0__CFG_SLV__PAR_VPAC_LDC0__S_VBUSP__MMR__VBUSP__REGS_RD_BASE_L" acronym="IVPAC_TOP_0__CFG_SLV__PAR_VPAC_LDC0__S_VBUSP__MMR__VBUSP__REGS_RD_BASE_L" offset="0x48" width="32" description="Lower 32-bit of Input Frame Base Address">
		<bitfield id="ADDR" width="32" begin="31" end="0" resetval="0x0" description="Lower 32-bit of Read Base address of Input Frame Base Address. Must be 16-byte aligned so four LSB are coded to 0" range="31 - 0" rwaccess="R/W"/>
	</register>
	<register id="IVPAC_TOP_0__CFG_SLV__PAR_VPAC_LDC0__S_VBUSP__MMR__VBUSP__REGS_RD_420C_BASE_H" acronym="IVPAC_TOP_0__CFG_SLV__PAR_VPAC_LDC0__S_VBUSP__MMR__VBUSP__REGS_RD_420C_BASE_H" offset="0x4C" width="32" description="Higher 16-bit of Input Frame 420C Base Address">
		<bitfield id="ADDR" width="16" begin="15" end="0" resetval="0x0" description="Higher 16-bit of Input Frame Chroma Base Address in YUV420" range="15 - 0" rwaccess="R/W"/>
	</register>
	<register id="IVPAC_TOP_0__CFG_SLV__PAR_VPAC_LDC0__S_VBUSP__MMR__VBUSP__REGS_RD_420C_BASE_L" acronym="IVPAC_TOP_0__CFG_SLV__PAR_VPAC_LDC0__S_VBUSP__MMR__VBUSP__REGS_RD_420C_BASE_L" offset="0x50" width="32" description="Lower 32-bit of Input Frame Chroma Base Address in YUV420">
		<bitfield id="ADDR" width="32" begin="31" end="0" resetval="0x0" description="Lower 32-bit of Read Base address of Input Frame Chroma Base Address in YUV420. Must be 16-byte aligned so four LSB are coded to 0" range="31 - 0" rwaccess="R/W"/>
	</register>
	<register id="IVPAC_TOP_0__CFG_SLV__PAR_VPAC_LDC0__S_VBUSP__MMR__VBUSP__REGS_RD_OFST" acronym="IVPAC_TOP_0__CFG_SLV__PAR_VPAC_LDC0__S_VBUSP__MMR__VBUSP__REGS_RD_OFST" offset="0x54" width="32" description="Define stride between lines in the Input Frame in bytes and circular buffer height">
		<bitfield id="MOD" width="14" begin="29" end="16" resetval="0x0" description="Sets the circular buffer size if circular buffering mode is used. The circular buffer is sized in terms of number of lines and has to be multiple of 2" range="29 - 16" rwaccess="R/W"/> 
		<bitfield id="OFST" width="16" begin="15" end="0" resetval="0x0" description="Read frame line offset, must be 16-byte aligned so internally [3:0] bits are hard-wired zero. OFST is common for Luma and Chroma in YUV420 mode" range="15 - 0" rwaccess="R/W"/>
	</register>
	<register id="IVPAC_TOP_0__CFG_SLV__PAR_VPAC_LDC0__S_VBUSP__MMR__VBUSP__REGS_CH_RD_OFST" acronym="IVPAC_TOP_0__CFG_SLV__PAR_VPAC_LDC0__S_VBUSP__MMR__VBUSP__REGS_CH_RD_OFST" offset="0x58" width="32" description="Define Chroma stride between lines in the Input Frame in bytes and chroma circular buffer height. Used when CH_CHANCTRL_EN is enabled">
		<bitfield id="MOD" width="14" begin="29" end="16" resetval="0x0" description="Sets the circular buffer size if circular buffering mode is used. The circular buffer is sized in terms of number of chroma lines" range="29 - 16" rwaccess="R/W"/> 
		<bitfield id="OFST" width="16" begin="15" end="0" resetval="0x0" description="Read frame line offset, must be 16-byte aligned so internally [3:0] bits are hard-wired zero." range="15 - 0" rwaccess="R/W"/>
	</register>
	<register id="IVPAC_TOP_0__CFG_SLV__PAR_VPAC_LDC0__S_VBUSP__MMR__VBUSP__REGS_VBUSMR_CFG" acronym="IVPAC_TOP_0__CFG_SLV__PAR_VPAC_LDC0__S_VBUSP__MMR__VBUSP__REGS_VBUSMR_CFG" offset="0x5C" width="32" description="Control VBUSM Read Interface">
		<bitfield id="BW_CTRL" width="12" begin="27" end="16" resetval="0x0" description="Limits the mean bandwidth (computed over one block) that the LDC module can request for read from system memory.   0: The BW limiter is bypassed   1~4095: maximum number of bytes per 256 cycles.   Examples:   1 : 1.17 MBytes/s @ 300 MHz   4095 : ~4.8 GBytes/s @ 300 Mhz " range="27 - 16" rwaccess="R/W"/> 
		<bitfield id="TAG_CNT" width="5" begin="7" end="3" resetval="0x31" description="Limits the maximum number of outstanding LDC requests to TAG_CNT+1" range="7 - 3" rwaccess="R/W"/> 
		<bitfield id="MAX_BURSTLEN" width="2" begin="2" end="1" resetval="0x1" description="Limits the maximum burst length that could be used by LDC. Each burst is of 16 bytes. HW also breaks the command at max burst size boundary.   For K3 devices, it is best to keep burst size of 8 which command size of 128 bytes.   0: 16   1: 8   2: 4   3: 2" range="2 - 1" rwaccess="R/W"/>
	</register>
	<register id="IVPAC_TOP_0__CFG_SLV__PAR_VPAC_LDC0__S_VBUSP__MMR__VBUSP__REGS_COREOUT_CHANCFG" acronym="IVPAC_TOP_0__CFG_SLV__PAR_VPAC_LDC0__S_VBUSP__MMR__VBUSP__REGS_COREOUT_CHANCFG" offset="0x60" width="32" description="LDC Core to LSE output channel enable control">
		<bitfield id="CH3_EN" width="1" begin="3" end="3" resetval="0x0" description="Enable for LDC Core to LSE Channel_3 connection used for Chroma Dual output. Expected to be enabled in Y1_Y2Y3 Data mode" range="3" rwaccess="R/W"/> 
		<bitfield id="CH2_EN" width="1" begin="2" end="2" resetval="0x0" description="Enable for LDC Core to LSE Channel_2 connection used for Luma Dual output. Should be disabled in Y1_Y2Y3 Data mode" range="2" rwaccess="R/W"/> 
		<bitfield id="RSRV_CH1" width="1" begin="1" end="1" resetval="0x0" description="Primary Chroma channel (LSE Channel_1) enable extracted from output data mode" range="1" rwaccess=""/> 
		<bitfield id="RSRV_CH0" width="1" begin="0" end="0" resetval="0x0" description="Primary Luuma channel (LSE Channel_0) enable extracted from output data mode" range="0" rwaccess=""/>
	</register>
	<register id="IVPAC_TOP_0__CFG_SLV__PAR_VPAC_LDC0__S_VBUSP__MMR__VBUSP__REGS_DUALOUT_CFG" acronym="IVPAC_TOP_0__CFG_SLV__PAR_VPAC_LDC0__S_VBUSP__MMR__VBUSP__REGS_DUALOUT_CFG" offset="0x64" width="32" description="Configuration for Dual Luma and Chroma channels and LUT">
		<bitfield id="COUT_BITDPTH" width="4" begin="24" end="21" resetval="0x8" description="Chroma Output Data Bit depth. Output clipped at 2^COUT_BITDPTH -1. Valid values 12-8" range="24 - 21" rwaccess="R/W"/> 
		<bitfield id="CIN_BITDPTH" width="4" begin="20" end="17" resetval="0x12" description="Chroma Input Data Bit depth. Should same as YIN_BITDPTH. Valid values 12 to 8" range="20 - 17" rwaccess="R/W"/> 
		<bitfield id="CLUT_EN" width="1" begin="16" end="16" resetval="0x0" description="Chroma LUT mapping enable. If disabled data is sent as it is bypassing LUT mapping. Expected to be disabled in Y1_Y2Y3 Data mode" range="16" rwaccess="R/W"/> 
		<bitfield id="YOUT_BITDPTH" width="4" begin="8" end="5" resetval="0x8" description="Luma Output Data Bit depth. Output clipped at 2^YOUT_BITDPTH -1. Valid values 12-8" range="8 - 5" rwaccess="R/W"/> 
		<bitfield id="YIN_BITDPTH" width="4" begin="4" end="1" resetval="0x12" description="Luma Input Data Bit depth. Valid values 12 to 8" range="4 - 1" rwaccess="R/W"/> 
		<bitfield id="YLUT_EN" width="1" begin="0" end="0" resetval="0x0" description="Luma LUT mapping enable. If disabled data is sent as it is bypassing LUT mapping" range="0" rwaccess="R/W"/>
	</register>
	<register id="IVPAC_TOP_0__CFG_SLV__PAR_VPAC_LDC0__S_VBUSP__MMR__VBUSP__REGS_IBUF_PIX_START" acronym="IVPAC_TOP_0__CFG_SLV__PAR_VPAC_LDC0__S_VBUSP__MMR__VBUSP__REGS_IBUF_PIX_START" offset="0x68" width="32" description="Expected to be used when Circular buffer is enabled. SW needs to make sure that all required pixel data is after this start pixel. Base address and Off Set needs to align with Pixel Start">
		<bitfield id="STARTY" width="13" begin="28" end="16" resetval="0x0" description="Vertical pixel start position. Must be Even and should be programmed as '0' when hybrid addressing mode is enabled" range="28 - 16" rwaccess="R/W"/> 
		<bitfield id="STARTX" width="13" begin="12" end="0" resetval="0x0" description="Horizontal pixel start position. Must be align to 16-byte base address" range="12 - 0" rwaccess="R/W"/>
	</register>
	<register id="IVPAC_TOP_0__CFG_SLV__PAR_VPAC_LDC0__S_VBUSP__MMR__VBUSP__REGS_HYBD_CBUFF_PARAM" acronym="IVPAC_TOP_0__CFG_SLV__PAR_VPAC_LDC0__S_VBUSP__MMR__VBUSP__REGS_HYBD_CBUFF_PARAM" offset="0x6C" width="32" description="Valid when HYBD_ADDREN is enabled. Frame data from Start to end line is stored in Circular buffer and rest of the data in stored in linear buffer(s)">
		<bitfield id="STARTLINE" width="13" begin="28" end="16" resetval="0x8191" description="Start line of the frame which is stored in the circular buffer. Must be even" range="28 - 16" rwaccess="R/W"/> 
		<bitfield id="ENDLINE" width="13" begin="12" end="0" resetval="0x8191" description="End line of the frame which is stored in the circular buffer. Must be Odd" range="12 - 0" rwaccess="R/W"/>
	</register>
	<register id="IVPAC_TOP_0__CFG_SLV__PAR_VPAC_LDC0__S_VBUSP__MMR__VBUSP__REGS_HYBD_CBUFF_BA_H" acronym="IVPAC_TOP_0__CFG_SLV__PAR_VPAC_LDC0__S_VBUSP__MMR__VBUSP__REGS_HYBD_CBUFF_BA_H" offset="0x70" width="32" description="Higher 16-bit of circular buffer base address in hydrid addressing mode. Valid when HYBD_ADDREN is enabled.">
		<bitfield id="ADDR" width="16" begin="15" end="0" resetval="0x0" description="Higher 16-bit of circular buffer base address in hydrid addressing mode" range="15 - 0" rwaccess="R/W"/>
	</register>
	<register id="IVPAC_TOP_0__CFG_SLV__PAR_VPAC_LDC0__S_VBUSP__MMR__VBUSP__REGS_HYBD_CBUFF_BA_L" acronym="IVPAC_TOP_0__CFG_SLV__PAR_VPAC_LDC0__S_VBUSP__MMR__VBUSP__REGS_HYBD_CBUFF_BA_L" offset="0x74" width="32" description="Lower 32-bit of circular buffer base address in hydrid addressing mode. Valid when HYBD_ADDREN is enabled.">
		<bitfield id="ADDR" width="32" begin="31" end="0" resetval="0x0" description="Lower 32-bit of circular buffer base address in hydrid addressing mode. Must be 16-byte aligned so four LSB are coded to 0" range="31 - 0" rwaccess="R/W"/>
	</register>
	<register id="IVPAC_TOP_0__CFG_SLV__PAR_VPAC_LDC0__S_VBUSP__MMR__VBUSP__REGS_HYBD_BUFF2_BA_H" acronym="IVPAC_TOP_0__CFG_SLV__PAR_VPAC_LDC0__S_VBUSP__MMR__VBUSP__REGS_HYBD_BUFF2_BA_H" offset="0x78" width="32" description="Higher 16-bit of second linear buffer base address in hydrid addressing mode. Valid when HYBD_ADDREN is enabled.">
		<bitfield id="ADDR" width="16" begin="15" end="0" resetval="0x0" description="Higher 16-bit of second linear buffer base address in hydrid addressing mode" range="15 - 0" rwaccess="R/W"/>
	</register>
	<register id="IVPAC_TOP_0__CFG_SLV__PAR_VPAC_LDC0__S_VBUSP__MMR__VBUSP__REGS_HYBD_BUFF2_BA_L" acronym="IVPAC_TOP_0__CFG_SLV__PAR_VPAC_LDC0__S_VBUSP__MMR__VBUSP__REGS_HYBD_BUFF2_BA_L" offset="0x7C" width="32" description="Lower 32-bit of second linear buffer base address in hydrid addressing mode. Valid when HYBD_ADDREN is enabled.">
		<bitfield id="ADDR" width="32" begin="31" end="0" resetval="0x0" description="Lower 32-bit of second linear buffer base address in hydrid addressing mode. Must be 16-byte aligned so four LSB are coded to 0" range="31 - 0" rwaccess="R/W"/>
	</register>
	<register id="IVPAC_TOP_0__CFG_SLV__PAR_VPAC_LDC0__S_VBUSP__MMR__VBUSP__REGS_HYBD_CHCBUFF_PARAM" acronym="IVPAC_TOP_0__CFG_SLV__PAR_VPAC_LDC0__S_VBUSP__MMR__VBUSP__REGS_HYBD_CHCBUFF_PARAM" offset="0x80" width="32" description="Valid when both CH_CHANCTRL_EN and HYBD_ADDREN are enabled. Frame data from Start to end line is stored in Circular buffer and rest of the data in stored in linear buffers. Program them assuming in full frame lines ; not interms of sub-sampled chroma lines in YUV420 mode">
		<bitfield id="STARTLINE" width="13" begin="28" end="16" resetval="0x8191" description="Start line of the frame which is stored in the circular buffer. Must be even" range="28 - 16" rwaccess="R/W"/> 
		<bitfield id="ENDLINE" width="13" begin="12" end="0" resetval="0x8191" description="End line of the frame which is stored in the circular buffer. Must be odd" range="12 - 0" rwaccess="R/W"/>
	</register>
	<register id="IVPAC_TOP_0__CFG_SLV__PAR_VPAC_LDC0__S_VBUSP__MMR__VBUSP__REGS_HYBD_CHCBUFF_BA_H" acronym="IVPAC_TOP_0__CFG_SLV__PAR_VPAC_LDC0__S_VBUSP__MMR__VBUSP__REGS_HYBD_CHCBUFF_BA_H" offset="0x84" width="32" description="Higher 16-bit of chroma circular buffer base address in hydrid addressing mode. Valid when HYBD_ADDREN is enabled.">
		<bitfield id="ADDR" width="16" begin="15" end="0" resetval="0x0" description="Higher 16-bit of circular buffer base address in hydrid addressing mode" range="15 - 0" rwaccess="R/W"/>
	</register>
	<register id="IVPAC_TOP_0__CFG_SLV__PAR_VPAC_LDC0__S_VBUSP__MMR__VBUSP__REGS_HYBD_CHCBUFF_BA_L" acronym="IVPAC_TOP_0__CFG_SLV__PAR_VPAC_LDC0__S_VBUSP__MMR__VBUSP__REGS_HYBD_CHCBUFF_BA_L" offset="0x88" width="32" description="Lower 32-bit of chroma circular buffer base address in hydrid addressing mode. Valid when HYBD_ADDREN is enabled.">
		<bitfield id="ADDR" width="32" begin="31" end="0" resetval="0x0" description="Lower 32-bit of circular buffer base address in hydrid addressing mode. Must be 16-byte aligned so four LSB are coded to 0" range="31 - 0" rwaccess="R/W"/>
	</register>
	<register id="IVPAC_TOP_0__CFG_SLV__PAR_VPAC_LDC0__S_VBUSP__MMR__VBUSP__REGS_HYBD_CHBUFF2_BA_H" acronym="IVPAC_TOP_0__CFG_SLV__PAR_VPAC_LDC0__S_VBUSP__MMR__VBUSP__REGS_HYBD_CHBUFF2_BA_H" offset="0x8C" width="32" description="Higher 16-bit of second linear chroma buffer base address in hydrid addressing mode. Valid when HYBD_ADDREN is enabled.">
		<bitfield id="ADDR" width="16" begin="15" end="0" resetval="0x0" description="Higher 16-bit of second linear buffer base address in hydrid addressing mode" range="15 - 0" rwaccess="R/W"/>
	</register>
	<register id="IVPAC_TOP_0__CFG_SLV__PAR_VPAC_LDC0__S_VBUSP__MMR__VBUSP__REGS_HYBD_CHBUFF2_BA_L" acronym="IVPAC_TOP_0__CFG_SLV__PAR_VPAC_LDC0__S_VBUSP__MMR__VBUSP__REGS_HYBD_CHBUFF2_BA_L" offset="0x90" width="32" description="Lower 32-bit of second linear chroma buffer base address in hydrid addressing mode. Valid when HYBD_ADDREN is enabled.">
		<bitfield id="ADDR" width="32" begin="31" end="0" resetval="0x0" description="Lower 32-bit of second linear buffer base address in hydrid addressing mode. Must be 16-byte aligned so four LSB are coded to 0" range="31 - 0" rwaccess="R/W"/>
	</register>
	<register id="IVPAC_TOP_0__CFG_SLV__PAR_VPAC_LDC0__S_VBUSP__MMR__VBUSP__REGS_REGN_W12_SZ" acronym="IVPAC_TOP_0__CFG_SLV__PAR_VPAC_LDC0__S_VBUSP__MMR__VBUSP__REGS_REGN_W12_SZ" offset="0xE0" width="32" description="Horizontal slice width for Region division">
		<bitfield id="W2" width="14" begin="29" end="16" resetval="0x0" description="Width of second horizontal slice. (Minimum of 8 and must be even)" range="29 - 16" rwaccess="R/W"/> 
		<bitfield id="W1" width="14" begin="13" end="0" resetval="0x0" description="Width of first horizontal slice. (Minimum of 8 and must be even)" range="13 - 0" rwaccess="R/W"/>
	</register>
	<register id="IVPAC_TOP_0__CFG_SLV__PAR_VPAC_LDC0__S_VBUSP__MMR__VBUSP__REGS_REGN_W3_SZ" acronym="IVPAC_TOP_0__CFG_SLV__PAR_VPAC_LDC0__S_VBUSP__MMR__VBUSP__REGS_REGN_W3_SZ" offset="0xE4" width="32" description="Horizontal slice width for Region division">
		<bitfield id="W3" width="14" begin="13" end="0" resetval="0x0" description="Width of third horizontal slice. (Minimum of 8 and must be even)" range="13 - 0" rwaccess="R/W"/>
	</register>
	<register id="IVPAC_TOP_0__CFG_SLV__PAR_VPAC_LDC0__S_VBUSP__MMR__VBUSP__REGS_REGN_H12_SZ" acronym="IVPAC_TOP_0__CFG_SLV__PAR_VPAC_LDC0__S_VBUSP__MMR__VBUSP__REGS_REGN_H12_SZ" offset="0xE8" width="32" description="vertical slice height for Region division">
		<bitfield id="H2" width="14" begin="29" end="16" resetval="0x0" description="Height of second vertical slice. (must be even)" range="29 - 16" rwaccess="R/W"/> 
		<bitfield id="H1" width="14" begin="13" end="0" resetval="0x0" description="Height of first vertical slice. (must be even)" range="13 - 0" rwaccess="R/W"/>
	</register>
	<register id="IVPAC_TOP_0__CFG_SLV__PAR_VPAC_LDC0__S_VBUSP__MMR__VBUSP__REGS_REGN_H3_SZ" acronym="IVPAC_TOP_0__CFG_SLV__PAR_VPAC_LDC0__S_VBUSP__MMR__VBUSP__REGS_REGN_H3_SZ" offset="0xEC" width="32" description="Vertical slice height for Region division">
		<bitfield id="H3" width="14" begin="13" end="0" resetval="0x0" description="Height of third vertical slice. (must be even)" range="13 - 0" rwaccess="R/W"/>
	</register>
	<register id="IVPAC_TOP_0__CFG_SLV__PAR_VPAC_LDC0__S_VBUSP__MMR__VBUSP__REGS_ERR_STATUS" acronym="IVPAC_TOP_0__CFG_SLV__PAR_VPAC_LDC0__S_VBUSP__MMR__VBUSP__REGS_ERR_STATUS" offset="0x200" width="32" description="Control VBUSM Read Interface">
		<bitfield id="VBUSMR_ERR" width="3" begin="10" end="8" resetval="0x0" description="VBUSM Read I/F Last Error Status. Write '1' to clear, works independently for each bit." range="10 - 8" rwaccess="R/W1TC"/> 
		<bitfield id="INT_SZOVF" width="1" begin="5" end="5" resetval="0x0" description="Internal operation has overflown the HW supported block or frame sizes. Should be fixed" range="5" rwaccess="R/W1TC"/> 
		<bitfield id="M_IBLK_MEMOVF" width="1" begin="4" end="4" resetval="0x0" description="Mesh block storage requirement is more than internal memory available. Should be fixed" range="4" rwaccess="R/W1TC"/> 
		<bitfield id="P_IBLK_MEMOVF" width="1" begin="3" end="3" resetval="0x0" description="Input pixel block storage requirement is more than internal memory available. Should be fixed" range="3" rwaccess="R/W1TC"/> 
		<bitfield id="IFRAME_OUTB" width="1" begin="2" end="2" resetval="0x0" description="Either Mesh data or Input pixel data required is going out of valid frame available" range="2" rwaccess="R/W1TC"/> 
		<bitfield id="M_IBLK_OUTB" width="1" begin="1" end="1" resetval="0x0" description="Mesh Input Block out of Bound. Mesh data required for block is not available in the prefetched internal memory. Should be fine." range="1" rwaccess="R/W1TC"/> 
		<bitfield id="P_IBLK_OUTB" width="1" begin="0" end="0" resetval="0x0" description="Pixel Input Block out of Bound. Pixel data required for block is not available in the prefetched internal memory. PIX_PAD is not enough" range="0" rwaccess="R/W1TC"/>
	</register>
	<register id="IVPAC_TOP_0__CFG_SLV__PAR_VPAC_LDC0__S_VBUSP__MMR__VBUSP__REGS_DEBUG_CTRL" acronym="IVPAC_TOP_0__CFG_SLV__PAR_VPAC_LDC0__S_VBUSP__MMR__VBUSP__REGS_DEBUG_CTRL" offset="0x204" width="32" description="Control the memory access selection">
		<bitfield id="CFG_MEMACC_SEL" width="1" begin="0" end="0" resetval="0x0" description="VBUSP Configuration access control. 0 - VBUSP can access Ping memories   1 - VBUSP can access pong memories                                                                           All private memories Mesh,Luma, Chroma will share same control. Ping and pong memories will have same memory map" range="0" rwaccess="R/W"/>
	</register>
	<register id="IVPAC_TOP_0__CFG_SLV__PAR_VPAC_LDC0__S_VBUSP__MMR__VBUSP__REGS_DEBUG_STATUS" acronym="IVPAC_TOP_0__CFG_SLV__PAR_VPAC_LDC0__S_VBUSP__MMR__VBUSP__REGS_DEBUG_STATUS" offset="0x208" width="32" description="LDC Debug Status Register">
		<bitfield id="PROC_STATUS" width="1" begin="24" end="24" resetval="0x1" description="Block Processing status.   0 - Block Processing is ongoing   1 - Either block processing is completed or not started " range="24" rwaccess="R"/> 
		<bitfield id="FETCH_RESPSTATE" width="3" begin="18" end="16" resetval="0x0" description="VBUSM Fetch Response state machine                                                                                                  3'd0 = ST_RESP_IDLE                                                                                                       3'd1 = ST_RESP_MREQWAIT                                                                                                   3'd2 = ST_RESP_MRESPWAIT                                                                                                  3'd3 = ST_RESP_IREQWAIT                                                                                                   3'd4 = ST_RESP_IRESPWAIT                                                                                                  3'd5 = ST_RESP_DONE" range="18 - 16" rwaccess="R"/> 
		<bitfield id="FETCH_REQSTATE" width="5" begin="12" end="8" resetval="0x0" description="VBUSM Fetch Request state machine                                                                                                  5'b00_000 = ST_REQ_IDLE                                                                                                       5'b10_000 = ST_REQ_MBASECAL                                                                                                   5'b10_001 = ST_REQ_MDATA                                                                                                      5'b11_000 = ST_REQ_INITWAIT                                                                                                   5'b11_001 = ST_REQ_ICBUF                                                                                                      5'b11_010 = ST_REQ_IBASECAL                                                                                                   5'b11_011 = ST_REQ_IDATA  " range="12 - 8" rwaccess="R"/> 
		<bitfield id="CTRL_STATE" width="4" begin="3" end="0" resetval="0x0" description="Main Control State machine                                                                                                 4'd0  = STATE_IDLE                                                                                                               4'd1  = STATE_GET_BLOCK_P1                                                                                                       4'd2  = STATE_GET_BLOCK_P2                                                                                                       4'd3  = STATE_GET_BLOCK_P3                                                                                                       4'd4  = STATE_GET_BLOCK_P4                                                                                                       4'd5  = STATE_SET_BLOCK_PWARP                                                                                                    4'd6  = STATE_SET_BLOCK_MESHDC                                                                                                   4'd7  = STATE_INIT_BLOCK                                                                                                         4'd8  = STATE_GET_BLOCK                                                                                                          4'd9  = STATE_WAIT_PROCESS_DONE                                                                                                  4'd10 = STATE_LAST_PROCESS                                                                                                       4'd11 = STATE_LAST_PROCESS_DONE" range="3 - 0" rwaccess="R"/>
	</register>
	<register id="IVPAC_TOP_0__CFG_SLV__PAR_VPAC_LDC0__S_VBUSP__MMR__VBUSP__REGS_FR_PDFTCH" acronym="IVPAC_TOP_0__CFG_SLV__PAR_VPAC_LDC0__S_VBUSP__MMR__VBUSP__REGS_FR_PDFTCH" offset="0x20C" width="32" description="Pixel bytes fetched by VBUSM Read Interface. It is updated on every command issued and cleared at the beginning frame fetch. Reading at the end of the frame will provide total number of pixel data fetched for entire frame">
		<bitfield id="PBYTES" width="32" begin="31" end="0" resetval="0x0" description="Pixel bytes fetched for current Frame. Reading at the end of frame will provide pixel data fetched for entire frame" range="31 - 0" rwaccess="R"/>
	</register>
	<register id="IVPAC_TOP_0__CFG_SLV__PAR_VPAC_LDC0__S_VBUSP__MMR__VBUSP__REGS_FR_MDFTCH" acronym="IVPAC_TOP_0__CFG_SLV__PAR_VPAC_LDC0__S_VBUSP__MMR__VBUSP__REGS_FR_MDFTCH" offset="0x210" width="32" description="Mesh bytes fetched by VBUSM Read Interface. It is updated on every command issued and cleared at the beginning frame fetch. Reading at the end of the frame will provide total number of mesh data band fetched for entire frame">
		<bitfield id="MBYTES" width="32" begin="31" end="0" resetval="0x0" description="Mesh bytes fetched for current Frame. Reading at the end of frame will provide Mesh data fetched for entire frame" range="31 - 0" rwaccess="R"/>
	</register>
	<register id="IVPAC_TOP_0__CFG_SLV__PAR_VPAC_LDC0__S_VBUSP__MMR__VBUSP__REGS_PIXMEMOVF_BLK" acronym="IVPAC_TOP_0__CFG_SLV__PAR_VPAC_LDC0__S_VBUSP__MMR__VBUSP__REGS_PIXMEMOVF_BLK" offset="0x214" width="32" description="Starting co-ordinates of first output block for which input pixel buffer overflowed">
		<bitfield id="Y" width="13" begin="28" end="16" resetval="0x0" description="Start Y Co-ordinate" range="28 - 16" rwaccess="R"/> 
		<bitfield id="X" width="13" begin="12" end="0" resetval="0x0" description="Start X Co-ordinate" range="12 - 0" rwaccess="R"/>
	</register>
	<register id="IVPAC_TOP_0__CFG_SLV__PAR_VPAC_LDC0__S_VBUSP__MMR__VBUSP__REGS_MESHMEMOVF_BLK" acronym="IVPAC_TOP_0__CFG_SLV__PAR_VPAC_LDC0__S_VBUSP__MMR__VBUSP__REGS_MESHMEMOVF_BLK" offset="0x218" width="32" description="Starting co-ordinates of first output block for which input mesh buffer overflowed">
		<bitfield id="Y" width="13" begin="28" end="16" resetval="0x0" description="Start Y Co-ordinate" range="28 - 16" rwaccess="R"/> 
		<bitfield id="X" width="13" begin="12" end="0" resetval="0x0" description="Start X Co-ordinate" range="12 - 0" rwaccess="R"/>
	</register>
	<register id="IVPAC_TOP_0__CFG_SLV__PAR_VPAC_LDC0__S_VBUSP__MMR__VBUSP__REGS_OUTOFBOUND_BLK" acronym="IVPAC_TOP_0__CFG_SLV__PAR_VPAC_LDC0__S_VBUSP__MMR__VBUSP__REGS_OUTOFBOUND_BLK" offset="0x21C" width="32" description="Starting co-ordinates of first output block for which PIX_PAD is not enough">
		<bitfield id="Y" width="13" begin="28" end="16" resetval="0x0" description="Start Y Co-ordinate" range="28 - 16" rwaccess="R"/> 
		<bitfield id="X" width="13" begin="12" end="0" resetval="0x0" description="Start X Co-ordinate" range="12 - 0" rwaccess="R"/>
	</register>
	<register id="IVPAC_TOP_0__CFG_SLV__PAR_VPAC_LDC0__S_VBUSP__MMR__VBUSP__REGS_CTRL" acronym="IVPAC_TOP_0__CFG_SLV__PAR_VPAC_LDC0__S_VBUSP__MMR__VBUSP__REGS_CTRL" offset="0x100" width="32" description="Region Control Register">
		<bitfield id="ENABLE" width="1" begin="0" end="0" resetval="0x1" description="Enable for processing of this region. This is can be used to selectively disable processing of some regions (default enabled).   1 - Process the region i.e. no skipping   0 - Don't process the region" range="0" rwaccess="R/W"/>
	</register>
	<register id="IVPAC_TOP_0__CFG_SLV__PAR_VPAC_LDC0__S_VBUSP__MMR__VBUSP__REGS_OUT_BLKSZ" acronym="IVPAC_TOP_0__CFG_SLV__PAR_VPAC_LDC0__S_VBUSP__MMR__VBUSP__REGS_OUT_BLKSZ" offset="0x104" width="32" description="Block size and Pixel Pad config">
		<bitfield id="PIXPAD" width="4" begin="19" end="16" resetval="0x0" description="Pixel pad" range="19 - 16" rwaccess="R/W"/> 
		<bitfield id="OBH" width="8" begin="15" end="8" resetval="0x0" description="Output block height must be >0 and even. Should be less than or equal to corresponding region height" range="15 - 8" rwaccess="R/W"/> 
		<bitfield id="OBW" width="8" begin="7" end="0" resetval="0x0" description="Output block width, must be >0 and multiple of 8. Should be less than or equal to corresponding region width" range="7 - 0" rwaccess="R/W"/>
	</register>
</module>