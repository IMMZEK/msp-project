<?xml version="1.0" encoding="UTF-8"?>
<!-- This file was autogenerated by Socrates Bitwise, Duolog Technologies Ltd. -->
<module id="AES" HW_revision="" XML_version="1.0" description="Register fields should be considered static unless otherwise noted as dynamic." xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="setup_parser.xsd">
    <register acronym="DMAC_CH0_CTRL" width="32" description="Channel control
This register is used for channel enabling and priority selection. When a channel is disabled, it becomes inactive only when all ongoing requests are finished." id="DMAC_CH0_CTRL" offset="0x0" >
        <bitfield range="" begin="31" width="30" end="2" rwaccess="RW" description="Should be written with 0s and ignored on read" id="Reserved30" resetval="" >
        </bitfield>
        <bitfield range="" begin="1" width="1" end="1" rwaccess="RW" description="Channel priority
0: Low
1: High
If both channels have the same priority, access of the channels to the external port is arbitrated using the round robin scheme. If one channel has a high priority and another one low, the channel with the high priority is served first, in case of simultaneous access requests." id="PRIO" resetval="" >
        </bitfield>
        <bitfield range="" begin="0" width="1" end="0" rwaccess="RW" description="Channel enable
0: Disabled
1: Enable
Note: Disabling an active channel interrupts the DMA operation. The ongoing block transfer completes, but no new transfers are requested." id="EN" resetval="" >
        </bitfield>
    </register>
    <register acronym="DMAC_CH0_EXTADDR" width="32" description="Channel external address" id="DMAC_CH0_EXTADDR" offset="0x4" >
        <bitfield range="" begin="31" width="32" end="0" rwaccess="RW" description="Channel external address value
When read during operation, it holds the last updated external address after being sent to the master interface." id="ADDR" resetval="" >
        </bitfield>
    </register>
    <register acronym="DMAC_CH0_DMALENGTH" width="32" description="Channel DMA length" id="DMAC_CH0_DMALENGTH" offset="0xc" >
        <bitfield range="" begin="31" width="16" end="16" rwaccess="RW" description="Should be written with 0s and ignored on read" id="Reserved16" resetval="" >
        </bitfield>
        <bitfield range="" begin="15" width="16" end="0" rwaccess="RW" description="Channel DMA length in bytes
During configuration, this register contains the DMA transfer length in bytes. During operation, it contains the last updated value of the DMA transfer length after being sent to the master interface.
Note: Setting this register to a nonzero value starts the transfer if the channel is enabled. Therefore, this register must be written last when setting up a DMA channel." id="DMALEN" resetval="" >
        </bitfield>
    </register>
    <register acronym="DMAC_STATUS" width="32" description="DMAC status
This register provides the actual state of each DMA channel. It also reports port errors in case these were received by the master interface module during the data transfer." id="DMAC_STATUS" offset="0x18" >
        <bitfield range="" begin="31" width="14" end="18" rwaccess="RO" description="Bits should be ignored on read." id="Reserved14" resetval="" >
        </bitfield>
        <bitfield range="" begin="17" width="1" end="17" rwaccess="RO" description="Reflects possible transfer errors on the AHB port." id="PORT_ERR" resetval="" >
        </bitfield>
        <bitfield range="" begin="16" width="15" end="2" rwaccess="RO" description="Bits should be ignored on read." id="Reserved15" resetval="" >
        </bitfield>
        <bitfield range="" begin="1" width="1" end="1" rwaccess="RO" description="A value of 1 indicates that channel 1 is active (DMA transfer on-going)." id="CH1_ACT" resetval="" >
        </bitfield>
        <bitfield range="" begin="0" width="1" end="0" rwaccess="RO" description="A value of 1 indicates that channel 0 is active (DMA transfer on-going)." id="CH0_ACT" resetval="" >
        </bitfield>
    </register>
    <register acronym="DMAC_SWRES" width="32" description="DMAC software reset register
Software reset is used to reset the DMAC to stop all transfers and clears the port error status register. After the software reset is performed, all the channels are disabled and no new requests are performed by the channels. The DMAC waits for the existing (active) requests to finish and accordingly sets the DMAC status registers." id="DMAC_SWRES" offset="0x1c" >
        <bitfield range="" begin="31" width="31" end="1" rwaccess="WO" description="Bits should be written with a value of 0." id="Reserved31" resetval="" >
        </bitfield>
        <bitfield range="" begin="0" width="1" end="0" rwaccess="WO" description="Software reset enable
0 = Disabled
1 = Enabled (self-cleared to 0)
Completion of the software reset must be checked through the DMAC_STATUS register." id="SWRES" resetval="" >
        </bitfield>
    </register>
    <register acronym="DMAC_CH1_CTRL" width="32" description="Channel control
This register is used for channel enabling and priority selection. When a channel is disabled, it becomes inactive only when all ongoing requests are finished." id="DMAC_CH1_CTRL" offset="0x20" >
        <bitfield range="" begin="31" width="30" end="2" rwaccess="RW" description="Should be written with 0s and ignored on read" id="Reserved30" resetval="" >
        </bitfield>
        <bitfield range="" begin="1" width="1" end="1" rwaccess="RW" description="Channel priority
0: Low
1: High
If both channels have the same priority, access of the channels to the external port is arbitrated using the round robin scheme. If one channel has a high priority and another one low, the channel with the high priority is served first, in case of simultaneous access requests." id="PRIO" resetval="" >
        </bitfield>
        <bitfield range="" begin="0" width="1" end="0" rwaccess="RW" description="Channel enable
0: Disabled
1: Enable
Note: Disabling an active channel interrupts the DMA operation. The ongoing block transfer completes, but no new transfers are requested." id="EN" resetval="" >
        </bitfield>
    </register>
    <register acronym="DMAC_CH1_EXTADDR" width="32" description="Channel external address" id="DMAC_CH1_EXTADDR" offset="0x24" >
        <bitfield range="" begin="31" width="32" end="0" rwaccess="RW" description="Channel external address value.
When read during operation, it holds the last updated external address after being sent to the master interface." id="ADDR" resetval="" >
        </bitfield>
    </register>
    <register acronym="DMAC_CH1_DMALENGTH" width="32" description="Channel DMA length" id="DMAC_CH1_DMALENGTH" offset="0x2c" >
        <bitfield range="" begin="31" width="16" end="16" rwaccess="RW" description="Should be written with 0s and ignored on read" id="Reserved16" resetval="" >
        </bitfield>
        <bitfield range="" begin="15" width="16" end="0" rwaccess="RW" description="Channel DMA length in bytes.
During configuration, this register contains the DMA transfer length in bytes. During operation, it contains the last updated value of the DMA transfer length after being sent to the master interface.
Note: Setting this register to a nonzero value starts the transfer if the channel is enabled. Therefore, this register must be written last when setting up a DMA channel." id="DMALEN" resetval="" >
        </bitfield>
    </register>
    <register acronym="DMAC_MST_RUNPARAMS" width="32" description="DMAC master run-time parameters
This register defines all the run-time parameters for the AHB master interface port. These parameters are required for the proper functioning of the EIP-101m AHB master adapter." id="DMAC_MST_RUNPARAMS" offset="0x78" >
        <bitfield range="" begin="31" width="16" end="16" rwaccess="RW" description="Should be written with 0s and ignored on read" id="Reserved16" resetval="" >
        </bitfield>
        <bitfield range="" begin="15" width="4" end="12" rwaccess="RW" description="Maximum burst size that can be performed on the AHB bus
0010b = 4 bytes (default)
0011b = 8 bytes
0100b = 16 bytes
0101b = 32 bytes
0110b = 64 bytes
Others = Reserved" id="AHB_MST1_BURST_SIZE" resetval="" >
        </bitfield>
        <bitfield range="" begin="11" width="1" end="11" rwaccess="RW" description="Idle insertion between consecutive burst transfers on AHB
0: No Idle insertion
1: Idle insertion" id="AHB_MST1_IDLE_EN" resetval="" >
        </bitfield>
        <bitfield range="" begin="10" width="1" end="10" rwaccess="RW" description="Burst length type of AHB transfer
0: Unspecified length burst transfers
1: Fixed length burst or single transfers" id="AHB_MST1_INCR_EN" resetval="" >
        </bitfield>
        <bitfield range="" begin="9" width="1" end="9" rwaccess="RW" description="Locked transform on AHB
0: Transfers are not locked
1: Transfers are locked" id="AHB_MST1_LOCK_EN" resetval="" >
        </bitfield>
        <bitfield range="" begin="8" width="1" end="8" rwaccess="RW" description="Endianess for the AHB master
0: Little endian
1: Big endian" id="AHB_MST1_BIGEND" resetval="" >
        </bitfield>
        <bitfield range="" begin="7" width="8" end="0" rwaccess="RW" description="Should be written with 0s and ignored on read" id="Reserved8" resetval="" >
        </bitfield>
    </register>
    <register acronym="DMAC_PERSR" width="32" description="DMAC port error raw status register
This register provides the actual status of individual port errors. It also indicates which channel is serviced by an external AHB port (which is frozen by a port error). A port error aborts operations on all serviced channels (channel enable bit is forced to 0) and prevents further transfers via that port until the error is cleared by writing to the DMAC_SWRES register." id="DMAC_PERSR" offset="0x7c" >
        <bitfield range="" begin="31" width="19" end="13" rwaccess="RO" description="Bits should be ignored on read" id="Reserved19" resetval="" >
        </bitfield>
        <bitfield range="" begin="12" width="1" end="12" rwaccess="RO" description="A value of 1 indicates that the EIP-101 has detected an AHB bus error" id="PORT1_AHB_ERROR" resetval="" >
        </bitfield>
        <bitfield range="" begin="11" width="2" end="10" rwaccess="RO" description="Bits should be ignored on read" id="Reserved2" resetval="" >
        </bitfield>
        <bitfield range="" begin="9" width="1" end="9" rwaccess="RO" description="Indicates which channel has serviced last (channel 0 or channel 1) by AHB master port." id="PORT1_CHANNEL" resetval="" >
        </bitfield>
        <bitfield range="" begin="8" width="9" end="0" rwaccess="RO" description="Bits should be ignored on read" id="Reserved9" resetval="" >
        </bitfield>
    </register>
    <register acronym="DMAC_OPTIONS" width="32" description="DMAC options register
These registers contain information regarding the different options configured in this DMAC." id="DMAC_OPTIONS" offset="0xf8" >
        <bitfield range="" begin="31" width="20" end="12" rwaccess="RO" description="Bits should be ignored on read" id="Reserved20" resetval="" >
        </bitfield>
        <bitfield range="" begin="11" width="4" end="8" rwaccess="RO" description="Number of channels implemented, value in the range 1-8." id="NR_OF_CHANNELS" resetval="" >
        </bitfield>
        <bitfield range="" begin="7" width="5" end="3" rwaccess="RO" description="Bits should be ignored on read" id="Reserved5" resetval="" >
        </bitfield>
        <bitfield range="" begin="2" width="3" end="0" rwaccess="RO" description="Number of ports implemented, value in range 1-4." id="NR_OF_PORTS" resetval="" >
        </bitfield>
    </register>
    <register acronym="DMAC_VERSION" width="32" description="DMAC version register
This register contains an indication (or signature) of the EIP type of this DMAC, as well as the hardware version/patch numbers." id="DMAC_VERSION" offset="0xfc" >
        <bitfield range="" begin="31" width="4" end="28" rwaccess="RO" description="Bits should be ignored on read" id="Reserved4" resetval="" >
        </bitfield>
        <bitfield range="" begin="27" width="4" end="24" rwaccess="RO" description="Major version number" id="HW_MAJOR_VERSION" resetval="" >
        </bitfield>
        <bitfield range="" begin="23" width="4" end="20" rwaccess="RO" description="Minor version number" id="HW_MINOR_VERSION" resetval="" >
        </bitfield>
        <bitfield range="" begin="19" width="4" end="16" rwaccess="RO" description="Patch level
Starts at 0 at first delivery of this version" id="HW_PATCH_LEVEL" resetval="" >
        </bitfield>
        <bitfield range="" begin="15" width="8" end="8" rwaccess="RO" description="Bit-by-bit complement of the EIP_NUMBER field bits." id="EIP_NUMBER_COMPL" resetval="" >
        </bitfield>
        <bitfield range="" begin="7" width="8" end="0" rwaccess="RO" description="Binary encoding of the EIP-number of this DMA controller (209)" id="EIP_NUMBER" resetval="" >
        </bitfield>
    </register>
    <register acronym="KEY_STORE_WRITE_AREA" width="32" description="Key store write area register
This register defines where the keys should be written in the key store RAM. After writing this register, the key store module is ready to receive the keys through a DMA operation. In case the key data transfer triggered an error in the key store, the error will be available in the interrupt status register after the DMA is finished. The key store write-error is asserted when the programmed/selected area is not completely written. This error is also asserted when the DMA operation writes to ram areas that are not selected.
The key store RAM is divided into 8 areas of 128 bits.
192-bit keys written in the key store RAM should start on boundaries of 256 bits. This means that writing a 192-bit key to the key store RAM must be done by writing 256 bits of data with the 64 most-significant bits set to 0. These bits are ignored by the AES engine." id="KEY_STORE_WRITE_AREA" offset="0x400" >
        <bitfield range="" begin="31" width="24" end="8" rwaccess="RW" description="Write 0s and ignore on reading" id="Reserved1" resetval="" >
        </bitfield>
        <bitfield range="" begin="7" width="1" end="7" rwaccess="RW" description="Each RAM_AREAx represents an area of 128 bits.
Select the key store RAM area(s) where the key(s) needs to be written
0: RAM_AREA7 is not selected to be written.
1: RAM_AREA7 is selected to be written.
Writing to multiple RAM locations is possible only when the selected RAM areas are sequential.
Keys that require more than one RAM locations (key size is 192 or 256 bits), must start at one of the following areas: RAM_AREA0, RAM_AREA2, RAM_AREA4, or RAM_AREA6." id="RAM_AREA7" resetval="" >
        </bitfield>
        <bitfield range="" begin="6" width="1" end="6" rwaccess="RW" description="Each RAM_AREAx represents an area of 128 bits.
Select the key store RAM area(s) where the key(s) needs to be written
0: RAM_AREA6 is not selected to be written.
1: RAM_AREA6 is selected to be written.
Writing to multiple RAM locations is possible only when the selected RAM areas are sequential.
Keys that require more than one RAM locations (key size is 192 or 256 bits), must start at one of the following areas: RAM_AREA0, RAM_AREA2, RAM_AREA4, or RAM_AREA6." id="RAM_AREA6" resetval="" >
        </bitfield>
        <bitfield range="" begin="5" width="1" end="5" rwaccess="RW" description="Each RAM_AREAx represents an area of 128 bits.
Select the key store RAM area(s) where the key(s) needs to be written
0: RAM_AREA5 is not selected to be written.
1: RAM_AREA5 is selected to be written.
Writing to multiple RAM locations is possible only when the selected RAM areas are sequential.
Keys that require more than one RAM locations (key size is 192 or 256 bits), must start at one of the following areas: RAM_AREA0, RAM_AREA2, RAM_AREA4, or RAM_AREA6." id="RAM_AREA5" resetval="" >
        </bitfield>
        <bitfield range="" begin="4" width="1" end="4" rwaccess="RW" description="Each RAM_AREAx represents an area of 128 bits.
Select the key store RAM area(s) where the key(s) needs to be written
0: RAM_AREA4 is not selected to be written.
1: RAM_AREA4 is selected to be written.
Writing to multiple RAM locations is possible only when the selected RAM areas are sequential.
Keys that require more than one RAM locations (key size is 192 or 256 bits), must start at one of the following areas: RAM_AREA0, RAM_AREA2, RAM_AREA4, or RAM_AREA6." id="RAM_AREA4" resetval="" >
        </bitfield>
        <bitfield range="" begin="3" width="1" end="3" rwaccess="RW" description="Each RAM_AREAx represents an area of 128 bits.
Select the key store RAM area(s) where the key(s) needs to be written
0: RAM_AREA3 is not selected to be written.
1: RAM_AREA3 is selected to be written.
Writing to multiple RAM locations is possible only when the selected RAM areas are sequential.
Keys that require more than one RAM locations (key size is 192 or 256 bits), must start at one of the following areas: RAM_AREA0, RAM_AREA2, RAM_AREA4, or RAM_AREA6." id="RAM_AREA3" resetval="" >
        </bitfield>
        <bitfield range="" begin="2" width="1" end="2" rwaccess="RW" description="Each RAM_AREAx represents an area of 128 bits.
Select the key store RAM area(s) where the key(s) needs to be written
0: RAM_AREA2 is not selected to be written.
1: RAM_AREA2 is selected to be written.
Writing to multiple RAM locations is possible only when the selected RAM areas are sequential.
Keys that require more than one RAM locations (key size is 192 or 256 bits), must start at one of the following areas: RAM_AREA0, RAM_AREA2, RAM_AREA4, or RAM_AREA6." id="RAM_AREA2" resetval="" >
        </bitfield>
        <bitfield range="" begin="1" width="1" end="1" rwaccess="RW" description="Each RAM_AREAx represents an area of 128 bits.
Select the key store RAM area(s) where the key(s) needs to be written
0: RAM_AREA1 is not selected to be written.
1: RAM_AREA1 is selected to be written.
Writing to multiple RAM locations is possible only when the selected RAM areas are sequential.
Keys that require more than one RAM locations (key size is 192 or 256 bits), must start at one of the following areas: RAM_AREA0, RAM_AREA2, RAM_AREA4, or RAM_AREA6." id="RAM_AREA1" resetval="" >
        </bitfield>
        <bitfield range="" begin="0" width="1" end="0" rwaccess="RW" description="Each RAM_AREAx represents an area of 128 bits.
Select the key store RAM area(s) where the key(s) needs to be written
0: RAM_AREA0 is not selected to be written.
1: RAM_AREA0 is selected to be written.
Writing to multiple RAM locations is possible only when the selected RAM areas are sequential.
Keys that require more than one RAM locations (key size is 192 or 256 bits), must start at one of the following areas: RAM_AREA0, RAM_AREA2, RAM_AREA4, or RAM_AREA6." id="RAM_AREA0" resetval="" >
        </bitfield>
    </register>
    <register acronym="KEY_STORE_WRITTEN_AREA" width="32" description="Key store written area register
This register shows which areas of the key store RAM contain valid written keys.
When a new key needs to be written to the key store, on a location that is already occupied by a valid key, this key area must be cleared first. This can be done by writing this register before the new key is written to the key store memory.
Attempting to write to a key area that already contains a valid key is not allowed and results in an error." id="KEY_STORE_WRITTEN_AREA" offset="0x404" >
        <bitfield range="" begin="31" width="24" end="8" rwaccess="RW" description="Write 0s and ignore on reading" id="Reserved1" resetval="" >
        </bitfield>
        <bitfield range="" begin="7" width="1" end="7" rwaccess="RW" description="Read operation:
0: This RAM area is not written with valid key information.
1: This RAM area is written with valid key information.

Each individual ram_area_writtenx bit can be reset by writing 1.

Note: This register is reset on a soft reset from the master control module. After a soft reset, all keys must be rewritten to the key store memory." id="RAM_AREA_WRITTEN7" resetval="" >
        </bitfield>
        <bitfield range="" begin="6" width="1" end="6" rwaccess="RW" description="Read operation:
0: This RAM area is not written with valid key information.
1: This RAM area is written with valid key information.

Each individual ram_area_writtenx bit can be reset by writing 1.

Note: This register is reset on a soft reset from the master control module. After a soft reset, all keys must be rewritten to the key store memory." id="RAM_AREA_WRITTEN6" resetval="" >
        </bitfield>
        <bitfield range="" begin="5" width="1" end="5" rwaccess="RW" description="Read operation:
0: This RAM area is not written with valid key information.
1: This RAM area is written with valid key information.

Each individual ram_area_writtenx bit can be reset by writing 1.

Note: This register is reset on a soft reset from the master control module. After a soft reset, all keys must be rewritten to the key store memory." id="RAM_AREA_WRITTEN5" resetval="" >
        </bitfield>
        <bitfield range="" begin="4" width="1" end="4" rwaccess="RW" description="Read operation:
0: This RAM area is not written with valid key information.
1: This RAM area is written with valid key information.

Each individual ram_area_writtenx bit can be reset by writing 1.

Note: This register is reset on a soft reset from the master control module. After a soft reset, all keys must be rewritten to the key store memory." id="RAM_AREA_WRITTEN4" resetval="" >
        </bitfield>
        <bitfield range="" begin="3" width="1" end="3" rwaccess="RW" description="Read operation:
0: This RAM area is not written with valid key information.
1: This RAM area is written with valid key information.

Each individual ram_area_writtenx bit can be reset by writing 1.

Note: This register is reset on a soft reset from the master control module. After a soft reset, all keys must be rewritten to the key store memory." id="RAM_AREA_WRITTEN3" resetval="" >
        </bitfield>
        <bitfield range="" begin="2" width="1" end="2" rwaccess="RW" description="Read operation:
0: This RAM area is not written with valid key information.
1: This RAM area is written with valid key information.

Each individual ram_area_writtenx bit can be reset by writing 1.

Note: This register is reset on a soft reset from the master control module. After a soft reset, all keys must be rewritten to the key store memory." id="RAM_AREA_WRITTEN2" resetval="" >
        </bitfield>
        <bitfield range="" begin="1" width="1" end="1" rwaccess="RW" description="Read operation:
0: This RAM area is not written with valid key information.
1: This RAM area is written with valid key information.

Each individual ram_area_writtenx bit can be reset by writing 1.

Note: This register is reset on a soft reset from the master control module. After a soft reset, all keys must be rewritten to the key store memory." id="RAM_AREA_WRITTEN1" resetval="" >
        </bitfield>
        <bitfield range="" begin="0" width="1" end="0" rwaccess="RW" description="Read operation:
0: This RAM area is not written with valid key information.
1: This RAM area is written with valid key information.

Each individual ram_area_writtenx bit can be reset by writing 1.

Note: This register is reset on a soft reset from the master control module. After a soft reset, all keys must be rewritten to the key store memory." id="RAM_AREA_WRITTEN0" resetval="" >
        </bitfield>
    </register>
    <register acronym="KEY_STORE_SIZE" width="32" description="Key store size register
This register defines the size of the keys that are written with DMA. This register should be configured before writing to the KEY_STORE_WRITE_AREA register." id="KEY_STORE_SIZE" offset="0x408" >
        <bitfield range="" begin="31" width="30" end="2" rwaccess="RW" description="Write 0s and ignore on reading" id="Reserved1" resetval="" >
        </bitfield>
        <bitfield range="" begin="1" width="2" end="0" rwaccess="RW" description="Key size:
00: Reserved
01: 128 bits
10: 192 bits
11: 256 bits
When writing this to this register, the KEY_STORE_WRITTEN_AREA register is reset." id="KEY_SIZE" resetval="" >
        </bitfield>
    </register>
    <register acronym="KEY_STORE_READ_AREA" width="32" description="Key store read area register
This register selects the key store RAM area from where the key needs to be read that will be used for an AES operation. The operation directly starts after writing this register. When the operation is finished, the status of the key store read operation is available in the interrupt status register. Key store read error is asserted when a RAM area is selected which does not contain valid written key." id="KEY_STORE_READ_AREA" offset="0x40c" >
        <bitfield range="" begin="31" width="1" end="31" rwaccess="RO" description="Key store operation busy status flag (read only):
0: Operation is complete.
1: Operation is not completed and the key store is busy." id="BUSY" resetval="" >
        </bitfield>
        <bitfield range="" begin="30" width="27" end="4" rwaccess="RW" description="Write 0s and ignore on reading" id="Reserved1" resetval="" >
        </bitfield>
        <bitfield range="" begin="3" width="4" end="0" rwaccess="RW" description="Selects the area of the key store RAM from where the key needs to be read that will be writen to the AES engine
RAM_AREA:
0000: RAM_AREA0
0001: RAM_AREA1
0010: RAM_AREA2
0011: RAM_AREA3
0100: RAM_AREA4
0101: RAM_AREA5
0110: RAM_AREA6
0111: RAM_AREA7
1000: no RAM area selected
1001-1111:  Reserved
RAM areas RAM_AREA0, RAM_AREA2, RAM_AREA4 and RAM_AREA6 are the only valid read areas for 192 and 256 bits key sizes.
Only RAM areas that contain valid written keys can be selected." id="RAM_AREA" resetval="" >
        </bitfield>
    </register>
    <register acronym="AES_KEY2_0" width="32" description="AES_KEY2_0 / AES_GHASH_H_IN_0
Second Key / GHASH Key (internal, but clearable)
The following registers are not accessible through the host for reading and writing. They are used to store internally calculated key information and intermediate results. However, when the host performs a write to the any of the respective AES_KEY2_n or AES_KEY3_n addresses, respectively the whole 128-bit AES_KEY2_n or AES_KEY3_n register is cleared to 0s.
The AES_GHASH_H_IN_n registers (required for GHASH, which is part of GCM) are mapped to the AES_KEY2_n registers. The (intermediate) authentication result for GCM and CCM is stored in the AES_KEY3_n register." id="AES_KEY2_0" offset="0x500" >
        <bitfield range="" begin="31" width="32" end="0" rwaccess="WO" description="AES_KEY2/AES_GHASH_H[31:0]

For GCM: 
-[127:0] - GHASH_H - The internally calculated GHASH key is stored in these registers. Only used for modes that use the GHASH function (GCM).
-[255:128] - This register is used to store intermediate values and is initialized with 0s when loading a new key.

For CCM:
-[255:0] - This register is used to store intermediate values.

For CBC-MAC:
-[255:0] - ZEROES - This register must remain 0." id="AES_KEY2" resetval="" >
        </bitfield>
    </register>
    <register acronym="AES_KEY2_1" width="32" description="AES_KEY2_1 / AES_GHASH_H_IN_1
Second Key / GHASH Key (internal, but clearable)
The following registers are not accessible through the host for reading and writing. They are used to store internally calculated key information and intermediate results. However, when the host performs a write to the any of the respective AES_KEY2_n or AES_KEY3_n addresses, respectively the whole 128-bit AES_KEY2_n or AES_KEY3_n register is cleared to 0s.
The AES_GHASH_H_IN_n registers (required for GHASH, which is part of GCM) are mapped to the AES_KEY2_n registers. The (intermediate) authentication result for GCM and CCM is stored in the AES_KEY3_n register." id="AES_KEY2_1" offset="0x504" >
        <bitfield range="" begin="31" width="32" end="0" rwaccess="WO" description="AES_KEY2/AES_GHASH_H[63:32]

For GCM: 
-[127:0] - GHASH_H - The internally calculated GHASH key is stored in these registers. Only used for modes that use the GHASH function (GCM).
-[255:128] - This register is used to store intermediate values and is initialized with 0s when loading a new key.

For CCM:
-[255:0] - This register is used to store intermediate values.

For CBC-MAC:
-[255:0] - ZEROES - This register must remain 0." id="AES_KEY2" resetval="" >
        </bitfield>
    </register>
    <register acronym="AES_KEY2_2" width="32" description="AES_KEY2_2 / AES_GHASH_H_IN_2
Second Key / GHASH Key (internal, but clearable)
The following registers are not accessible through the host for reading and writing. They are used to store internally calculated key information and intermediate results. However, when the host performs a write to the any of the respective AES_KEY2_n or AES_KEY3_n addresses, respectively the whole 128-bit AES_KEY2_n or AES_KEY3_n register is cleared to 0s.
The AES_GHASH_H_IN_n registers (required for GHASH, which is part of GCM) are mapped to the AES_KEY2_n registers. The (intermediate) authentication result for GCM and CCM is stored in the AES_KEY3_n register." id="AES_KEY2_2" offset="0x508" >
        <bitfield range="" begin="31" width="32" end="0" rwaccess="WO" description="AES_KEY2/AES_GHASH_H[95:64]

For GCM: 
-[127:0] - GHASH_H - The internally calculated GHASH key is stored in these registers. Only used for modes that use the GHASH function (GCM).
-[255:128] - This register is used to store intermediate values and is initialized with 0s when loading a new key.

For CCM:
-[255:0] - This register is used to store intermediate values.

For CBC-MAC:
-[255:0] - ZEROES - This register must remain 0." id="AES_KEY2" resetval="" >
        </bitfield>
    </register>
    <register acronym="AES_KEY2_3" width="32" description="AES_KEY2_3 / AES_GHASH_H_IN_3
Second Key / GHASH Key (internal, but clearable)
The following registers are not accessible through the host for reading and writing. They are used to store internally calculated key information and intermediate results. However, when the host performs a write to the any of the respective AES_KEY2_n or AES_KEY3_n addresses, respectively the whole 128-bit AES_KEY2_n or AES_KEY3_n register is cleared to 0s.
The AES_GHASH_H_IN_n registers (required for GHASH, which is part of GCM) are mapped to the AES_KEY2_n registers. The (intermediate) authentication result for GCM and CCM is stored in the AES_KEY3_n register." id="AES_KEY2_3" offset="0x50c" >
        <bitfield range="" begin="31" width="32" end="0" rwaccess="WO" description="AES_KEY2/AES_GHASH_H[127:96]

For GCM: 
-[127:0] - GHASH_H - The internally calculated GHASH key is stored in these registers. Only used for modes that use the GHASH function (GCM).
-[255:128] - This register is used to store intermediate values and is initialized with 0s when loading a new key.

For CCM:
-[255:0] - This register is used to store intermediate values.

For CBC-MAC:
-[255:0] - ZEROES - This register must remain 0." id="AES_KEY2" resetval="" >
        </bitfield>
    </register>
    <register acronym="AES_KEY3_0" width="32" description="AES_KEY3_0 / AES_KEY2_4
Third Key / Second Key (internal, but clearable)
The following registers are not accessible through the host for reading and writing. They are used to store internally calculated key information and intermediate results. However, when the host performs a write to the any of the respective AES_KEY2_n or AES_KEY3_n addresses, respectively the whole 128-bit AES_KEY2_n or AES_KEY3_n register is cleared to 0s.
The AES_GHASH_H_IN_n registers (required for GHASH, which is part of GCM) are mapped to the AES_KEY2_n registers. The (intermediate) authentication result for GCM and CCM is stored in the AES_KEY3_n register." id="AES_KEY3_0" offset="0x510" >
        <bitfield range="" begin="31" width="32" end="0" rwaccess="WO" description="AES_KEY3[31:0]/AES_KEY2[159:128]

For GCM: 
-[127:0] - GHASH_H - The internally calculated GHASH key is stored in these registers. Only used for modes that use the GHASH function (GCM).
-[255:128] - This register is used to store intermediate values and is initialized with 0s when loading a new key.

For CCM:
-[255:0] - This register is used to store intermediate values.

For CBC-MAC:
-[255:0] - ZEROES - This register must remain 0." id="AES_KEY3" resetval="" >
        </bitfield>
    </register>
    <register acronym="AES_KEY3_1" width="32" description="AES_KEY3_1 / AES_KEY2_5
Third Key / Second Key (internal, but clearable)
The following registers are not accessible through the host for reading and writing. They are used to store internally calculated key information and intermediate results. However, when the host performs a write to the any of the respective AES_KEY2_n or AES_KEY3_n addresses, respectively the whole 128-bit AES_KEY2_n or AES_KEY3_n register is cleared to 0s.
The AES_GHASH_H_IN_n registers (required for GHASH, which is part of GCM) are mapped to the AES_KEY2_n registers. The (intermediate) authentication result for GCM and CCM is stored in the AES_KEY3_n register." id="AES_KEY3_1" offset="0x514" >
        <bitfield range="" begin="31" width="32" end="0" rwaccess="WO" description="AES_KEY3[63:32]/AES_KEY2[191:160]

For GCM: 
-[127:0] - GHASH_H - The internally calculated GHASH key is stored in these registers. Only used for modes that use the GHASH function (GCM).
-[255:128] - This register is used to store intermediate values and is initialized with 0s when loading a new key.

For CCM:
-[255:0] - This register is used to store intermediate values.

For CBC-MAC:
-[255:0] - ZEROES - This register must remain 0." id="AES_KEY3" resetval="" >
        </bitfield>
    </register>
    <register acronym="AES_KEY3_2" width="32" description="AES_KEY3_2 / AES_KEY2_6
Third Key / Second Key (internal, but clearable)
The following registers are not accessible through the host for reading and writing. They are used to store internally calculated key information and intermediate results. However, when the host performs a write to the any of the respective AES_KEY2_n or AES_KEY3_n addresses, respectively the whole 128-bit AES_KEY2_n or AES_KEY3_n register is cleared to 0s.
The AES_GHASH_H_IN_n registers (required for GHASH, which is part of GCM) are mapped to the AES_KEY2_n registers. The (intermediate) authentication result for GCM and CCM is stored in the AES_KEY3_n register." id="AES_KEY3_2" offset="0x518" >
        <bitfield range="" begin="31" width="32" end="0" rwaccess="WO" description="AES_KEY3[95:64]/AES_KEY2[223:192]

For GCM: 
-[127:0] - GHASH_H - The internally calculated GHASH key is stored in these registers. Only used for modes that use the GHASH function (GCM).
-[255:128] - This register is used to store intermediate values and is initialized with 0s when loading a new key.

For CCM:
-[255:0] - This register is used to store intermediate values.

For CBC-MAC:
-[255:0] - ZEROES - This register must remain 0." id="AES_KEY3" resetval="" >
        </bitfield>
    </register>
    <register acronym="AES_KEY3_3" width="32" description="AES_KEY3_3 / AES_KEY2_7
Third Key / Second Key (internal, but clearable)
The following registers are not accessible through the host for reading and writing. They are used to store internally calculated key information and intermediate results. However, when the host performs a write to the any of the respective AES_KEY2_n or AES_KEY3_n addresses, respectively the whole 128-bit AES_KEY2_n or AES_KEY3_n register is cleared to 0s.
The AES_GHASH_H_IN_n registers (required for GHASH, which is part of GCM) are mapped to the AES_KEY2_n registers. The (intermediate) authentication result for GCM and CCM is stored in the AES_KEY3_n register." id="AES_KEY3_3" offset="0x51c" >
        <bitfield range="" begin="31" width="32" end="0" rwaccess="WO" description="AES_KEY3[127:96]/AES_KEY2[255:224]

For GCM: 
-[127:0] - GHASH_H - The internally calculated GHASH key is stored in these registers. Only used for modes that use the GHASH function (GCM).
-[255:128] - This register is used to store intermediate values and is initialized with 0s when loading a new key.

For CCM:
-[255:0] - This register is used to store intermediate values.

For CBC-MAC:
-[255:0] - ZEROES - This register must remain 0." id="AES_KEY3" resetval="" >
        </bitfield>
    </register>
    <register acronym="AES_IV_0" width="32" description="AES initialization vector registers
These registers are used to provide and read the IV from the AES engine." id="AES_IV_0" offset="0x540" >
        <bitfield range="" begin="31" width="32" end="0" rwaccess="RW" description="AES_IV[31:0]

Initialization vector
Used for regular non-ECB modes (CBC/CTR):
-[127:0] - AES_IV - For regular AES operations (CBC and CTR) these registers must be written with a new 128-bit IV. After an operation, these registers contain the latest 128-bit result IV, generated by the EIP-120t. If CTR mode is selected, this value is incremented with 0x1: After first use - When a new data block is submitted to the engine

For GCM:
-[127:0] - AES_IV - For GCM operations, these registers must be written with a new 128-bit IV.
After an operation, these registers contain the updated 128-bit result IV, generated by the EIP-120t. Note that bits [127:96] of the IV represent the initial counter value (which is 1 for GCM) and must therefore be initialized to 0x01000000. This value is incremented with 0x1: After first use - When a new data block is submitted to the engine.

For CCM:
-[127:0] - A0: For CCM this field must be written with value A0, this value is the concatenation of: A0-flags (5-bits of 0 and 3-bits &apos;L&apos;), Nonce and counter value. &apos;L&apos; must be a copy from the &apos;L&apos; value of the AES_CTRL register. This &apos;L&apos; indicates the width of the Nonce and counter. The loaded counter must be initialized to 0. The total width of A0 is 128-bit.

For CBC-MAC:
-[127:0] - Zeroes - For CBC-MAC this register must be written with 0s at the start of each operation. After an operation, these registers contain the 128-bit TAG output, generated by the EIP-120t." id="AES_IV" resetval="" >
        </bitfield>
    </register>
    <register acronym="AES_IV_1" width="32" description="AES initialization vector registers
These registers are used to provide and read the IV from the AES engine." id="AES_IV_1" offset="0x544" >
        <bitfield range="" begin="31" width="32" end="0" rwaccess="RW" description="AES_IV[63:32]

Initialization vector
Used for regular non-ECB modes (CBC/CTR):
-[127:0] - AES_IV - For regular AES operations (CBC and CTR) these registers must be written with a new 128-bit IV. After an operation, these registers contain the latest 128-bit result IV, generated by the EIP-120t. If CTR mode is selected, this value is incremented with 0x1: After first use - When a new data block is submitted to the engine

For GCM:
-[127:0] - AES_IV - For GCM operations, these registers must be written with a new 128-bit IV.
After an operation, these registers contain the updated 128-bit result IV, generated by the EIP-120t. Note that bits [127:96] of the IV represent the initial counter value (which is 1 for GCM) and must therefore be initialized to 0x01000000. This value is incremented with 0x1: After first use - When a new data block is submitted to the engine.

For CCM:
-[127:0] - A0: For CCM this field must be written with value A0, this value is the concatenation of: A0-flags (5-bits of 0 and 3-bits &apos;L&apos;), Nonce and counter value. &apos;L&apos; must be a copy from the &apos;L&apos; value of the AES_CTRL register. This &apos;L&apos; indicates the width of the Nonce and counter. The loaded counter must be initialized to 0. The total width of A0 is 128-bit.

For CBC-MAC:
-[127:0] - Zeroes - For CBC-MAC this register must be written with 0s at the start of each operation. After an operation, these registers contain the 128-bit TAG output, generated by the EIP-120t." id="AES_IV" resetval="" >
        </bitfield>
    </register>
    <register acronym="AES_IV_2" width="32" description="AES initialization vector registers
These registers are used to provide and read the IV from the AES engine." id="AES_IV_2" offset="0x548" >
        <bitfield range="" begin="31" width="32" end="0" rwaccess="RW" description="AES_IV[95:64]

Initialization vector
Used for regular non-ECB modes (CBC/CTR):
-[127:0] - AES_IV - For regular AES operations (CBC and CTR) these registers must be written with a new 128-bit IV. After an operation, these registers contain the latest 128-bit result IV, generated by the EIP-120t. If CTR mode is selected, this value is incremented with 0x1: After first use - When a new data block is submitted to the engine

For GCM:
-[127:0] - AES_IV - For GCM operations, these registers must be written with a new 128-bit IV.
After an operation, these registers contain the updated 128-bit result IV, generated by the EIP-120t. Note that bits [127:96] of the IV represent the initial counter value (which is 1 for GCM) and must therefore be initialized to 0x01000000. This value is incremented with 0x1: After first use - When a new data block is submitted to the engine.

For CCM:
-[127:0] - A0: For CCM this field must be written with value A0, this value is the concatenation of: A0-flags (5-bits of 0 and 3-bits &apos;L&apos;), Nonce and counter value. &apos;L&apos; must be a copy from the &apos;L&apos; value of the AES_CTRL register. This &apos;L&apos; indicates the width of the Nonce and counter. The loaded counter must be initialized to 0. The total width of A0 is 128-bit.

For CBC-MAC:
-[127:0] - Zeroes - For CBC-MAC this register must be written with 0s at the start of each operation. After an operation, these registers contain the 128-bit TAG output, generated by the EIP-120t." id="AES_IV" resetval="" >
        </bitfield>
    </register>
    <register acronym="AES_IV_3" width="32" description="AES initialization vector registers
These registers are used to provide and read the IV from the AES engine." id="AES_IV_3" offset="0x54c" >
        <bitfield range="" begin="31" width="32" end="0" rwaccess="RW" description="AES_IV[127:96]

Initialization vector
Used for regular non-ECB modes (CBC/CTR):
-[127:0] - AES_IV - For regular AES operations (CBC and CTR) these registers must be written with a new 128-bit IV. After an operation, these registers contain the latest 128-bit result IV, generated by the EIP-120t. If CTR mode is selected, this value is incremented with 0x1: After first use - When a new data block is submitted to the engine

For GCM:
-[127:0] - AES_IV - For GCM operations, these registers must be written with a new 128-bit IV.
After an operation, these registers contain the updated 128-bit result IV, generated by the EIP-120t. Note that bits [127:96] of the IV represent the initial counter value (which is 1 for GCM) and must therefore be initialized to 0x01000000. This value is incremented with 0x1: After first use - When a new data block is submitted to the engine.

For CCM:
-[127:0] - A0: For CCM this field must be written with value A0, this value is the concatenation of: A0-flags (5-bits of 0 and 3-bits &apos;L&apos;), Nonce and counter value. &apos;L&apos; must be a copy from the &apos;L&apos; value of the AES_CTRL register. This &apos;L&apos; indicates the width of the Nonce and counter. The loaded counter must be initialized to 0. The total width of A0 is 128-bit.

For CBC-MAC:
-[127:0] - Zeroes - For CBC-MAC this register must be written with 0s at the start of each operation. After an operation, these registers contain the 128-bit TAG output, generated by the EIP-120t." id="AES_IV" resetval="" >
        </bitfield>
    </register>
    <register acronym="AES_CTRL" width="32" description="AES input/output buffer control and mode register
This register specifies the AES mode of operation for the EIP-120t.
Electronic codebook (ECB) mode is automatically selected if bits [28:5] of this register are all 0." id="AES_CTRL" offset="0x550" >
        <bitfield range="" begin="31" width="1" end="31" rwaccess="RO" description="If 1, this read-only status bit indicates that the context data registers can be overwritten and the host is permitted to write the next context." id="context_ready" resetval="" >
        </bitfield>
        <bitfield range="" begin="30" width="1" end="30" rwaccess="RW" description="If 1, this status bit indicates that an AES authentication TAG and/or IV block(s) is/are available for the host to retrieve. This bit is only asserted if the save_context bit is set to 1. The bit is mutual exclusive with the context_ready bit.
Writing one clears the bit to 0, indicating the AES core can start its next operation. This bit is also cleared when the 4th word of the output TAG and/or IV is read.
Note: All other mode bit writes are ignored when this mode bit is written with 1.
Note: This bit is controlled automatically by the EIP-120t for TAG read DMA operations." id="saved_context_ready" resetval="" >
        </bitfield>
        <bitfield range="" begin="29" width="1" end="29" rwaccess="RW" description="This bit indicates that an authentication TAG or result IV needs to be stored as a result context.
Typically this bit must be set for authentication modes returning a TAG (CBC-MAC, GCM and CCM), or for basic encryption modes that require future continuation with the current result IV.
If this bit is set, the engine retains its full context until the TAG and/or IV registers are read.
The TAG or IV must be read before the AES engine can start a new operation." id="save_context" resetval="" >
        </bitfield>
        <bitfield range="" begin="28" width="4" end="25" rwaccess="RW" description="Bits should be written with a value of 0. and ignored on a read." id="Reserved1" resetval="" >
        </bitfield>
        <bitfield range="" begin="24" width="3" end="22" rwaccess="RW" description="Defines M, which indicates the length of the authentication field for CCM operations; the authentication field length equals two times (the value of CCM-M plus one).
Note: The EIP-120t always returns a 128-bit authentication field, of which the M least significant bytes are valid. All values are supported." id="CCM_M" resetval="" >
        </bitfield>
        <bitfield range="" begin="21" width="3" end="19" rwaccess="RW" description="Defines L, which indicates the width of the length field for CCM operations; the length field in bytes equals the value of CMM-L plus one. All values are supported." id="CCM_L" resetval="" >
        </bitfield>
        <bitfield range="" begin="18" width="1" end="18" rwaccess="RW" description="If set to 1, AES-CCM is selected
AES-CCM is a combined mode, using AES for authentication and encryption.
Note: Selecting AES-CCM mode requires writing of the AAD length register after all other registers.
Note: The CTR mode bit in this register must also be set to 1 to enable AES-CTR; selecting other AES modes than CTR mode is invalid." id="CCM" resetval="" >
        </bitfield>
        <bitfield range="" begin="17" width="2" end="16" rwaccess="RW" description="Set these bits to 11 to select AES-GCM mode.
AES-GCM is a combined mode, using the Galois field multiplier GF(2 to the power of 128) for authentication and AES-CTR mode for encryption.
Note: The CTR mode bit in this register must also be set to 1 to enable AES-CTR
Bit combination description:
00 = No GCM mode
01 = Reserved, do not select
10 = Reserved, do not select
11 = Autonomous GHASH (both H- and Y0-encrypted calculated internally)
Note: The EIP-120t-1 configuration only supports mode 11 (autonomous GHASH), other GCM modes are not allowed." id="GCM" resetval="" >
        </bitfield>
        <bitfield range="" begin="15" width="1" end="15" rwaccess="RW" description="Set to 1 to select AES-CBC MAC mode.
The direction bit must be set to 1 for this mode.
Selecting this mode requires writing the length register after all other registers." id="CBC_MAC" resetval="" >
        </bitfield>
        <bitfield range="" begin="14" width="6" end="9" rwaccess="RW" description="Bits should be written with a value of 0. and ignored on a read." id="Reserved2" resetval="" >
        </bitfield>
        <bitfield range="" begin="8" width="2" end="7" rwaccess="RW" description="Specifies the counter width for AES-CTR mode
00 = 32-bit counter
01 = 64-bit counter
10 = 96-bit counter
11 = 128-bit counter" id="ctr_width" resetval="" >
        </bitfield>
        <bitfield range="" begin="6" width="1" end="6" rwaccess="RW" description="If set to 1, AES counter mode (CTR) is selected.
Note: This bit must also be set for GCM and CCM, when encryption/decryption is required." id="CTR" resetval="" >
        </bitfield>
        <bitfield range="" begin="5" width="1" end="5" rwaccess="RW" description="If set to 1, cipher-block-chaining (CBC) mode is selected." id="CBC" resetval="" >
        </bitfield>
        <bitfield range="" begin="4" width="2" end="3" rwaccess="RO" description="This read-only field specifies the key size.
The key size is automatically configured when a new key is loaded through the key store module.
00 = N/A - Reserved
01 = 128-bit
10 = 192-bit
11 = 256-bit" id="key_size" resetval="" >
        </bitfield>
        <bitfield range="" begin="2" width="1" end="2" rwaccess="RW" description="If set to 1 an encrypt operation is performed.
If set to 0 a decrypt operation is performed.
This bit must be written with a 1 when CBC-MAC is selected." id="direction" resetval="" >
        </bitfield>
        <bitfield range="" begin="1" width="1" end="1" rwaccess="RW" description="If 1, this status bit indicates that the 16-byte AES input buffer is empty. The host is permitted to write the next block of data.
Writing 0 clears the bit to 0 and indicates that the AES core can use the provided input data block.
Writing 1 to this bit is ignored.
Note: For DMA operations, this bit is automatically controlled by the EIP-120t.
After reset, this bit is 0. After writing a context, this bit becomes 1." id="input_ready" resetval="" >
        </bitfield>
        <bitfield range="" begin="0" width="1" end="0" rwaccess="RW" description="If 1, this status bit indicates that an AES output block is available to be retrieved by the host.
Writing 0 clears the bit to 0 and indicates that output data is read by the host. The AES core can provide a next output data block.
Writing 1 to this bit is ignored.
Note: For DMA operations, this bit is automatically controlled by the EIP-120t." id="output_ready" resetval="" >
        </bitfield>
    </register>
    <register acronym="AES_C_LENGTH_0" width="32" description="AES crypto length registers (LSW)
These registers are used to write the Length values to the EIP-120t. While processing, the length values decrement to 0. If both lengths are 0, the data stream is finished and a new context is requested. For basic AES modes (ECB, CBC, and CTR), a crypto length of 0 can be written if multiple streams need to be processed with the same key. Writing 0 length results in continued data requests until a new context is written. For the other modes (CBC-MAC, GCM, and CCM) no (new) data requests are done if the length decrements to or equals 0.
It is advised to write a new length per packet. If the length registers decrement to 0, no new data is processed until a new context or length value is written.
When writing a new mode without writing the length registers, the length register values from the previous context is reused." id="AES_C_LENGTH_0" offset="0x554" >
        <bitfield range="" begin="31" width="32" end="0" rwaccess="WO" description="C_LENGTH[31:0]
Bits [60:0] of the crypto length registers (LSW and MSW) store the cryptographic data length in bytes for all modes. Once processing with this context is started, this length decrements to 0. Data lengths up to (261: 1) bytes are allowed.
For GCM, any value up to 236 - 32 bytes can be used. This is because a 32-bit counter mode is used; the maximum number of 128-bit blocks is 232 - 2, resulting in a maximum number of bytes of 236 - 32.
A write to this register triggers the engine to start using this context. This is valid for all modes except GCM and CCM.
Note: For the combined modes (GCM and CCM), this length does not include the authentication only data; the authentication length is specified in the AES_AUTH_LENGTH register below.
All modes must have a length greater than 0. For the combined modes, it is allowed to have one of the lengths equal to 0.
For the basic encryption modes (ECB, CBC, and CTR) it is allowed to program zero to the length field; in that case the length is assumed infinite.
All data must be byte (8-bit) aligned for stream cipher modes; bit aligned data streams are not supported by the EIP-120t. For block cipher modes, the data length must be programmed in multiples of the block cipher size, 16 bytes.
For a host read operation, these registers return all-0s." id="C_LENGTH" resetval="" >
        </bitfield>
    </register>
    <register acronym="AES_C_LENGTH_1" width="32" description="AES crypto length registers (MSW)
These registers are used to write the Length values to the EIP-120t. While processing, the length values decrement to 0. If both lengths are 0, the data stream is finished and a new context is requested. For basic AES modes (ECB, CBC, and CTR), a crypto length of 0 can be written if multiple streams need to be processed with the same key. Writing 0 length results in continued data requests until a new context is written. For the other modes (CBC-MAC, GCM and CCM) no (new) data requests are done if the length decrements to or equals 0.
It is advised to write a new length per packet. If the length registers decrement to 0, no new data is processed until a new context or length value is written.
When writing a new mode without writing the length registers, the length register values from the previous context is reused." id="AES_C_LENGTH_1" offset="0x558" >
        <bitfield range="" begin="31" width="3" end="29" rwaccess="WO" description="Bits should be written with a value of 0. and ignored on a read." id="Reserved1" resetval="" >
        </bitfield>
        <bitfield range="" begin="28" width="29" end="0" rwaccess="WO" description="C_LENGTH[60:32]
Bits [60:0] of the crypto length registers (LSW and MSW) store the cryptographic data length in bytes for all modes. Once processing with this context is started, this length decrements to 0. Data lengths up to (261: 1) bytes are allowed.
For GCM, any value up to 236 - 32 bytes can be used. This is because a 32-bit counter mode is used; the maximum number of 128-bit blocks is 232 - 2, resulting in a maximum number of bytes of 236 - 32.
A write to this register triggers the engine to start using this context. This is valid for all modes except GCM and CCM.
Note: For the combined modes (GCM and CCM), this length does not include the authentication only data; the authentication length is specified in the AES_AUTH_LENGTH register below.
All modes must have a length greater than 0. For the combined modes, it is allowed to have one of the lengths equal to 0.
For the basic encryption modes (ECB, CBC, and CTR) it is allowed to program zero to the length field; in that case the length is assumed infinite.
All data must be byte (8-bit) aligned for stream cipher modes; bit aligned data streams are not supported by the EIP-120t. For block cipher modes, the data length must be programmed in multiples of the block cipher size, 16 bytes.
For a host read operation, these registers return all-0s." id="C_LENGTH" resetval="" >
        </bitfield>
    </register>
    <register acronym="AES_AUTH_LENGTH" width="32" description="Authentication length register" id="AES_AUTH_LENGTH" offset="0x55c" >
        <bitfield range="" begin="31" width="32" end="0" rwaccess="WO" description="Bits [31:0] of the authentication length register store the authentication data length in bytes for combined modes only (GCM or CCM).
Supported AAD-lengths for CCM are from 0 to (2^16 - 2^8) bytes. For GCM any value up to (2^32 - 1) bytes can be used. Once processing with this context is started, this length decrements to 0.
A write to this register triggers the engine to start using this context for GCM and CCM.
For a host read operation, these registers return all-0s." id="AUTH_LENGTH" resetval="" >
        </bitfield>
    </register>
    <register acronym="AES_DATA_IN_OUT_0" width="32" description="Data input/output registers
The data registers are typically accessed through the DMA and not with host writes and/or reads. However, for debugging purposes the data input/output registers can be accessed via host write and read operations. The registers are used to buffer the input/output data blocks to/from the EIP-120t.
Note: The data input buffer (AES_DATA_IN_n) and data output buffer (AES_DATA_OUT_n) are mapped to the same address locations.
Writes (both DMA and host) to these addresses load the Input Buffer while reads pull from the Output Buffer. Therefore, for write access, the data input buffer is written; for read access, the data output buffer is read. The data input buffer must be written before starting an operation. The data output buffer contains valid data on completion of an operation. Therefore, any 128-bit data block can be split over multiple 32-bit word transfers; these can be mixed with other host transfers over the external interface." id="AES_DATA_IN_OUT_0" offset="0x560" >
        <bitfield range="" begin="31" width="32" end="0" rwaccess="WO" description="AES input data[31:0] / AES output data[31:0]
Data registers for input/output block data to/from the EIP-120t.
For normal operations, this register is not used, since data input and output is transferred from and to the AES core via DMA. For a host write operation, these registers must be written with the 128-bit input block for the next AES operation. Writing at a word-aligned offset within this address range stores the word (4 bytes) of data into the corresponding position of 4-word deep (16 bytes = 128-bit AES block) data input buffer. This buffer is used for the next AES operation. If the last data block is not completely filled with valid data (see notes below), it is allowed to write only the words with valid data. Next AES operation is triggered by writing to the input_ready flag of the AES_CTRL register.
For a host read operation, these registers contain the 128-bit output block from the latest AES operation. Reading from a word-aligned offset within this address range reads one word (4 bytes) of data out the 4-word deep (16 bytes = 128-bits AES block) data output buffer. The words (4 words, one full block) should be read before the core will move the next block to the data output buffer. To empty the data output buffer, the output_ready flag of the AES_CTRL register must be written.
For the modes with authentication (CBC-MAC, GCM and CCM), the invalid (message) bytes/words can be written with any data.
Note: AES typically operates on 128 bits block multiple input data. The CTR, GCM and CCM modes form an exception. The last block of a CTR-mode message may contain less than 128 bits (refer to [NIST 800-38A]). For GCM/CCM, the last block of both AAD and message data may contain less than 128 bits (refer to [NIST 800-38D]). The EIP-120t automatically pads or masks misaligned ending data blocks with 0s for GCM, CCM and CBC-MAC. For CTR mode, the remaining data in an unaligned data block is ignored.
Note: The AAD / authentication only data is not copied to the output buffer but only used for authentication." id="AES_DATA_IN_OUT" resetval="" >
        </bitfield>
    </register>
    <register acronym="AES_DATA_IN_OUT_1" width="32" description="Data Input/Output Registers
The data registers are typically accessed via DMA and not with host writes and/or reads. However, for debugging purposes the Data Input/Output Registers can be accessed via host write and read operations. The registers are used to buffer the input/output data blocks to/from the EIP-120t.
Note: The data input buffer (AES_DATA_IN_n) and data output buffer (AES_DATA_OUT_n) are mapped to the same address locations.
Writes (both DMA and host) to these addresses load the Input Buffer while reads pull from the Output Buffer. Therefore, for write access, the data input buffer is written; for read access, the data output buffer is read. The data input buffer must be written before starting an operation. The data output buffer contains valid data on completion of an operation. Therefore, any 128-bit data block can be split over multiple 32-bit word transfers; these can be mixed with other host transfers over the external interface." id="AES_DATA_IN_OUT_1" offset="0x564" >
        <bitfield range="" begin="31" width="32" end="0" rwaccess="WO" description="AES input data[63:32] / AES output data[63:32]
Data registers for input/output block data to/from the EIP-120t.
For normal operations, this register is not used, since data input and output is transferred from and to the AES core via DMA. For a host write operation, these registers must be written with the 128-bit input block for the next AES operation. Writing at a word-aligned offset within this address range stores the word (4 bytes) of data into the corresponding position of 4-word deep (16 bytes = 128-bit AES block) data input buffer. This buffer is used for the next AES operation. If the last data block is not completely filled with valid data (see notes below), it is allowed to write only the words with valid data. Next AES operation is triggered by writing to the input_ready flag of the AES_CTRL register.
For a host read operation, these registers contain the 128-bit output block from the latest AES operation. Reading from a word-aligned offset within this address range reads one word (4 bytes) of data out the 4-word deep (16 bytes = 128-bits AES block) data output buffer. The words (4 words, one full block) should be read before the core will move the next block to the data output buffer. To empty the data output buffer, the output_ready flag of the AES_CTRL register must be written.
For the modes with authentication (CBC-MAC, GCM and CCM), the invalid (message) bytes/words can be written with any data.
Note: AES typically operates on 128 bits block multiple input data. The CTR, GCM and CCM modes form an exception. The last block of a CTR-mode message may contain less than 128 bits (refer to [NIST 800-38A]). For GCM/CCM, the last block of both AAD and message data may contain less than 128 bits (refer to [NIST 800-38D]). The EIP-120t automatically pads or masks misaligned ending data blocks with 0s for GCM, CCM and CBC-MAC. For CTR mode, the remaining data in an unaligned data block is ignored.
Note: The AAD / authentication only data is not copied to the output buffer but only used for authentication." id="AES_DATA_IN_OUT" resetval="" >
        </bitfield>
    </register>
    <register acronym="AES_DATA_IN_OUT_2" width="32" description="Data Input/Output Registers
The data registers are typically accessed via DMA and not with host writes and/or reads. However, for debugging purposes the Data Input/Output Registers can be accessed via host write and read operations. The registers are used to buffer the input/output data blocks to/from the EIP-120t.
Note: The data input buffer (AES_DATA_IN_n) and data output buffer (AES_DATA_OUT_n) are mapped to the same address locations.
Writes (both DMA and host) to these addresses load the Input Buffer while reads pull from the Output Buffer. Therefore, for write access, the data input buffer is written; for read access, the data output buffer is read. The data input buffer must be written before starting an operation. The data output buffer contains valid data on completion of an operation. Therefore, any 128-bit data block can be split over multiple 32-bit word transfers; these can be mixed with other host transfers over the external interface." id="AES_DATA_IN_OUT_2" offset="0x568" >
        <bitfield range="" begin="31" width="32" end="0" rwaccess="WO" description="AES input data[95:64] / AES output data[95:64]
Data registers for input/output block data to/from the EIP-120t.
For normal operations, this register is not used, since data input and output is transferred from and to the AES core via DMA. For a host write operation, these registers must be written with the 128-bit input block for the next AES operation. Writing at a word-aligned offset within this address range stores the word (4 bytes) of data into the corresponding position of 4-word deep (16 bytes = 128-bit AES block) data input buffer. This buffer is used for the next AES operation. If the last data block is not completely filled with valid data (see notes below), it is allowed to write only the words with valid data. Next AES operation is triggered by writing to the input_ready flag of the AES_CTRL register.
For a host read operation, these registers contain the 128-bit output block from the latest AES operation. Reading from a word-aligned offset within this address range reads one word (4 bytes) of data out the 4-word deep (16 bytes = 128-bits AES block) data output buffer. The words (4 words, one full block) should be read before the core will move the next block to the data output buffer. To empty the data output buffer, the output_ready flag of the AES_CTRL register must be written.
For the modes with authentication (CBC-MAC, GCM and CCM), the invalid (message) bytes/words can be written with any data.
Note: AES typically operates on 128 bits block multiple input data. The CTR, GCM and CCM modes form an exception. The last block of a CTR-mode message may contain less than 128 bits (refer to [NIST 800-38A]). For GCM/CCM, the last block of both AAD and message data may contain less than 128 bits (refer to [NIST 800-38D]). The EIP-120t automatically pads or masks misaligned ending data blocks with 0s for GCM, CCM and CBC-MAC. For CTR mode, the remaining data in an unaligned data block is ignored.
Note: The AAD / authentication only data is not copied to the output buffer but only used for authentication." id="AES_DATA_IN_OUT" resetval="" >
        </bitfield>
    </register>
    <register acronym="AES_DATA_IN_OUT_3" width="32" description="Data Input/Output Registers
The data registers are typically accessed via DMA and not with host writes and/or reads. However, for debugging purposes the Data Input/Output Registers can be accessed via host write and read operations. The registers are used to buffer the input/output data blocks to/from the EIP-120t.
Note: The data input buffer (AES_DATA_IN_n) and data output buffer (AES_DATA_OUT_n) are mapped to the same address locations.
Writes (both DMA and host) to these addresses load the Input Buffer while reads pull from the Output Buffer. Therefore, for write access, the data input buffer is written; for read access, the data output buffer is read. The data input buffer must be written before starting an operation. The data output buffer contains valid data on completion of an operation. Therefore, any 128-bit data block can be split over multiple 32-bit word transfers; these can be mixed with other host transfers over the external interface." id="AES_DATA_IN_OUT_3" offset="0x56c" >
        <bitfield range="" begin="31" width="32" end="0" rwaccess="WO" description="AES input data[127:96] / AES output data[127:96]
Data registers for input/output block data to/from the EIP-120t.
For normal operations, this register is not used, since data input and output is transferred from and to the AES core via DMA. For a host write operation, these registers must be written with the 128-bit input block for the next AES operation. Writing at a word-aligned offset within this address range stores the word (4 bytes) of data into the corresponding position of 4-word deep (16 bytes = 128-bit AES block) data input buffer. This buffer is used for the next AES operation. If the last data block is not completely filled with valid data (see notes below), it is allowed to write only the words with valid data. Next AES operation is triggered by writing to the input_ready flag of the AES_CTRL register.
For a host read operation, these registers contain the 128-bit output block from the latest AES operation. Reading from a word-aligned offset within this address range reads one word (4 bytes) of data out the 4-word deep (16 bytes = 128-bits AES block) data output buffer. The words (4 words, one full block) should be read before the core will move the next block to the data output buffer. To empty the data output buffer, the output_ready flag of the AES_CTRL register must be written.
For the modes with authentication (CBC-MAC, GCM and CCM), the invalid (message) bytes/words can be written with any data.
Note: AES typically operates on 128 bits block multiple input data. The CTR, GCM and CCM modes form an exception. The last block of a CTR-mode message may contain less than 128 bits (refer to [NIST 800-38A]). For GCM/CCM, the last block of both AAD and message data may contain less than 128 bits (refer to [NIST 800-38D]). The EIP-120t automatically pads or masks misaligned ending data blocks with 0s for GCM, CCM and CBC-MAC. For CTR mode, the remaining data in an unaligned data block is ignored.
Note: The AAD / authentication only data is not copied to the output buffer but only used for authentication." id="AES_DATA_IN_OUT" resetval="" >
        </bitfield>
    </register>
    <register acronym="AES_TAG_OUT_0" width="32" description="TAG registers
The tag registers can be accessed via DMA or directly with host reads.
These registers buffer the TAG from the EIP-120t. The registers are shared with the intermediate authentication result registers, but cannot be read until the processing is finished. While processing, a read from these registers returns 0s. If an operation does not return a TAG, reading from these registers returns an IV. If an operation returns a TAG plus an IV and both need to be read by the host, the host must first read the TAG followed by the IV. Reading these in reverse order will return the IV twice." id="AES_TAG_OUT_0" offset="0x570" >
        <bitfield range="" begin="31" width="32" end="0" rwaccess="RO" description="AES_TAG[31:0]
Bits [31:0] of the AES_TAG registers store the authentication value for the combined and authentication only modes.
For a host read operation, these registers contain the last 128-bit TAG output of the EIP-120t; the TAG is available until the next context is written.
This register will only contain valid data if the TAG is available and when the store_ready bit from AES_CTRL register is set. During processing or for operations/modes that do not return a TAG, reads from this register return data from the IV register." id="AES_TAG" resetval="" >
        </bitfield>
    </register>
    <register acronym="AES_TAG_OUT_1" width="32" description="TAG registers
The tag registers can be accessed via DMA or directly with host reads.
These registers buffer the TAG from the EIP-120t. The registers are shared with the intermediate authentication result registers, but cannot be read until the processing is finished. While processing, a read from these registers returns 0s. If an operation does not return a TAG, reading from these registers returns an IV. If an operation returns a TAG plus an IV and both need to be read by the host, the host must first read the TAG followed by the IV. Reading these in reverse order returns the IV twice." id="AES_TAG_OUT_1" offset="0x574" >
        <bitfield range="" begin="31" width="32" end="0" rwaccess="RO" description="AES_TAG[63:32]
For a host read operation, these registers contain the last 128-bit TAG output of the EIP-120t; the TAG is available until the next context is written.
This register contains valid data only if the TAG is available and when the store_ready bit from AES_CTRL register is set. During processing or for operations/modes that do not return a TAG, reads from this register return data from the IV register." id="AES_TAG" resetval="" >
        </bitfield>
    </register>
    <register acronym="AES_TAG_OUT_2" width="32" description="TAG registers
The tag registers can be accessed via DMA or directly with host reads.
These registers buffer the TAG from the EIP-120t. The registers are shared with the intermediate authentication result registers, but cannot be read until the processing is finished. While processing, a read from these registers returns 0s. If an operation does not return a TAG, reading from these registers returns an IV. If an operation returns a TAG plus an IV and both need to be read by the host, the host must first read the TAG followed by the IV. Reading these in reverse order returns the IV twice." id="AES_TAG_OUT_2" offset="0x578" >
        <bitfield range="" begin="31" width="32" end="0" rwaccess="RO" description="AES_TAG[95:64]
For a host read operation, these registers contain the last 128-bit TAG output of the EIP-120t; the TAG is available until the next context is written.
This register contains valid data only if the TAG is available and when the store_ready bit from AES_CTRL register is set. During processing or for operations/modes that do not return a TAG, reads from this register return data from the IV register." id="AES_TAG" resetval="" >
        </bitfield>
    </register>
    <register acronym="AES_TAG_OUT_3" width="32" description="TAG registers
The tag registers can be accessed via DMA or directly with host reads.
These registers buffer the TAG from the EIP-120t. The registers are shared with the intermediate authentication result registers, but cannot be read until the processing is finished. While processing, a read from these registers returns 0s. If an operation does not return a TAG, reading from these registers returns an IV. If an operation returns a TAG plus an IV and both need to be read by the host, the host must first read the TAG followed by the IV. Reading these in reverse order returns the IV twice." id="AES_TAG_OUT_3" offset="0x57c" >
        <bitfield range="" begin="31" width="32" end="0" rwaccess="RO" description="AES_TAG[127:96]
For a host read operation, these registers contain the last 128-bit TAG output of the EIP-120t; the TAG is available until the next context is written.
This register contains valid data only if the TAG is available and when the store_ready bit from AES_CTRL register is set. During processing or for operations/modes that do not return a TAG, reads from this register return data from the IV register." id="AES_TAG" resetval="" >
        </bitfield>
    </register>
    <register acronym="HASH_DATA_IN_0" width="32" description="HASH data input registers
The data input registers should be used to provide input data to the hash module through the slave interface." id="HASH_DATA_IN_0" offset="0x600" >
        <bitfield range="" begin="31" width="32" end="0" rwaccess="WO" description="HASH_DATA_IN[31:0]
These registers must be written with the 512-bit input data. The data lines are connected directly to the data input of the hash module and hence into the engine&apos;s internal data buffer. Writing to each of the registers triggers a corresponding 32-bit write enable to the internal buffer.
Note: The host may only write the input data buffer when the rfd_in bit of the HASH_IO_BUF_CTRL register is high. If the rfd_in bit is 0, the engine is busy with processing. During processing, it is not allowed to write new input data.
For message lengths larger than 64 bytes, multiple blocks of data are written to this input buffer using a handshake through flags of the HASH_IO_BUF_CTRL register. All blocks except the last are required to be 512 bits in size. If the last block is not 512 bits long, only the least significant bits of data must be written, but they must be padded with 0s to the next 32-bit boundary.
Host read operations from these register addresses return 0s." id="HASH_DATA_IN" resetval="" >
        </bitfield>
    </register>
    <register acronym="HASH_DATA_IN_1" width="32" description="HASH data input registers
The data input registers should be used to provide input data to the hash module through the slave interface." id="HASH_DATA_IN_1" offset="0x604" >
        <bitfield range="" begin="31" width="32" end="0" rwaccess="WO" description="HASH_DATA_IN[63:32]
These registers must be written with the 512-bit input data. The data lines are connected directly to the data input of the hash module and hence into the engine&apos;s internal data buffer. Writing to each of the registers triggers a corresponding 32-bit write enable to the internal buffer.
Note: The host may only write the input data buffer when the rfd_in bit of the HASH_IO_BUF_CTRL register is high. If the rfd_in bit is 0, the engine is busy with processing. During processing, it is not allowed to write new input data.
For message lengths larger than 64 bytes, multiple blocks of data are written to this input buffer using a handshake through flags of the HASH_IO_BUF_CTRL register. All blocks except the last are required to be 512 bits in size. If the last block is not 512 bits long, only the least significant bits of data must be written, but they must be padded with 0s to the next 32-bit boundary.
Host read operations from these register addresses return 0s." id="HASH_DATA_IN" resetval="" >
        </bitfield>
    </register>
    <register acronym="HASH_DATA_IN_2" width="32" description="HASH data input registers
The data input registers should be used to provide input data to the hash module through the slave interface." id="HASH_DATA_IN_2" offset="0x608" >
        <bitfield range="" begin="31" width="32" end="0" rwaccess="WO" description="HASH_DATA_IN[95:64]
These registers must be written with the 512-bit input data. The data lines are connected directly to the data input of the hash module and hence into the engine&apos;s internal data buffer. Writing to each of the registers triggers a corresponding 32-bit write enable to the internal buffer.
Note: The host may only write the input data buffer when the rfd_in bit of the HASH_IO_BUF_CTRL register is high. If the rfd_in bit is 0, the engine is busy with processing. During processing, it is not allowed to write new input data.
For message lengths larger than 64 bytes, multiple blocks of data are written to this input buffer using a handshake through flags of the HASH_IO_BUF_CTRL register. All blocks except the last are required to be 512 bits in size. If the last block is not 512 bits long, only the least significant bits of data must be written, but they must be padded with 0s to the next 32-bit boundary.
Host read operations from these register addresses return 0s." id="HASH_DATA_IN" resetval="" >
        </bitfield>
    </register>
    <register acronym="HASH_DATA_IN_3" width="32" description="HASH data input registers
The data input registers should be used to provide input data to the hash module through the slave interface." id="HASH_DATA_IN_3" offset="0x60c" >
        <bitfield range="" begin="31" width="32" end="0" rwaccess="WO" description="HASH_DATA_IN[127:96]
These registers must be written with the 512-bit input data. The data lines are connected directly to the data input of the hash module and hence into the engine&apos;s internal data buffer. Writing to each of the registers triggers a corresponding 32-bit write enable to the internal buffer.
Note: The host may only write the input data buffer when the rfd_in bit of the HASH_IO_BUF_CTRL register is high. If the rfd_in bit is 0, the engine is busy with processing. During processing, it is not allowed to write new input data.
For message lengths larger than 64 bytes, multiple blocks of data are written to this input buffer using a handshake through flags of the HASH_IO_BUF_CTRL register. All blocks except the last are required to be 512 bits in size. If the last block is not 512 bits long, only the least significant bits of data must be written, but they must be padded with 0s to the next 32-bit boundary.
Host read operations from these register addresses return 0s." id="HASH_DATA_IN" resetval="" >
        </bitfield>
    </register>
    <register acronym="HASH_DATA_IN_4" width="32" description="HASH data input registers
The data input registers should be used to provide input data to the hash module through the slave interface." id="HASH_DATA_IN_4" offset="0x610" >
        <bitfield range="" begin="31" width="32" end="0" rwaccess="WO" description="HASH_DATA_IN[159:128]
These registers must be written with the 512-bit input data. The data lines are connected directly to the data input of the hash module and hence into the engine&apos;s internal data buffer. Writing to each of the registers triggers a corresponding 32-bit write enable to the internal buffer.
Note: The host may only write the input data buffer when the rfd_in bit of the HASH_IO_BUF_CTRL register is high. If the rfd_in bit is 0, the engine is busy with processing. During processing, it is not allowed to write new input data.
For message lengths larger than 64 bytes, multiple blocks of data are written to this input buffer using a handshake through flags of the HASH_IO_BUF_CTRL register. All blocks except the last are required to be 512 bits in size. If the last block is not 512 bits long, only the least significant bits of data must be written, but they must be padded with 0s to the next 32-bit boundary.
Host read operations from these register addresses return 0s." id="HASH_DATA_IN" resetval="" >
        </bitfield>
    </register>
    <register acronym="HASH_DATA_IN_5" width="32" description="HASH data input registers
The data input registers should be used to provide input data to the hash module through the slave interface." id="HASH_DATA_IN_5" offset="0x614" >
        <bitfield range="" begin="31" width="32" end="0" rwaccess="WO" description="HASH_DATA_IN[191:160]
These registers must be written with the 512-bit input data. The data lines are connected directly to the data input of the hash module and hence into the engine&apos;s internal data buffer. Writing to each of the registers triggers a corresponding 32-bit write enable to the internal buffer.
Note: The host may only write the input data buffer when the rfd_in bit of the HASH_IO_BUF_CTRL register is high. If the rfd_in bit is 0, the engine is busy with processing. During processing, it is not allowed to write new input data.
For message lengths larger than 64 bytes, multiple blocks of data are written to this input buffer using a handshake through flags of the HASH_IO_BUF_CTRL register. All blocks except the last are required to be 512 bits in size. If the last block is not 512 bits long, only the least significant bits of data must be written, but they must be padded with 0s to the next 32-bit boundary.
Host read operations from these register addresses return 0s." id="HASH_DATA_IN" resetval="" >
        </bitfield>
    </register>
    <register acronym="HASH_DATA_IN_6" width="32" description="HASH data input registers
The data input registers should be used to provide input data to the hash module through the slave interface." id="HASH_DATA_IN_6" offset="0x618" >
        <bitfield range="" begin="31" width="32" end="0" rwaccess="WO" description="HASH_DATA_IN[223:192]
These registers must be written with the 512-bit input data. The data lines are connected directly to the data input of the hash module and hence into the engine&apos;s internal data buffer. Writing to each of the registers triggers a corresponding 32-bit write enable to the internal buffer.
Note: The host may only write the input data buffer when the rfd_in bit of the HASH_IO_BUF_CTRL register is high. If the rfd_in bit is 0, the engine is busy with processing. During processing, it is not allowed to write new input data.
For message lengths larger than 64 bytes, multiple blocks of data are written to this input buffer using a handshake through flags of the HASH_IO_BUF_CTRL register. All blocks except the last are required to be 512 bits in size. If the last block is not 512 bits long, only the least significant bits of data must be written, but they must be padded with 0s to the next 32-bit boundary.
Host read operations from these register addresses return 0s." id="HASH_DATA_IN" resetval="" >
        </bitfield>
    </register>
    <register acronym="HASH_DATA_IN_7" width="32" description="HASH data input registers
The data input registers should be used to provide input data to the hash module through the slave interface." id="HASH_DATA_IN_7" offset="0x61c" >
        <bitfield range="" begin="31" width="32" end="0" rwaccess="WO" description="HASH_DATA_IN[255:224]
These registers must be written with the 512-bit input data. The data lines are connected directly to the data input of the hash module and hence into the engine&apos;s internal data buffer. Writing to each of the registers triggers a corresponding 32-bit write enable to the internal buffer.
Note: The host may only write the input data buffer when the rfd_in bit of the HASH_IO_BUF_CTRL register is high. If the rfd_in bit is 0, the engine is busy with processing. During processing, it is not allowed to write new input data.
For message lengths larger than 64 bytes, multiple blocks of data are written to this input buffer using a handshake through flags of the HASH_IO_BUF_CTRL register. All blocks except the last are required to be 512 bits in size. If the last block is not 512 bits long, only the least significant bits of data must be written, but they must be padded with 0s to the next 32-bit boundary.
Host read operations from these register addresses return 0s." id="HASH_DATA_IN" resetval="" >
        </bitfield>
    </register>
    <register acronym="HASH_DATA_IN_8" width="32" description="HASH data input registers
The data input registers should be used to provide input data to the hash module through the slave interface." id="HASH_DATA_IN_8" offset="0x620" >
        <bitfield range="" begin="31" width="32" end="0" rwaccess="WO" description="HASH_DATA_IN[287:256]
These registers must be written with the 512-bit input data. The data lines are connected directly to the data input of the hash module and hence into the engine&apos;s internal data buffer. Writing to each of the registers triggers a corresponding 32-bit write enable to the internal buffer.
Note: The host may only write the input data buffer when the rfd_in bit of the HASH_IO_BUF_CTRL register is high. If the rfd_in bit is 0, the engine is busy with processing. During processing, it is not allowed to write new input data.
For message lengths larger than 64 bytes, multiple blocks of data are written to this input buffer using a handshake through flags of the HASH_IO_BUF_CTRL register. All blocks except the last are required to be 512 bits in size. If the last block is not 512 bits long, only the least significant bits of data must be written, but they must be padded with 0s to the next 32-bit boundary.
Host read operations from these register addresses return 0s." id="HASH_DATA_IN" resetval="" >
        </bitfield>
    </register>
    <register acronym="HASH_DATA_IN_9" width="32" description="HASH data input registers
The data input registers should be used to provide input data to the hash module through the slave interface." id="HASH_DATA_IN_9" offset="0x624" >
        <bitfield range="" begin="31" width="32" end="0" rwaccess="WO" description="HASH_DATA_IN[319:288]
These registers must be written with the 512-bit input data. The data lines are connected directly to the data input of the hash module and hence into the engine&apos;s internal data buffer. Writing to each of the registers triggers a corresponding 32-bit write enable to the internal buffer.
Note: The host may only write the input data buffer when the rfd_in bit of the HASH_IO_BUF_CTRL register is high. If the rfd_in bit is 0, the engine is busy with processing. During processing, it is not allowed to write new input data.
For message lengths larger than 64 bytes, multiple blocks of data are written to this input buffer using a handshake through flags of the HASH_IO_BUF_CTRL register. All blocks except the last are required to be 512 bits in size. If the last block is not 512 bits long, only the least significant bits of data must be written, but they must be padded with 0s to the next 32-bit boundary.
Host read operations from these register addresses return 0s." id="HASH_DATA_IN" resetval="" >
        </bitfield>
    </register>
    <register acronym="HASH_DATA_IN_10" width="32" description="HASH data input registers
The data input registers should be used to provide input data to the hash module through the slave interface." id="HASH_DATA_IN_10" offset="0x628" >
        <bitfield range="" begin="31" width="32" end="0" rwaccess="WO" description="HASH_DATA_IN[351:320]
These registers must be written with the 512-bit input data. The data lines are connected directly to the data input of the hash module and hence into the engine&apos;s internal data buffer. Writing to each of the registers triggers a corresponding 32-bit write enable to the internal buffer.
Note: The host may only write the input data buffer when the rfd_in bit of the HASH_IO_BUF_CTRL register is high. If the rfd_in bit is 0, the engine is busy with processing. During processing, it is not allowed to write new input data.
For message lengths larger than 64 bytes, multiple blocks of data are written to this input buffer using a handshake through flags of the HASH_IO_BUF_CTRL register. All blocks except the last are required to be 512 bits in size. If the last block is not 512 bits long, only the least significant bits of data must be written, but they must be padded with 0s to the next 32-bit boundary.
Host read operations from these register addresses return 0s." id="HASH_DATA_IN" resetval="" >
        </bitfield>
    </register>
    <register acronym="HASH_DATA_IN_11" width="32" description="HASH data input registers
The data input registers should be used to provide input data to the hash module through the slave interface." id="HASH_DATA_IN_11" offset="0x62c" >
        <bitfield range="" begin="31" width="32" end="0" rwaccess="WO" description="HASH_DATA_IN[383:352]
These registers must be written with the 512-bit input data. The data lines are connected directly to the data input of the hash module and hence into the engine&apos;s internal data buffer. Writing to each of the registers triggers a corresponding 32-bit write enable to the internal buffer.
Note: The host may only write the input data buffer when the rfd_in bit of the HASH_IO_BUF_CTRL register is high. If the rfd_in bit is 0, the engine is busy with processing. During processing, it is not allowed to write new input data.
For message lengths larger than 64 bytes, multiple blocks of data are written to this input buffer using a handshake through flags of the HASH_IO_BUF_CTRL register. All blocks except the last are required to be 512 bits in size. If the last block is not 512 bits long, only the least significant bits of data must be written, but they must be padded with 0s to the next 32-bit boundary.
Host read operations from these register addresses return 0s." id="HASH_DATA_IN" resetval="" >
        </bitfield>
    </register>
    <register acronym="HASH_DATA_IN_12" width="32" description="HASH data input registers
The data input registers should be used to provide input data to the hash module through the slave interface." id="HASH_DATA_IN_12" offset="0x630" >
        <bitfield range="" begin="31" width="32" end="0" rwaccess="WO" description="HASH_DATA_IN[415:384]
These registers must be written with the 512-bit input data. The data lines are connected directly to the data input of the hash module and hence into the engine&apos;s internal data buffer. Writing to each of the registers triggers a corresponding 32-bit write enable to the internal buffer.
Note: The host may only write the input data buffer when the rfd_in bit of the HASH_IO_BUF_CTRL register is high. If the rfd_in bit is 0, the engine is busy with processing. During processing, it is not allowed to write new input data.
For message lengths larger than 64 bytes, multiple blocks of data are written to this input buffer using a handshake through flags of the HASH_IO_BUF_CTRL register. All blocks except the last are required to be 512 bits in size. If the last block is not 512 bits long, only the least significant bits of data must be written, but they must be padded with 0s to the next 32-bit boundary.
Host read operations from these register addresses return 0s." id="HASH_DATA_IN" resetval="" >
        </bitfield>
    </register>
    <register acronym="HASH_DATA_IN_13" width="32" description="HASH data input registers
The data input registers should be used to provide input data to the hash module through the slave interface." id="HASH_DATA_IN_13" offset="0x634" >
        <bitfield range="" begin="31" width="32" end="0" rwaccess="WO" description="HASH_DATA_IN[447:416]
These registers must be written with the 512-bit input data. The data lines are connected directly to the data input of the hash module and hence into the engine&apos;s internal data buffer. Writing to each of the registers triggers a corresponding 32-bit write enable to the internal buffer.
Note: The host may only write the input data buffer when the rfd_in bit of the HASH_IO_BUF_CTRL register is high. If the rfd_in bit is 0, the engine is busy with processing. During processing, it is not allowed to write new input data.
For message lengths larger than 64 bytes, multiple blocks of data are written to this input buffer using a handshake through flags of the HASH_IO_BUF_CTRL register. All blocks except the last are required to be 512 bits in size. If the last block is not 512 bits long, only the least significant bits of data must be written, but they must be padded with 0s to the next 32-bit boundary.
Host read operations from these register addresses return 0s." id="HASH_DATA_IN" resetval="" >
        </bitfield>
    </register>
    <register acronym="HASH_DATA_IN_14" width="32" description="HASH data input registers
The data input registers should be used to provide input data to the hash module through the slave interface." id="HASH_DATA_IN_14" offset="0x638" >
        <bitfield range="" begin="31" width="32" end="0" rwaccess="WO" description="HASH_DATA_IN[479:448]
These registers must be written with the 512-bit input data. The data lines are connected directly to the data input of the hash module and hence into the engine&apos;s internal data buffer. Writing to each of the registers triggers a corresponding 32-bit write enable to the internal buffer.
Note: The host may only write the input data buffer when the rfd_in bit of the HASH_IO_BUF_CTRL register is high. If the rfd_in bit is 0, the engine is busy with processing. During processing, it is not allowed to write new input data.
For message lengths larger than 64 bytes, multiple blocks of data are written to this input buffer using a handshake through flags of the HASH_IO_BUF_CTRL register. All blocks except the last are required to be 512 bits in size. If the last block is not 512 bits long, only the least significant bits of data must be written, but they must be padded with 0s to the next 32-bit boundary.
Host read operations from these register addresses return 0s." id="HASH_DATA_IN" resetval="" >
        </bitfield>
    </register>
    <register acronym="HASH_DATA_IN_15" width="32" description="HASH data input registers
The data input registers should be used to provide input data to the hash module through the slave interface." id="HASH_DATA_IN_15" offset="0x63c" >
        <bitfield range="" begin="31" width="32" end="0" rwaccess="WO" description="HASH_DATA_IN[511:480]
These registers must be written with the 512-bit input data. The data lines are connected directly to the data input of the hash module and hence into the engine&apos;s internal data buffer. Writing to each of the registers triggers a corresponding 32-bit write enable to the internal buffer.
Note: The host may only write the input data buffer when the rfd_in bit of the HASH_IO_BUF_CTRL register is high. If the rfd_in bit is 0, the engine is busy with processing. During processing, it is not allowed to write new input data.
For message lengths larger than 64 bytes, multiple blocks of data are written to this input buffer using a handshake through flags of the HASH_IO_BUF_CTRL register. All blocks except the last are required to be 512 bits in size. If the last block is not 512 bits long, only the least significant bits of data must be written, but they must be padded with 0s to the next 32-bit boundary.
Host read operations from these register addresses return 0s." id="HASH_DATA_IN" resetval="" >
        </bitfield>
    </register>
    <register acronym="HASH_IO_BUF_CTRL" width="32" description="Input/output buffer control and status register
This register pair shares a single address location and contains bits that control and monitor the data flow between the host and the hash engine." id="HASH_IO_BUF_CTRL" offset="0x640" >
        <bitfield range="" begin="31" width="24" end="8" rwaccess="RW" description="Write 0s and ignore on reading" id="Reserved1" resetval="" >
        </bitfield>
        <bitfield range="" begin="7" width="1" end="7" rwaccess="RW" description="Note: This bit must only be used when data is supplied through the DMA. It should not be used when data is supplied through the slave interface.
This bit indicates whether the hash engine has to pad the message, received through the DMA and finalize the hash.
When set to 1, the hash engine pads the last block using the programmed length. After padding, the final hash result is calculated.
When set to 0, the hash engine treats the last written block as block-size aligned and calculates the intermediate digest.
This bit is automatically cleared when the last DMA data block is arrived in the hash engine." id="PAD_DMA_MESSAGE" resetval="" >
        </bitfield>
        <bitfield range="" begin="6" width="1" end="6" rwaccess="RW" description="Note: The bit description below is only applicable when data is sent through the slave interface. This bit must be set to 0 when data is received through the DMA.
This bit indicates whether the hash engine should provide the hash digest.
When provided simultaneously with data_in_av, the hash digest is provided after processing the data that is currently in the HASH_DATA_IN register. When provided without data_in_av, the current internal digest buffer value is copied to the HASH_DIGEST_n registers.
The host must write a 1 to this bit to make the intermediate hash digest available.
Writing 0 to this bit has no effect.
This bit is automatically cleared (that is, reads 0) when the hash engine has processed the contents of the HASH_DATA_IN register. In the period between this bit is set by the host and the actual HASH_DATA_IN processing, this bit reads 1." id="GET_DIGEST" resetval="" >
        </bitfield>
        <bitfield range="" begin="5" width="1" end="5" rwaccess="RW" description="Note: The bit description below is only applicable when data is sent through the slave interface. This bit must be set to 0 when data is received through the DMA.
This bit indicates that the HASH_DATA_IN registers hold the last data of the message and hash padding must be applied.
The host must write this bit to 1 in order to indicate to the hash engine that the HASH_DATA_IN register currently holds the last data of the message. When pad_message is set to 1, the hash engine will add padding bits to the data currently in the HASH_DATA_IN register.
When the last message block is smaller than 512 bits, the pad_message bit must be set to 1 together with the data_in_av bit.
When the last message block is equal to 512 bits, pad_message may be set together with data_in_av. In this case the pad_message bit may also be set after the last data block has been written to the hash engine (so when the rfd_in bit has become 1 again after writing the last data block).
Writing 0 to this bit has no effect.
This bit is automatically cleared (i.e. reads 0) by the hash engine. This bit reads 1 between the time it was set by the host and the hash engine interpreted its value." id="PAD_MESSAGE" resetval="" >
        </bitfield>
        <bitfield range="" begin="4" width="2" end="3" rwaccess="RW" description="Write 0s and ignore on reading" id="Reserved0" resetval="" >
        </bitfield>
        <bitfield range="" begin="2" width="1" end="2" rwaccess="RW" description="Note: The bit description below is only applicable when data is sent through the slave interface. This bit can be ignored when data is received through the DMA.
Read-only status of the input buffer of the hash engine.
When 1, the input buffer of the hash engine can accept new data; the HASH_DATA_IN registers can safely be populated with new data.
When 0, the input buffer of the hash engine is processing the data that is currently in HASH_DATA_IN; writing new data to these registers is not allowed." id="RFD_IN" resetval="" >
        </bitfield>
        <bitfield range="" begin="1" width="1" end="1" rwaccess="RW" description="Note: The bit description below is only applicable when data is sent through the slave interface. This bit must be set to 0 when data is received through the DMA.
This bit indicates that the HASH_DATA_IN registers contain new input data for processing.
The host must write a 1 to this bit to start processing the data in HASH_DATA_IN; the hash engine will process the new data as soon as it is ready for it (rfd_in bit is 1).
Writing 0 to this bit has no effect.
This bit is automatically cleared (i.e. reads as 0) when the hash engine starts processing the HASH_DATA_IN contents. This bit reads 1 between the time it was set by the host and the hash engine actually starts processing the input data block." id="DATA_IN_AV" resetval="" >
        </bitfield>
        <bitfield range="" begin="0" width="1" end="0" rwaccess="RW" description="Indicates that the output buffer registers (HASH_DIGEST_n) are available for reading by the host.
When this bit reads 0, the output buffer registers are released; the hash engine is allowed to write new data to it. In this case, the registers should not be read by the host.
When this bit reads 1, the hash engine has stored the result of the latest hash operation in the output buffer registers. As long as this bit reads 1, the host may read output buffer registers and the hash engine is prevented from writing new data to the output buffer.
After retrieving the hash result data from the output buffer, the host must write a 1 to this bit to clear it. This makes the digest output buffer available for the hash engine to store new hash results.
Writing 0 to this bit has no effect.
Note: If this bit is asserted (1) no new operation should be started before the digest is retrieved from the hash engine and this bit is cleared (0)." id="OUTPUT_FULL" resetval="" >
        </bitfield>
    </register>
    <register acronym="HASH_MODE_IN" width="32" description="Hash mode register" id="HASH_MODE_IN" offset="0x644" >
        <bitfield range="" begin="31" width="28" end="4" rwaccess="WO" description="Write 0s and ignore on reading" id="Reserved1" resetval="" >
        </bitfield>
        <bitfield range="" begin="3" width="1" end="3" rwaccess="WO" description="The host must write this bit with 1 before processing a hash session." id="SHA256_MODE" resetval="" >
        </bitfield>
        <bitfield range="" begin="2" width="2" end="1" rwaccess="WO" description="Write 0s and ignore on reading" id="Reserved2" resetval="" >
        </bitfield>
        <bitfield range="" begin="0" width="1" end="0" rwaccess="WO" description="When set to 1, it indicates that the hash engine must start processing a new hash session. The HASH_DIGEST_n registers will automatically be loaded with the initial hash algorithm constants of the selected hash algorithm.
When this bit is 0 while the hash processing is started, the initial hash algorithm constants are not loaded in the HASH_DIGEST_n registers. The hash engine will start processing with the digest that is currently in its internal HASH_DIGEST_n registers.
This bit is automatically cleared when hash processing is started." id="NEW_HASH" resetval="" >
        </bitfield>
    </register>
    <register acronym="HASH_LENGTH_IN_L" width="32" description="Hash length register" id="HASH_LENGTH_IN_L" offset="0x648" >
        <bitfield range="" begin="31" width="32" end="0" rwaccess="WO" description="LENGTH_IN[31:0]
Message length registers. The content of these registers is used by the hash engine during the message padding phase of the hash session. The data lines of this registers are directly connected to the interface of the hash engine.
For a write operation by the host, these registers should be written with the message length in bits.

Final hash operations:
The total input data length must be programmed for new hash operations that require finalization (padding). The input data must be provided through the slave or DMA interface.

Continued hash operations (finalized):
For continued hash operations that require finalization, the total message length must be programmed, including the length of previously hashed data that corresponds to the written input digest.

Non-final hash operations:
For hash operations that do not require finalization (input data length is multiple of 512-bits which is SHA-256 data block size), the length field does not need to be programmed since not used by the operation.

If the message length in bits is below (2^32-1), then only HASH_LENGTH_IN_L needs to be written. The hardware automatically sets HASH_LENGTH_IN_H to 0s in this case.
The host may write the length register at any time during the hash session when the rfd_in bit of the HASH_IO_BUF_CTRL is high. The length register must be written before the last data of the active hash session is written into the hash engine.
host read operations from these register locations will return 0s.
Note: When getting data from DMA, this register must be programmed before DMA is programmed to start." id="LENGTH_IN" resetval="" >
        </bitfield>
    </register>
    <register acronym="HASH_LENGTH_IN_H" width="32" description="Hash length register" id="HASH_LENGTH_IN_H" offset="0x64c" >
        <bitfield range="" begin="31" width="32" end="0" rwaccess="WO" description="LENGTH_IN[63:32]
Message length registers. The content of these registers is used by the hash engine during the message padding phase of the hash session. The data lines of this registers are directly connected to the interface of the hash engine.
For a write operation by the host, these registers should be written with the message length in bits.

Final hash operations:
The total input data length must be programmed for new hash operations that require finalization (padding). The input data must be provided through the slave or DMA interface.

Continued hash operations (finalized):
For continued hash operations that require finalization, the total message length must be programmed, including the length of previously hashed data that corresponds to the written input digest.

Non-final hash operations:
For hash operations that do not require finalization (input data length is multiple of 512-bits which is SHA-256 data block size), the length field does not need to be programmed since not used by the operation.

If the message length in bits is below (2^32-1), then only HASH_LENGTH_IN_L needs to be written. The hardware automatically sets HASH_LENGTH_IN_H to 0s in this case.
The host may write the length register at any time during the hash session when the rfd_in bit of the HASH_IO_BUF_CTRL is high. The length register must be written before the last data of the active hash session is written into the hash engine.
host read operations from these register locations will return 0s.
Note: When getting data from DMA, this register must be programmed before DMA is programmed to start." id="LENGTH_IN" resetval="" >
        </bitfield>
    </register>
    <register acronym="HASH_DIGEST_A" width="32" description="Hash digest registers
The hash digest registers consist of eight 32-bit registers, named HASH_DIGEST_A to HASH_DIGEST_H. After processing a message, the output digest can be read from these registers. These registers can be written with an intermediate hash result for continued hash operations." id="HASH_DIGEST_A" offset="0x650" >
        <bitfield range="" begin="31" width="32" end="0" rwaccess="RW" description="HASH_DIGEST[31:0]
Hash digest registers
Write operation:

Continued hash:
These registers should be written with the context data, before the start of a resumed hash session (the new_hash bit in the HASH_MODE register is 0 when starting a hash session).

New hash:
When initiating a new hash session (the new_hash bit in the HASH_MODE register is high), the internal digest registers are automatically set to the SHA-256 algorithm constant and these register should not be written.

Reading from these registers provides the intermediate hash result (non-final hash operation) or the final hash result (final hash operation) after data processing." id="HASH_DIGEST" resetval="" >
        </bitfield>
    </register>
    <register acronym="HASH_DIGEST_B" width="32" description="Hash digest registers
The hash digest registers consist of eight 32-bit registers, named HASH_DIGEST_A to HASH_DIGEST_H. After processing a message, the output digest can be read from these registers. These registers can be written with an intermediate hash result for continued hash operations." id="HASH_DIGEST_B" offset="0x654" >
        <bitfield range="" begin="31" width="32" end="0" rwaccess="RW" description="HASH_DIGEST[63:32]
Hash digest registers
Write operation:

Continued hash:
These registers should be written with the context data, before the start of a resumed hash session (the new_hash bit in the HASH_MODE register is 0 when starting a hash session).

New hash:
When initiating a new hash session (the new_hash bit in the HASH_MODE register is high), the internal digest registers are automatically set to the SHA-256 algorithm constant and these register should not be written.

Reading from these registers provides the intermediate hash result (non-final hash operation) or the final hash result (final hash operation) after data processing." id="HASH_DIGEST" resetval="" >
        </bitfield>
    </register>
    <register acronym="HASH_DIGEST_C" width="32" description="Hash digest registers
The hash digest registers consist of eight 32-bit registers, named HASH_DIGEST_A to HASH_DIGEST_H. After processing a message, the output digest can be read from these registers. These registers can be written with an intermediate hash result for continued hash operations." id="HASH_DIGEST_C" offset="0x658" >
        <bitfield range="" begin="31" width="32" end="0" rwaccess="RW" description="HASH_DIGEST[95:64]
Hash digest registers
Write operation:

Continued hash:
These registers should be written with the context data, before the start of a resumed hash session (the new_hash bit in the HASH_MODE register is 0 when starting a hash session).

New hash:
When initiating a new hash session (the new_hash bit in the HASH_MODE register is high), the internal digest registers are automatically set to the SHA-256 algorithm constant and these register should not be written.

Reading from these registers provides the intermediate hash result (non-final hash operation) or the final hash result (final hash operation) after data processing." id="HASH_DIGEST" resetval="" >
        </bitfield>
    </register>
    <register acronym="HASH_DIGEST_D" width="32" description="Hash digest registers
The hash digest registers consist of eight 32-bit registers, named HASH_DIGEST_A to HASH_DIGEST_H. After processing a message, the output digest can be read from these registers. These registers can be written with an intermediate hash result for continued hash operations." id="HASH_DIGEST_D" offset="0x65c" >
        <bitfield range="" begin="31" width="32" end="0" rwaccess="RW" description="HASH_DIGEST[127:96]
Hash digest registers
Write operation:

Continued hash:
These registers should be written with the context data, before the start of a resumed hash session (the new_hash bit in the HASH_MODE register is 0 when starting a hash session).

New hash:
When initiating a new hash session (the new_hash bit in the HASH_MODE register is high), the internal digest registers are automatically set to the SHA-256 algorithm constant and these register should not be written.

Reading from these registers provides the intermediate hash result (non-final hash operation) or the final hash result (final hash operation) after data processing." id="HASH_DIGEST" resetval="" >
        </bitfield>
    </register>
    <register acronym="HASH_DIGEST_E" width="32" description="Hash digest registers
The hash digest registers consist of eight 32-bit registers, named HASH_DIGEST_A to HASH_DIGEST_H. After processing a message, the output digest can be read from these registers. These registers can be written with an intermediate hash result for continued hash operations." id="HASH_DIGEST_E" offset="0x660" >
        <bitfield range="" begin="31" width="32" end="0" rwaccess="RW" description="HASH_DIGEST[159:128]
Hash digest registers
Write operation:

Continued hash:
These registers should be written with the context data, before the start of a resumed hash session (the new_hash bit in the HASH_MODE register is 0 when starting a hash session).

New hash:
When initiating a new hash session (the new_hash bit in the HASH_MODE register is high), the internal digest registers are automatically set to the SHA-256 algorithm constant and these register should not be written.

Reading from these registers provides the intermediate hash result (non-final hash operation) or the final hash result (final hash operation) after data processing." id="HASH_DIGEST" resetval="" >
        </bitfield>
    </register>
    <register acronym="HASH_DIGEST_F" width="32" description="Hash digest registers
The hash digest registers consist of eight 32-bit registers, named HASH_DIGEST_A to HASH_DIGEST_H. After processing a message, the output digest can be read from these registers. These registers can be written with an intermediate hash result for continued hash operations." id="HASH_DIGEST_F" offset="0x664" >
        <bitfield range="" begin="31" width="32" end="0" rwaccess="RW" description="HASH_DIGEST[191:160]
Hash digest registers
Write operation:

Continued hash:
These registers should be written with the context data, before the start of a resumed hash session (the new_hash bit in the HASH_MODE register is 0 when starting a hash session).

New hash:
When initiating a new hash session (the new_hash bit in the HASH_MODE register is high), the internal digest registers are automatically set to the SHA-256 algorithm constant and these register should not be written.

Reading from these registers provides the intermediate hash result (non-final hash operation) or the final hash result (final hash operation) after data processing." id="HASH_DIGEST" resetval="" >
        </bitfield>
    </register>
    <register acronym="HASH_DIGEST_G" width="32" description="Hash digest registers
The hash digest registers consist of eight 32-bit registers, named HASH_DIGEST_A to HASH_DIGEST_H. After processing a message, the output digest can be read from these registers. These registers can be written with an intermediate hash result for continued hash operations." id="HASH_DIGEST_G" offset="0x668" >
        <bitfield range="" begin="31" width="32" end="0" rwaccess="RW" description="HASH_DIGEST[223:192]
Hash digest registers
Write operation:

Continued hash:
These registers should be written with the context data, before the start of a resumed hash session (the new_hash bit in the HASH_MODE register is 0 when starting a hash session).

New hash:
When initiating a new hash session (the new_hash bit in the HASH_MODE register is high), the internal digest registers are automatically set to the SHA-256 algorithm constant and these register should not be written.

Reading from these registers provides the intermediate hash result (non-final hash operation) or the final hash result (final hash operation) after data processing." id="HASH_DIGEST" resetval="" >
        </bitfield>
    </register>
    <register acronym="HASH_DIGEST_H" width="32" description="Hash digest registers
The hash digest registers consist of eight 32-bit registers, named HASH_DIGEST_A to HASH_DIGEST_H. After processing a message, the output digest can be read from these registers. These registers can be written with an intermediate hash result for continued hash operations." id="HASH_DIGEST_H" offset="0x66c" >
        <bitfield range="" begin="31" width="32" end="0" rwaccess="RW" description="HASH_DIGEST[255:224]
Hash digest registers
Write operation:

Continued hash:
These registers should be written with the context data, before the start of a resumed hash session (the new_hash bit in the HASH_MODE register is 0 when starting a hash session).

New hash:
When initiating a new hash session (the new_hash bit in the HASH_MODE register is high), the internal digest registers are automatically set to the SHA-256 algorithm constant and these register should not be written.

Reading from these registers provides the intermediate hash result (non-final hash operation) or the final hash result (final hash operation) after data processing." id="HASH_DIGEST" resetval="" >
        </bitfield>
    </register>
    <register acronym="CTRL_ALG_SEL" width="32" description="Algorithm select
This algorithm selection register configures the internal destination of the DMA controller." id="CTRL_ALG_SEL" offset="0x700" >
        <bitfield range="" begin="31" width="1" end="31" rwaccess="RW" description="If this bit is cleared to 0, the DMA operation involves only data.
If this bit is set, the DMA operation includes a TAG (Authentication Result / Digest).
For SHA-256 operation, a DMA must be set up for both input data and TAG. For any other selected module, setting this bit only allows a DMA that reads the TAG. No data allowed to be transferred to or from the selected module via the DMA." id="TAG" resetval="" >
        </bitfield>
        <bitfield range="" begin="30" width="28" end="3" rwaccess="RW" description="Bits should be written with 0s and ignored on read." id="Reserved28" resetval="" >
        </bitfield>
        <bitfield range="" begin="2" width="1" end="2" rwaccess="RW" description="If set to one, selects the hash engine as destination for the DMA
The maximum transfer size to DMA engine is set to 64 bytes for reading and 32 bytes for writing (the latter is only applicable if the hash result is written out through the DMA)." id="HASH" resetval="" >
        </bitfield>
        <bitfield range="" begin="1" width="1" end="1" rwaccess="RW" description="If set to one, selects the AES engine as source/destination for the DMA
The read and write maximum transfer size to the DMA engine is set to 16 bytes." id="AES" resetval="" >
        </bitfield>
        <bitfield range="" begin="0" width="1" end="0" rwaccess="RW" description="If set to one, selects the Key Store as destination for the DMA
The maximum transfer size to DMA engine is set to 32 bytes (however transfers of 16, 24 and 32 bytes are allowed)" id="KEYSTORE" resetval="" >
        </bitfield>
    </register>
    <register acronym="CTRL_PROT_EN" width="32" description="Master PROT privileged access enable
This register enables the second bit (bit [1]) of the AHB HPROT bus of the AHB master interface when a read action of key(s) is performed on the AHB master interface for writing keys into the store module." id="CTRL_PROT_EN" offset="0x704" >
        <bitfield range="" begin="31" width="31" end="1" rwaccess="RW" description="Bits should be written with 0s and ignored on read." id="Reserved31" resetval="" >
        </bitfield>
        <bitfield range="" begin="0" width="1" end="0" rwaccess="RW" description="If this bit is cleared to 0, m_h_prot[1] on the AHB mater interface always remains 0.
If this bit is set to one, the m_h_prot[1] signal on the master AHB bus is asserted to 1 if an AHB read operation is performed, using DMA, with the key store module as destination." id="PROT_EN" resetval="" >
        </bitfield>
    </register>
    <register acronym="CTRL_SW_RESET" width="32" description="Software reset" id="CTRL_SW_RESET" offset="0x740" >
        <bitfield range="" begin="31" width="31" end="1" rwaccess="RW" description="Bits should be written with 0s and ignored on read." id="Reserved31" resetval="" >
        </bitfield>
        <bitfield range="" begin="0" width="1" end="0" rwaccess="RW" description="If this bit is set to 1, the following modules are reset: 
- Master control internal state is reset. That includes interrupt, error status register, and result available interrupt generation FSM. 
- Key store module state is reset. That includes clearing the written area flags; therefore, the keys must be reloaded to the key store module.
Writing 0 has no effect.
The bit is self cleared after executing the reset." id="SW_RESET" resetval="" >
        </bitfield>
    </register>
    <register acronym="CTRL_INT_CFG" width="32" description="Interrupt configuration" id="CTRL_INT_CFG" offset="0x780" >
        <bitfield range="" begin="31" width="31" end="1" rwaccess="RW" description="Bits should be written with 0s and ignored on read." id="Reserved31" resetval="" >
        </bitfield>
        <bitfield range="" begin="0" width="1" end="0" rwaccess="RW" description="If this bit is 0, the interrupt output is a pulse.
If this bit is set to 1, the interrupt is a level interrupt that must be cleared by writing the interrupt clear register.
This bit is applicable for both interrupt output signals." id="LEVEL" resetval="" >
        </bitfield>
    </register>
    <register acronym="CTRL_INT_EN" width="32" description="Interrupt enable" id="CTRL_INT_EN" offset="0x784" >
        <bitfield range="" begin="31" width="30" end="2" rwaccess="RW" description="Bits should be written with 0s and ignored on read." id="Reserved30" resetval="" >
        </bitfield>
        <bitfield range="" begin="1" width="1" end="1" rwaccess="RW" description="If this bit is set to 0, the DMA input done (irq_dma_in_done) interrupt output is disabled and remains 0.
If this bit is set to 1, the DMA input done interrupt output is enabled." id="DMA_IN_DONE" resetval="" >
        </bitfield>
        <bitfield range="" begin="0" width="1" end="0" rwaccess="RW" description="If this bit is set to 0, the result available (irq_result_av) interrupt output is disabled and remains 0.
If this bit is set to 1, the result available interrupt output is enabled." id="RESULT_AV" resetval="" >
        </bitfield>
    </register>
    <register acronym="CTRL_INT_CLR" width="32" description="Interrupt clear" id="CTRL_INT_CLR" offset="0x788" >
        <bitfield range="" begin="31" width="1" end="31" rwaccess="WO" description="If 1 is written to this bit, the DMA bus error status is cleared.
Writing 0 has no effect." id="DMA_BUS_ERR" resetval="" >
        </bitfield>
        <bitfield range="" begin="30" width="1" end="30" rwaccess="WO" description="If 1 is written to this bit, the key store write error status is cleared.
Writing 0 has no effect." id="KEY_ST_WR_ERR" resetval="" >
        </bitfield>
        <bitfield range="" begin="29" width="1" end="29" rwaccess="WO" description="If 1 is written to this bit, the key store read error status is cleared.
Writing 0 has no effect." id="KEY_ST_RD_ERR" resetval="" >
        </bitfield>
        <bitfield range="" begin="28" width="27" end="2" rwaccess="WO" description="Bits should be written with 0s and ignored on read." id="Reserved27" resetval="" >
        </bitfield>
        <bitfield range="" begin="1" width="1" end="1" rwaccess="WO" description="If 1 is written to this bit, the DMA in done (irq_dma_in_done) interrupt output is cleared.
Writing 0 has no effect.
Note that clearing an interrupt makes sense only if the interrupt output is programmed as level (refer to CTRL_INT_CFG)." id="DMA_IN_DONE" resetval="" >
        </bitfield>
        <bitfield range="" begin="0" width="1" end="0" rwaccess="WO" description="If 1 is written to this bit, the result available (irq_result_av) interrupt output is cleared.
Writing 0 has no effect.
Note that clearing an interrupt makes sense only if the interrupt output is programmed as level (refer to CTRL_INT_CFG)." id="RESULT_AV" resetval="" >
        </bitfield>
    </register>
    <register acronym="CTRL_INT_SET" width="32" description="Interrupt set" id="CTRL_INT_SET" offset="0x78c" >
        <bitfield range="" begin="31" width="30" end="2" rwaccess="WO" description="Bits should be written with 0s and ignored on read." id="Reserved30" resetval="" >
        </bitfield>
        <bitfield range="" begin="1" width="1" end="1" rwaccess="WO" description="If 1 is written to this bit, the DMA data in done (irq_dma_in_done) interrupt output is set to one.
Writing 0 has no effect.
If the interrupt configuration register is programmed to pulse, clearing the DMA data in done (irq_dma_in_done) interrupt is not needed. If it is programmed to level, clearing the interrupt output should be done by writing the interrupt clear register (CTRL_INT_CLR)." id="DMA_IN_DONE" resetval="" >
        </bitfield>
        <bitfield range="" begin="0" width="1" end="0" rwaccess="WO" description="If 1 is written to this bit, the result available (irq_result_av) interrupt output is set to one.
Writing 0 has no effect.
If the interrupt configuration register is programmed to pulse, clearing the result available (irq_result_av) interrupt is not needed. If it is programmed to level, clearing the interrupt output should be done by writing the interrupt clear register (CTRL_INT_CLR)." id="RESULT_AV" resetval="" >
        </bitfield>
    </register>
    <register acronym="CTRL_INT_STAT" width="32" description="Interrupt status" id="CTRL_INT_STAT" offset="0x790" >
        <bitfield range="" begin="31" width="1" end="31" rwaccess="RO" description="This bit is set when a DMA bus error is detected during a DMA operation. The value of this register is held until it is cleared through the CTRL_INT_CLR register.
Note: This error is asserted if an error is detected on the AHB master interface during a DMA operation." id="DMA_BUS_ERR" resetval="" >
        </bitfield>
        <bitfield range="" begin="30" width="1" end="30" rwaccess="RO" description="This bit is set when a write error is detected during the DMA write operation to the key store memory. The value of this register is held until it is cleared through the CTRL_INT_CLR register.
Note: This error is asserted if a DMA operation does not cover a full key area or more areas are written than expected." id="KEY_ST_WR_ERR" resetval="" >
        </bitfield>
        <bitfield range="" begin="29" width="1" end="29" rwaccess="RO" description="This bit is set when a read error is detected during the read of a key from the key store, while copying it to the AES core. The value of this register is held until it is cleared through the CTRL_INT_CLR register.
Note: This error is asserted if a key location is selected in the key store that is not available." id="KEY_ST_RD_ERR" resetval="" >
        </bitfield>
        <bitfield range="" begin="28" width="27" end="2" rwaccess="RO" description="Bits should be ignored" id="Reserved27" resetval="" >
        </bitfield>
        <bitfield range="" begin="1" width="1" end="1" rwaccess="RO" description="This read only bit returns the actual DMA data in done (irq_data_in_done) interrupt status of the DMA data in done interrupt output pin (irq_data_in_done)." id="DMA_IN_DONE" resetval="" >
        </bitfield>
        <bitfield range="" begin="0" width="1" end="0" rwaccess="RO" description="This read only bit returns the actual result available (irq_result_av) interrupt status of the result available interrupt output pin (irq_result_av)." id="RESULT_AV" resetval="" >
        </bitfield>
    </register>
    <register acronym="CTRL_OPTIONS" width="32" description="Options register" id="CTRL_OPTIONS" offset="0x7f8" >
        <bitfield range="" begin="31" width="8" end="24" rwaccess="RO" description="This field is 0x01 for the TYPE1 device." id="TYPE" resetval="" >
        </bitfield>
        <bitfield range="" begin="23" width="7" end="17" rwaccess="RO" description="Bits should be ignored" id="Reserved7" resetval="" >
        </bitfield>
        <bitfield range="" begin="16" width="1" end="16" rwaccess="RO" description="AHB interface is available
If this bit is 0, the EIP-120t has a TCM interface." id="AHBINTERFACE" resetval="" >
        </bitfield>
        <bitfield range="" begin="15" width="7" end="9" rwaccess="RO" description="Bits should be ignored" id="Reserved1" resetval="" >
        </bitfield>
        <bitfield range="" begin="8" width="1" end="8" rwaccess="RO" description="The HASH core supports SHA-256." id="SHA_256" resetval="" >
        </bitfield>
        <bitfield range="" begin="7" width="1" end="7" rwaccess="RO" description="AES-CCM is available as a single operation." id="AES_CCM" resetval="" >
        </bitfield>
        <bitfield range="" begin="6" width="1" end="6" rwaccess="RO" description="AES-GCM is available as a single operation." id="AES_GCM" resetval="" >
        </bitfield>
        <bitfield range="" begin="5" width="1" end="5" rwaccess="RO" description="AES core supports 256-bit keys
Note: If both AES-128 and AES-256 are set to one, the AES core supports 192-bit keys as well." id="AES_256" resetval="" >
        </bitfield>
        <bitfield range="" begin="4" width="1" end="4" rwaccess="RO" description="AES core supports 128-bit keys." id="AES_128" resetval="" >
        </bitfield>
        <bitfield range="" begin="3" width="1" end="3" rwaccess="RO" description="Bit should be ignored" id="Reserved2" resetval="" >
        </bitfield>
        <bitfield range="" begin="2" width="1" end="2" rwaccess="RO" description="HASH Core is available." id="HASH" resetval="" >
        </bitfield>
        <bitfield range="" begin="1" width="1" end="1" rwaccess="RO" description="AES core is available." id="AES" resetval="" >
        </bitfield>
        <bitfield range="" begin="0" width="1" end="0" rwaccess="RO" description="KEY STORE is available." id="KEYSTORE" resetval="" >
        </bitfield>
    </register>
    <register acronym="CTRL_VERSION" width="32" description="Version register" id="CTRL_VERSION" offset="0x7fc" >
        <bitfield range="" begin="31" width="4" end="28" rwaccess="RO" description="Bit should be ignored" id="Reserved1" resetval="" >
        </bitfield>
        <bitfield range="" begin="27" width="4" end="24" rwaccess="RO" description="Major version number" id="MAJOR_VERSION" resetval="" >
        </bitfield>
        <bitfield range="" begin="23" width="4" end="20" rwaccess="RO" description="Minor version number" id="MINOR_VERSION" resetval="" >
        </bitfield>
        <bitfield range="" begin="19" width="4" end="16" rwaccess="RO" description="Patch level
Starts at 0 at first delivery of this version" id="PATCH_LEVEL" resetval="" >
        </bitfield>
        <bitfield range="" begin="15" width="8" end="8" rwaccess="RO" description="These bits simply contain the complement of bits [7:0] (0x87), used by a driver to ascertain that the EIP-120t register is indeed read." id="EIP_NUMBER_COMPL" resetval="" >
        </bitfield>
        <bitfield range="" begin="7" width="8" end="0" rwaccess="RO" description="These bits encode the EIP number for the EIP-120t, this field contains the value 120 (decimal) or 0x78." id="EIP_NUMBER" resetval="" >
        </bitfield>
    </register>
</module>
