<module name="MMCSD1_CTL_CFG" acronym="" XML_version="1.0" HW_revision="n/a" description="">
	<register id="SDHC_WRAP__CTL_CFG__CTLCFG_sdma_sys_addr_lo" acronym="SDHC_WRAP__CTL_CFG__CTLCFG_sdma_sys_addr_lo" offset="0x0" width="16" description="
					This register contains the Lower 16-bit of physical system memory address used for DMA transfers or the second argument for the Auto CMD23 in Host version 3.0 and as 32-bit Block Count in Version 4.10.
					">
		<bitfield id="SDMA_ADDRESS" width="16" begin="15" end="0" resetval="0x0" description=" 						When Host Version 4 Enable is set to 0 in the Host Control 2 register,DMA uses this register as system address in only 32-bit addressing mode. Auto CMD23 cannot be used with SDMA. When Host Version 4 Enable is set to 1, SDMA uses ADMA System Address register [05Fh-058h] instead of using this register to sup- port both 32-bit and 64-bit addressing. This register is re-assigned to 32-bit Block Count and then SDMA may use Auto CMD23.[1] SDMA System Address [Host Version 4 Enable = 0] This register contains the system memory address for a SDMA transfer in 32-bit addressing mode. When the Host Controller stops a SDMA transfer, this register shall point to the system address of the next contiguous data position. It can be accessed only if no transaction is executing [i.e., after a transaction has stopped]. Reading this register during SDMA transfers may return an invalid value. The Host Driver shall initialize this register before starting a SDMA transaction. After SDMA has stopped, the next system address of the next contiguous data posi- tion can be read from this register. The SDMA transfer waits at the every boundary specified by the SDMA Buffer Boundary in the Block Size register. The Host Controller generates DMA Interrupt to request the Host Driver to update this register. The Host Driver sets the next system address of the next data position to this register. When the most upper byte of this register [003h] is written, the Host Controller restarts the SDMA transfer. When restarting SDMA by setting Continue Request in the Block Gap Control register, the Host Controller shall start at the next contiguous address stored here in the SDMA System Address register. ADMA does not use this register. 						[2] 32-bit Block Count [Host Version 4 Enable = 1] 						Host Controller Version 4.10 re-defines this register as 32-bit Block Count [Refer to Section 1.15 for more details about block count extension]. In version 4.00, this register may be used as 32-bit block count only for Auto CMD23 to set the argument of the CMD23 while executing Auto CMD23. The Host Controller would decrement the block count of this register every block transfer and data transfer stops when the count reaches zero. This register should be accessed only when no transaction is executing. Reading this register during data transfers may return invalid value. 						" range="15 - 0" rwaccess="R/W"/>
	</register>
	<register id="SDHC_WRAP__CTL_CFG__CTLCFG_sdma_sys_addr_hi" acronym="SDHC_WRAP__CTL_CFG__CTLCFG_sdma_sys_addr_hi" offset="0x2" width="16" description="
					This register contains the Upper 16-bit of physical system memory address used for DMA transfers or the second argument for the Auto CMD23 in Host version 3.0 and as 32-bit Block Count in Version 4.10.
					">
		<bitfield id="SDMA_ADDRESS" width="16" begin="15" end="0" resetval="0x0" description="                                                 This register contains the Upper 16-bit of physical system memory address used for DMA transfers or the second argument for the Auto CMD23 in Host version 3.0 and as 32-bit Block Count in Version 4.10. 						" range="15 - 0" rwaccess="R/W"/>
	</register>
	<register id="SDHC_WRAP__CTL_CFG__CTLCFG_block_size" acronym="SDHC_WRAP__CTL_CFG__CTLCFG_block_size" offset="0x4" width="16" description="This register is used to configure the number of bytes in a data block">
		<bitfield id="SDMA_BUF_SIZE" width="3" begin="14" end="12" resetval="0x0" description=" 						To perform long DMA transfer, System Address register shall be updated at every system boundary during DMA transfer. These bits specify the size of contiguous buffer in the system memory. The DMA transfer shall wait at the every boundary specified by these fields and the HC generates the DMA Interrupt to request the HD to update the System Address register. These bits shall support when the DMA Support in the Capabilities register is set to 1 and this function is active when the DMA Enable in the Transfer Mode register is set to 1. 						" range="14 - 12" rwaccess="R/W"/> 
		<bitfield id="XFER_BLK_SIZE" width="12" begin="11" end="0" resetval="0x0" description=" 						This  field specifies the block size for block data transfers for CMD17, CMD18, CMD24, CMD25 and CMD53. It can be accessed only if no transaction is executing [i.e after a transaction has stopped]. Read operations during transfer return an invalid value and write operations shall be ignored. 						" range="11 - 0" rwaccess="R/W"/>
	</register>
	<register id="SDHC_WRAP__CTL_CFG__CTLCFG_block_count" acronym="SDHC_WRAP__CTL_CFG__CTLCFG_block_count" offset="0x6" width="16" description="This register is used to configure the number of data blocks">
		<bitfield id="XFER_BLK_CNT" width="16" begin="15" end="0" resetval="0x0" description=" 					Host Controller Version 4.10 extends block count to 32-bit [Refer to Section 1.15].Selection of either 16-bit Block Count register or 32-bit Block Count register is defined as follows: 					[1] If Host Version 4 Enable in the Host Control 2 register is set to 0 or 16-bit Block Count register is set to non-zero, 16-bit Block Count register is selected 					[2] If Host Version 4 Enable is set to 1 and 16-bit Block Count register is set to zero, 32-bit Block Count register is selected.Use of 16-bit/32-bit Block Count register is enabled when Block     Count Enable in the Transfer Mode register is set to 1 and is valid only for multiple block transfers. The Host Driver shall set this register to a value between 1 and the maximum block count.The Host Controller decrements the block     count after each block transfer and stops when the count reaches zero. Setting the block count to 0 results in no data blocks is transferred.This register should be accessed only when no transaction is executing                          [i.e., after transactions are stopped]. During data transfer,read operations on this register may return an invalid value and write operations are ignored. 						" range="15 - 0" rwaccess="R/W"/>
	</register>
	<register id="SDHC_WRAP__CTL_CFG__CTLCFG_argument1_lo" acronym="SDHC_WRAP__CTL_CFG__CTLCFG_argument1_lo" offset="0x8" width="16" description="This register contains Lower bits of SD Command Argument">
		<bitfield id="CMD_ARG1" width="16" begin="15" end="0" resetval="0x0" description=" 						The SD Command Argument is specified as bit23-8 of Command-Format. 						" range="15 - 0" rwaccess="R/W"/>
	</register>
	<register id="SDHC_WRAP__CTL_CFG__CTLCFG_argument1_hi" acronym="SDHC_WRAP__CTL_CFG__CTLCFG_argument1_hi" offset="0xA" width="16" description="This register contains higher bits of SD Command Argument">
		<bitfield id="CMD_ARG1" width="16" begin="15" end="0" resetval="0x0" description=" 						The SD Command Argument is specified as bit39-24 of Command-Format. 						" range="15 - 0" rwaccess="R/W"/>
	</register>
	<register id="SDHC_WRAP__CTL_CFG__CTLCFG_transfer_mode" acronym="SDHC_WRAP__CTL_CFG__CTLCFG_transfer_mode" offset="0xC" width="16" description="This register is used to control the operations of data transfers">
		<bitfield id="RESP_INTR_DIS" width="1" begin="8" end="8" resetval="0x0" description=" 					Host Controller Version 4.00 supports response error check function to avoid overhead of response error check by Host Driver. Only R1 or R5 can be checked. If Host Driver checks response error,sets this bit to 0 and waits Command Complete Interrupt and then checks the response register. If Host Controller checks response error, sets this bit to 1 and sets Response Error Check Enable to 1. Command Complete Interrupt is disabled by  this bit regardless of Command Complete Signal Enable. 						" range="8" rwaccess="R/W"/> 
		<bitfield id="RESP_ERR_CHK_ENA" width="1" begin="7" end="7" resetval="0x0" description=" 					Host Controller Version 4.00 supports response error check function to avoid overhead of response error check by Host Driver. Only R1 or R5 can be checked.If Host Driver checks response error, this bit is set to 0 and Response Interrupt Disable is set to 0.If Host Controller checks response error, sets this bit to 1 and sets Response Interrupt Disable to 1. Response Type R1 / R5 selects either R1 or R5 response type. If an error   is detected, Response Error Interrupt is generated in the Response Error Interrupt Status register. 						" range="7" rwaccess="R/W"/> 
		<bitfield id="RESP_TYPE" width="1" begin="6" end="6" resetval="0x0" description=" 						When response error check is enabled, this bit selects either R1 or R5 response types. Two types of response checks are supported:                                                 R1 for memory and R5 for SDIO.                                                   Error Statuses Checked in R1                                                  	.Bit31 OUT_OF_RANGE 							.Bit30 ADDRESS_ERROR 							.Bit29 BLOCK_LEN_ERROR 							.Bit26 WP_VIOLATION 							.Bit25 CARD_IS_LOCKED 							.Bit23 COM_CRC_ERROR 							.Bit21 CARD_ECC_FAILED 							.Bit20 CC_ERROR 							.Bit19 ERROR 							Response Flags Checked in R5 							.Bit07 COM_CRC_ERROR 							.Bit03 ERROR 							.Bit01 FUNCTION_NUMBER 							.Bit00 OUT_OF_RANGE 						" range="6" rwaccess="R/W"/> 
		<bitfield id="MULTI_BLK_SEL" width="1" begin="5" end="5" resetval="0x0" description=" 						This bit enables multiple block data transfers. 						" range="5" rwaccess="R/W"/> 
		<bitfield id="DATA_XFER_DIR" width="1" begin="4" end="4" resetval="0x0" description=" 						This bit defines the direction of data transfers.  						" range="4" rwaccess="R/W"/> 
		<bitfield id="AUTO_CMD_ENA" width="2" begin="3" end="2" resetval="0x0" description=" 						There are three methods to stop Multiple-block read and write operation. 						[1] Auto CMD12 Enable: 						Multiple-block read and write commands for memory require CMD12 to stop the operation. When this field is set to 01b, the Host Controller issues CMD12 automatically when last block transfer is completed. Auto CMD12 error is indicated to the Auto CMD Error Status register. The Host Driver shall not set this bit if the command does not require CMD12. 						When Host Version 4 Enable =0, CMD12 is issued when 16-bit Block Count is expired. When Host Version 4 Enable =1, CMD12 is issued when 16-bit Block Count or 32-bit Block Count is expired. 						[2] Auto CMD23 Enable:                                                  When this bit field is set to 10b, the Host Controller issues a CMD23 automatically before issuing a command specified in the Command register. The Host Controller Version 3.00 and later shall support this function. The following conditions are required to use the Auto CMD23.  					 						The following conditions are required to use the Auto CMD23. 						 Auto CMD23 Supported [Host Controller Version is 3.00 or later]. 						 A memory card that supports CMD23 [SCR[33]=1]. 						 If DMA is used, it shall be ADMA. 						 Only when CMD18 or CMD25 is issued. 						 						Auto CMD23 can be used with or without ADMA. By writing the Command register, the Host Controller issues a CMD23 first and then issues a command specified by the Command Index in Com-mand register. If response errors of CMD23 are detected, the second command is not issued. A CMD23 error is indicated in the Auto CMD Error Status register.32-bit block count value for CMD23 is set to 32-bit Block Count [SDMA System Address] register. 						[3] Auto CMD Auto Select [Version 4.10] 						As CMD23 is optional for SD memory card except UHS 104 card, if card supports CMD23, Auto CMD 23 should be used instead of Auto CMD12. Host Controller Version 4.10 defines this Auto CMD Auto Select mode. Selection of Auto CMD depends on setting of CMD23 Enable in the Host Control 2 register which indicates whether card supports CMD23. If CMD23 Enable =1, Auto CMD23 is used and if CMD23 Enable =0, Auto CMD12 is used. In case of Version 4.10 or later, use of Auto CMD Auto Select is recommended rather than use of Auto CMD12 Enable or Auto CMD23 Enable. 						" range="3 - 2" rwaccess="R/W"/> 
		<bitfield id="BLK_CNT_ENA" width="1" begin="1" end="1" resetval="0x0" description=" 						This bit is used to enable the Block count register, which is only relevant for multiple block transfers. When this bit is 0, the Block Count register is disabled, which is useful in executing an infinite transfer. 						" range="1" rwaccess="R/W"/> 
		<bitfield id="DMA_ENA" width="1" begin="0" end="0" resetval="0x0" description="DMA can be enabled only if DMA Support bit in the Capabilities register is set. If this bit is set to 1, a DMA operation shall begin when the HD writes to the upper byte of Command register [00Fh]. 						" range="0" rwaccess="R/W"/>
	</register>
	<register id="SDHC_WRAP__CTL_CFG__CTLCFG_command" acronym="SDHC_WRAP__CTL_CFG__CTLCFG_command" offset="0xE" width="16" description="This register is used to program the Command for host controller">
		<bitfield id="CMD_INDEX" width="6" begin="13" end="8" resetval="0x0" description=" 						This bit shall be set to the command number [CMD0-63, ACMD0-63]. 						" range="13 - 8" rwaccess="R/W"/> 
		<bitfield id="CMD_TYPE" width="2" begin="7" end="6" resetval="0x0" description=" 						There are three types of special commands. Suspend, Resume andAbort. These bits shall bet set to 00b for all other commands.  						Suspend Command: If the Suspend command succeeds, the HC shall assume the SD Bus has been released and that it is possible to issue the next command which uses the DAT line. The HC shall de-assert Read Wait for read transactions and stop checking busy   for write transactions. The Interrupt cycle shall start, in 4-bit mode. If the Suspend command fails, the HC shall maintain its current state. and the HD shall restart the transfer by setting Continue Request in the Block Gap            Control Register. 						Resume Command: The HD re-starts the data transfer by restoring the registers in the range of 000-00Dh. The HC shall check for busy before starting write transfers.  						Abort Command: If this command is set when exe- cuting a read transfer, the HC shall stop reads to the buffer. If this command is set when executing a writetransfer, the HC shall stop driving the DAT line. After issuing the Abort command, the HD should issue a software reset. 						" range="7 - 6" rwaccess="R/W"/> 
		<bitfield id="DATA_PRESENT" width="1" begin="5" end="5" resetval="0x0" description=" 						This bit is set to 1 to indicate that data is present and shall be transferred using the DAT line. If is set to 0 for the following: 						1. Commands using only CMD line [ex. CMD52]. 						2. Commands with no data transferbut using busy signal on DAT[0]line [R1b or R5b ex. CMD38]. 						3. Resume Command. 						" range="5" rwaccess="R/W"/> 
		<bitfield id="CMD_INDEX_CHK_ENA" width="1" begin="4" end="4" resetval="0x0" description=" 						If this bit is set to 1, the HC shall check the index field in the response to see if it has the same value as the command index. If it is not, it is reported as a Command Index Error. If this bit is set to 0, the Index field is not checked. 						" range="4" rwaccess="R/W"/> 
		<bitfield id="CMD_CRC_CHK_ENA" width="1" begin="3" end="3" resetval="0x0" description=" 						If this bit is set to 1, the HC shall check the CRC field in the response. If an error is detected, it is reported as a Command CRC Error. If this bit is set to 0, the CRC field is not checked. 						" range="3" rwaccess="R/W"/> 
		<bitfield id="SUB_CMD" width="1" begin="2" end="2" resetval="0x0" description="This bit is added from Version 4.10 to distinguish a main command or sub command [Refer to Section 1.17]. When issuing a main com-mand, this bit is set to 0 and when    issuing a sub command, this bit is set to 1. Setting of this bit is checked by Sub Command Status in the Present State register.Host Driver manages whether main or sub command. Host Controller does not refer to this bit to issue a       command. 						" range="2" rwaccess="R/W"/> 
		<bitfield id="RESP_TYPE_SEL" width="2" begin="1" end="0" resetval="0x0" description=" 						Response Type Select.  						" range="1 - 0" rwaccess="R/W"/>
	</register>
	<register id="SDHC_WRAP__CTL_CFG__CTLCFG_response" acronym="SDHC_WRAP__CTL_CFG__CTLCFG_response" offset="0x10" width="16" description="This register is used to store responses from SD Cards">
		<bitfield id="CMD_RESP" width="16" begin="15" end="0" resetval="0x0" description=" 						 R[] refers to a bit range within the response data as transmitted on the SD Bus, REP[] refers to a bit 						range within the Response register. 						" range="15 - 0" rwaccess="R"/>
	</register>
	<register id="SDHC_WRAP__CTL_CFG__CTLCFG_data_port" acronym="SDHC_WRAP__CTL_CFG__CTLCFG_data_port" offset="0x20" width="32" description="This register is used to access internal buffer">
		<bitfield id="BUF_RD_DATA" width="32" begin="31" end="0" resetval="0x0" description=" 						 The Host Controller Buffer can be accessed through this 32-bit Data Port Register. 						" range="31 - 0" rwaccess="R/W"/>
	</register>
	<register id="SDHC_WRAP__CTL_CFG__CTLCFG_presentstate" acronym="SDHC_WRAP__CTL_CFG__CTLCFG_presentstate" offset="0x24" width="32" description="The Host Driver can get status of the Host Controller from this 32-bit read-only register">
		<bitfield id="UHS2_IF_DETECTION" width="1" begin="31" end="31" resetval="0x0" description="  					This status indicates whether a card supports UHS-II IF. This status is enabled by setting UHS-II Interface Enable to 1 in the Host Control 2 regis-ter. UHS-II interface initialization is activated by setting SD Clock Enable in the Clock Control reg-ister. Host Controller drives STB.L on D0 lanefrom EIDL state and waits for receiving STB.L on D1 lane. This bit is set to 1 if STB.L is detected on D1 lane. Host Controller shall compensate latency from setting SD Clock Enable to output STB.L on D0 lane when reading this status [Refer to Figure 3-35 about details of this method]. This bit may be read any time after setting SD Clock Enable for faster UHS-II IF detection but Host Driver shall check this status at least 200us period from set- ting SD Clock Enable until detecting UHS-II IF. After UHS-II IF is detected, this bit is cleared by when EIDL is detected on D0 lane, UHS-II Inter-face Enable is set to 0 or Host full reset is exe-cuted.  						'0' UHS-II IF is not detected 						'1' UHS-II IF is detected  						" range="31" rwaccess="R"/> 
		<bitfield id="UHS2_IF_LANE_SYNC" width="1" begin="30" end="30" resetval="0x0" description="  					This status indicates whether lane is synchronized in UHS-II mode. This status is enabled by setting UHS-II Interface Enable to 1 in the Host Control 2 register. On detecting UHS-II Interface      [D31=1], Host Controller provides SYN LSS on D0 lane and waits for receiving SYN LSS on D1 lane. If SYN LSS is detected on D1 lane, Host Controller pro-vides LIDL LSS on D0 lane and waits for receiving LIDL LSS on D1 lane. In case of Version 4.00, this bit indicates comple-tion of Device PHY Initialization by detecting LIDL LSS on D1 lane.From Version 4.10, Host Controller may imple-ment a specific PHY verification method and PHY Initialization Failure can be indicated by keeping this bit to 0 even LIDL LSS is detected on D1 lane.Host Driver detects PHY Initialization Failure by timeout.This bit is cleared by when D0 lane is set to EIDL,UHS-II Interface Enable is set to 0 or executes Host full reset.   						" range="30" rwaccess="R"/> 
		<bitfield id="UHS2_DORMANT" width="1" begin="29" end="29" resetval="0x0" description="  					This status indicates whether UHS-II Ianes enterDormant state. This function is enabled by setting UHS-II Interface Enable to 1 in the Host Control 2 register. On issuing GO_DORMAT_STATE com-mand, Go Dormant Command [111b]; is set to Command type in the UHS-II Command register.This command type acts as a trigger to enterlanes into dormant state. Host Controller provides STB.H and EIDL on D0 lane and waits for receiv-ing STB.H and EIDL on D1 lane. This bit is set to 1 after the time of T_DMT_ENTRY [750 RCLK cycle] or more from detecting EIDL on D1 lane. 						RCLK may be stopped in dormant state, by setting SD Clock Enable to 0 in the Clock Control register while In Dormant State bit is set to 1. On writingClock Control register with setting SD Clock Enable to 1, Host Controller wakes lanes to exit Dormant State and In Dormant State is set to 0. In case of the card enters Hibernate Mode [RCLK is stopped], Host Driver may turn off VDD1 by clearing SD Bus Power for VDD1 bit in   the Power Control register. Host Controller shall turn off VDD1 after stopping RCLK. This bit is cleared by when Host Controller drives STB.L on D0 lane, UHS-II Interface Enable is set to 0 or executesHost full reset. 						" range="29" rwaccess="R"/> 
		<bitfield id="SUB_COMMAND_STS" width="1" begin="28" end="28" resetval="0x0" description="  						The Command register and Response register are commonly used for main command and sub command. This status is used to distinguish which response error statuses, main command or sub 						command, indicated in the Error Interrupt Status register or in the UHS-II Error Interrupt Status register. Refer to Section 1.17 about details of response error statuses.  						Just before reading of this register, the Sub Command Flag of the Command register or the UHS-II Command register is copied to this status. This status is effective not 						only when Response Error interrupt is generated but also when data error interrupt is generated with Command Not Issued by Error [D27 of this register] or  						Auto CMD Error interrupt is generated with Command Not Issued by Error by Auto CMD12 in the Auto CMD Error Status register. 						1 - Sub Command Status 						0 - Main Command Status  						" range="28" rwaccess="R"/> 
		<bitfield id="CMD_NOT_ISS_BY_ERR" width="1" begin="27" end="27" resetval="0x0" description="  						Setting of this status indicates that a command cannot be issued due to an error except Auto CMD12 error. [Equivalent error status by Auto CMD12 error is defined as Command Not Issued 						By Auto CMD12 Error in the Auto CMD Error Status register.] This status is set to 1 when Host Controller cannot issue a command after setting Command register  						or UHS-II Command register.Refer to Section 3.10 about 2L-HD error case inUHS-II mode.Sub Command Status [D28] indicates which command is not issued [main or sub]. 						1 - Command cannot be issued 						0 - No error for issuing a command  						" range="27" rwaccess="R"/> 
		<bitfield id="SDIF_CMDIN" width="1" begin="24" end="24" resetval="0x1" description="  						This status is used to check DAT line level to recover from errors, and for debugging.  						" range="24" rwaccess="R"/> 
		<bitfield id="SDIF_DAT3IN" width="1" begin="23" end="23" resetval="0x1" description=" 						This status is used to check DAT line level to recover from errors, and for debugging. This is 						especially useful in detecting the busy signal level from DAT[3]. 						" range="23" rwaccess="R"/> 
		<bitfield id="SDIF_DAT2IN" width="1" begin="22" end="22" resetval="0x1" description=" 						This status is used to check DAT line level to recover from errors, and for debugging. This is 						especially useful in detecting the busy signal level from DAT[2]. 						" range="22" rwaccess="R"/> 
		<bitfield id="SDIF_DAT1IN" width="1" begin="21" end="21" resetval="0x1" description=" 						This status is used to check DAT line level to recover from errors, and for debugging. This is 						especially useful in detecting the busy signal level from DAT[1]. 						" range="21" rwaccess="R"/> 
		<bitfield id="SDIF_DAT0IN" width="1" begin="20" end="20" resetval="0x1" description=" 						This status is used to check DAT line level to recover from errors, and for debugging. This is 						especially useful in detecting the busy signal level from DAT[0]. 						" range="20" rwaccess="R"/> 
		<bitfield id="WRITE_PROTECT" width="1" begin="19" end="19" resetval="0x0" description="  						The Write Protect Switch is supported for memory and combo cards.This bit reflects the SDWP# pin. 						" range="19" rwaccess="R"/> 
		<bitfield id="CARD_DETECT" width="1" begin="18" end="18" resetval="0x0" description="  						This bit reflects the inverse value of the SDCD# pin. 						'0' No Card present [SDCD# = 1] 						'1' Card present [SDCD# = 0] 						" range="18" rwaccess="R"/> 
		<bitfield id="CARD_STATE_STABLE" width="1" begin="17" end="17" resetval="0x0" description="  						This bit is used for testing. If it is 0, the Card Detect Pin Level is not stable. If this bit is set to 1,it means the Card Detect Pin Level is stable. The Software Reset For All in the Software Reset Register shall not affect this bit.   							'0' Reset of Debouncing 							'1' No Card or Inserted 						" range="17" rwaccess="R"/> 
		<bitfield id="CARD_INSERTED" width="1" begin="16" end="16" resetval="0x0" description="  						This bit indicates whether a card has been inserted. Changing from 0 to 1 generates a Card Insertion interrupt in the Normal Interrupt Status register and changing from 1 to 0 generates a Card Removal Interrupt in the Normal Interrupt Status register. The Software Reset For All in the Software Reset register shall not affect this bit. If a Card is removed while its power is on and its clock is oscillating, the HC shall clear SD Bus Power in the Power Control register and SD Clock Enable in the Clock control register. In addition the HD should clear the HC by the Software Reset For All in Software register. The card detect is active regardless of the SD Bus Power. 						'0' Reset or Debouncing or No Card 						'1' Card Inserted  						" range="16" rwaccess="R"/> 
		<bitfield id="BUF_RD_ENA" width="1" begin="11" end="11" resetval="0x0" description="  						This status is used for non-DMA read transfers.This read only flag indicates that valid data exists in the host side buffer status. If this bit is 1, readable data exists in the buffer. A change of this bit from 1 to 0 occurs when all the block data is read from the buffer. A change of this bit from 0 to 1 occurs when all the block data is ready in the buffer and generates the Buffer Read Ready Interrupt. 						" range="11" rwaccess="R"/> 
		<bitfield id="BUF_WR_ENA" width="1" begin="10" end="10" resetval="0x0" description="  						This status is used for non-DMA write transfers.This read only flag indicates if space is available for write data. If this bit is 1, data can be written to the buffer. A change of this bit from 1 to 0 occurs when all the block data is written to the buffer. A change of this bit from 0 to 1 occurs when top of block data can be written to the buffer and generates the Buffer Write Ready Interrupt. 						" range="10" rwaccess="R"/> 
		<bitfield id="RD_XFER_ACTIVE" width="1" begin="9" end="9" resetval="0x0" description="  						This status is used for detecting completion of a read transfer.  						This bit is set to 1 for either of the following conditions: 						  After the end bit of the read command. 						  When writing a 1 to continue Request in the Block Gap Control register to restart a read transfer. 						This bit is cleared to 0 for either of the following conditions: 						  When the last data block as specified by block length is transferred to the system. 						  When all valid data blocks have been transferred to the system and no current block transfers are being sent as a result of the Stop At Block Gap Request set to 1. A transfer complete interrupt is generated when this bit changes to 0.  						'0' No valid data 						'1' Transferring data 						" range="9" rwaccess="R"/> 
		<bitfield id="WR_XFER_ACTIVE" width="1" begin="8" end="8" resetval="0x0" description="  						This status indicates a write transfer is active. If this bit is 0, it means no valid write data exists in the HC. 						This bit is set in either of the following cases: 						 After the end bit of the write command. 						 When writing a 1 to Continue Request in the Block Gap Control register to restart a write transfer.  						This bit is cleared in either of the following cases: 						 After getting the CRC status of the last data block as specified by the transfer count [Single  or Multiple] 						 After getting a CRC status of any block where data transmission is about to be stopped by a Stop At Block Gap Request. During a write transaction, a Block Gap Event interrupt is generated when this bit is changed to 0, as a result of the Stop At Block Gap Request being set. This status is useful for the HD in determining when to issue commands during write busy. 						" range="8" rwaccess="R"/> 
		<bitfield id="SDIF_DAT7IN" width="1" begin="7" end="7" resetval="0x0" description="  						This status is used to check DAT line level to recover from errors, and for debugging.  						" range="7" rwaccess="R"/> 
		<bitfield id="SDIF_DAT6IN" width="1" begin="6" end="6" resetval="0x0" description="  						This status is used to check DAT line level to recover from errors, and for debugging.  						" range="6" rwaccess="R"/> 
		<bitfield id="SDIF_DAT5IN" width="1" begin="5" end="5" resetval="0x0" description="  						This status is used to check DAT line level to recover from errors, and for debugging.  						" range="5" rwaccess="R"/> 
		<bitfield id="SDIF_DAT4IN" width="1" begin="4" end="4" resetval="0x0" description="  						This status is used to check DAT line level to recover from errors, and for debugging.  						" range="4" rwaccess="R"/> 
		<bitfield id="RETUNING_REQ" width="1" begin="3" end="3" resetval="0x0" description="  						Host Controller may request Host Driver to execute re-tuning sequence by setting this bit when the data window is shifted by temperature drift and a tuned sampling point does not have a good margin to receive correct data. This bit is cleared when a command is issued with setting Execute Tuning in the Host Control 2 register.  Changing of this bit from 0 to 1 generates Re-Tuning Event. Refer to Normal Interrupt registers for more detail. This bit isn't set to 1 if Sampling Clock Select in the Host Control 2 register is set to 0 [using fixed sampling clock]. 						" range="3" rwaccess="R"/> 
		<bitfield id="DATA_LINE_ACTIVE" width="1" begin="2" end="2" resetval="0x0" description="  						This bit indicates whether one of the DAT line on SD bus is in use. 						" range="2" rwaccess="R"/> 
		<bitfield id="INHIBIT_DAT" width="1" begin="1" end="1" resetval="0x0" description="  						This status bit is generated if either the DAT Line Active or the Read transfer Active is set to 1. If this bit is 0, it indicates the HC can issue the next SD command. Commands with busy signal belong to Command Inhibit [DAT] [ex. R1b, R5b type]. Changing from 1 to 0 generates a Transfer Complete interrupt in the Normal interrupt status register. Note: The SD Host Driver can save registers in the range of 000-00Dh for a suspend transaction after this bit has changed from 1 to 0.  						'0' Can issue command which uses the DAT line 						'1' Cannot issue command which uses the DATline 						" range="1" rwaccess="R"/> 
		<bitfield id="INHIBIT_CMD" width="1" begin="0" end="0" resetval="0x0" description="  									SD Mode If this bit is 0, it indicates the CMD line is not in use and the HC can issue a SD command using the CMD line. This bit is set immediately after the Command register [00Fh] is written. This bit is cleared when the command response is   received. Even if the Command Inhibit [DAT] is set to 1, Commands using only the CMD line can be issued if this bit is 0. Changing from 1 to 0 gener- ates a Command complete interrupt in the Normal Interrupt Status register. If the HC   cannot issuethe command because of a command conflict error or because of Command Not Issued By Auto CMD12 Error, this bit shall remain 1 and the Com- mand Complete is not set. Status issuing Auto CMD12 is not read from this bit. Auto CMD12 and Auto CMD23 consist of two responses. In this case, this bit is not cleared by the response of CMD12 or CMD23 but cleared by the response of a read/write command. Status issuing Auto CMD12 is not read from this bit. So if a command is issued during Auto CMD12 opera- tion, Host Controller shall manage to issue two commands: CMD12 and a command set by Com-mand register.  									UHS-II Mode This bit is 0 means that a command packet can be issued by the Host Controller. While this bit is set to 1, which means the Host Controller is not ready to issue a next command, Host Driver shall not write the registers from UHS-II BlockSize [Offset 080h] to the UHS-II Command [Offset 09Eh]. Changing from 1 to 0 generates a Command Complete Interrupt in the Normal Interrupt Status-register. 									 									1- Host Controller is not ready to issue a com-mand 									0 - Host Controller is ready to issue a command Version 4.10 adds a new control to prevent error statuses from overwriting by receipt of a next com-mand. This status keeps indicating 1 while any of response error statuses is set to 1 [as described in Section 1.17], Command Not Issued by Error in this register is set to 1 or Command Not Issued by Auto CMD12 Error in the Auto CMD Error Status register is set to 1. Software Reset For CMD Lineis used to clear the error statuses above and this status. 						" range="0" rwaccess="R"/>
	</register>
	<register id="SDHC_WRAP__CTL_CFG__CTLCFG_host_control1" acronym="SDHC_WRAP__CTL_CFG__CTLCFG_host_control1" offset="0x28" width="8" description="This register is used to program DMA modes, LED Control, Data Transfer Width, High Speed Enable, Card detect test level and signal selection">
		<bitfield id="CD_SIG_SEL" width="1" begin="7" end="7" resetval="0x0" description=" 						This bit selects source for card detection. 						'0' SDCD# is selected [for normal use] 						'1' The card detect test level is selected 						" range="7" rwaccess="R/W"/> 
		<bitfield id="CD_TEST_LEVEL" width="1" begin="6" end="6" resetval="0x0" description=" 						This bit is enabled while the Card Detect Signal Selection is set to 1 and it indicates card inserted or not. Generates [card ins or card removal] interrupt when the normal int sts enable bit is set.  						'0' No Card 						'1' Card Inserted 						" range="6" rwaccess="R/W"/> 
		<bitfield id="EXT_DATA_WIDTH" width="1" begin="5" end="5" resetval="0x0" description=" 						This bit controls 8-bit bus width mode for embedded device. Support of this function is indicated in 8-bit Support for Embedded Device in the Capabilities register. If a device supports 8-bit bus mode, this bit may be set to 1. If this bit is 0, bus width is controlled by Data Transfer Width in the Host Control 1 register.This bit is not effective when multiple devices are installed on a bus slot [Slot Type is set to 10b in the Capabilities register]. In this case, each  device bus width is controlled by Bus Width Preset field in the Shared Bus register. 						" range="5" rwaccess="R/W"/> 
		<bitfield id="DMA_SELECT" width="2" begin="4" end="3" resetval="0x0" description=" 						This field is used to select DMA type. The Host Driver shall check support of DMA modes by referring the Capabilities register. Selected DMA is enabled by DMA Enable of the Transfer Mode   register in SD mode and DMA Enable of UHS-II Transfer Mode register in UHS-II mode. [1] Up to Version 3.00 When Host Version 4 Enable is set to 0, setting of this field is compatible to Host Controller Version 3.00.SDMA is initiated by  writing to the Command register when this field is set to 00b and the SDMA System Address regis-ter [32-bit] is used. SDMA does not support 64-bit address-ing.ADMA2 is initiated by writing to the Command register when this field is set  to 10b or 11b. Lower 32-bit of the ADMA Sys-tem Address register is used when this field is set to 10b and 64-bit of the ADMA System Address register is used when this field is set to 11b. Support of 64-bit System Addressing is indicated by 64-bit System Address Support for V3 in the Capabilities register. 64-bit AMDA2 uses 96-bit Descriptor. 					00 - SDMA is selected 					01 - 32-bit Address ADMA1 is selected 					10 -32-bit Address ADMA2 is selected 					11 - 64-bit Address ADMA2 is selected [Optional] 					[2] Version 4.00 or later When Host Version 4 Enable is set to 1, setting of this field is changed as follows.                                                 SDMA is initiated by Host Driver writes to the Command reg-ister when this field is set to 00b.ADMA2 is initiated by Host Driver writes to the Command register when this field is set to 10b or 11b and by ADMA3 sets to the ADMA System Address register when this field is set to 11b. ADMA3 is initiated by Host Driver writes to the ADMA3 IDAddress register when this field is set to 11b. 					00 - SDMA is selected 					01 - Not Used [New assignment is not allowed] 					10 - ADMA2 is selected [AMDA3 is not supported or dis-abled] 					11 - ADMA2 or ADMA3 is selected 						Support of 64-bit DMA and 128-bit Descriptor is indicated by 64-bit System Address Support for V4 in the Capabilities register. If the support bit is set to 1, all supported DMAs [depends on Support, ADMA2 Support and ADMA3 Sup-port] shall support 64-bit addressing. 64-bit Addressing in the Host Controller 2 register selects either 32-bit or 64-bit system addressing of DMAs. 						" range="4 - 3" rwaccess="R/W"/> 
		<bitfield id="HIGH_SPEED_ENA" width="1" begin="2" end="2" resetval="0x0" description=" 						This bit is optional. Before setting this bit, the HD shall check the High Speed Support in the capabilities register. If this bit is set to 0 [default], the HC outputs CMD line and DAT    lines at the falling edge of the SD clock [up to 25 MHz/20MHz for MMC]. If this bit is set to 1, the HC outputs CMD line and DAT lines at the rising edge of the SD clock [up to 50 MHz for SD/52MHz for MMC]/ 208Mhz [for SD3.0] If Preset Value Enable in the Host Control 2 register is set to 1, Host Driver needs to reset SD Clock Enable before changing this field to avoid generating clock glitches. After setting this field, the Host Driver sets SD Clock Enable again. 						This bit is not effective in UHS-II mode. 						" range="2" rwaccess="R/W"/> 
		<bitfield id="DATA_WIDTH" width="1" begin="1" end="1" resetval="0x0" description=" 						This bit selects the data width of the HC. The HD shall select it to match the data width of the SD card. 						This bit is not effective in UHS-II mode. 						" range="1" rwaccess="R/W"/> 
		<bitfield id="LED_CONTROL" width="1" begin="0" end="0" resetval="0x0" description=" 						This bit is used to caution the user not to remove the card while the SD card is being accessed. If the software is going to issue multiple SD commands, this bit can be set during all transactions. It is not necessary to change for each transaction. 						" range="0" rwaccess="R/W"/>
	</register>
	<register id="SDHC_WRAP__CTL_CFG__CTLCFG_power_control" acronym="SDHC_WRAP__CTL_CFG__CTLCFG_power_control" offset="0x29" width="8" description="This register is used to program the SD Bus power and voltage level">
		<bitfield id="UHS2_VOLTAGE" width="3" begin="7" end="5" resetval="0x0" description=" 						This field determines supply voltage range to VDD2. This field can be set to 101b if 1.8V VDD2 Support in the Capabilities register is set to 1.  						'000' VDD2 Not supported 						'001'- '011' Reserved 						'100' Reserved for 1.2V 						'101' 1.8V 						'110' Not Used 						'111' Not Used 						" range="7 - 5" rwaccess="R/W"/> 
		<bitfield id="UHS2_POWER" width="1" begin="4" end="4" resetval="0x0" description=" 						Setting this bit enables providing VDD2. 						'0' Power Off 						'1' Power On 						" range="4" rwaccess="R/W"/> 
		<bitfield id="SD_BUS_VOLTAGE" width="3" begin="3" end="1" resetval="0x0" description=" 						By setting these bits, the HD selects the voltage level for the SD card. Before setting this register, the HD shall check the voltage support bits in the capabilities register. If an unsupported voltage is selected, the Host System shall not supply SD bus voltage. 						 						'000'- '100' Reserved 						'101' 1.8V 						'110' 3.0V 						'111' 3.3V 						" range="3 - 1" rwaccess="R/W"/> 
		<bitfield id="SD_BUS_POWER" width="1" begin="0" end="0" resetval="0x0" description=" 						Before setting this bit, the SD host driver shall set SD Bus Voltage Select. If the HC detects the No Card State, this bit shall be cleared. 						If this bit is cleared, the Host Control-ler should immediately stop driving CMD and DAT[3:0] [tri-state], and drive SDCLK to low level [Refer to Section 2.2.14]. If card is connectedto    Host Controller, Host Controller shall set these lines to low before stopping to supply VDD1.In UHS-II mode, before clearing this bit, Host Driver shall clear SD Clock Enable and before stopping to sup-ply VDD1, Host Controller shall set DAT[2] to low if DAT[2] is used as out-of band interrupt. 						" range="0" rwaccess="R/W"/>
	</register>
	<register id="SDHC_WRAP__CTL_CFG__CTLCFG_block_gap_control" acronym="SDHC_WRAP__CTL_CFG__CTLCFG_block_gap_control" offset="0x2A" width="8" description="This register is used to program the block gap request, read wait control and interrupt at block gap">
		<bitfield id="BOOT_ACK_ENA" width="1" begin="7" end="7" resetval="0x1" description=" 						To check for the boot acknowledge in boot operation. 						" range="7" rwaccess="R/W"/> 
		<bitfield id="ALT_BOOT_MODE" width="1" begin="6" end="6" resetval="0x0" description=" 						To start boot code access in alternative mode. 						" range="6" rwaccess="R/W"/> 
		<bitfield id="BOOT_ENABLE" width="1" begin="5" end="5" resetval="0x0" description=" 						To start boot code access.   						" range="5" rwaccess="R/W"/> 
		<bitfield id="SPI_MODE" width="1" begin="4" end="4" resetval="0x0" description=" 						SPI mode enable bit.  						" range="4" rwaccess="R/W"/> 
		<bitfield id="INTRPT_AT_BLK_GAP" width="1" begin="3" end="3" resetval="0x0" description=" 						This bit is valid only in 4-bit mode of the SDIO card and selects a sample point in the interrupt cycle. Setting to 1 enables interrupt detection at the block gap for a multiple block transfer. If the SD card cannot signal an interrupt during a multiple block transfer, this bit should be set to 0. When the HD detects an SD card insertion, it shall set this bit according to the CCCR of the SDIO card. 						" range="3" rwaccess="R/W"/> 
		<bitfield id="RDWAIT_CTRL" width="1" begin="2" end="2" resetval="0x0" description=" 						The read wait function is optional for SDIO cards. If the card supports read wait, set this bit to enable use of the read wait protocol to stop read data using DAT[2] line. Otherwise the HC has to stop the SD clock to hold read data, which restricts commands generation. When the HD detects an SD card insertion, it shall set this bit according to the CCCR of the SDIO card. If the card does not support read wait, this bit shall never be set to 1 otherwise DAT line conflict may occur. If this bit is set to 0, Suspend / Resume cannot be supported. 						In UHS-II mode, Read Wait is disabled and DAT[2] line is used for Interrupt Signal from UHS-II Card.  						" range="2" rwaccess="R/W"/> 
		<bitfield id="CONTINUE" width="1" begin="1" end="1" resetval="0x0" description=" 						This bit is used to restart a transaction which was stopped using the Stop At Block Gap Request. To cancel stop at the block gap, set Stop At block Gap Request to 0 and set this bit to restart the transfer. The Host Controller automatically clears this bit when the transaction re-starts. If Stop At Block Gap Request is set to 1, any write to this bit is ignored. In SD mode, this bit is cleared in either of the following cases:  [1] In the case of a read transaction, the DAT Line Active changes from 0 to 1 as a read transaction restarts. [2] In the case of a write transaction, the Write transfer active changes from 0 to 1 as the write transaction restarts. Therefore it is not necessary for Host driver to set this bit to 0. If Stop At Block Gap Request is set to 1, any write to this bit is ignored. 						'0'  Ignore 						'1' Restart 						" range="1" rwaccess="R/W"/> 
		<bitfield id="STOP_AT_BLK_GAP" width="1" begin="0" end="0" resetval="0x0" description=" 						This bit is used to stop executing a transaction at the next block gap for non- DMA,SDMA and ADMA transfers. Until the transfer complete is set to 1, indicating a transfer completion the HD shall leave this bit set to 1. Clearing both the Stop At Block Gap Request and Continue Request shall not cause the transaction to restart. Read Wait is used to stop the read transaction at the block gap. The HC shall honour Stop At Block Gap Request for write transfers, but for read transfers it requires that the SD card support Read Wait. Therefore the HD shall not set this bit during read transfers unless the SD card supports Read Wait and has set Read Wait Control to 1. In case of write transfers in which the HD writes data to the Buffer Data Port register, the HD shall set this bit after all block data is written. If this bit is set to 1, the HD shall not write data to Buffer data port register. This bit affects Read Transfer Active, Write Transfer Active, DAT line active and Command Inhibit [DAT] in the Present State register. 						In case of UHS-II, a transaction can be stopped at the boundary of DATA Burst [Flow Control basis]. Host Control-ler waits for sending Flow Control MSG until Continue Request is set to 1.  						'0' Transfer 						'1' Stop 						" range="0" rwaccess="R/W"/>
	</register>
	<register id="SDHC_WRAP__CTL_CFG__CTLCFG_wakeup_control" acronym="SDHC_WRAP__CTL_CFG__CTLCFG_wakeup_control" offset="0x2B" width="8" description="This register is used to program the wakeup functionality">
		<bitfield id="CARD_REMOVAL" width="1" begin="2" end="2" resetval="0x0" description=" 						This bit enables wakeup event via Card removal assertion in the Normal Interrupt Status register.FN_WUS [Wake up Support] in CIS does not affect this bit. 						" range="2" rwaccess="R/W"/> 
		<bitfield id="CARD_INSERTION" width="1" begin="1" end="1" resetval="0x0" description=" 						This bit enables wakeup event via Card Insertion assertion in the Normal Interrupt Status register.FN_WUS [Wake up Support] in CIS does not affect this bit. 						" range="1" rwaccess="R/W"/> 
		<bitfield id="CARD_INTERRUPT" width="1" begin="0" end="0" resetval="0x0" description=" 						This bit enables wakeup event via Card Interrupt assertion in the Normal Interrupt Status register.This bit can be set to 1 if FN_WUS [Wake Up Support] in CIS is set to 1. 						" range="0" rwaccess="R/W"/>
	</register>
	<register id="SDHC_WRAP__CTL_CFG__CTLCFG_clock_control" acronym="SDHC_WRAP__CTL_CFG__CTLCFG_clock_control" offset="0x2C" width="16" description="This register is used to program the Clock frequency select, generator select, Clock enable, Internal Clock state fields
					This register controls SDCLK in SD Mode and RCLK in UHS-II mode.
					">
		<bitfield id="SDCLK_FRQSEL" width="8" begin="15" end="8" resetval="0x0" description=" 						This register is used to select the frequency of the SDCLK pin. The frequency is not programmed directly; rather this register holds the divisor of the Base Clock Frequency For SD clock in the capabilities register. Only the following settings are allowed. 						[1] 8-bit Divided Clock Mode 							80h - base clock divided by 256 							40h - base clock divided by 128 							20h - base clock divided by 64 							10h - base clock divided by 32 							08h - base clock divided by 16 							04h - base clock divided by 8 							02h - base clock divided by 4 							01h - base clock divided by 2 							00h - base clock[10MHz-63MHz] Setting 00h specifies the highest frequency of the SD Clock. When setting multiple bits, the most significant bit is used as the divisor. But multiple bits should not be set. The two default divider values can be calculated by the frequency that is defined by the Base Clock Frequency For SD Clock in the Capabilities register. 							[1] 25 MHz divider value. 							[2] 400 KHz divider value. The frequency of the SDCLK is set by the following formula: Clock Frequency = [Baseclock] / divisor. Thus choose the smallest possible divisor which results in a clock frequency that is less than or equal to the target frequency. Maximum Frequency for SD = 50Mhz [base clock] Maximum Frequency for MMC = 52Mhz [base clock] Minimum Frequency = 195.3125Khz [50Mhz / 256], same calculation for MMC also.  						[2] 10-bit Divided Clock Mode Host Controller Version 3.00 supports this mandatory mode instead of the 8-bit Divided Clock Mode. The length of divider is extended to10 bits and all divider values shall be supported. 							3FFh --1/2046 Divided Clock 							N -------1/2N Divided Clock [Duty 50%] 							002h -- 1/4 Divided Clock 							001h ---1/2 Divided Clock 							000h --- Base Clock [10MHz-254MHz] 						" range="15 - 8" rwaccess="R/W"/> 
		<bitfield id="SDCLK_FRQSEL_UPBITS" width="2" begin="7" end="6" resetval="0x0" description=" 						Bit 07-06 is assigned to bit 09-08 of clock divider in SDCLK Frequency Select.  						" range="7 - 6" rwaccess="R/W"/> 
		<bitfield id="CLKGEN_SEL" width="1" begin="5" end="5" resetval="0x0" description=" 						This bit is used to select the clock generator mode in SDCLK Frequency Select. If the Programmable Clock Mode is supported [non-zero value is set to Clock Multiplier in the Capabilities register], this bit attribute is RW, and if not supported, this bit attribute is RO and zero is read. This bit depends on the setting of Preset Value Enable in the Host Control 2 register. If the Preset Value Enable = 0, this bit is set by Host Driver. If the Preset Value Enable = 1, this bit is automatically set to a value specified in one of Preset Value registers. 						'0' Divided Clock Mode 						'1' Programmable Clock Mode 						" range="5" rwaccess="R/W"/> 
		<bitfield id="PLL_ENA" width="1" begin="3" end="3" resetval="0x0" description="This bit is added from Version 4.10 for Host Controller using PLL. This feature allows Host Controller to initialize clock generator in two steps: by Internal Clock Enable and PLL Enable and to minimize output latency [ex. SDCLK/RCLK, D0lane] from SD Clock Enable. There are two modes to keep Host Drivers compatibility. In both modes, PLL Locked timing is indicated by Internal Clock Stable. 								[1] When Host Version 4 Enable =0 [Host Driver Version 3, which does not support this bit] or this bit is not implemented,Internal Clock Enable [or SD Clock Enable] may     activate PLL [exit low power mode and start locking clock]. 								[2] When Host Version 4 Enable =1 [Host Driver Version 4],Internal Clock Enable is set before setting this bit and then setting this bit may activate PLL [exit low power    mode and start locking clock]. 						" range="3" rwaccess="R/W"/> 
		<bitfield id="SD_CLK_ENA" width="1" begin="2" end="2" resetval="0x0" description=" 						The HC shall stop SDCLK when writing this bit to 0. SDCLK frequency Select can be changed when this bit is 0. Then, the HC shall maintain the same clock frequency until SDCLK is stopped [Stop at SDCLK = 0]. If the HC detects the No Card state, this bit shall be cleared. 						" range="2" rwaccess="R/W"/> 
		<bitfield id="INT_CLK_STABLE" width="1" begin="1" end="1" resetval="0x0" description=" 						This bit is set to 1 when SD clock is stable after writing to Internal Clock Enable in this register to 1. The SD Host Driver shall wait to set SD Clock Enable until this bit is set to 1.  Note: This is useful when using PLL for a clock oscillator that requires setup time. 						" range="1" rwaccess="R"/> 
		<bitfield id="INT_CLK_ENA" width="1" begin="0" end="0" resetval="0x0" description=" 						This bit is set to 0 when the HD is not using the HC or the HC awaits a wakeup event. The HC should stop its internal clock to go very low power state. Still, registers shall be able to be read and written. Clock starts to oscillate when this bit is set to 1. When clock oscillation is stable, the HC shall set Internal Clock Stable in this register to 1. This bit shall not affect card detection. 						" range="0" rwaccess="R/W"/>
	</register>
	<register id="SDHC_WRAP__CTL_CFG__CTLCFG_timeout_control" acronym="SDHC_WRAP__CTL_CFG__CTLCFG_timeout_control" offset="0x2E" width="8" description="The register sets the Data Timeout counter value">
		<bitfield id="COUNTER_VALUE" width="4" begin="3" end="0" resetval="0x0" description=" 						This value determines the interval by which DAT line time-outs are detected. Refer to the Data Time-out Error in the Error Interrupt Status register for information on factors that dictate time-out generation. Time-out clock frequency will be generated by dividing the sdclockTMCLK by this value. When setting this register, prevent inadvertent time-out events by clearing the Data Time-out Error Status Enable [in the Error Interrupt Status Enable register]. 						1111 - Reserved 						1110 - TMCLK * 2^27 						-------------------- 						-------------------- 						0001 - TMCLK * 2^14 						0000 - TMCLK * 2^13 						" range="3 - 0" rwaccess="R/W"/>
	</register>
	<register id="SDHC_WRAP__CTL_CFG__CTLCFG_software_reset" acronym="SDHC_WRAP__CTL_CFG__CTLCFG_software_reset" offset="0x2F" width="8" description="This register is used to program the software reset for data, command and for all">
		<bitfield id="SWRST_FOR_DAT" width="1" begin="2" end="2" resetval="0x0" description=" 						Only part of data circuit is reset. The following registers and bits are cleared by this bit: 						Buffer Data Port Register: Buffer is cleared and Initialized.  						Present State register: 						Buffer read Enable, 						Buffer write Enable, 						Read Transfer Active, 						Write Transfer Active, 						DAT Line Active, 						Command Inhibit [DAT].  						Block Gap Control register: 						Continue Request, 						Stop At Block Gap Request.  						Normal Interrupt Status register: 						Buffer Read Ready, 						Buffer Write Ready, 						Block Gap Event, 						Transfer Complete.  						" range="2" rwaccess="R/W"/> 
		<bitfield id="SWRST_FOR_CMD" width="1" begin="1" end="1" resetval="0x0" description=" 					Software Reset For CMD Line Only part of command circuit is reset to be able to issue a command. From Version 4.10, this bit is also used to initialize UHS-II command circuit. This reset is effective only command issuing circuit [including response error statuses related to Com-mand Inhibit [CMD] control] and does not affect data transfer circuit. Host Controller can continue data transfer even this reset is executed during handling of sub com- mand response errors. The following registers and bits are cleared by this bit: Present State register Command Inhibit [CMD] Normal Interrupt Status register Command Complete Error Interrupt Status [from Version 4.10] Response error statuses related to Com-mand Inhibit [CMD] 						" range="1" rwaccess="R/W"/> 
		<bitfield id="SWRST_FOR_ALL" width="1" begin="0" end="0" resetval="0x0" description=" 						This reset affects the entire HC except for the card detection circuit. Register bits of type ROC, RW, RW1C, RWAC are cleared to 0. During its initialization, the HD shall set this bit to 1 to reset the HC. The HC shall reset this bit to 0 when capabilities registers are valid and the HD can read them. Additional use of Software Reset For All may not affect the value of the Capabilities registers. If this bit is set to 1, the SD card shall reset itself and must be re initialized by the HD. 						" range="0" rwaccess="R/W"/>
	</register>
	<register id="SDHC_WRAP__CTL_CFG__CTLCFG_normal_intr_sts" acronym="SDHC_WRAP__CTL_CFG__CTLCFG_normal_intr_sts" offset="0x30" width="16" description="This register gives the status of all the interrupts">
		<bitfield id="ERROR_INTR" width="1" begin="15" end="15" resetval="0x0" description="  					        If any of the bits in the Error Interrupt Status Register are set, then this bit is set. Therefore the HD can test for an error by checking this bit first. 					        In UHS-II mode is enabled, if any of the bits in the UHS-II Error Interrupt Status register are set, this bit is also set.  						'0' No error 						'1' Error 						" range="15" rwaccess="R"/> 
		<bitfield id="BOOT_COMPLETE" width="1" begin="14" end="14" resetval="0x0" description="  						This status is set if the boot operation gets terminated. 						'0' Boot operation is not terminated 						'1' Boot operation is terminated 						" range="14" rwaccess="R/W1TC"/> 
		<bitfield id="RCV_BOOT_ACK" width="1" begin="13" end="13" resetval="0x0" description="  						This status is set if the boot acknowledge is received from device. 						'0' Boot ack not recieved 						'1' Boot ack is recieved 						" range="13" rwaccess="R/W1TC"/> 
		<bitfield id="RETUNING_EVENT" width="1" begin="12" end="12" resetval="0x0" description="  						This status is set if Re-Tuning Request in the Present State register changes from 0 to 1. Host Controller requests Host Driver to perform re-tuning for next data transfer. Current data transfer [not large block count] can be completed without re-tuning.In UHS-II mode, this bit is not effective  						'0' Re-tuning not required 						'1' Re-tuning should be performed 						" range="12" rwaccess="R"/> 
		<bitfield id="INTC" width="1" begin="11" end="11" resetval="0x0" description="  						This status is set if INT_C is enabled and INT_C# pin is in low level. Writing this bit to 1 does not clear this bit. It is cleared by resetting the INT_C interrupt factor. 						" range="11" rwaccess="R"/> 
		<bitfield id="INTB" width="1" begin="10" end="10" resetval="0x0" description="  						This status is set if INT_B is enabled and INT_B# pin is in low level. Writing this bit to 1 does not clear this bit. It is cleared by resetting the INT_B interrupt factor. 						" range="10" rwaccess="R"/> 
		<bitfield id="INTA" width="1" begin="9" end="9" resetval="0x0" description="  						This status is set if INT_A is enabled and INT_A# pin is in low level. Writing this bit to 1 does not clear this bit. It is cleared by resetting the INT_A interrupt factor. NOTE : INT_A, INT_B, and INT_C are to be implemented based on the Application Requirements. By default these are not implemented as there is no specific requirement from Customers. 						" range="9" rwaccess="R"/> 
		<bitfield id="CARD_INTR" width="1" begin="8" end="8" resetval="0x0" description="  					When this status has been set and the Host Driver needs to start this interrupt service, Card Interrupt Status Enable in the Normal Interrupt Status Enable register may be set to 0 in order to clear the card interrupt status latched in the Host Controller and to stop driv-ing the interrupt signal to the Host System.After completion of the card interrupt service [It should reset interrupt factors in the SD card and the interrupt signal may not be asserted],set Card Interrupt Status Enable to 1 and start sampling the interrupt signal again. 					Writing this bit to 1 does not clear this bit. It is cleared by resetting the SD card interrupt fac-tor. 								[1] DAT[1] Interrupt Input in SD Mode 					In 1-bit mode, the Host Controller shall detect the Card Interrupt without SD Clock to support wakeup. In 4-bit mode, the card interrupt sig-nal is sampled during the interrupt cycle, so there are some sample delays between the interrupt signal from the SD card and the inter-rupt to the Host System. Interrupt detected by DAT[1] is supported when there is a card per slot. In case of UHS-I mode, switching time of Interrupt Period is relaxed for 2 clock cycles. Then Host Controller needs to delay start of interrupt sampling at least 2 clocks and should sample interrupt while Interrupt Period is sta-ble. 								[2] DAT[2] Interrupt Input in UHS-II Mode 					When Card Inserted in the Present State reg-ister and SD Bus Power for VDD1 in the Power Control register are set to 1, Host Con-troller configures DAT[2] as Interrupt Input and enables pull-up of DAT[2]. DAT[2] interrupt is asynchronous to RCLK, low level sensitive and 3.3V signal level. DAT[2] interrupt is masked by setting Card Interrupt Status Enable to 0 in the Normal Interrupt register.When either Card Inserted or SD Bus Power for VDD1 is set to 0, Host Controller sets DAT[2] to low. Only point to point connection is allowed between Host and Card. 								[3] INT MSG in UHS-II Mode 					INT MSG is enabled by setting INT MSG Enable in the UHS-II Device Select register. DAT[2] and INT MSG interrupt sources are ORed and indicated to Card Interrupt. If any bit in the UHS-II Device Interrupt Status regis- ter is set to 1, INT MSG interrupt is generated. INT MSG interrupt is cleared by writing a cor-respondent bit to 1 in the UHS-II Device Inter-rupt Status register. Masking DAT[2] interrupt also disables INT MSG interupt due to Card Interrupt Status Enable is set to 0. SDIO Ver-sion 4.00 does not support INT MSG. 						'0' No Card Interrupt  						'1' Generate Card Interrupt 						" range="8" rwaccess="R"/> 
		<bitfield id="CARD_REM" width="1" begin="7" end="7" resetval="0x0" description="  						This status is set if the Card Inserted in the Present State register changes from 1 to 0. When the HD writes this bit to 1 to clear this status the status of the Card Inserted in the Present State register should be confirmed. Because the card detect may possibly be changed when the HD clear this bit an Interrupt event may not be generated. 						'0' Card State Stable or Debouncing 						'1' Card Removed 						" range="7" rwaccess="R/W1TC"/> 
		<bitfield id="CARD_INS" width="1" begin="6" end="6" resetval="0x0" description="  						This status is set if the Card Inserted in the Present State register changes from 0 to 1.When the HD writes this bit to 1 to clear this status the status of the Card Inserted in the Present State register should be confirmed. Because the card detect may possibly be changed when the HD clear this bit an Interrupt event may not be generated.  						'0' Card State Stable or Debouncing 						'1' Card Inserted 						" range="6" rwaccess="R/W1TC"/> 
		<bitfield id="BUF_RD_READY" width="1" begin="5" end="5" resetval="0x0" description="  						This status is set if the Buffer Read Enable changes from 0 to 1. 						Buffer Read Ready is set to 1 for every CMD19 execution in tuning procedure.In UHS-II mode, this bit is set at FC [Flow Control] unit basis. 								 '0' Not ready to read buffer,	 								 '1'  Ready to read buffer 						" range="5" rwaccess="R/W1TC"/> 
		<bitfield id="BUF_WR_READY" width="1" begin="4" end="4" resetval="0x0" description="  						This status is set if the Buffer Write Enable changes from 0 to 1.In UHS-II mode, this bit is set at FC [Flow	Control] unit basis. 						 '0' Not ready to write to buffer, 						 '1' Ready to write to buffer 						" range="4" rwaccess="R/W1TC"/> 
		<bitfield id="DMA_INTERRUPT" width="1" begin="3" end="3" resetval="0x0" description="  						This status is set if the HC detects the Host DMA Buffer Boundary in the Block Size regiser. 						'0' No DMA Interrupt 						'1' DMA Interrupt is generated 						" range="3" rwaccess="R/W1TC"/> 
		<bitfield id="BLK_GAP_EVENT" width="1" begin="2" end="2" resetval="0x0" description="  						If the Stop At Block Gap Request in the BlockGap Control Register is set, this bit is set. 						Read Transaction: This bit is set at the falling edge of the DAT Line Active Status [When the transaction is stopped at SD Bus timing. The Read Wait must be supported inorder to use this function].  						Write Transaction: This bit is set at the falling edge of Write Transfer Active Status [After getting CRC status at SD Bus timing]. 						In UHS-II mode, this bit is set at FC [Flow Control] unit basis. 						'0' No Block Gap Event 						'1' Transaction stopped at Block Gap 						" range="2" rwaccess="R/W1TC"/> 
		<bitfield id="XFER_COMPLETE" width="1" begin="1" end="1" resetval="0x0" description="  						This bit is set when a read / write transaction is completed. 							SD Mode 						Read Transaction: This bit is set at the falling edge of Read Transfer Active Status. There are two cases in which the Interrupt is generated. The first is when a data transfer is completed as specified by data length [After the last data has been read to the Host Sys- tem]. The second is when data has stopped at the block gap and completed the data transfer by setting the Stop At Block Gap Request in the Block Gap Control Register [After valid data has been read to the Host System]. 						Write Transaction: This bit is set at the falling edge of the DAT Line Active Status. There are two cases in which the Interrupt is generated. The first is when the last data is written to the card as specified by data length and Busy signal is released. The second is when data transfers are stopped at the block gap by setting Stop At Block Gap Request in the Block Gap Control Register and data transfers completed. [After valid data is written to the SD card and the busy signal is released]. Note: Transfer Complete has higher priority than Data Time-out Error. If both bits are set to 1, the data transfer can be considered complete. Note: While performing tuning procedure [Execute Tuning is set to 1], Transfer Complete is not set to 1 						Command with Busy: This bit is set when busy is de-asserted. Refer to DAT Line Active and Command Inhibit[DAT] in the Present State register.UHS-I mode While performing tuning procedure [Execute Tuning is set to 1], Transfer Complete is not set to 1.   						'0' No Data Transfer Complete, 						'1' Data Transfer Complete  						UHS-II Mode 						This interrupt is generated in following twocases:  							[a] EBSY Completion [for EBSY supported commands] When EBSY Wait in the UHS-II Transfer Mode register is set to 1, this bit is set when EBSY packet has been received, and all valid data have been sent to system memory in case of read operation. 							[b] Stop and Continue during DCMD Data Transfer When Stop At Block Gap Request in the Block Gap Control register is set to 1 and data transfer is stopped at the Flow Control. 						Following is for both SD mode and UHS-II mode. The table below shows that Transfer Com-plete has higher priority than Data Timeout Error. If both bits are set to 1, execution of a command can be considered to be completed. 							1 - Command execution is completed 							0 - Not complete 						" range="1" rwaccess="R/W1TC"/> 
		<bitfield id="CMD_COMPLETE" width="1" begin="0" end="0" resetval="0x0" description="  							SD Mode 						This bit is set when we get the end bit of the command response [Except Auto CMD12 and Auto CMD23] Note: Command Time-out Error has higher priority than Command Complete. If both are set to 1, it can be considered that the response was not received correctly. Version 4.00 defines response check function for R1 and R5. If Response Interrupt Disable in the Transfer Mode register is set to 1, gen-eration of this interrupt is prohibited regardless of Command Complete Signal Enable. 							UHS-II Mode If Response Interrupt Disable is set to 0 in the UHS-II Transfer Mode register, this interrupt is generated when response packet is received.If Response Interrupt Disable is set to 1 in the UHS-II Transfer Mode register, generation of   this interrupt is prohibited regardless of Com-mand Complete Signal Enable. 						'0' No Command Complete, 						'1' Command Complete 						" range="0" rwaccess="R/W1TC"/>
	</register>
	<register id="SDHC_WRAP__CTL_CFG__CTLCFG_error_intr_sts" acronym="SDHC_WRAP__CTL_CFG__CTLCFG_error_intr_sts" offset="0x32" width="16" description="This register gives the status of the error interrupts">
		<bitfield id="HOST" width="1" begin="12" end="12" resetval="0x0" description="  						Occurs when detecting ERROR in m_hresp[dma transaction] 						" range="12" rwaccess="R/W1TC"/> 
		<bitfield id="RESP" width="1" begin="11" end="11" resetval="0x0" description=" Host Controller Version 4.00 supports response error check function to avoid overhead of response error check by Host Driver during DMA execution. If Response Error Check Enable is set to 1 in the Transfer Mode register, Host Controller Checks R1 or R5 response. If an error is detected in a response, this bit is set to 1.If Response Error Check Enable is set to 1 in the Transfer Mode register, Host Controller Checks R1 or R5 response. 						" range="11" rwaccess="R/W1TC"/> 
		<bitfield id="TUNING" width="1" begin="10" end="10" resetval="0x0" description="  This bit is set when an unrecoverable error is detected in a tuning circuit except during tuning procedure [Occurrence of an error during tuning procedure is indicated by Sampling Select]. By detecting Tuning Error, Host Driver needs to abort a command executing and perform tuning.To reset tuning circuit, Sampling Clock shall be set to 0 before executing tuning procedure. The Tuning Error is higher priority than the other error interrupts generated during data transfer. By detecting Turning Error, the Host Driver should discard data transferred by a current read/write command and retry data transfer after the Host Controller retrieved from tuning circuit error. 	    " range="10" rwaccess="R/W1TC"/> 
		<bitfield id="ADMA" width="1" begin="9" end="9" resetval="0x0" description="  						This bit is set when the Host Controller detects errors during ADMA based data transfer. The state of the ADMA at an error occurrence is saved in the ADMA Error Status Register. 						" range="9" rwaccess="R/W1TC"/> 
		<bitfield id="AUTO_CMD" width="1" begin="8" end="8" resetval="0x0" description="   					         Auto CMD12 and Auto CMD23 use this error status.This bit is set when detecting that any of the bits D00 to D05 in Auto CMD Error Status register has changed from 0 to 1. D07 is effective in case of Auto CMD12. Auto CMD Error Status register is valid while this bit is set to 1 and may be cleared with clearing of this bit [another implementation is also allowed]. 						" range="8" rwaccess="R/W1TC"/> 
		<bitfield id="CURR_LIMIT" width="1" begin="7" end="7" resetval="0x0" description="  						By setting the SD Bus Power bit in the Power Control Register, the HC is requested to supply power for the SD Bus. If the HC supports the Current Limit Function, it can be protected from an Illegal card by stopping power supply to the card in which case this bit indicates a failure status. Reading 1 means the HC is not supplying power to SD card due to some failure. Reading 0 means that the HC is supplying power and no error has occurred. This bit shall always set to be 0, if the HC does not support this function. 						" range="7" rwaccess="R/W1TC"/> 
		<bitfield id="DATA_ENDBIT" width="1" begin="6" end="6" resetval="0x0" description="  						Occurs when detecting 0 at the end bit position of read data which uses the DAT line or the end bit position of the CRC status. 						" range="6" rwaccess="R/W1TC"/> 
		<bitfield id="DATA_CRC" width="1" begin="5" end="5" resetval="0x0" description="  						Occurs when detecting CRC error when transferring read data which uses the DAT line or when detecting the Write CRC Status having a value of other than 010. 						" range="5" rwaccess="R/W1TC"/> 
		<bitfield id="DATA_TIMEOUT" width="1" begin="4" end="4" resetval="0x0" description="  						Occurs when detecting one of following timeout conditions: 						1. Busy Timeout for R1b, R5b type. 						2. Busy Timeout after Write CRC status 						3. Write CRC status Timeout 						4. Read Data Timeout.  						" range="4" rwaccess="R/W1TC"/> 
		<bitfield id="CMD_INDEX" width="1" begin="3" end="3" resetval="0x0" description="  						Occurs if a Command Index error occurs in the Command Response. 						" range="3" rwaccess="R/W1TC"/> 
		<bitfield id="CMD_ENDBIT" width="1" begin="2" end="2" resetval="0x0" description="  						Occurs when detecting that the end bit of a command response is 0. 						" range="2" rwaccess="R/W1TC"/> 
		<bitfield id="CMD_CRC" width="1" begin="1" end="1" resetval="0x0" description="  						Command CRC Error is generated in two cases.  						1. If a response is returned and the Command Time-out Error is set to 0, this bit is set to 1 when detecting a CRT error in the command response 						2. The HC detects a CMD line conflict by monitoring the CMD line when a command is issued. If the HC drives the CMD line to 1 level, but detects 0 level on the CMD line at the next SDCLK edge, then the HC shall abort the command [Stop driving CMD line] and set this bit to 1. The Command Timeout Error shall also be set to 1 to distinguish CMD line conflict. 						" range="1" rwaccess="R/W1TC"/> 
		<bitfield id="CMD_TIMEOUT" width="1" begin="0" end="0" resetval="0x0" description="  						Occurs only if the no response is returned within 64 SDCLK cycles from the end bit of the command. If the HC detects a CMD line conflict, in which case Command CRC Error shall also be set. This bit shall be set without waiting for 64 SDCLK cycles because the command will be aborted by the HC. 						" range="0" rwaccess="R/W1TC"/>
	</register>
	<register id="SDHC_WRAP__CTL_CFG__CTLCFG_normal_intr_sts_ena" acronym="SDHC_WRAP__CTL_CFG__CTLCFG_normal_intr_sts_ena" offset="0x34" width="16" description="This register is used to enable the normal interrupt status register fields">
		<bitfield id="BIT15_FIXED0" width="1" begin="15" end="15" resetval="0x0" description="  						The HC shall control error Interrupts using the Error Interrupt Status Enable register. 						" range="15" rwaccess="R"/> 
		<bitfield id="BOOT_COMPLETE" width="1" begin="14" end="14" resetval="0x0" description="  						'0' Masked 						'1' Enabled 						" range="14" rwaccess="R/W"/> 
		<bitfield id="RCV_BOOT_ACK" width="1" begin="13" end="13" resetval="0x0" description="  						'0' Masked 						'1' Enabled 						" range="13" rwaccess="R/W"/> 
		<bitfield id="RETUNING_EVENT" width="1" begin="12" end="12" resetval="0x0" description="  									0 - Masked 									1 - Enabled 						" range="12" rwaccess="R/W"/> 
		<bitfield id="INTC" width="1" begin="11" end="11" resetval="0x0" description="  						If this bit is set to 0, the Host Controller shall clear the interrupt request to the System. The Host Driver may clear this bit before servicing the INT_C and may set this bit again after all interrupt requests to INT_C pin are cleared to prevent inadvertent interrupts. 						" range="11" rwaccess="R/W"/> 
		<bitfield id="INTB" width="1" begin="10" end="10" resetval="0x0" description="  						If this bit is set to 0, the Host Controller shall clear the interrupt request to the System. The Host Driver may clear this bit before servicing the INT_B and may set this bit again after all interrupt requests to INT_B pin are cleared to prevent inadvertent interrupts. 						" range="10" rwaccess="R/W"/> 
		<bitfield id="INTA" width="1" begin="9" end="9" resetval="0x0" description="  						If this bit is set to 0, the Host Controller shall clear the interrupt request to the System. The Host Driver may clear this bit before servicing the INT_A and may set this bit again after all interrupt requests to INT_A pin are cleared to prevent inadvertent interrupts. 						" range="9" rwaccess="R/W"/> 
		<bitfield id="CARD_INTERRUPT" width="1" begin="8" end="8" resetval="0x0" description="  						If this bit is set to 0, the HC shall clear Interrupt request to the System. The Card Interrupt	detection is stopped when this bit is cleared and restarted when this bit is set to 1. The HD may clear the Card Interrupt Status Enable before servicing the Card Interrupt and may set this bit again after all Interrupt requests from the card are cleared to prevent inadvertent Interrupts. 						By setting this bit to 0, interrupt input should be masked by implementation so that the interrupt Input is not affected by external signal in any state [ex. floating].  						" range="8" rwaccess="R/W"/> 
		<bitfield id="CARD_REMOVAL" width="1" begin="7" end="7" resetval="0x0" description="  						'0' Masked 						'1' Enabled 						" range="7" rwaccess="R/W"/> 
		<bitfield id="CARD_INSERTION" width="1" begin="6" end="6" resetval="0x0" description="  						'0' Masked 						'1' Enabled 						" range="6" rwaccess="R/W"/> 
		<bitfield id="BUF_RD_READY" width="1" begin="5" end="5" resetval="0x0" description="  						'0' Masked 						'1' Enabled 						" range="5" rwaccess="R/W"/> 
		<bitfield id="BUF_WR_READY" width="1" begin="4" end="4" resetval="0x0" description="  						'0' Masked 						'1' Enabled 						" range="4" rwaccess="R/W"/> 
		<bitfield id="DMA_INTERRUPT" width="1" begin="3" end="3" resetval="0x0" description="  						'0' Masked, 						'1' Enabled 						" range="3" rwaccess="R/W"/> 
		<bitfield id="BLK_GAP_EVENT" width="1" begin="2" end="2" resetval="0x0" description="  						'0' Masked 						'1' Enabled 						" range="2" rwaccess="R/W"/> 
		<bitfield id="XFER_COMPLETE" width="1" begin="1" end="1" resetval="0x0" description="  						'0' Masked 						'1' Enabled 						" range="1" rwaccess="R/W"/> 
		<bitfield id="CMD_COMPLETE" width="1" begin="0" end="0" resetval="0x0" description="  						'0' Masked 						'1' Enabled 						" range="0" rwaccess="R/W"/>
	</register>
	<register id="SDHC_WRAP__CTL_CFG__CTLCFG_error_intr_sts_ena" acronym="SDHC_WRAP__CTL_CFG__CTLCFG_error_intr_sts_ena" offset="0x36" width="16" description="This register is used to enable the Error Interrupt Status register fields">
		<bitfield id="VENDOR_SPECIFIC" width="2" begin="14" end="13" resetval="0x0" description="N/A" range="14 - 13" rwaccess="R/W"/> 
		<bitfield id="HOST" width="1" begin="12" end="12" resetval="0x0" description="  						'0' Masked 						'1' Enabled 						" range="12" rwaccess="R/W"/> 
		<bitfield id="RESP" width="1" begin="11" end="11" resetval="0x0" description="  						'0' Masked 						'1' Enabled 						" range="11" rwaccess="R/W"/> 
		<bitfield id="TUNING" width="1" begin="10" end="10" resetval="0x0" description="  						'0' Masked 						'1' Enabled 						" range="10" rwaccess="R/W"/> 
		<bitfield id="ADMA" width="1" begin="9" end="9" resetval="0x0" description="  						'0' Masked 						'1' Enabled 						" range="9" rwaccess="R/W"/> 
		<bitfield id="AUTO_CMD" width="1" begin="8" end="8" resetval="0x0" description="  						'0' Masked 						'1' Enabled 						" range="8" rwaccess="R/W"/> 
		<bitfield id="CURR_LIMIT" width="1" begin="7" end="7" resetval="0x0" description="  						'0' Masked 						'1' Enabled 						" range="7" rwaccess="R/W"/> 
		<bitfield id="DATA_ENDBIT" width="1" begin="6" end="6" resetval="0x0" description="  						'0' Masked 						'1' Enabled 						" range="6" rwaccess="R/W"/> 
		<bitfield id="DATA_CRC" width="1" begin="5" end="5" resetval="0x0" description="  						'0' Masked 						'1' Enabled 						" range="5" rwaccess="R/W"/> 
		<bitfield id="DATA_TIMEOUT" width="1" begin="4" end="4" resetval="0x0" description="  						'0' Masked 						'1' Enabled 						" range="4" rwaccess="R/W"/> 
		<bitfield id="CMD_INDEX" width="1" begin="3" end="3" resetval="0x0" description="  						'0' Masked 						'1' Enabled 						" range="3" rwaccess="R/W"/> 
		<bitfield id="CMD_ENDBIT" width="1" begin="2" end="2" resetval="0x0" description="  						'0' Masked 						'1' Enabled 						" range="2" rwaccess="R/W"/> 
		<bitfield id="CMD_CRC" width="1" begin="1" end="1" resetval="0x0" description="  						'0' Masked 						'1' Enabled 						" range="1" rwaccess="R/W"/> 
		<bitfield id="CMD_TIMEOUT" width="1" begin="0" end="0" resetval="0x0" description="  						'0' Masked 						'1' Enabled 						" range="0" rwaccess="R/W"/>
	</register>
	<register id="SDHC_WRAP__CTL_CFG__CTLCFG_normal_intr_sig_ena" acronym="SDHC_WRAP__CTL_CFG__CTLCFG_normal_intr_sig_ena" offset="0x38" width="16" description="This register is used to enable the Normal Interrupt Signal register">
		<bitfield id="BIT15_FIXED0" width="1" begin="15" end="15" resetval="0x0" description="  						The HD shall control error Interrupts using the Error Interrupt Signal Enable register. 						" range="15" rwaccess="R"/> 
		<bitfield id="BOOT_COMPLETE" width="1" begin="14" end="14" resetval="0x0" description="  						'0' Masked 						'1' Enabled 						" range="14" rwaccess="R/W"/> 
		<bitfield id="RCV_BOOT_ACK" width="1" begin="13" end="13" resetval="0x0" description="  						'0' Masked 						'1' Enabled 						" range="13" rwaccess="R/W"/> 
		<bitfield id="RETUNING_EVENT" width="1" begin="12" end="12" resetval="0x0" description="  						'0' Masked 						'1' Enabled 						" range="12" rwaccess="R/W"/> 
		<bitfield id="INTC" width="1" begin="11" end="11" resetval="0x0" description="  						'0' Masked 						'1' Enabled 						" range="11" rwaccess="R/W"/> 
		<bitfield id="INTB" width="1" begin="10" end="10" resetval="0x0" description="  						'0' Masked 						'1' Enabled 						" range="10" rwaccess="R/W"/> 
		<bitfield id="INTA" width="1" begin="9" end="9" resetval="0x0" description="  						'0' Masked 						'1' Enabled 						" range="9" rwaccess="R/W"/> 
		<bitfield id="CARD_INTERRUPT" width="1" begin="8" end="8" resetval="0x0" description="  						'0' Masked 						'1' Enabled 						" range="8" rwaccess="R/W"/> 
		<bitfield id="CARD_REMOVAL" width="1" begin="7" end="7" resetval="0x0" description="  						'0' Masked 						'1' Enabled 						" range="7" rwaccess="R/W"/> 
		<bitfield id="CARD_INSERTION" width="1" begin="6" end="6" resetval="0x0" description="  						'0' Masked 						'1' Enabled 						" range="6" rwaccess="R/W"/> 
		<bitfield id="BUF_RD_READY" width="1" begin="5" end="5" resetval="0x0" description="  						'0' Masked 						'1' Enabled 						" range="5" rwaccess="R/W"/> 
		<bitfield id="BUF_WR_READY" width="1" begin="4" end="4" resetval="0x0" description="  						'0' Masked 						'1' Enabled 						" range="4" rwaccess="R/W"/> 
		<bitfield id="DMA_INTERRUPT" width="1" begin="3" end="3" resetval="0x0" description="  						'0' Masked 						'1' Enabled 						" range="3" rwaccess="R/W"/> 
		<bitfield id="BLK_GAP_EVENT" width="1" begin="2" end="2" resetval="0x0" description="  						'0' Masked 						'1' Enabled 						" range="2" rwaccess="R/W"/> 
		<bitfield id="XFER_COMPLETE" width="1" begin="1" end="1" resetval="0x0" description="  						'0' Masked 						'1' Enabled 						" range="1" rwaccess="R/W"/> 
		<bitfield id="CMD_COMPLETE" width="1" begin="0" end="0" resetval="0x0" description="  						'0' Masked 						'1' Enabled 						" range="0" rwaccess="R/W"/>
	</register>
	<register id="SDHC_WRAP__CTL_CFG__CTLCFG_error_intr_sig_ena" acronym="SDHC_WRAP__CTL_CFG__CTLCFG_error_intr_sig_ena" offset="0x3A" width="16" description="This register is used to enable Error Interrupt Signal register">
		<bitfield id="VENDOR_SPECIFIC" width="2" begin="14" end="13" resetval="0x0" description="N/A" range="14 - 13" rwaccess="R/W"/> 
		<bitfield id="HOST" width="1" begin="12" end="12" resetval="0x0" description="  						'0' Masked 						'1' Enabled 						" range="12" rwaccess="R/W"/> 
		<bitfield id="RESP" width="1" begin="11" end="11" resetval="0x0" description="  						'0' Masked 						'1' Enabled 						" range="11" rwaccess="R/W"/> 
		<bitfield id="TUNING" width="1" begin="10" end="10" resetval="0x0" description="  						'0' Masked 						'1' Enabled 						" range="10" rwaccess="R/W"/> 
		<bitfield id="ADMA" width="1" begin="9" end="9" resetval="0x0" description="  						'0' Masked 						'1' Enabled 						" range="9" rwaccess="R/W"/> 
		<bitfield id="AUTO_CMD" width="1" begin="8" end="8" resetval="0x0" description="  						'0' Masked 						'1' Enabled 						" range="8" rwaccess="R/W"/> 
		<bitfield id="CURR_LIMIT" width="1" begin="7" end="7" resetval="0x0" description="  						'0' Masked 						'1' Enabled 						" range="7" rwaccess="R/W"/> 
		<bitfield id="DATA_ENDBIT" width="1" begin="6" end="6" resetval="0x0" description="  						'0' Masked 						'1' Enabled 						" range="6" rwaccess="R/W"/> 
		<bitfield id="DATA_CRC" width="1" begin="5" end="5" resetval="0x0" description="  						'0' Masked 						'1' Enabled 						" range="5" rwaccess="R/W"/> 
		<bitfield id="DATA_TIMEOUT" width="1" begin="4" end="4" resetval="0x0" description="  						'0' Masked 						'1' Enabled 						" range="4" rwaccess="R/W"/> 
		<bitfield id="CMD_INDEX" width="1" begin="3" end="3" resetval="0x0" description="  						'0' Masked 						'1' Enabled 						" range="3" rwaccess="R/W"/> 
		<bitfield id="CMD_ENDBIT" width="1" begin="2" end="2" resetval="0x0" description="  						'0' Masked 						'1' Enabled 						" range="2" rwaccess="R/W"/> 
		<bitfield id="CMD_CRC" width="1" begin="1" end="1" resetval="0x0" description="  						'0' Masked 						'1' Enabled 						" range="1" rwaccess="R/W"/> 
		<bitfield id="CMD_TIMEOUT" width="1" begin="0" end="0" resetval="0x0" description="  						'0' Masked 						'1' Enabled 						" range="0" rwaccess="R/W"/>
	</register>
	<register id="SDHC_WRAP__CTL_CFG__CTLCFG_autocmd_err_sts" acronym="SDHC_WRAP__CTL_CFG__CTLCFG_autocmd_err_sts" offset="0x3C" width="16" description="
					This register is used to indicate CMD12 response error of Auto CMD12 and CMD23 response error of Auto CMD 23
					">
		<bitfield id="CMD_NOT_ISSUED" width="1" begin="7" end="7" resetval="0x0" description=" 						Setting this bit to 1 means CMD_wo_DAT is not executed due to an Auto CMD12 error [D04- D01] in this register. This bit is set to 0 when Auto CMD Error is generated by Auto CMD23. 						" range="7" rwaccess="R"/> 
		<bitfield id="RESP" width="1" begin="5" end="5" resetval="0x0" description=" 				     This bit is set when Response Error Check Enable in the Transfer Mode register is set to 1 and an error is detected in R1 response of either Auto CMD12 or Auto CMD23. This status should be ignored if any bit of D00 to D04 is set to 1. 						" range="5" rwaccess="R"/> 
		<bitfield id="INDEX" width="1" begin="4" end="4" resetval="0x0" description=" 						Occurs if the Command Index error occurs in response to a command. 						" range="4" rwaccess="R"/> 
		<bitfield id="ENDBIT" width="1" begin="3" end="3" resetval="0x0" description=" 						Occurs when detecting that the end bit of command response is 0. 						" range="3" rwaccess="R"/> 
		<bitfield id="CRC" width="1" begin="2" end="2" resetval="0x0" description=" 						Occurs when detecting a CRC error in the command response. 						" range="2" rwaccess="R"/> 
		<bitfield id="TIMEOUT" width="1" begin="1" end="1" resetval="0x0" description=" 						Occurs if the no response is returned within 64 SDCLK cycles from the end bit of the command.If this bit is set to 1, the other error status bits [D04 - D02] are meaningless.  						" range="1" rwaccess="R"/> 
		<bitfield id="ACMD12_NOT_EXEC" width="1" begin="0" end="0" resetval="0x0" description=" 						If memory multiple block data transfer is not started due to command error, this bit is not set because it is not necessary to issue Auto CMD12. Setting this bit to 1 means the HC cannot issue Auto CMD12 to stop memory multiple block transfer due to some error. If this bit is set to 1, other error status bits [D04 - D01] are meaningless. This bit is set to 0 when Auto CMD Error is generated by Auto CMD23  						" range="0" rwaccess="R"/>
	</register>
	<register id="SDHC_WRAP__CTL_CFG__CTLCFG_host_control2" acronym="SDHC_WRAP__CTL_CFG__CTLCFG_host_control2" offset="0x3E" width="16" description="This register is used to program UHS Select Mode,UHS Select Mode,Driver Strength Select,Execute Tuning,Sampling Clock Select,Asynchronous Interrupt Enable and Preset value enable
					">
		<bitfield id="PRESET_VALUE_ENA" width="1" begin="15" end="15" resetval="0x0" description=" 						Host Controller Version 3.00 supports this bit. As the operating SDCLK frequency and I/O driver strength depend on the Host System implementation, it is difficult to determine these parameters in the Standard Host Driver. When Preset Value Enable is set to automatic. This bit enables the functions defined in the Preset Value registers.  If this bit is set to 0, SDCLK Frequency Select, Clock Generator Select in the Clock Control register and Driver Strength Select in Host Control 2 register are set by Host Driver. If this bit is set to 1, SDCLK Frequency Select, Clock Generator Select in the Clock Control register and Driver Strength Select in Host Control 2 register are set by Host Controller as specified in the Preset Value registers. 						" range="15" rwaccess="R/W"/> 
		<bitfield id="ASYNCH_INTR_ENA" width="1" begin="14" end="14" resetval="0x0" description=" 						This bit can be set to 1 if a card support asynchronous interrupt and Asynchronous Interrupt Support is set to 1 in the Capabilities register. Asynchronous interrupt is effective when DAT[1] interrupt is used in 4-bit SD mode [and zero is set to Interrupt Pin Select in the Shared Bus Control register]. If this bit is set to 1, the Host Driver can stop the SDCLK during asynchronous interrupt period to save power. During this period, the Host Controller continues to deliver Card Interrupt to the host when it is asserted by the Card. 						" range="14" rwaccess="R/W"/> 
		<bitfield id="BIT64_ADDRESSING" width="1" begin="13" end="13" resetval="0x0" description=" 						This field is effective when Host Version 4.00 Enable is set to 1. 						Host Controller selects either of 32-bit or 64-bit addressing	modes to access system memory. Whether 32-bit or 64-bit is determined by OS installed in a host system. Host Driver sets this bit depends on addressing mode of installed OS. Refer to 64-bit System Address Support in the Capabilities register. . 						" range="13" rwaccess="R/W"/> 
		<bitfield id="HOST_VER40_ENA" width="1" begin="12" end="12" resetval="0x0" description=" 					This bit selects either Version 3.00 compatible mode or Ver4.mode. In Version 4.00, support of 64-bit System Addressing is modified. All DMAs support 64-bit System Addressing. UHS-II supported Host Driver shall enable this bit. In Version 4.10, supported 32-bit Block Count for all operations. Functions of following fields are modified. 								SDMA Address 									SDMA uses ADMA System Address register [05Fh-058h] instead of SDMA System Address register [Offset 003-000h] 								ADMA2 / ADMA3 Selection 									ADMA3 is selected by DMA Select in the Host Control 1 regis-ter. 								64bit ADMA Descriptor Size 									128bit descriptor is used instead of 96-bit descriptor when 64-bit Addressing is set to 1. 									Selection of 32-bit / 64-bit System Addressing 									Either 32-bit or 64-bit system addressing is selected by 64-bit	Addressing bit in this register instead of DMA Select in the Host Control 1 register. 								32-bit Block Count 									SDMA System Address register [003h-000h] is modified to 32-bit Block Count register. 						" range="12" rwaccess="R/W"/> 
		<bitfield id="CMD23_ENA" width="1" begin="11" end="11" resetval="0x0" description=" 						In memory card initialization, Host Driver Version 4.10 checks whether card supports CMD23 by checking a bit SCR[33]. If the card supports CMD23 [SCR[33]=1], this bit is set to 1. This bit is used to select Auto CMD23 or Auto CMD12 for ADMA3 datatransfer. Refer to Auto CMD Enable in the Transfer Mode regis-ter. 						" range="11" rwaccess="R/W"/> 
		<bitfield id="ADMA2_LEN_MODE" width="1" begin="10" end="10" resetval="0x0" description=" 						This bit selects one of ADMA2 Length Modes either 16-bit or 26-bit. 						" range="10" rwaccess="R/W"/> 
		<bitfield id="DRIVER_STRENGTH2" width="1" begin="9" end="9" resetval="0x0" description=" 						This is the programmed Drive STrength output and Bit[2] of the sdhccore_drivestrength value. 						" range="9" rwaccess="R/W"/> 
		<bitfield id="UHS2_INTF_ENABLE" width="1" begin="8" end="8" resetval="0x0" description=" 					This bit is used to enable UHS-II Interface. Before trying to start UHS-II initialization, this bit shall be set to 1. Before trying to start SD mode initialization, this bit shall be set to 0. 					This bit is used to enable UHS-II IF Detection, Lane Synchroni-zation and In Dormant State in the Present State register, and to select clock source of either SD mode or UHS-II mode. 					Host Controller shall not leave unused SD 4-bit Interface lines [CLK, CMD and DAT[3:2]] floating in UHS-II mode by using pull-up or driving to low. When DAT[2] is used as interrupt input in UHS-II mode, DAT[2] of Host Controller is set to input and then DAT[2] of SDIO card is set to output to avoid conflict. 						'0' 4-bit SD Interface enabled 						'1' UHS-II Interface enabled 						" range="8" rwaccess="R/W"/> 
		<bitfield id="SAMPLING_CLK_SELECT" width="1" begin="7" end="7" resetval="0x0" description=" 						This bit is set by tuning procedure when Execute Tuning is cleared. Writing 1 to this bit is meaningless and ignored. Setting 1 means that tuning is completed successfully and setting 0 means that tuning is failed. Host Controller uses this bit to select sampling clock to receive CMD and DAT. This bit is cleared by writing 0. Change of this bit is not allowed while the Host Controller is receiving response or a read data block.  						" range="7" rwaccess="R/W"/> 
		<bitfield id="EXECUTE_TUNING" width="1" begin="6" end="6" resetval="0x0" description=" 						This bit is set to 1 to start tuning procedure and automatically cleared when tuning procedure is completed. The result of tuning is indicated to Sampling Clock Select. Tuning procedure is aborted by writing 0 for more detail about tuning procedure.  						'0' Not Tuned or Tuning Completed 						'1' Execute Tuning 						" range="6" rwaccess="R/W"/> 
		<bitfield id="DRIVER_STRENGTH1" width="2" begin="5" end="4" resetval="0x0" description=" 						Host Controller output driver in 1.8V signaling is selected by this bit. In 3.3V signaling, this field is not effective. This field can be set depends on Driver Type A, C and D support bits in the Capabilities register. This bit depends on setting of Preset Value Enable. If Preset Value Enable = 0, this field is set by Host Driver.  If Preset Value Enable = 1, this field is automatically set by a value specified in the one of Preset Value registers.  						" range="5 - 4" rwaccess="R/W"/> 
		<bitfield id="V1P8_SIGNAL_ENA" width="1" begin="3" end="3" resetval="0x0" description=" 						This bit controls voltage regulator for I/O cell. 3.3V is supplied to the card regardless of signaling voltage. Setting this bit from 0 to 1 starts changing signal voltage from 3.3V to 1.8V. 1.8V regulator output shall be stable within 5ms. Host Controller clears this bit if switching to 1.8V signaling fails.  Clearing this bit from 1 to 0 starts changing signal voltage from 1.8V to 3.3V. 3.3V regulator output shall be stable within 5ms. Host Driver can set this bit to 1 when Host Controller supports 1.8V signaling [One of support bits is set to 1: SDR50, SDR104 or DDR50 in the Capabilities register] and the card or device supports UHS-I. 						'0' 3.3V Signalling, '1' 1.8V Signalling  						" range="3" rwaccess="R/W"/> 
		<bitfield id="UHS_MODE_SELECT" width="3" begin="2" end="0" resetval="0x0" description=" 						This field is used to select one of UHS-I modes or UHS-II mode.In case of UHS-I mode, this field is effective when 1.8V Signal-ing Enable is set to 1. In case of UHS-II mode, 1.8V Signaling Enable shall be set to 0. Setting of this field is used to select one of preset values in UHS-I or UHS-II mode. 						If Preset Value Enable in the Host Control 2 register is set to 1,Host Controller sets SDCLK/RCLK Frequency Select, Clock Generator Select in the Clock Control register and Driver Strength Select according to Preset Value registers. In this case, one of preset value registers is selected by this field. Host Driver needs to reset SD Clock Enable before changing this field to avoid generating clock glitch. After setting this field, Host Driver sets SD Clock Enable again.  When SDR50, SDR104 or DDR50 is selected for SDIO card, interrupt detection at the block gap shall not be used. Read Wait timing is changed for these modes. Refer to the SDIO Specification Version 3.00 for more detail. 						  						" range="2 - 0" rwaccess="R/W"/>
	</register>
	<register id="SDHC_WRAP__CTL_CFG__CTLCFG_capabilities" acronym="SDHC_WRAP__CTL_CFG__CTLCFG_capabilities" offset="0x40" width="64" description="
				This register provides the HD with information specific to the HC implementation. The HC may implement these values as fixed or loaded from flash memory during power on initializa-tion.
					">
		<bitfield id="HS400_SUPPORT" width="1" begin="63" end="63" resetval="0x0" description=" 						1 HS400 is Supported 						0 HS400 is Not Supported 						" range="63" rwaccess="R"/> 
		<bitfield id="VDD2_1P8_SUPPORT" width="1" begin="60" end="60" resetval="0x1" description=" 						This field indicates that support of VDD2 on Host system. 						" range="60" rwaccess="R"/> 
		<bitfield id="ADMA3_SUPPORT" width="1" begin="59" end="59" resetval="0x1" description=" 						This field indicates that support of ADMA3 on Host Controller. 						" range="59" rwaccess="R"/> 
		<bitfield id="SPI_BLK_MODE" width="1" begin="57" end="57" resetval="0x0" description=" 						This field indicates whether SPI Block Mode is supported or not. 						" range="57" rwaccess="R"/> 
		<bitfield id="SPI_SUPPORT" width="1" begin="56" end="56" resetval="0x0" description=" 						This field indicates whether SPI Mode is supported or not. 						" range="56" rwaccess="R"/> 
		<bitfield id="CLOCK_MULTIPLIER" width="8" begin="55" end="48" resetval="0x0" description=" 						This field indicates clock multiplier value of programmable clock generator. Refer to Clock Control register. Setting 00h means that Host Controller does not support programmable clock generator. 						'FF' Clock Multiplier M = 256 						 --------- 						'02' Clock Multiplier M = 3 						'01' Clock Multiplier M = 2 						'00' Clock Multiplier is Not Supported. 						" range="55 - 48" rwaccess="R"/> 
		<bitfield id="RETUNING_MODES" width="2" begin="47" end="46" resetval="0x0" description=" 						This field defines the re-tuning capability of a Host Controller and how to manage the data transfer length and a Re-Tuning Timer by the Host Driver.  						'00' Mode 1 						'01' Mode 2 						'10' Mode 3 						'11' Reserved. There are two re-tuning timings:Re-Tuning Request and expiration of a Re-Tuning Timer. By receiving either timing, the Host Driver executes the re-tuning procedure just before a next command issue. 						" range="47 - 46" rwaccess="R"/> 
		<bitfield id="TUNING_FOR_SDR50" width="1" begin="45" end="45" resetval="0x0" description=" 						If this bit is set to 1, this Host Controller requires tuning to operate SDR50. [Tuning is always required to operate SDR104]. 						'0'  						'1'  						" range="45" rwaccess="R"/> 
		<bitfield id="RETUNING_TIMER_CNT" width="4" begin="43" end="40" resetval="0x4" description=" 						This field indicates an initial value of the Re-Tuning Timer for Re-Tuning Mode 1 to 3. 						0h - Get information via other source 						1h = 1 seconds 						2h = 2 seconds 						3h = 4 seconds 						4h = 8 seconds 						------ 						n = 2[n-1] seconds 						------ 						Bh = 1024 seconds 						Fh - Ch = Reserved 						" range="43 - 40" rwaccess="R"/> 
		<bitfield id="DRIVERD_SUPPORT" width="1" begin="38" end="38" resetval="0x0" description=" 						This bit indicates support of Driver Type D for 1.8 Signaling. 						'0' Driver Type D is Not supported,  						'1' Driver Type D is supported 						" range="38" rwaccess="R"/> 
		<bitfield id="DRIVERC_SUPPORT" width="1" begin="37" end="37" resetval="0x0" description=" 						This bit indicates support of Driver Type C for 1.8 Signaling. 						'0' Driver Type C is Not supported,  						'1' Driver Type C is supported 						" range="37" rwaccess="R"/> 
		<bitfield id="DRIVERA_SUPPORT" width="1" begin="36" end="36" resetval="0x0" description=" 						This bit indicates support of Driver Type A for 1.8 Signaling. 						'0' Driver Type A is Not supported,  						'1' Driver Type A is supported 						" range="36" rwaccess="R"/> 
		<bitfield id="UHS2_SUPPORT" width="1" begin="35" end="35" resetval="0x0" description=" 						This bit indicates whether Host controller supports UHS-II. If this bit is set to 1, 1.8V VDD2 Support shall be set to 1 [Host Sys- tem shall support VDD2 power supply]. 								1 UHS-II is Supported 								0 UHS-II is Not Supported 						" range="35" rwaccess="R"/> 
		<bitfield id="DDR50_SUPPORT" width="1" begin="34" end="34" resetval="0x1" description=" 						This bit indicates whether DDR50 is supported or not. 						" range="34" rwaccess="R"/> 
		<bitfield id="SDR104_SUPPORT" width="1" begin="33" end="33" resetval="0x1" description=" 						This bit indicates whether SDR104 is supported or not.SDR104 requires tuning. 						" range="33" rwaccess="R"/> 
		<bitfield id="SDR50_SUPPORT" width="1" begin="32" end="32" resetval="0x1" description=" 						If SDR104 is supported, this bit shall be set to 1. Bit 40 indicates whether SDR50 requires tuning or not. 						" range="32" rwaccess="R"/> 
		<bitfield id="SLOT_TYPE" width="2" begin="31" end="30" resetval="0x0" description=" 						This field indicates usage of a slot by a specific Host System. [A host controller register set is defined perslot.] Embedded slot for one device [01b] means that only one non-removable device is connected to a SD bus slot. Shared Bus Slot [10b] can be set if Host Controller supports Shared Bus Control register. The Standard Host Driver controls only a removable card or one embedded device is connected to a SD bus slot. If a slot is configured for shared bus [10b], the Standard Host Driver does not control embedded devices connected to a shared bus. Shared bus slot is controlled by a specific host driver developed by a Host System.  						" range="31 - 30" rwaccess="R"/> 
		<bitfield id="ASYNCH_INTR_SUPPORT" width="1" begin="29" end="29" resetval="0x1" description=" 						Refer to SDIO Specification Version 3.00 about asynchronous interrupt. 						" range="29" rwaccess="R"/> 
		<bitfield id="ADDR_64BIT_SUPPORT_V3" width="1" begin="28" end="28" resetval="0x1" description=" 						IMeaning of this bit is different depends on Versions [Refer to Table 2-35 for more details]. Host Controller Version 3.00 and Ver4.10 use this bit as 64-bit System Address support for V3 mode. Host Con- troller Version 4.00 uses this bit as 64-bit System Address support for both V3 and V4 modes. 						SDMA cannot be used in 64-bit Address-ing in Version 3 mode. 						If this bit is set to 1, 64-bit ADMA2 with using 96-bit Descriptor may be enabled as follows: 						In case of Host Controller Version 3, 64-bit ADMA2 is enabled by DMA Select =11b in the Host Control 1 register. In case of Host Controller Version 4, 64-bitADMA2 for Version 3 is enabled by setting Host Version 4 Enable =0 and DMA Select = 11b. 								1 - 64-bit System Address for V3 is Supported 								0 - 64-bit System Address for V3 is not Supported 						" range="28" rwaccess="R"/> 
		<bitfield id="ADDR_64BIT_SUPPORT_V4" width="1" begin="27" end="27" resetval="0x1" description=" 						This bit is added from Version 4.10. Set-ting 1 to this bit indicates that the Host Controller supports 64-bit System Addressing of Version 4 mode [Refer to Table 2-35 for the summary of 64-bit sys-tem address support].. 						When this bit is set to 1, full or a part of 64-bit address should be used to decode Host Controller Registers so that Host Controller Registers can be placed above system memory area. 64-bit address decode of Host Controller Registers is effective regardless of setting to 64bit Addressing in Host Control 2. 						If this bit is set to 1, 64-bit DMA Address-ing for Version 4 is enabled by setting Host Version 4 Enable =1, 64-bit Address-ing =1 in the Host Control 2 register.SDMA can be used and ADMA2 uses 128-bit Descriptor. 						" range="27" rwaccess="R"/> 
		<bitfield id="VOLT_1P8_SUPPORT" width="1" begin="26" end="26" resetval="0x1" description=" 						This bit indicates whether the HC supports 1.8V. 						" range="26" rwaccess="R"/> 
		<bitfield id="VOLT_3P0_SUPPORT" width="1" begin="25" end="25" resetval="0x0" description=" 						This bit indicates whether the HC supports 3.0V. 						" range="25" rwaccess="R"/> 
		<bitfield id="VOLT_3P3_SUPPORT" width="1" begin="24" end="24" resetval="0x1" description=" 						This bit indicates whether the HC supports 3.3V. 						" range="24" rwaccess="R"/> 
		<bitfield id="SUSP_RES_SUPPORT" width="1" begin="23" end="23" resetval="0x1" description=" 						This bit indicates whether the HC supports Suspend / Resume functionality. If this bit is 0, the Suspend and Resume mechanism are not supported and the HD shall not issue either Suspend / Resume commands. 						" range="23" rwaccess="R"/> 
		<bitfield id="SDMA_SUPPORT" width="1" begin="22" end="22" resetval="0x1" description=" 						This bit indicates whether the HC is capable of using DMA to transfer data between system memory and the HC directly.Version 4.10 Host Controller shall support SDMA if ADMA2 is supported. 						" range="22" rwaccess="R"/> 
		<bitfield id="HIGH_SPEED_SUPPORT" width="1" begin="21" end="21" resetval="0x1" description=" 						This bit indicates whether the HC and the Host System support High Speed mode and they can supply SD Clock frequency from 25Mhz to 50 Mhz [for SD]/ 20MHz to 52MHz [for MMC]. 						" range="21" rwaccess="R"/> 
		<bitfield id="ADMA2_SUPPORT" width="1" begin="19" end="19" resetval="0x1" description=" 						'0' ADMA2 Not Supported 						'1' ADMA2 Supported 						" range="19" rwaccess="R"/> 
		<bitfield id="BUS_8BIT_SUPPORT" width="1" begin="18" end="18" resetval="0x0" description=" 						This bit indicates whether the Host Controller is capable of using 8-bit bus width mode. This bit is not effective when Slot Type is set to 10b. In this case, refer to Bus Width Preset in the Shared Bus resister. 						" range="18" rwaccess="R"/> 
		<bitfield id="MAX_BLK_LENGTH" width="2" begin="17" end="16" resetval="0x0" description=" 						This value indicates the maximum block size that the HD can read and write to the buffer in the HC. The buffer shall transfer this block size without wait cycles. Three sizes can be defined as indicated below. 						" range="17 - 16" rwaccess="R"/> 
		<bitfield id="BASE_CLK_FREQ" width="8" begin="15" end="8" resetval="0x200" description=" 						[1]6-bit Base Clock Frequency: 						This mode is supported by the Host Controller Version 1.00 and 2.00. Upper 2-bit is not effective and always 0. Unit values are 1MHz. The supported clock range is 10MHz to 63MHz.  						'11xx xxxxb' Not Supported 						'0011 1111b' 63MHz 						'0000 0010b' 2MHz 						'0000 0001b' 1MHz 						'0000 0000b'Get Information via another method   						[2]8-bit Base Clock Frequency: 						This mode is supported by the Host Controller Version 3.00.Unit values are 1MHz. The supported clock range is 10MHz to 255MHz. 						'FFh' 255MHz 						'02h' 2MHz 						'01h' 1MHz 						'00h' Get Information via another method.  If the real frequency is 16.5MHz, the lager value shall be set 0001 0001b [17MHz] because the Host Driver use this value to calculate the clock divider value [Refer to the SDCLK Frequency Select in the Clock Control register.] and it shall not exceed upper limit of the SD Clock frequency. If these bits are all 0, the Host System has to get information via another method.  						" range="15 - 8" rwaccess="R"/> 
		<bitfield id="TIMEOUT_CLK_UNIT" width="1" begin="7" end="7" resetval="0x0" description=" 						This bit shows the unit of base clock frequency used to detect Data Timeout Error.  						" range="7" rwaccess="R"/> 
		<bitfield id="TIMEOUT_CLK_FREQ" width="6" begin="5" end="0" resetval="0x1" description=" 						This bit shows the base clock frequency used to detect Data Timeout Error. 						'000000' Get Information via another method, 'not 0' 1KHz to 63KHz/1MHz to 63MHz  						" range="5 - 0" rwaccess="R"/>
	</register>
	<register id="SDHC_WRAP__CTL_CFG__CTLCFG_max_current_cap" acronym="SDHC_WRAP__CTL_CFG__CTLCFG_max_current_cap" offset="0x48" width="64" description="This register indicates maximum current capability for each voltage">
		<bitfield id="VDD2_1P8V" width="8" begin="39" end="32" resetval="0x0" description="Maximum Current for 1.8V VDD2" range="39 - 32" rwaccess="R"/> 
		<bitfield id="VDD1_1P8V" width="8" begin="23" end="16" resetval="0x0" description="Maximum Current for 1.8V VDD1" range="23 - 16" rwaccess="R"/> 
		<bitfield id="VDD1_3P0V" width="8" begin="15" end="8" resetval="0x0" description=" 						Maximum Current for 3.0V VDD1 						" range="15 - 8" rwaccess="R"/> 
		<bitfield id="VDD1_3P3V" width="8" begin="7" end="0" resetval="0x0" description=" 						Maximum Current for 3.3V VDD1 						" range="7 - 0" rwaccess="R"/>
	</register>
	<register id="SDHC_WRAP__CTL_CFG__CTLCFG_force_evnt_ACMD_Err_Sts" acronym="SDHC_WRAP__CTL_CFG__CTLCFG_force_evnt_ACMD_Err_Sts" offset="0x50" width="16" description="This register is not physically implemented, rather it is an address where Auto CMD Error Status register can be written.
							    Writing 1 : set each bit of the Auto CMD12 Error Status Register
								Writing 0 : no effect.
					">
		<bitfield id="CMD_NOT_ISS" width="1" begin="7" end="7" resetval="0x0" description="  						Force Event for Command Not Issued by AUTO CMD12 Error. 						" range="7" rwaccess="W"/> 
		<bitfield id="RESP" width="1" begin="5" end="5" resetval="0x0" description="  						Force Event for AUTO CMD Response Error.. 						" range="5" rwaccess="W"/> 
		<bitfield id="INDEX" width="1" begin="4" end="4" resetval="0x0" description="  						Force Event for AUTO CMD Index Error.. 						" range="4" rwaccess="W"/> 
		<bitfield id="ENDBIT" width="1" begin="3" end="3" resetval="0x0" description="  						Force Event for AUTO CMD End Bit Error. 						" range="3" rwaccess="W"/> 
		<bitfield id="CRC" width="1" begin="2" end="2" resetval="0x0" description="  						Force Event for AUTO CMD Timeout Error. 						" range="2" rwaccess="W"/> 
		<bitfield id="TIMEOUT" width="1" begin="1" end="1" resetval="0x0" description="  						Force Event for AUTO CMD Timeout Error. 						" range="1" rwaccess="W"/> 
		<bitfield id="ACMD_NOT_EXEC" width="1" begin="0" end="0" resetval="0x0" description="  						Force Event for AUTO CMD12 Not Executed. 						" range="0" rwaccess="W"/>
	</register>
	<register id="SDHC_WRAP__CTL_CFG__CTLCFG_force_evnt_Err_Int_Sts" acronym="SDHC_WRAP__CTL_CFG__CTLCFG_force_evnt_Err_Int_Sts" offset="0x52" width="16" description="This register is not physically implemented, rather it is an address where Error Interrupt Status register can be written.">
		<bitfield id="HOST" width="1" begin="12" end="12" resetval="0x0" description="  						Force Event for Host Error 						" range="12" rwaccess="W"/> 
		<bitfield id="RESP" width="1" begin="11" end="11" resetval="0x0" description="  						Force Event for Response Error 						" range="11" rwaccess="W"/> 
		<bitfield id="TUNING" width="1" begin="10" end="10" resetval="0x0" description="  						Force Event for Tuning Error. 						" range="10" rwaccess="W"/> 
		<bitfield id="ADMA" width="1" begin="9" end="9" resetval="0x0" description="  						Force Event for ADMA Error. 						" range="9" rwaccess="W"/> 
		<bitfield id="AUTO_CMD" width="1" begin="8" end="8" resetval="0x0" description="  						Force Event for Auto CMD Error.  						" range="8" rwaccess="W"/> 
		<bitfield id="CURR_LIM" width="1" begin="7" end="7" resetval="0x0" description="  						Force Event for Current Limit Error. 						" range="7" rwaccess="W"/> 
		<bitfield id="DAT_ENDBIT" width="1" begin="6" end="6" resetval="0x0" description="  						Force Event for Data End Bit Error.  						" range="6" rwaccess="W"/> 
		<bitfield id="DAT_CRC" width="1" begin="5" end="5" resetval="0x0" description="  						Force Event for Data CRC Error. 						" range="5" rwaccess="W"/> 
		<bitfield id="DAT_TIMEOUT" width="1" begin="4" end="4" resetval="0x0" description="  						Force Event for Data Timeout Error. 						" range="4" rwaccess="W"/> 
		<bitfield id="CMD_INDEX" width="1" begin="3" end="3" resetval="0x0" description="  						Force Event for Command Index Error 						" range="3" rwaccess="W"/> 
		<bitfield id="CMD_ENDBIT" width="1" begin="2" end="2" resetval="0x0" description="  						Force Event for Command End Bit Error. 						" range="2" rwaccess="W"/> 
		<bitfield id="CMD_CRC" width="1" begin="1" end="1" resetval="0x0" description="  						Force Event for Command CRC Error. 						" range="1" rwaccess="W"/> 
		<bitfield id="CMD_TIMEOUT" width="1" begin="0" end="0" resetval="0x0" description="  						Force Event for CMD Timeout Error. 						" range="0" rwaccess="W"/>
	</register>
	<register id="SDHC_WRAP__CTL_CFG__CTLCFG_adma_err_status" acronym="SDHC_WRAP__CTL_CFG__CTLCFG_adma_err_status" offset="0x54" width="8" description="When the ADMA Error interrupt occur, this register holds the ADMA State in ADMA Error States field and ADMA System Address holds address around the error descriptor">
		<bitfield id="ADMA_LENGTH_ERR" width="1" begin="2" end="2" resetval="0x0" description="  						This error occurs in the following 2 cases. While Block Count Enable being set, the total data length specified by the Descriptor table is different from that specified by the Block Count and Block Length. Total data length can not be divided by the block length. 						" range="2" rwaccess="R"/> 
		<bitfield id="ADMA_ERR_STATE" width="2" begin="1" end="0" resetval="0x0" description=" 						This field indicates the state of ADMA when error is occurred during ADMA data transfer. This field never indicates 10 because ADMA never stops in this state. 						D01  D00 : ADMA Error State when error occurred Contents of SYS_SDR register.  						" range="1 - 0" rwaccess="R"/>
	</register>
	<register id="SDHC_WRAP__CTL_CFG__CTLCFG_adma_sys_address" acronym="SDHC_WRAP__CTL_CFG__CTLCFG_adma_sys_address" offset="0x58" width="64" description="This register contains the physical address used for ADMA data transfer">
		<bitfield id="ADMA_ADDR" width="64" begin="63" end="0" resetval="0x0" description=" 					The 32-bit addressing Host Driver uses lower 32-bit of this register [upper 32-bit should be set to 0] and shall program Descriptor Table on 32-bit boundary andset 32-bit boundary address to this register. DMA2/3 ignores lower 2-bit of this register and assumes it to be 00b. 					DMA in 64-bit addressing. The 64-bit addressing Host Driver uses all bits of this register and shall program Descriptor Table on 64-bit boundary and set 64-bit boundary address to this register. DMA2/3 ignores lower 3-bit of this register andassumes it to be 000b. 							SDMA 					If Host Version 4.00 Enable is set to 1, SDMA use this register to indicate System Address of data location instead of using SDMA System Address register [Offset 003-000h]. SDMA can be used in 32-bit and 64-bit addressing in Version 4.00. 							ADMA2 					This register holds byte address of executing command of the Descriptor table. At the start of ADMA2, the Host Driver shall set start address of the Descriptor table. The ADMA increments this register address, which points to next line, when every fetching a Descriptor line. When the ADMA Error Interrupt is generated, this register shall hold the Descriptor address depending on the ADMA state. 							ADMA3 					This register is set by ADMA3. Host Driver is not necessary to set this register. The ADMA3 increments address of this register,which points to next line, when every time fetching a Descriptor line. When Error Interrupt is generated, this register shall hold the Descriptor address depending on the ADMA state. 							Register Value - 00000000_xxxxxxxxh 						 	Addressing Mode - 32-bit System Address 						 	Register Value - xxxxxxxx_xxxxxxxxh 							Addressing Mode - 64-bit System Address 						" range="63 - 0" rwaccess="R/W"/>
	</register>
	<register id="SDHC_WRAP__CTL_CFG__CTLCFG_preset_value0" acronym="SDHC_WRAP__CTL_CFG__CTLCFG_preset_value0" offset="0x60" width="16" description="
					This register is used to read the SDCLK Frequency Select Value,Clock Generator Select Value,Driver Strength Select Value 
					">
		<bitfield id="DRIVER_STRENGTH_SEL" width="2" begin="15" end="14" resetval="0x0" description="Driver Strength is supported by 1.8V signaling bus speed modes. This field is meaningless for 3.3V signaling. 						" range="15 - 14" rwaccess="R"/> 
		<bitfield id="CLOCK_GENSEL" width="1" begin="10" end="10" resetval="0x0" description=" 						This bit is effective when Host Controller supports programmable clock 						'0'  Host Controller Ver2.00 Compatible Clock Generator 						'1' Programmable Clock Generator 						" range="10" rwaccess="R"/> 
		<bitfield id="SDCLK_FRQSEL" width="10" begin="9" end="0" resetval="0x256" description=" 						10-bit preset value to set SDCLK Frequency Select in the Clock Control Register is described by a host system. 						" range="9 - 0" rwaccess="R"/>
	</register>
	<register id="SDHC_WRAP__CTL_CFG__CTLCFG_preset_value1" acronym="SDHC_WRAP__CTL_CFG__CTLCFG_preset_value1" offset="0x62" width="16" description="
					This register is used to read the SDCLK Frequency Select Value,Clock Generator Select Value,Driver Strength Select Value 
					">
		<bitfield id="DRIVER_STRENGTH_SEL" width="2" begin="15" end="14" resetval="0x0" description="Driver Strength is supported by 1.8V signaling bus speed modes. This field is meaningless for 3.3V signaling. 						" range="15 - 14" rwaccess="R"/> 
		<bitfield id="CLOCK_GENSEL" width="1" begin="10" end="10" resetval="0x0" description=" 						This bit is effective when Host Controller supports programmable clock 						'0'  Host Controller Ver2.00 Compatible Clock Generator 						'1' Programmable Clock Generator 						" range="10" rwaccess="R"/> 
		<bitfield id="SDCLK_FRQSEL" width="10" begin="9" end="0" resetval="0x4" description=" 						10-bit preset value to set SDCLK Frequency Select in the Clock Control Register is described by a host system. 						" range="9 - 0" rwaccess="R"/>
	</register>
	<register id="SDHC_WRAP__CTL_CFG__CTLCFG_preset_value2" acronym="SDHC_WRAP__CTL_CFG__CTLCFG_preset_value2" offset="0x64" width="16" description="
					This register is used to read the SDCLK Frequency Select Value,Clock Generator Select Value,Driver Strength Select Value
					">
		<bitfield id="DRIVER_STRENGTH_SEL" width="2" begin="15" end="14" resetval="0x0" description="Driver Strength is supported by 1.8V signaling bus speed modes. This field is meaningless for 3.3V signaling. 						" range="15 - 14" rwaccess="R"/> 
		<bitfield id="CLOCK_GENSEL" width="1" begin="10" end="10" resetval="0x0" description=" 						This bit is effective when Host Controller supports programmable clock 						'0'  Host Controller Ver2.00 Compatible Clock Generator 						'1' Programmable Clock Generator 						" range="10" rwaccess="R"/> 
		<bitfield id="SDCLK_FRQSEL" width="10" begin="9" end="0" resetval="0x2" description=" 						10-bit preset value to set SDCLK Frequency Select in the Clock Control Register is described by a host system. 						" range="9 - 0" rwaccess="R"/>
	</register>
	<register id="SDHC_WRAP__CTL_CFG__CTLCFG_preset_value3" acronym="SDHC_WRAP__CTL_CFG__CTLCFG_preset_value3" offset="0x66" width="16" description="
					This register is used to read the SDCLK Frequency Select Value,Clock Generator Select Value,Driver Strength Select Value
					">
		<bitfield id="DRIVER_STRENGTH_SEL" width="2" begin="15" end="14" resetval="0x0" description="Driver Strength is supported by 1.8V signaling bus speed modes. This field is meaningless for 3.3V signaling. 						" range="15 - 14" rwaccess="R"/> 
		<bitfield id="CLOCK_GENSEL" width="1" begin="10" end="10" resetval="0x0" description=" 						This bit is effective when Host Controller supports programmable clock 						'0'  Host Controller Ver2.00 Compatible Clock Generator 						'1' Programmable Clock Generator 						" range="10" rwaccess="R"/> 
		<bitfield id="SDCLK_FRQSEL" width="10" begin="9" end="0" resetval="0x4" description=" 						10-bit preset value to set SDCLK Frequency Select in the Clock Control Register is described by a host system. 						" range="9 - 0" rwaccess="R"/>
	</register>
	<register id="SDHC_WRAP__CTL_CFG__CTLCFG_preset_value4" acronym="SDHC_WRAP__CTL_CFG__CTLCFG_preset_value4" offset="0x68" width="16" description="
					This register is used to read the SDCLK Frequency Select Value,Clock Generator Select Value,Driver Strength Select Value
					">
		<bitfield id="DRIVER_STRENGTH_SEL" width="2" begin="15" end="14" resetval="0x0" description="Driver Strength is supported by 1.8V signaling bus speed modes. This field is meaningless for 3.3V signaling. 						" range="15 - 14" rwaccess="R"/> 
		<bitfield id="CLOCK_GENSEL" width="1" begin="10" end="10" resetval="0x0" description=" 						This bit is effective when Host Controller supports programmable clock 						'0'  Host Controller Ver2.00 Compatible Clock Generator 						'1' Programmable Clock Generator 						" range="10" rwaccess="R"/> 
		<bitfield id="SDCLK_FRQSEL" width="10" begin="9" end="0" resetval="0x2" description=" 						10-bit preset value to set SDCLK Frequency Select in the Clock Control Register is described by a host system. 						" range="9 - 0" rwaccess="R"/>
	</register>
	<register id="SDHC_WRAP__CTL_CFG__CTLCFG_preset_value5" acronym="SDHC_WRAP__CTL_CFG__CTLCFG_preset_value5" offset="0x6A" width="16" description="
					This register is used to read the SDCLK Frequency Select Value,Clock Generator Select Value,Driver Strength Select Value
					">
		<bitfield id="DRIVER_STRENGTH_SEL" width="2" begin="15" end="14" resetval="0x0" description="Driver Strength is supported by 1.8V signaling bus speed modes. This field is meaningless for 3.3V signaling. 						" range="15 - 14" rwaccess="R"/> 
		<bitfield id="CLOCK_GENSEL" width="1" begin="10" end="10" resetval="0x0" description=" 						This bit is effective when Host Controller supports programmable clock 						'0'  Host Controller Ver2.00 Compatible Clock Generator 						'1' Programmable Clock Generator 						" range="10" rwaccess="R"/> 
		<bitfield id="SDCLK_FRQSEL" width="10" begin="9" end="0" resetval="0x1" description=" 						10-bit preset value to set SDCLK Frequency Select in the Clock Control Register is described by a host system. 						" range="9 - 0" rwaccess="R"/>
	</register>
	<register id="SDHC_WRAP__CTL_CFG__CTLCFG_preset_value6" acronym="SDHC_WRAP__CTL_CFG__CTLCFG_preset_value6" offset="0x6C" width="16" description="
					This register is used to read the SDCLK Frequency Select Value,Clock Generator Select Value,Driver Strength Select Value
					">
		<bitfield id="DRIVER_STRENGTH_SEL" width="2" begin="15" end="14" resetval="0x0" description="Driver Strength is supported by 1.8V signaling bus speed modes. This field is meaningless for 3.3V signaling. 						" range="15 - 14" rwaccess="R"/> 
		<bitfield id="CLOCK_GENSEL" width="1" begin="10" end="10" resetval="0x0" description=" 						This bit is effective when Host Controller supports programmable clock 						'0'  Host Controller Ver2.00 Compatible Clock Generator 						'1' Programmable Clock Generator 						" range="10" rwaccess="R"/> 
		<bitfield id="SDCLK_FRQSEL" width="10" begin="9" end="0" resetval="0x0" description=" 						10-bit preset value to set SDCLK Frequency Select in the Clock Control Register is described by a host system. 						" range="9 - 0" rwaccess="R"/>
	</register>
	<register id="SDHC_WRAP__CTL_CFG__CTLCFG_preset_value7" acronym="SDHC_WRAP__CTL_CFG__CTLCFG_preset_value7" offset="0x6E" width="16" description="
					This register is used to read the SDCLK Frequency Select Value,Clock Generator Select Value,Driver Strength Select Value
					">
		<bitfield id="DRIVER_STRENGTH_SEL" width="2" begin="15" end="14" resetval="0x0" description="Driver Strength is supported by 1.8V signaling bus speed modes. This field is meaningless for 3.3V signaling. 						" range="15 - 14" rwaccess="R"/> 
		<bitfield id="CLOCK_GENSEL" width="1" begin="10" end="10" resetval="0x0" description=" 						This bit is effective when Host Controller supports programmable clock 						'0'  Host Controller Ver2.00 Compatible Clock Generator 						'1' Programmable Clock Generator 						" range="10" rwaccess="R"/> 
		<bitfield id="SDCLK_FRQSEL" width="10" begin="9" end="0" resetval="0x2" description=" 						10-bit preset value to set SDCLK Frequency Select in the Clock Control Register is described by a host system. 						" range="9 - 0" rwaccess="R"/>
	</register>
	<register id="SDHC_WRAP__CTL_CFG__CTLCFG_preset_value8" acronym="SDHC_WRAP__CTL_CFG__CTLCFG_preset_value8" offset="0x72" width="16" description="
					This register is used to read the SDCLK Frequency Select Value,Clock Generator Select Value,Driver Strength Select Value
					">
		<bitfield id="DRIVER_STRENGTH_SEL" width="2" begin="15" end="14" resetval="0x0" description="Driver Strength is supported by 1.8V signaling bus speed modes. This field is meaningless for 3.3V signaling. 						" range="15 - 14" rwaccess="R"/> 
		<bitfield id="CLOCK_GENSEL" width="1" begin="10" end="10" resetval="0x0" description=" 						This bit is effective when Host Controller supports programmable clock 						'0'  Host Controller Ver2.00 Compatible Clock Generator 						'1' Programmable Clock Generator 						" range="10" rwaccess="R"/> 
		<bitfield id="SDCLK_FRQSEL" width="10" begin="9" end="0" resetval="0x0" description=" 						10-bit preset value to set SDCLK Frequency Select in the Clock Control Register is described by a host system. 						" range="9 - 0" rwaccess="R"/>
	</register>
	<register id="SDHC_WRAP__CTL_CFG__CTLCFG_preset_value10" acronym="SDHC_WRAP__CTL_CFG__CTLCFG_preset_value10" offset="0x74" width="16" description="
					This register is used to read the SDCLK Frequency Select Value,Clock Generator Select Value,Driver Strength Select Value
					">
		<bitfield id="DRIVER_STRENGTH_SEL" width="2" begin="15" end="14" resetval="0x0" description="Driver Strength is supported by 1.8V signaling bus speed modes. This field is meaningless for 3.3V signaling. 						" range="15 - 14" rwaccess="R"/> 
		<bitfield id="CLOCK_GENSEL" width="1" begin="10" end="10" resetval="0x0" description=" 						This bit is effective when Host Controller supports programmable clock 						'0'  Host Controller Ver2.00 Compatible Clock Generator 						'1' Programmable Clock Generator 						" range="10" rwaccess="R"/> 
		<bitfield id="SDCLK_FRQSEL" width="10" begin="9" end="0" resetval="0x0" description=" 						10-bit preset value to set SDCLK Frequency Select in the Clock Control Register is described by a host system. 						" range="9 - 0" rwaccess="R"/>
	</register>
	<register id="SDHC_WRAP__CTL_CFG__CTLCFG_adma3_desc_address" acronym="SDHC_WRAP__CTL_CFG__CTLCFG_adma3_desc_address" offset="0x78" width="64" description="The start address of Integrated DMA Descriptor is set to this register.">
		<bitfield id="INTG_DESC_ADDR" width="64" begin="63" end="0" resetval="0x0" description=" 						The start address of Integrated DMA Descriptor is set to this register. Writing to a specific address starts ADMA3 depends on 32-bit/64-bit address-ing. The ADMA3 fetches one Descriptor Address and increments this field to indicate the next Descriptor address. 						The 32-bit addressing Host Driver uses lower 32- bit of this register and shall 						program Descriptor Table on 32-bit boundary.ADMA3 ignores lower 2-bit of this register and assumes it to be 00b. Writing to 07Bh starts ADMA3 data transfer. 						The 64-bit addressing Host Driver uses all 64-bit of this register and shall program Descriptor Table on 64-bit boundary. ADMA3 ignores lower 3-bit of this register and assumes it to be 000b. Writing to 07Fh starts ADMA3 data transfer. 						Register Value- 00000000_xxxxxxxxh Addressing Mode - 32-bit System Address 						Register Value - xxxxxxxx_xxxxxxxxh Addressing Mode - 64-bit System Address 						" range="63 - 0" rwaccess="R/W"/>
	</register>
	<register id="SDHC_WRAP__CTL_CFG__CTLCFG_uhs2_block_size" acronym="SDHC_WRAP__CTL_CFG__CTLCFG_uhs2_block_size" offset="0x80" width="16" description="This register is used to configure the number of bytes in a data block">
		<bitfield id="SDMA_BUF_BOUNDARY" width="3" begin="14" end="12" resetval="0x0" description=" 							When system memory is managed by paging, SDMA data transfer is performed in unit of paging. A page size of sys-tem memory management is set to this field. 							Host Controller generates the DMA Interrupt at the page boundary and requests the Host Driver to update the ADMA System Address register. SDMA waits until the ADMA System Address register is written. 							At the end of transfer, the Host Controller may issue or may not issue DMA Interrupt. In particular, DMA Interrupt shall not be issued after Transfer Complete Interrupt is issued. 							These bits shall be supported when the SDMA Support in the Capabilities register is set to 1 and this function is active when the DMA Enable in the UHS-II Transfer Mode register is set to 1. ADMA does not use this field. 						" range="14 - 12" rwaccess="R/W"/> 
		<bitfield id="XFER_BLK_SIZE" width="12" begin="11" end="0" resetval="0x0" description="This register specifies the block size of data packet. SD Memory Card uses a fixed block size of 512 bytes. Vari-able block size may be used for SDIO. The maximum value is 2048 Bytes because CRC16 covers up to 2048 bytes. This register is effective when Data Present is set to 1 in UHS-II Command register. 	    " range="11 - 0" rwaccess="R/W"/>
	</register>
	<register id="SDHC_WRAP__CTL_CFG__CTLCFG_uhs2_block_count" acronym="SDHC_WRAP__CTL_CFG__CTLCFG_uhs2_block_count" offset="0x84" width="32" description="This register is used to configure the number of data blocks">
		<bitfield id="XFER_BLK_COUNT" width="32" begin="31" end="0" resetval="0x0" description=" 						This register is effective when Data Present is set to 1 in UHS-II Command register and is enabled when Block Count Enable is set to 1 and Block / Byte Mode is set to 0 in the UHS-II Transfer Mode register. Data transfer stops when the count reaches zero. Setting the block count to 0 results in no data blocks is transferred. 						This register should be accessed only when no transaction is executing [i.e.,after transactions are stopped]. During data transfer, read operations on this register may return an invalid   value and write operations are ignored. 								00000000h - Stop Count 								00000001h - 1 block 								00000002h - 2 blocks 								..... ..... 								FFFFFFFFh - 4G blocks -1. 						" range="31 - 0" rwaccess="R/W"/>
	</register>
	<register id="SDHC_WRAP__CTL_CFG__CTLCFG_uhs2_command_pkt" acronym="SDHC_WRAP__CTL_CFG__CTLCFG_uhs2_command_pkt" offset="0x88" width="8" description="UHS-II Command Packet image is set to this register. The maximum length is 20 bytes. The command length varies depends on a Command Packet type. The length is specified by the UHS-II Command register.
					">
		<bitfield id="CMD_PKT_BYTE" width="8" begin="7" end="0" resetval="0x0" description="UHS-II Command Packet image is set to this register.The command length varies depends on a Command Packet type. 						" range="7 - 0" rwaccess="R/W"/>
	</register>
	<register id="SDHC_WRAP__CTL_CFG__CTLCFG_uhs2_xfer_mode" acronym="SDHC_WRAP__CTL_CFG__CTLCFG_uhs2_xfer_mode" offset="0x9C" width="16" description="This register is used to control the operations of data transfers">
		<bitfield id="DUPLEX_SELECT" width="1" begin="15" end="15" resetval="0x0" description=" 						Use of 2 lane half duplex mode is determined by Host Driver. 						" range="15" rwaccess="R/W"/> 
		<bitfield id="EBSY_WAIT" width="1" begin="14" end="14" resetval="0x0" description=" 									This bit is set when issuing a command which is accompanied by EBSY packet to indicate end of command execution. Busy is expected for CCMD with R1b/R5b type and DCMD with data transfer.If this bit is set to 1, Host Controller waits receiving of EBSY packet and on receiving EBSY packet, Transfer Com-plete in the Normal Interrupt Status reg-ister is set to 1 to indicate end ofbusy. If an error is indicated in EBSY packet [ex. Memory Error], EBSY Error in the UHS-II Error Interrupt Status register is set to 1. Setting of EBSY Error also sets Error Interrupt to 1 in the Normal Inter-rupt Status register. Error Interrupt and Transfer Complete shall be set together. 						'1' Wait EBSY, 						'0' Issue a command without busy. 						" range="14" rwaccess="R/W"/> 
		<bitfield id="RESP_INTR_DIS" width="1" begin="8" end="8" resetval="0x0" description=" 							Host Controller Version 4.00 supports response error check function to avoid overhead of response error check by Host Driver. Only R1 or R5 can be checked. 							If Host Driver checks response error, sets this bit to 0 and waits Command Complete Interrupt and then check the response register. If Host Controller checks response error, sets this bit to 1 and sets Response Error Check Enable to 1. Command Complete Interrupt is disabled by this bit regardless of Com-mand Complete Signal Enable. 						" range="8" rwaccess="R/W"/> 
		<bitfield id="RESP_ERR_CHK_ENA" width="1" begin="7" end="7" resetval="0x0" description=" 						Host Controller Version 4.00 supports response error check function to avoid overhead of response error check by Host Driver.Only R1 or R5 can be checked. 						If Host Driver checks response error, this bit is set to 0 and Response Inter-rupt Disable is set to 0. If Host Control-ler checks response error, sets this bit to 1 and sets Response Interrupt Dis-able to 1. Response Type R1 / R5 selects either R1 or R5 response type. If an error is detected, RES Packet Error Interrupt is generated in the UHS-II Error Interrupt Status register. 						" range="7" rwaccess="R/W"/> 
		<bitfield id="RESP_TYPE" width="1" begin="6" end="6" resetval="0x0" description=" 								When response error check is enabled, this bit selects either R1 or R5 response 								types. Two types of response checks are supported: R1 for memory and R5 for SDIO. 								Error Statuses Checked in R1 									 Bit31 OUT_OF_RANGE 									 Bit30 ADDRESS_ERROR 									 Bit29 BLOCK_LEN_ERROR 									 Bit26 WP_VIOLATION 									 Bit25 CARD_IS_LOCKED 									 Bit23 COM_CRC_ERROR 									 Bit21 CARD_ECC_FAILED 									 Bit20 CC_ERROR 									 Bit19 ERROR 								Response Flags Checked in R5 									.Bit07 COM_CRC_ERROR 									.Bit03 ERROR 									.Bit01 FUNCTION_NUMBER 									.Bit00 OUT_OF_RANGE 						" range="6" rwaccess="R/W"/> 
		<bitfield id="BYTE_MODE" width="1" begin="5" end="5" resetval="0x0" description=" 						This bit specifies whether data transfer is in byte mode or block mode when Data Present is set to 1. This bit is effective to a command with data trans-fer. 						" range="5" rwaccess="R/W"/> 
		<bitfield id="DATA_XFER_DIR" width="1" begin="4" end="4" resetval="0x0" description=" 							This bit specifies direction of data trans-fer when Data Present is set to 1. This bit is effective to a command with data transfer.  								0 - Read [Card to Host] 								1 - Write [Host to Card] 						" range="4" rwaccess="R/W"/> 
		<bitfield id="BLK_CNT_ENA" width="1" begin="1" end="1" resetval="0x0" description=" 						This bit specifies whether data transfer usesUHS-II Block Count register. If this bit is set to 1, data transfer is terminated by Block Count. Setting to UHS-II Block Count register shall  be equivalent to TLEN in UHS-II Command Packet reg-ister. 						" range="1" rwaccess="R/W"/> 
		<bitfield id="DMA_ENA" width="1" begin="0" end="0" resetval="0x0" description="This bit selects whether DMA is used or not and is effective to a command with data transfer. One of DMA types is selected by DMA Select in the Host Control 1 register. 						" range="0" rwaccess="R/W"/>
	</register>
	<register id="SDHC_WRAP__CTL_CFG__CTLCFG_uhs2_command" acronym="SDHC_WRAP__CTL_CFG__CTLCFG_uhs2_command" offset="0x9E" width="16" description="This register is used to program the Command for host controller">
		<bitfield id="PKT_LENGTH" width="5" begin="12" end="8" resetval="0x0" description="A command packet length, which is set in the UHS-II Command Packet register, is set to this register. 								        00011b - 00000b - 3-0 Bytes [Not used] 									00100b - 4 Bytes 									.......... ...... 									10100b - 20 Bytes 									11111b  10101b 						" range="12 - 8" rwaccess="R/W"/> 
		<bitfield id="CMD_TYPE" width="2" begin="7" end="6" resetval="0x0" description=" 						     This field is used to distinguish a spe-cific command like abort command. If this field is set to 00b, the UHS-II RES Packet is stored in UHS-II Response register [0B3h-0A0h]. To avoid overwrit-ing the UHS-II Response register, when this filed is set to 01b, the RES Packet [4 bytes length] of TRANS_ABORT CCMD is stored in the Response regis-ter [013h-010h] and when this filed is set to 10b, the RES Packet [8 bytes length] of memory or SDIO abort com-mand [CMD12 or SDIO Abort com-mand] is stored in the Response register [01Fh-018h]. When this filed is set to 11b, Host Controller controls lane to go into dormant state. 						'00' Normal Command 						'01' TRANS_ABORT CCMD 						'10' CMD12 or SDIO Abort Command 						'11' Go Dormant Command 						" range="7 - 6" rwaccess="R/W"/> 
		<bitfield id="DATA_PRESENT" width="1" begin="5" end="5" resetval="0x0" description="This bit specifies whether the command is accompanied by data packet. 						" range="5" rwaccess="R/W"/> 
		<bitfield id="SUB_COMMAND" width="1" begin="2" end="2" resetval="0x0" description="This bit is added from Version 4.10 to distinguish a main command or sub command [Refer to Section 1.17].When issuing a main command, this bit is set to 0 and when issuing a sub com-mand, this bit is set to 1. Setting of this bit is checked by Sub Command Status in the Present State register. 						" range="2" rwaccess="R/W"/>
	</register>
	<register id="SDHC_WRAP__CTL_CFG__CTLCFG_uhs2_response" acronym="SDHC_WRAP__CTL_CFG__CTLCFG_uhs2_response" offset="0xA0" width="8" description="This register is used to store received UHS-II RES Packet image">
		<bitfield id="RESP_PKT_BYTE" width="8" begin="7" end="0" resetval="0x0" description=" 						Host Controller saves received UHS-II RES Packet image to this register except the response of an abort command. 						" range="7 - 0" rwaccess="R"/>
	</register>
	<register id="SDHC_WRAP__CTL_CFG__CTLCFG_uhs2_message_select" acronym="SDHC_WRAP__CTL_CFG__CTLCFG_uhs2_message_select" offset="0xB4" width="8" description="This register is used to access internal buffer">
		<bitfield id="MSG_SEL" width="2" begin="1" end="0" resetval="0x0" description=" 						Host Controller holds 4 MSG packets in FIFO buffer.One of 4 MSGs can be read from the UHS-II MSG register [0BB-0B8h] by setting this register.[Assumed for debug usage.] 						'00' The latest MSG 						'01' One MSG before 						'10' Two MSGs before 						'11' Three MSGs before 						" range="1 - 0" rwaccess="R/W"/>
	</register>
	<register id="SDHC_WRAP__CTL_CFG__CTLCFG_uhs2_message" acronym="SDHC_WRAP__CTL_CFG__CTLCFG_uhs2_message" offset="0xB8" width="32" description="This register is used to access internal buffer">
		<bitfield id="MSG_BYTE3" width="8" begin="31" end="24" resetval="0x0" description=" 						  Host Controller holds 4 MSG packets in FIFO buffer. One of 4 MSGs [length is 4 bytes] can be read fromthis register by setting UHS-II MSG Select register. Usually 2 duplicate MSG packets are sent from/toUHS-II card. One of these 2 MSG packets which Host Controller recognizes as valid one is stored in theUHS-II MSG Register. 						" range="31 - 24" rwaccess="R"/> 
		<bitfield id="MSG_BYTE2" width="8" begin="23" end="16" resetval="0x0" description=" 						 Host Controller holds 4 MSG packets in FIFO buffer. One of 4 MSGs [length is 4 bytes] can be read fromthis register by setting UHS-II MSG Select register. Usually 2 duplicate MSG packets are sent from/toUHS-II card. One of these 2 MSG packets which Host Controller recognizes as valid one is stored in theUHS-II MSG Register. 						" range="23 - 16" rwaccess="R"/> 
		<bitfield id="MSG_BYTE1" width="8" begin="15" end="8" resetval="0x0" description=" 						 Host Controller holds 4 MSG packets in FIFO buffer. One of 4 MSGs [length is 4 bytes] can be read fromthis register by setting UHS-II MSG Select register. Usually 2 duplicate MSG packets are sent from/toUHS-II card. One of these 2 MSG packets which Host Controller recognizes as valid one is stored in theUHS-II MSG Register. 						" range="15 - 8" rwaccess="R"/> 
		<bitfield id="MSG_BYTE0" width="8" begin="7" end="0" resetval="0x0" description=" 						 Host Controller holds 4 MSG packets in FIFO buffer. One of 4 MSGs [length is 4 bytes] can be read fromthis register by setting UHS-II MSG Select register. Usually 2 duplicate MSG packets are sent from/toUHS-II card. One of these 2 MSG packets which Host Controller recognizes as valid one is stored in theUHS-II MSG Register. 						" range="7 - 0" rwaccess="R"/>
	</register>
	<register id="SDHC_WRAP__CTL_CFG__CTLCFG_uhs2_device_intr_status" acronym="SDHC_WRAP__CTL_CFG__CTLCFG_uhs2_device_intr_status" offset="0xBC" width="16" description="This register shows receipt of INT MSG from which device
					">
		<bitfield id="DEV_INT_STS" width="16" begin="15" end="0" resetval="0x0" description="This register shows receipt of INT MSG from which device and is effective when INT MSG Enable is set to 1 in the UHS- II Device Select register. On receiving INT MSG from a device, Host Controller saves the INT MSG to UHS-II Device Interrupt Code register. A bit of this register, which is corre- spondent to Device ID, is set to 1 and generate Card Interrupt in Normal Interrupt Status register. 							Writing a bit to 1 clears the status bit [interrupt is treated] and writing a bit to 0 keeps the status value [interrupt is untreated]. If INT MSG Enable is set to 0, this register is cleared to 0 and Host Controller ignores receipt of INT MSG. 							Effective bit range of this register is determined by Number of Devices Supported in the UHS-II General Capabilities regis-ter. If N devices are supported, bits 1 to N are          effective. Then Device ID is supposed to be assigned from 1 sequentially at the UHS-II Initialization. A bit of unsupported Device ID in this register shall be indicated to 0. 							D00 - Not used [Reserved] 							D01 - Setting 1 means INT MSG is received from Device ID 1 							D02 - Setting 1 means INT MSG is received from Device ID 2 							.... ..... 							D15 - Setting 1 means INT MSG is received from Device ID 15 						" range="15 - 0" rwaccess="R/W1TC"/>
	</register>
	<register id="SDHC_WRAP__CTL_CFG__CTLCFG_uhs2_device_select" acronym="SDHC_WRAP__CTL_CFG__CTLCFG_uhs2_device_select" offset="0xBE" width="8" description="UHS-II Device Select Register
					">
		<bitfield id="INT_MSG_ENA" width="1" begin="7" end="7" resetval="0x0" description="  							This bit enables receipt of INT MSG. If this bit is set to 1,receipt of INT MSG is informed by Card Interrupt in the Nor-mal Interrupt Status register. If this bit is set to 0, Host Con-troller ignores receipt of INT MSG and may not set the UHS-II Device Interrupt Code register. 							Support of INT MSG Interrupt is optional. If trying to set this bit to 1 but still this bit is read 0, INT MSG Interrupt is not sup-ported by the Host Controller. In this case, UHS-II Device Interrupt Status register always shall be read 0 and UHS-II Device Interrupt Code register may not be implemented. 						'0' Disabled 						'1' Enabled 						" range="7" rwaccess="R/W"/> 
		<bitfield id="DEV_SEL" width="4" begin="3" end="0" resetval="0x0" description="Host Controller holds an INT MSG packet per device. One of INT MSGs [up to 15] can be selected by this field and read from the UHS-II Device Interrupt Code Register     [0BFh]. This field is effective when INT MSG Enable is set to 1. 						The number of devices implemented in the Host Controller is indicated by Number of Devices supported in the UHS-II General Capabilities register. 						0h Unselected [Default] 						1h INT MSG of Device ID 1 is selected 						2h INT MSG of Device ID 2 is selected 						..... ..... 						Fh INT MSG of Device ID 15 is selected 						" range="3 - 0" rwaccess="R/W"/>
	</register>
	<register id="SDHC_WRAP__CTL_CFG__CTLCFG_uhs2_device_int_code" acronym="SDHC_WRAP__CTL_CFG__CTLCFG_uhs2_device_int_code" offset="0xBF" width="8" description="This register is effective when INT MSG Enable is set to 1 in the UHS-II Device Select register.
					">
		<bitfield id="DEV_INTR" width="8" begin="7" end="0" resetval="0x0" description="This register is effective when INT MSG Enable is set to 1 in the UHS-II Device Select register. Host Controller holds an INT MSG packet per device. One of INT MSGs     [Code length is 1 byte] up to 15 can be read from this register by select-ing UHS-II Device Select. The number of the registers to hold INT MSGs is determined by Number of Devices Sup-ported in the UHS-II General Capabili-ties register. Device ID is supposed to be assigned from 1 sequentially at the UHS-II Initialization. 						" range="7 - 0" rwaccess="R"/>
	</register>
	<register id="SDHC_WRAP__CTL_CFG__CTLCFG_uhs2_software_reset" acronym="SDHC_WRAP__CTL_CFG__CTLCFG_uhs2_software_reset" offset="0xC0" width="16" description="UHS-II Software Reset Register
					">
		<bitfield id="HOST_SDTRAN_RESET" width="1" begin="1" end="1" resetval="0x0" description="Host Driver set this bit to 1 to reset SD-TRAN layer when CMD0 is issued to Device or data transfer error occurs. This bit is cleared automatically at completionof SD-TRAN reset. If CMD0 is issued, SD-TRAN Initial- ization sequence from CMD8 is required to use UHS-II mode. Assuming that bus power is maintained and CM-TRAN Initialization is not required. 								'0' Not Affected 								'1' Reset SD TRAN 								Host Controller requires to do followings: 									[1] SD Clock Enable is maintained.[Continue to provide RCLK]. 									[2] All setting register is maintained. 									[3] Internal sequencers are reset to just after power on.be able to issue a command. 									[4] All Interrupt Status, Status Enable and Signal Enable are cleared. 									[5] Data transfer is terminated and data in buffer is dis-carded. 						" range="1" rwaccess="R/W"/> 
		<bitfield id="HOST_FULL_RESET" width="1" begin="0" end="0" resetval="0x0" description="On issuing FULL_RESET CCMD, Host Driver set this bit to 1 to reset Host Controller. This bit is cleared auto-matically at completion of Host Controller reset. Initial- ization sequence from PHY Initialization is required to use UHS-II mode. Assuming that bus power is maintained. 							Host Controller requires to do followings: 								[1] SD Clock Enable is cleared. [Internal Clock is still synchronized]. 								[2] All setting register is cleared. 								[3] Internal sequencers are reset to just after power on. 								[4] All Interrupt Status, Status Enable and Signal Enable are cleared. 						" range="0" rwaccess="R/W"/>
	</register>
	<register id="SDHC_WRAP__CTL_CFG__CTLCFG_uhs2_timer_control" acronym="SDHC_WRAP__CTL_CFG__CTLCFG_uhs2_timer_control" offset="0xC2" width="16" description="UHS-II Timeout Control Register">
		<bitfield id="DEADLOCK_TIMEOUT_CTR" width="4" begin="7" end="4" resetval="0x0" description=" 						This value determines the deadlock period while host expecting to receive a packet [1 second]. Tim-eout clock frequency will be generated by dividing the base clock TMCLK value by this value. When setting this register, prevent inadvertent timeout events by clearing the Timeout for Deadlock [in the UHS-II Error Interrupt Status Enable register] 								1111b Reserved 								1110b TMCLK x 2^27 								.............. .................. 								0001b TMCLK x 2^14 								0000b TMCLK x 2^13 						" range="7 - 4" rwaccess="R/W"/> 
		<bitfield id="CMDRESP_TIMEOUT_CTR" width="4" begin="3" end="0" resetval="0x0" description=" 						This value determines the interval between com-mand packet and response packet [5ms]. Timeout clock frequency will be generated by dividing the base clock TMCLK value by this value. When   set-ting this register, prevent inadvertent timeout events by clearing the Timeout for CMD_RES [in the UHS-II Error Interrupt Status Enable register] 								1111b Reserved 								1110b TMCLK x 2^27 								.............. .................. 								0001b TMCLK x 2^14 								0000b TMCLK x 2^13 						" range="3 - 0" rwaccess="R/W"/>
	</register>
	<register id="SDHC_WRAP__CTL_CFG__CTLCFG_uhs2_err_intr_sts" acronym="SDHC_WRAP__CTL_CFG__CTLCFG_uhs2_err_intr_sts" offset="0xC4" width="32" description="This register gives the status of all UHS-II interrupts">
		<bitfield id="VENDOR_SPECFIC_ERR" width="5" begin="31" end="27" resetval="0x0" description="  						Vendor may use this field for vendor specific error status. 						'0' Interrupt is not generated 						'1' Vendor Specific Error 						" range="31 - 27" rwaccess="R/W1TC"/> 
		<bitfield id="DEADLOCK_TIMEOUT" width="1" begin="17" end="17" resetval="0x0" description="  						Setting of this bit means that deadlock timeout occurs. Host expects to receive a packet but not received in a specified timeout [1 second]. Timeout value is determined by the setting of Timeout Counter Value for Deadlock in UHS-II Timer Control register. 						" range="17" rwaccess="R/W1TC"/> 
		<bitfield id="CMD_RESP_TIMEOUT" width="1" begin="16" end="16" resetval="0x0" description="  							Setting of this bit means that RES Packet timeout occurs. Host expects to receive RES packet but not received in a specified timeout [5ms]. Timeout value is determined by the setting of Timeout Counter Value for CMD_RES in UHS-II Timer Control register. 						" range="16" rwaccess="R/W1TC"/> 
		<bitfield id="ADMA2_ADMA3" width="1" begin="15" end="15" resetval="0x0" description="  							Setting of this bit means that ADMA2/3 Error occurs in UHS-II mode. ADMA2/3 Error Status is indicated to the ADMA Error Status [054h], which is defined in the Host spec 3.00. 						" range="15" rwaccess="R/W1TC"/> 
		<bitfield id="EBSY" width="1" begin="8" end="8" resetval="0x0" description="  						On receiving EBSY packet, if the packet indicates an error, this bit is set to 1. Setting of this bit also sets Error Interrupt and Transfer Completer together in the Normal Interrupt Status register. This error check is effective for a command with setting EBSY Wait in the UHS-II Transfer Mode register. 						" range="8" rwaccess="R/W1TC"/> 
		<bitfield id="UNRECOVERABLE" width="1" begin="7" end="7" resetval="0x0" description="  						Setting of this bit means that Unrecoverable Error is set in a packet from a device. 						" range="7" rwaccess="R/W1TC"/> 
		<bitfield id="TID" width="1" begin="5" end="5" resetval="0x0" description="  						Setting of this bit means that TID Error occurs. 						" range="5" rwaccess="R/W1TC"/> 
		<bitfield id="FRAMING" width="1" begin="4" end="4" resetval="0x0" description="  						Setting of this bit means that Framing Error occurs during a packet receiving. 						" range="4" rwaccess="R/W1TC"/> 
		<bitfield id="CRC" width="1" begin="3" end="3" resetval="0x0" description="  						Setting of this bit means that CRC Error occurs during a packet receiving. 						" range="3" rwaccess="R/W1TC"/> 
		<bitfield id="RETRY_EXPIRED" width="1" begin="2" end="2" resetval="0x0" description="  						Setting of this bit means that Retry Counter Expired Error occurs during data transfer.If this bit is set,either Framing Error or CRC Error in this register shall be set. 						" range="2" rwaccess="R/W1TC"/> 
		<bitfield id="RESP_PKT" width="1" begin="1" end="1" resetval="0x0" description="  							Host Controller Version 4.00 supports response error check function to avoid overhead of response error check by Host Driver during DMA execution. If Response Error Check Enable is set to1 in the UHS- II Transfer Mode register, Host Controller Checks R1 or R5 response. If an error is detected in a response,this bit is set to 1. 						" range="1" rwaccess="R/W1TC"/> 
		<bitfield id="HEADER" width="1" begin="0" end="0" resetval="0x0" description="  						Setting of this bit means that Header Error occurs in a received packet. 						" range="0" rwaccess="R/W1TC"/>
	</register>
	<register id="SDHC_WRAP__CTL_CFG__CTLCFG_uhs2_err_intr_sts_ena" acronym="SDHC_WRAP__CTL_CFG__CTLCFG_uhs2_err_intr_sts_ena" offset="0xC8" width="32" description="This register is used to enable the UHS-II Error Interrupt Status register fields">
		<bitfield id="VENDOR_SPECFIC" width="5" begin="31" end="27" resetval="0x0" description="  								Setting this bit to 1 enables setting of Vendor Specific Error bit in the UHS-II Error Interrupt Status register. 										0h - Status is Disabled 										1h - Status is Enabled 						" range="31 - 27" rwaccess="R/W"/> 
		<bitfield id="DEADLOCK_TIMEOUT" width="1" begin="17" end="17" resetval="0x0" description="  								Setting this bit to 1 enables setting of Timeout for Dead lock bit in the UHS-II Error Interrupt Status register. 						" range="17" rwaccess="R/W"/> 
		<bitfield id="CMD_RESP_TIMEOUT" width="1" begin="16" end="16" resetval="0x0" description="  								Setting this bit to 1 enables setting of Timeout for CMD_RES bit in the UHS-II Error Interrupt Status register. 						" range="16" rwaccess="R/W"/> 
		<bitfield id="ADMA2_ADMA3" width="1" begin="15" end="15" resetval="0x0" description="  								Setting this bit to 1 enables setting of ADMA2/3 Error bit in the UHS-II Error Interrupt Status register. 						" range="15" rwaccess="R/W"/> 
		<bitfield id="EBSY" width="1" begin="8" end="8" resetval="0x0" description="  								Setting this bit to 1 enables setting of EBSY Error bit in the UHS-II Error Interrupt Status register. 						" range="8" rwaccess="R/W"/> 
		<bitfield id="UNRECOVERABLE" width="1" begin="7" end="7" resetval="0x0" description="  								Setting this bit to 1 enables setting of Unrecoverable Error bit in the UHS-II Error Interrupt Status register. 						" range="7" rwaccess="R/W"/> 
		<bitfield id="TID" width="1" begin="5" end="5" resetval="0x0" description="  								Setting this bit to 1 enables setting of TID Error bit in the UHS-II Error Interrupt Status register. 						" range="5" rwaccess="R/W"/> 
		<bitfield id="FRAMING" width="1" begin="4" end="4" resetval="0x0" description="  								Setting this bit to 1 enables setting of Framing Error bit in the UHS-II Error Interrupt Status register. 						" range="4" rwaccess="R/W"/> 
		<bitfield id="CRC" width="1" begin="3" end="3" resetval="0x0" description="  								Setting this bit to 1 enables setting of CRC Error bit in the UHS-II Error Interrupt Status register. 						" range="3" rwaccess="R/W"/> 
		<bitfield id="RETRY_EXPIRED" width="1" begin="2" end="2" resetval="0x0" description="  								Setting this bit to 1 enables setting of Retry Expired bit in the UHS-II Error Interrupt Status register. 						" range="2" rwaccess="R/W"/> 
		<bitfield id="RESP_PKT" width="1" begin="1" end="1" resetval="0x0" description="  								Setting this bit to 1 enables setting of RES Packet Error bit in the UHS-II Error Interrupt Status register. 						" range="1" rwaccess="R/W"/> 
		<bitfield id="HEADER" width="1" begin="0" end="0" resetval="0x0" description="  								Setting this bit to 1 enables setting of Header Error bit in the UHS-II Error Interrupt Status Register. 						" range="0" rwaccess="R/W"/>
	</register>
	<register id="SDHC_WRAP__CTL_CFG__CTLCFG_uhs2_err_intr_sig_ena" acronym="SDHC_WRAP__CTL_CFG__CTLCFG_uhs2_err_intr_sig_ena" offset="0xCC" width="32" description="This register is used to generate UHS-II Interrupt signals">
		<bitfield id="VENDOR_SPECFIC" width="5" begin="31" end="27" resetval="0x0" description="  						Setting of a bit to 1 in this field enables generating interrupt signal when corre-spondent bit of Vendor Specific Error is set in the UHS-II Error Interrupt Status Register. 										0h - Interrupt Signal is Disabled 										1h - Interrupt Signal is Enabled 						" range="31 - 27" rwaccess="R/W"/> 
		<bitfield id="DEADLOCK_TIMEOUT" width="1" begin="17" end="17" resetval="0x0" description="  						Setting this bit to 1 enables generating interrupt signal when Timeout for Dead lock bit is set in the UHS-II Error InterruptStatus Register. 						" range="17" rwaccess="R/W"/> 
		<bitfield id="CMD_RESP_TIMEOUT" width="1" begin="16" end="16" resetval="0x0" description="  						Setting this bit to 1 enables generating interrupt signal when Timeout for CMD_RES bit is set in the UHS-II Error InterruptStatus Register. 						" range="16" rwaccess="R/W"/> 
		<bitfield id="ADMA2_ADMA3" width="1" begin="15" end="15" resetval="0x0" description="  						Setting this bit to 1 enables generating interrupt signal when ADMA2/3 Error bit is set in the UHS-II Error InterruptStatus Register. 						" range="15" rwaccess="R/W"/> 
		<bitfield id="EBSY" width="1" begin="8" end="8" resetval="0x0" description="  						Setting this bit to 1 enables generating interrupt signal when EBSY Error bit is set in the UHS-II Error InterruptStatus Register. 						" range="8" rwaccess="R/W"/> 
		<bitfield id="UNRECOVERABLE" width="1" begin="7" end="7" resetval="0x0" description="  						Setting this bit to 1 enables generating interrupt signal when Unrecoverable Error bit is set in the UHS-II Error InterruptStatus Register. 						" range="7" rwaccess="R/W"/> 
		<bitfield id="TID" width="1" begin="5" end="5" resetval="0x0" description="  						Setting this bit to 1 enables generating interrupt signal when TID Error bit is set in the UHS-II Error InterruptStatus Register. 						" range="5" rwaccess="R/W"/> 
		<bitfield id="FRAMING" width="1" begin="4" end="4" resetval="0x0" description="  						Setting this bit to 1 enables generating interrupt signal when Framing Error bit is set in the UHS-II Error InterruptStatus Register. 						" range="4" rwaccess="R/W"/> 
		<bitfield id="CRC" width="1" begin="3" end="3" resetval="0x0" description="  						Setting this bit to 1 enables generating interrupt signal when CRC Error bit is set in the UHS-II Error InterruptStatus Register. 						" range="3" rwaccess="R/W"/> 
		<bitfield id="RETRY_EXPIRED_SIG_ENA" width="1" begin="2" end="2" resetval="0x0" description="  						Setting this bit to 1 enables generating interrupt signal when Retry Expired bit is set in the UHS-II Error InterruptStatus Register. 						" range="2" rwaccess="R/W"/> 
		<bitfield id="RESP_PKT" width="1" begin="1" end="1" resetval="0x0" description="  						Setting this bit to 1 enables generating interrupt signal when RES Packet Error bit is set in the UHS-II Error InterruptStatus Register. 						" range="1" rwaccess="R/W"/> 
		<bitfield id="HEADER" width="1" begin="0" end="0" resetval="0x0" description=" Setting this bit to 1 enables generating interrupt signal when Header Error bit is set in the UHS-II Error Interrupt Status Register. 						" range="0" rwaccess="R/W"/>
	</register>
	<register id="SDHC_WRAP__CTL_CFG__CTLCFG_uhs2_settings_ptr" acronym="SDHC_WRAP__CTL_CFG__CTLCFG_uhs2_settings_ptr" offset="0xE0" width="16" description="
					This register is pointer for UHS-II settings.
					">
		<bitfield id="UHS2_SETTINGS_PTR" width="16" begin="15" end="0" resetval="0x256" description="Pointer for UHS-II Settings Register" range="15 - 0" rwaccess="R"/>
	</register>
	<register id="SDHC_WRAP__CTL_CFG__CTLCFG_uhs2_capabilities_ptr" acronym="SDHC_WRAP__CTL_CFG__CTLCFG_uhs2_capabilities_ptr" offset="0xE2" width="16" description="
					This register is pointer for UHS-II Capabilities Register.
					">
		<bitfield id="UHS2_CAPABILITIES_PTR" width="16" begin="15" end="0" resetval="0x272" description="Pointer for UHS-II Capabilities Register" range="15 - 0" rwaccess="R"/>
	</register>
	<register id="SDHC_WRAP__CTL_CFG__CTLCFG_uhs2_test_ptr" acronym="SDHC_WRAP__CTL_CFG__CTLCFG_uhs2_test_ptr" offset="0xE4" width="16" description="
					This register is pointer for UHS-II Test Register.
					">
		<bitfield id="UHS2_TEST_PTR" width="16" begin="15" end="0" resetval="0x288" description="Pointer for UHS-II Test Register" range="15 - 0" rwaccess="R"/>
	</register>
	<register id="SDHC_WRAP__CTL_CFG__CTLCFG_shared_bus_ctrl_ptr" acronym="SDHC_WRAP__CTL_CFG__CTLCFG_shared_bus_ctrl_ptr" offset="0xE6" width="16" description="
					This register is pointer for UHS-II Shared Bus Control Register.
					">
		<bitfield id="SHARED_BUS_CTRL_PTR" width="16" begin="15" end="0" resetval="0x304" description="Pointer for Shared Bus Control Register" range="15 - 0" rwaccess="R"/>
	</register>
	<register id="SDHC_WRAP__CTL_CFG__CTLCFG_vendor_specfic_ptr" acronym="SDHC_WRAP__CTL_CFG__CTLCFG_vendor_specfic_ptr" offset="0xE8" width="16" description="
					This register is pointer for UHS-II Vendor Specific Pointer Register.
					">
		<bitfield id="VENDOR_SPECFIC_PTR" width="16" begin="15" end="0" resetval="0x320" description="Pointer for Vendor Specific Area" range="15 - 0" rwaccess="R"/>
	</register>
	<register id="SDHC_WRAP__CTL_CFG__CTLCFG_boot_timeout_control" acronym="SDHC_WRAP__CTL_CFG__CTLCFG_boot_timeout_control" offset="0xF4" width="32" description="This is used to program the boot timeout value counter">
		<bitfield id="DATA_TIMEOUT_CNT" width="32" begin="31" end="0" resetval="0x0" description=" 						This value determines the interval by which DAT line time-outs are detected during boot operation for eMMC4.4 card.The value is in number of sd clock. 						" range="31 - 0" rwaccess="R/W"/>
	</register>
	<register id="SDHC_WRAP__CTL_CFG__CTLCFG_vendor_register" acronym="SDHC_WRAP__CTL_CFG__CTLCFG_vendor_register" offset="0xF8" width="32" description="Vendor register added for autogate sdclk, cmd11 power down timer, enhancedstrobe and eMMC hardware reset">
		<bitfield id="AUTOGATE_SDCLK" width="1" begin="16" end="16" resetval="0x0" description="If this bit is set, SD CLK will be gated automatically when there is no transfer. This is applicable only for Embedded Device" range="16" rwaccess="R/W"/> 
		<bitfield id="CMD11_PD_TIMER" width="14" begin="15" end="2" resetval="0x5000" description="cmd11 power-down timer value 						" range="15 - 2" rwaccess="R/W"/> 
		<bitfield id="EMMC_HW_RESET" width="1" begin="1" end="1" resetval="0x0" description="Hardware reset signal is generared for eMMC card when this bit is set 						" range="1" rwaccess="R/W"/> 
		<bitfield id="ENHANCED_STROBE" width="1" begin="0" end="0" resetval="0x0" description="This bit enables the enhanced strobe logic of the Host Controller" range="0" rwaccess="R/W"/>
	</register>
	<register id="SDHC_WRAP__CTL_CFG__CTLCFG_slot_int_sts" acronym="SDHC_WRAP__CTL_CFG__CTLCFG_slot_int_sts" offset="0xFC" width="16" description="This register is used to read the interrupt signal for each slot.">
		<bitfield id="INTR_SIG" width="8" begin="7" end="0" resetval="0x0" description=" 						These status bits indicate the logical OR of Interrupt signal and Wakeup signal for each slot. 						" range="7 - 0" rwaccess="R"/>
	</register>
	<register id="SDHC_WRAP__CTL_CFG__CTLCFG_host_controller_ver" acronym="SDHC_WRAP__CTL_CFG__CTLCFG_host_controller_ver" offset="0xFE" width="16" description="This register is used to read the vendor version number and specification version number
					">
		<bitfield id="VEN_VER_NUM" width="8" begin="15" end="8" resetval="0x16" description=" 						The Vendor Version Number is set to 0x10 [1.0] 						" range="15 - 8" rwaccess="R"/> 
		<bitfield id="SPEC_VER_NUM" width="8" begin="7" end="0" resetval="0x4" description=" 						This status indicates the Host Controller Spec. Version. The upper and lower 4-bits indicate the version. 						00h - SD Host Controller Specification Version 1.00 						01h - SD Host Controller Specification Version 2.00 Including the feature of the ADMA and Test Register 						02h - SD Host Controller Specification Version 3.00 						03h - SD Host Controller Specification Version 4.00 						04h - SD Host Controller Specification Version 4.10 						'others' Reserved 						" range="7 - 0" rwaccess="R"/>
	</register>
	<register id="SDHC_WRAP__CTL_CFG__CTLCFG_uhs2_gen_settings" acronym="SDHC_WRAP__CTL_CFG__CTLCFG_uhs2_gen_settings" offset="0x100" width="32" description="Start Address of General settings is pointed by Pointer for UHS-II Setting Register.
					">
		<bitfield id="NUMLANES" width="6" begin="13" end="8" resetval="0x0" description=" 						The lane configuration of a Host System is set to this field depends on the capability among Host Controller and connected devices. 2 Lanes FD mode is mandatory and the others modes are optional. 							0000b - 2 Lanes FD or 2L-HD 							0001b - Not Used 							0010b - 3 Lanes 2D1U-FD [Embedded] 							0011b - 3 Lanes 1D2U-FD [Embedded] 							0100b - 4 Lanes 2D2U-FD [Embedded] 							others - Reserved 						" range="13 - 8" rwaccess="R/W"/> 
		<bitfield id="POWER_MODE" width="1" begin="0" end="0" resetval="0x0" description="  						This field determines either Fast mode or Low Power mode.Host and all devices connected to the host shall be set to the same mode.  						" range="0" rwaccess="R/W"/>
	</register>
	<register id="SDHC_WRAP__CTL_CFG__CTLCFG_uhs2_phy_settings" acronym="SDHC_WRAP__CTL_CFG__CTLCFG_uhs2_phy_settings" offset="0x104" width="32" description="Start Address of PHY settings is pointed by Pointer for UHS-II Setting Register.
					">
		<bitfield id="N_LSS_DIR" width="4" begin="23" end="20" resetval="0x0" description="The largest value of N_LSS_DIR capabilities among the Host Controller and Connected Devices is set to this field. 									0h - 8 x16 LSS 									1h - 8 x 1 LSS 									2h - 8 x 2 LSS 									3h - 8 x 3 LSS 									...... 									...... 									Fh - 8 x 15 LSS 	 						" range="23 - 20" rwaccess="R/W"/> 
		<bitfield id="N_LSS_SYN" width="4" begin="19" end="16" resetval="0x0" description="The largest value of N_LSS_SYN capabilities among the Host Controller and Connected Devices is set to this field. 									0h - 4 x16 LSS 									1h - 4 x 1 LSS 									2h - 4 x 2 LSS 									3h - 4 x 3 LSS 									...... 									...... 									Fh - 4 x 15 LSS  						" range="19 - 16" rwaccess="R/W"/> 
		<bitfield id="HIBERNATE_ENA" width="1" begin="15" end="15" resetval="0x0" description="After checking card capability of Hibernate mode, if all devices support Hibernate mode, this bit may be set. This bit determines whether Host remains in Dormant state or goes to Hibernate state. In Hibernate mode, VDD1 Power may be off.  						" range="15" rwaccess="R/W"/> 
		<bitfield id="SPEED_RANGE" width="2" begin="7" end="6" resetval="0x0" description="PLL multiplier is selected by this field.Change of PLL Multiplier is not effective immediately and is applied from exiting Dormant State.  						'00' Range A [Default] 						'01' Range B 						'10' Reserved 						'11' Reserved 						" range="7 - 6" rwaccess="R/W"/>
	</register>
	<register id="SDHC_WRAP__CTL_CFG__CTLCFG_uhs2_lnk_trn_settings" acronym="SDHC_WRAP__CTL_CFG__CTLCFG_uhs2_lnk_trn_settings" offset="0x108" width="64" description="Start Address of LINK/TRAN settings is pointed by Pointer for UHS-II Setting Register.
					">
		<bitfield id="N_DATA_GAP" width="8" begin="39" end="32" resetval="0x0" description=" 						The largest value of N_DATA_GAP capabilities among the Host Controller and Connected Devices is set to this field. 								00h - No Gap 								01h - 1 LSS 								02h - 2 LSS 								03h - 3 LSS 								...... 								...... 								FFh - 255 LSS 					      						" range="39 - 32" rwaccess="R/W"/> 
		<bitfield id="RETRY_COUNT" width="2" begin="17" end="16" resetval="0x0" description=" 						Data Burst retry count is set to this field. 						'00' Retry Disabled 						'01' 1 time 						'10' 2 times 						'11' 3 times 						" range="17 - 16" rwaccess="R/W"/> 
		<bitfield id="HOST_NFCU" width="8" begin="15" end="8" resetval="0x0" description=" 							Host Driver sets the number of blocks in Data Burst [Flow Control] to this field.The value shall be smaller than or equal to N_FCU capabilities among the Host Controller and connected card and devices. Setting 1 to 4 blocks is recommended considering buffer size. 							00h - 256 Blocks 							01h - 1 Block 							02h - 2 Blocks 							03h - 3 Blocks 							...... 							...... 							FFh - 255 Blocks 						" range="15 - 8" rwaccess="R/W"/>
	</register>
	<register id="SDHC_WRAP__CTL_CFG__CTLCFG_uhs2_gen_cap" acronym="SDHC_WRAP__CTL_CFG__CTLCFG_uhs2_gen_cap" offset="0x110" width="32" description="Start Address of General Capabilities is pointed by Pointer for UHS-II Host Capabilities Register.
					">
		<bitfield id="CORECFG_UHS2_BUS_TOPLOGY" width="2" begin="23" end="22" resetval="0x0" description="This field indicates one of bus topologies configured by a Host system. 						'00' P2P Connection 						'01' Ring Connection 						'10' HUB Connection 						'11' HUB is connected in Ring 						" range="23 - 22" rwaccess="R"/> 
		<bitfield id="CORECFG_UHS2_MAX_DEVICES" width="4" begin="21" end="18" resetval="0x1" description="This field indicates the maximum number of devices supported by the Host Controller. 									0h - Not used 									1h - 1 Devices 									2h - 2 Devices 									..... 									....... 									Fh - 15 Devices  						" range="21 - 18" rwaccess="R"/> 
		<bitfield id="DEVICE_TYPE" width="2" begin="17" end="16" resetval="0x0" description="This field indicates device type configured by a Host system. 						'00' Removable Card[P2P] 						'01' Embedded Devices 						'10' Embedded Devices+Removable Card 						'11' Reserved 						" range="17 - 16" rwaccess="R"/> 
		<bitfield id="CFG_64BIT_ADDRESSING" width="1" begin="14" end="14" resetval="0x1" description="This field indicates support of 64-bit addressing by the Host Controller. 						'0' 32-bit Addressing is supported 						'1' 32-bit and 64-bit Addressing is supported 						" range="14" rwaccess="R"/> 
		<bitfield id="NUM_LANES" width="6" begin="13" end="8" resetval="0x15" description="This field indicates support of lanes by the Host Controller.0 mean not supported and 1 means supported. 									D08 - 2L-HD 									D09 - 2D1U-FD 									D10 - 1D2U-FD 									D11 - 2D2U-FD 									D12 - Reserved 									D13 - Reserved  						" range="13 - 8" rwaccess="R"/> 
		<bitfield id="GAP" width="4" begin="7" end="4" resetval="0x1" description="This field indicates the maximum capability of host power supply for a group configured by a Host system.This field is used to set the argument of DEVICE_INIT CCMD 									0h -Not used 									1h - 360 mW 									2h - 720 mW 									..... 									....... 									Fh - 360x15 mW 						" range="7 - 4" rwaccess="R"/> 
		<bitfield id="DAP" width="4" begin="3" end="0" resetval="0x1" description="This field indicates the maximum capability of host power supply for a device configured by a Host system.This field is used to set the argument of DEVICE_INIT CCMD 									0h -360 mW [Default] 									1h - 360 mW 									2h - 720 mW 									..... 									....... 									Fh - 360 x15 mW 						" range="3 - 0" rwaccess="R"/>
	</register>
	<register id="SDHC_WRAP__CTL_CFG__CTLCFG_uhs2_phy_cap" acronym="SDHC_WRAP__CTL_CFG__CTLCFG_uhs2_phy_cap" offset="0x114" width="32" description="Start Address of PHY Capabilities is pointed by Pointer for UHS-II Host Capabilities Register.
					">
		<bitfield id="N_LSS_DIR" width="4" begin="23" end="20" resetval="0x1" description=" 						This field indicates the minimum N_LSS_DIR required by the Host Controller. 									0h - 4 x16 LSS 									1h - 4 x 1 LSS 									2h - 4 x 2 LSS 									3h - 4 x 3 LSS 									...... 									...... 									Fh - 4 x 15 LSS 						 " range="23 - 20" rwaccess="R"/> 
		<bitfield id="N_LSS_SYN" width="4" begin="19" end="16" resetval="0x1" description="This field indicates the minimum N_LSS_SYN required by the Host Controller. 									0h - 4 x16 LSS 									1h - 4 x 1 LSS 									2h - 4 x 2 LSS 									3h - 4 x 3 LSS 									...... 									...... 									Fh - 4 x 15 LSS  						" range="19 - 16" rwaccess="R"/> 
		<bitfield id="SPEED_RANGE" width="2" begin="7" end="6" resetval="0x0" description="This field indicates supported Speed Range by the Host Controller 						'00' Range A [Default] 						'01' Range A and Range B 						'10' Reserved 						'11' Reserved 						" range="7 - 6" rwaccess="R"/>
	</register>
	<register id="SDHC_WRAP__CTL_CFG__CTLCFG_uhs2_lnk_trn_cap" acronym="SDHC_WRAP__CTL_CFG__CTLCFG_uhs2_lnk_trn_cap" offset="0x118" width="64" description="Start Address of LINK/TRAN settings is pointed by Pointer for UHS-II Capabilities Register.
					">
		<bitfield id="N_DATA_GAP" width="8" begin="39" end="32" resetval="0x129" description="This field indicates the minimum number of data gap[DIDL] supported by the Host Controller.	 										00h - No Gap 										01h - 1 LSS 										02h - 2 LSS 										03h - 3 LSS 										...... 										...... 										FFh - 255 LSS 					     " range="39 - 32" rwaccess="R"/> 
		<bitfield id="MAX_BLK_LENGTH" width="12" begin="31" end="20" resetval="0x512" description="This field indicates maximum block length by the Host Controller. 									000h - Not Used 									001h - 1 byte 									002h - 2 bytes 									...... 									...... 									200h - 512 bytes 									...... 									...... 									800h - 2048 bytes 									801h-FFFh -Not Used  						" range="31 - 20" rwaccess="R"/> 
		<bitfield id="N_FCU" width="8" begin="15" end="8" resetval="0x1" description=" 						This field indicates maximum the number of blocks in a Flow Control unit by the Host Controller.This value is determined by supported buffer size. 								00h - 256 Blocks 								01h - 1 Block 								02h - 2 Block 								03h - 3 Block 								....... 								FFh - 255 Blocks 						" range="15 - 8" rwaccess="R"/>
	</register>
	<register id="SDHC_WRAP__CTL_CFG__CTLCFG_force_UHSII_Err_Int_Sts" acronym="SDHC_WRAP__CTL_CFG__CTLCFG_force_UHSII_Err_Int_Sts" offset="0x120" width="32" description="This register is not physically implemented, rather it is an address where UHS-II Error Interrupt Status register can be written.
					">
		<bitfield id="VENDOR_SPECIFIC" width="5" begin="31" end="27" resetval="0x0" description="Force Event for Vendor Specific Error 									 0h - Not Affected 									 1h - Vendor Specific Error Status is set 						" range="31 - 27" rwaccess="W"/> 
		<bitfield id="TIMEOUT_DEADLOCK" width="1" begin="17" end="17" resetval="0x0" description="Setting this bit forces the Host Controller to set Timeout for Deadlock in the UHS-II Error Interrupt Status register. 						" range="17" rwaccess="W"/> 
		<bitfield id="TIMEOUT_CMD_RES" width="1" begin="16" end="16" resetval="0x0" description="Setting this bit forces the Host Controller to set Timeout for CMD_RES in the UHS-II Error Interrupt Status register. 						" range="16" rwaccess="W"/> 
		<bitfield id="ADMA" width="1" begin="15" end="15" resetval="0x0" description="Setting this bit forces the Host Controller to set ADMA Error in the UHS-II Error Interrupt Status register. 						" range="15" rwaccess="W"/> 
		<bitfield id="EBSY" width="1" begin="8" end="8" resetval="0x0" description="Setting this bit forces the Host Controller to set EBSY Error in the UHS-II Error Interrupt Status register. 						" range="8" rwaccess="W"/> 
		<bitfield id="UNRECOVERABLE" width="1" begin="7" end="7" resetval="0x0" description="Setting this bit forces the Host Controller to set Unrecover-able Error in the UHS-II Error Interrupt Status register. 						" range="7" rwaccess="W"/> 
		<bitfield id="TID" width="1" begin="5" end="5" resetval="0x0" description="Setting this bit forces the Host Controller to set TID Error in the UHS-II Error Interrupt Status register. 						" range="5" rwaccess="W"/> 
		<bitfield id="FRAMING" width="1" begin="4" end="4" resetval="0x0" description="Setting this bit forces the Host Controller to set Framing Error in the UHS-II Error Interrupt Status register. 						" range="4" rwaccess="W"/> 
		<bitfield id="CRC" width="1" begin="3" end="3" resetval="0x0" description="Setting this bit forces the Host Controller to set CRC Error in the UHS-II Error Interrupt Status register. 						" range="3" rwaccess="W"/> 
		<bitfield id="RETRY_EXPIRED" width="1" begin="2" end="2" resetval="0x0" description="Setting this bit forces the Host Controller to set Retry Expired in the UHS-II Error Interrupt Status register. 						" range="2" rwaccess="W"/> 
		<bitfield id="RES_PKT" width="1" begin="1" end="1" resetval="0x0" description="Setting this bit forces the Host Controller to set RES Packet Error in the UHS-II Error Interrupt Status register. 						" range="1" rwaccess="W"/> 
		<bitfield id="HEADER" width="1" begin="0" end="0" resetval="0x0" description="Setting this bit forces the Host Controller to set Header Error in the UHS-II Error Interrupt Status register. 						" range="0" rwaccess="W"/>
	</register>
	<register id="SDHC_WRAP__CTL_CFG__CTLCFG_cq_version" acronym="SDHC_WRAP__CTL_CFG__CTLCFG_cq_version" offset="0x200" width="32" description="This register provides information about the version of the eMMC CQ standard which is 285 implemented by the CQE, in BCD format. The current version is rev 5.1
							    The following table describes the CQBASE+00h: CQVReservedER   Command Queueing Version.
					">
		<bitfield id="EMMC_MAJOR_VER_NUM" width="4" begin="11" end="8" resetval="0x5" description=" 						eMMC Major Version Number [digit left of decimal point],in BCD format 						" range="11 - 8" rwaccess="R"/> 
		<bitfield id="EMMC_MINOR_VER_NUM" width="4" begin="7" end="4" resetval="0x1" description=" 						eMMC Minor Version Number [digit right of decimal point], in BCD format 						" range="7 - 4" rwaccess="R"/> 
		<bitfield id="EMMC_VERSION_SUFFIX" width="4" begin="3" end="0" resetval="0x0" description=" 						eMMC Version Suffix [2nd digit right of decimal point], in BCD format 						" range="3 - 0" rwaccess="R"/>
	</register>
	<register id="SDHC_WRAP__CTL_CFG__CTLCFG_cq_capabilities" acronym="SDHC_WRAP__CTL_CFG__CTLCFG_cq_capabilities" offset="0x204" width="32" description="This register is reserved for capability indication.
					">
		<bitfield id="CF_MUL" width="4" begin="15" end="12" resetval="0x3" description=" 						Internal Timer Clock Frequency Multiplier [ITCFMUL] ITCFMUL and ITCFVAL indicate the frequency of the clock used for interrupt coalescing timer and for deter-mining the SQS polling period. 						     See ITCFVAL definition 						for details. 						Field Value Description: 						0h = 0.001 MHz 						1h = 0.01 MHz 						2h = 0.1 MHz 						3h = 1 MHz 						4h = 10 MHz 						Other values are reserved 						" range="15 - 12" rwaccess="R"/> 
		<bitfield id="CF_VAL" width="10" begin="9" end="0" resetval="0x200" description=" 						Internal Timer Clock Frequency Value [ITCFVAL] 						TCFMUL and ITCFVAL indicate the frequency of the clock used for interrupt coalescing timer and for deter-mining the polling period when using periodic 						SEND_QUEUE_ STATUS [CMD13] polling. 						The clock frequency is calculated as ITCFVAL*ITCFMUL. 						For example, to encode 19.2 MHz ITCFVAL shall be C0h [= 192 decimal] and ITCFMUL shall be 2h [0.1 MHz 192 * 0.1 MHz 19.2 MHz] 						" range="9 - 0" rwaccess="R"/>
	</register>
	<register id="SDHC_WRAP__CTL_CFG__CTLCFG_cq_config" acronym="SDHC_WRAP__CTL_CFG__CTLCFG_cq_config" offset="0x208" width="32" description="This register controls CQE behavior affecting the general operation of command queueing 290 module or operation of multiple tasks in the same time.
					">
		<bitfield id="DCMD_ENA" width="1" begin="12" end="12" resetval="0x0" description=" 						Direct Command [DCMD] Enable This bit indicates to the hardware whether the Task Descriptor in slot #31 of the TDL is a Data Transfer Task Descriptor, or a Direct Command Task Descriptor. 						CQE uses this bit when a task is issued in slot #31, to determine how to decode the Task Descriptor. 						Bit Value Description 						1 = Task descriptor in slot #31 is a DCMD Task Descrip-tor 						0 = Task descriptor in slot #31 is a Data Transfer Task Descriptor 						" range="12" rwaccess="R/W"/> 
		<bitfield id="TASK_DESC_SIZE" width="1" begin="8" end="8" resetval="0x0" description=" 						Task Descriptor Size This bit indicates whether the task descriptor size is 128 bits or 64 bits as detailed in Data Structures section. This bit can only be configured when Command Queueing 						Enable bit is 0 [command queueing is disabled] Bit Value Description 						1 = Task descriptor size is 128 bits 						0 = Task descriptor size is 64 bits 						" range="8" rwaccess="R/W"/> 
		<bitfield id="CQ_ENABLE" width="1" begin="0" end="0" resetval="0x0" description=" 						Command Queueing Enable Software shall write 1 this bit when in order to enable command queueing mode [i.e. enable CQE]. 						When this bit is 0, CQE is disabled and software controls the eMMC bus using the legacy eMMC host controller. 						Before software writes 1 to this bit, software shall verify that the eMMC host controller is in idle state and there are no commands or data transfers ongoing. 						When software wants to exit command queueing mode,it shall clear all previous tasks if such exist before setting this bit to 0. 						" range="0" rwaccess="R/W"/>
	</register>
	<register id="SDHC_WRAP__CTL_CFG__CTLCFG_cq_control" acronym="SDHC_WRAP__CTL_CFG__CTLCFG_cq_control" offset="0x20C" width="32" description="This register controls CQE behavior affecting the general operation of command queueing 293 module or operation of multiple tasks in the same time.
					">
		<bitfield id="CLEAR_ALL_TASKS" width="1" begin="8" end="8" resetval="0x0" description=" 						Clear All Tasks Software shall write 1 this bit when it wants to clear all the tasks sent to the device. 						This bit can only be written when CQE is in halt state [i.e.Halt bit is 1]. 						When software writes 1, the value of the register is updated to 1, and CQE shall reset CQTDBR register and all other context information for all unfinished tasks. 						Then CQE will clear this bit.Software should poll on this bit until it is set to back 0 and may then resume normal operation, by clearing the Halt bit. 						CQE does not communicate to the device that the tasks were cleared. It is softwares responsibility to order the device to discard the tasks in its queue using CMDQ_TASK_MGMT command. 						Writing 0 to this register shall have no effect. 						" range="8" rwaccess="R/W"/> 
		<bitfield id="HALT_BIT" width="1" begin="0" end="0" resetval="0x0" description=" 						Halt Host software shall write 1 to the bit when it wants to acquire software control over the eMMC bus and disable CQE from issuing commands on the bus. 						For example, issuing a Discard Task command [CMDQ_TASK_MGMT] When software writes 1, CQE shall complete the ongo-ing task if such a task is in progress. 						Once the task is completed and CQE is in idle state,CQE shall not issue new commands and shall indicate so to software by setting this bit to 1. 						Software may poll on this bit until it is set to 1, and may only then send commands on the eMMC bus. 						In order to exit halt state [i.e. resume CQE activity], soft-ware shall clear this bit [write 0]. Writing 0 when thevalue is already 0 shall have no effect. 						" range="0" rwaccess="R/W"/>
	</register>
	<register id="SDHC_WRAP__CTL_CFG__CTLCFG_cq_intr_sts" acronym="SDHC_WRAP__CTL_CFG__CTLCFG_cq_intr_sts" offset="0x210" width="32" description="This register indicates pending interrupts that require service. Each bit in this registers is asserted 296 in response a specific event, only if the respective bit is set in CQ								 ISTE register.
					">
		<bitfield id="TASK_ERROR" width="1" begin="4" end="4" resetval="0x0" description=" 						Task Error Interrupt [TERR] This bit is asserted when task error is detected due to invalid task descriptor 						" range="4" rwaccess="R/W1TC"/> 
		<bitfield id="TASK_CLEARED" width="1" begin="3" end="3" resetval="0x0" description=" 						Task Cleared [TCL] This status bit is asserted [if CQISTE.TCL=1] when a task clear operation is completed by CQE. The com-pleted task clear operation is either an individual task 						clear [CQTCLR] or clearing of all tasks [CQCTL]. 						" range="3" rwaccess="R/W1TC"/> 
		<bitfield id="RESP_ERR_DET" width="1" begin="2" end="2" resetval="0x0" description=" 						Response Error Detected Interrupt [RED] This status bit is asserted [if CQISTE.RED=1] when a response is received with an error bit set in the device 						status field. The contents of the device status field are listed in Section 6.13.Software uses CQRMEM register to configure which device status bit fields may trigger an interrupt, and 						which are masked. 						" range="2" rwaccess="R/W1TC"/> 
		<bitfield id="TASK_COMPLETE" width="1" begin="1" end="1" resetval="0x0" description=" 						Task Complete Interrupt [TCC] This status bit is asserted [if CQISTE.TCC=1] when atleast one of the following two conditions are met: 						[1] A task is completed and the INT bit is set in its Task Descriptor 						[2] Interrupt caused by Interrupt Coalescing logic [see Section C.4.9] 						" range="1" rwaccess="R/W1TC"/> 
		<bitfield id="HALT_COMPLETE" width="1" begin="0" end="0" resetval="0x0" description=" 						Halt Complete Interrupt [HAC] This status bit is asserted [if CQISTE.HAC=1] when halt bit in CQCTL register transitions from 0 to 1 indicating 						that host controller has completed its current ongoing task and has entered halt state. 						" range="0" rwaccess="R/W1TC"/>
	</register>
	<register id="SDHC_WRAP__CTL_CFG__CTLCFG_cq_intr_sts_ena" acronym="SDHC_WRAP__CTL_CFG__CTLCFG_cq_intr_sts_ena" offset="0x214" width="32" description="This register enables and disables the reporting of the corresponding interrupt to host soft-ware in 299 CQIS register. When a bit is set ( 1 ) and the corresponding interrupt c								-ondition is active, then the 300 bit is CQIS is asserted. Interrupt sources that are disabled ( 0 ) are not
							    indicated in the CQIS 301 register. This register is bit-index matched to CQIS register.
					">
		<bitfield id="TASK_ERROR" width="1" begin="4" end="4" resetval="0x0" description=" 						Task Error Interrupt Status Enable 						1 = CQIS.TERR will be set when its interrupt condition is active 						0 = CQIS.TERR is disabled 						" range="4" rwaccess="R/W"/> 
		<bitfield id="TASK_CLEARED" width="1" begin="3" end="3" resetval="0x0" description=" 						Task Cleared Status Enable [TCL] 						1 = CQIS.TCL will be set when its interrupt condition is active 						0 = CQIS.TCL is disabled 						" range="3" rwaccess="R/W"/> 
		<bitfield id="RESP_ERR_DET" width="1" begin="2" end="2" resetval="0x0" description=" 						Response Error Detected Status Enable [RED] 						1 = CQIS.RED will be set when its interrupt condition is active 						0 = CQIS.RED is disabled 						" range="2" rwaccess="R/W"/> 
		<bitfield id="TASK_COMPLETE" width="1" begin="1" end="1" resetval="0x0" description=" 						Task Complete Status Enable [TCC] 						1 = CQIS.TCC will be set when its interrupt condition is active 						0 = CQIS.TCC is disabled 						" range="1" rwaccess="R/W"/> 
		<bitfield id="HALT_COMPLETE" width="1" begin="0" end="0" resetval="0x0" description=" 						Halt Complete Status Enable [HAC]  						1 = CQIS.HAC will be set when its interrupt condition is active 						0 = CQIS.HAC is disabled 						" range="0" rwaccess="R/W"/>
	</register>
	<register id="SDHC_WRAP__CTL_CFG__CTLCFG_cq_intr_sig_ena" acronym="SDHC_WRAP__CTL_CFG__CTLCFG_cq_intr_sig_ena" offset="0x218" width="32" description="This register enables and disables the generation of interrupts to host software. When a bit is set 304 ( 1 ) and the corresponding bit in CQIS is set, then an interrupt is gene								 -rated. Interrupt sources 305 that are disabled ( 0 ) are still indicated in the CQIS register. This register is bit-index matched 306 to CQIS register.
					">
		<bitfield id="TASK_ERROR" width="1" begin="4" end="4" resetval="0x0" description=" 						Task Error Interrupt Signal Enable [TERR] 						When set and CQIS.TERR is asserted, the CQE shall generate an interrupt 						" range="4" rwaccess="R/W"/> 
		<bitfield id="TASK_CLEARED" width="1" begin="3" end="3" resetval="0x0" description=" 						Task Cleared Signal Enable [TCL] 						When set and CQIS.TCL is asserted, the CQE shall generate an interrupt 						" range="3" rwaccess="R/W"/> 
		<bitfield id="RESP_ERR_DET" width="1" begin="2" end="2" resetval="0x0" description=" 						Response Error Detected Signal Enable [TCC] 						When set and CQIS.RED is asserted, the CQE shall generate an interrupt 						" range="2" rwaccess="R/W"/> 
		<bitfield id="TASK_COMPLETE" width="1" begin="1" end="1" resetval="0x0" description=" 						Task Complete Signal Enable [TCC] 						When set and CQIS.TCC is asserted, the CQE shall generate an interrupt 						" range="1" rwaccess="R/W"/> 
		<bitfield id="HALT_COMPLETE" width="1" begin="0" end="0" resetval="0x0" description=" 						Halt Complete Signal Enable [HAC] 						When set and CQIS.HAC is asserted, the CQE shall generate an interrupt 						" range="0" rwaccess="R/W"/>
	</register>
	<register id="SDHC_WRAP__CTL_CFG__CTLCFG_cq_intr_coalescing" acronym="SDHC_WRAP__CTL_CFG__CTLCFG_cq_intr_coalescing" offset="0x21C" width="32" description="This register controls the interrupt coalescing feature.
					">
		<bitfield id="CQINTCOALESC_ENABLE" width="1" begin="31" end="31" resetval="0x0" description=" 						When set to 0 by software, command responses are neither counted nor timed. Interrupts are still triggered by completion of tasks with INT=1 in the Task Descriptor. 						When set to 1, the interrupt coalescing mechanism is enabled and coalesced interrupts are generated. 						" range="31" rwaccess="R/W"/> 
		<bitfield id="IC_STATUS" width="1" begin="20" end="20" resetval="0x0" description=" 						This bit indicates to software whether any tasks [with INT=0] have completed and counted towards interrupt coalescing [i.e., ICSB is set if and only if IC counter > 0]. 						Bit Value Description 1 = At least one task completion has been counted [IC counter >0] 						0 = No task completions have occurred since last counter reset [IC counter =0] 						" range="20" rwaccess="R"/> 
		<bitfield id="CTR_THRESHOLD" width="5" begin="12" end="8" resetval="0x0" description=" 						Interrupt Coalescing Counter Threshold [ICCTH]: 						Software uses this field to configure the number of task completions [only tasks with INT=0 in the Task Descriptor] which are required in order to generate an interrupt. 						Counter Operation: As data transfer tasks with INT=0 complete, they are counted by CQE. The counter is reset by software during the interrupt service routine. 						The counter stops counting when it reaches the value configured in ICCTH. 						The maximum allowed value is 31 						NOTE : When ICCTH is 0, task completions are not counted, and counting-based interrupts are not generated.In order to write to this field, the ICCTHWEN bit must be 						set at the same write operation. 						" range="12 - 8" rwaccess="R/W"/> 
		<bitfield id="TIMEOUT_VAL" width="7" begin="6" end="0" resetval="0x0" description=" 						Interrupt Coalescing Timeout Value [ICTOVAL]: 						Software uses this field to configure the maximum time allowed between the completion of a task on the bus and the generation of an interrupt. 						Timer Operation: The timer is reset by software during the interrupt service routine. 						It starts running when a data transfer task with INT=0 is completed, after the timer was reset. When the timer 						reaches the value configured in ICTOVAL field it generates an interrupt and stops. 						The timers unit is equal to 1024 clock periods of the clock whose frequency is specified in the Internal Timer 						Clock Frequency field CQCAP register.The minimum value is 01h [1024 clock periods] and the maximum value is 7Fh [127*1024 clock periods]. 						For example, a CQCAP field value of 0 indicates a 19.2 MHz clock frequency [period = 52.08 ns]. If the setting in ICTOVAL is 10h, the calculated polling period is 						16*1024*52.08 ns= 853.33 us 						NOTE: When ICTOVAL is 0, the timer is not running, and timer-based interrupts are not generated. 						In order to write to this field, the ICTOVALWEN bit must be set at the same write operation. 						" range="6 - 0" rwaccess="R/W"/>
	</register>
	<register id="SDHC_WRAP__CTL_CFG__CTLCFG_cq_tdl_base_addr" acronym="SDHC_WRAP__CTL_CFG__CTLCFG_cq_tdl_base_addr" offset="0x220" width="32" description="This register is used for configuring the lower 32 bits of the byte address of the head of the Task 312 Descriptor List in the host memory.
					">
		<bitfield id="CQTDLBA_LO" width="32" begin="31" end="0" resetval="0x0" description=" 						Task Descriptor List Base Address [TDLBA] 						This register stores the LSB bits [bits 31:0] of the byte address of the head of the Task Descriptor List in system memory. 						The size of the task descriptor list is 32 * [Task Descrip-tor size + Transfer Descriptor size] as configured by Host driver. 						This address shall be set on Byte1 KByte boundary.: The lower 10 bits of this register shall be set to 0 by software and shall be ignored by CQE. 						" range="31 - 0" rwaccess="R/W"/>
	</register>
	<register id="SDHC_WRAP__CTL_CFG__CTLCFG_cq_tdl_base_addr_upbits" acronym="SDHC_WRAP__CTL_CFG__CTLCFG_cq_tdl_base_addr_upbits" offset="0x224" width="32" description="This register is used for configuring the upper 32 bits of the byte address of the head of the Task 316 Descriptor List in the host memory.
					">
		<bitfield id="CQTDLBA_HI" width="32" begin="31" end="0" resetval="0x0" description=" 						Task Descriptor List Base Address [TDLBA] 						This register stores the MSB bits [bits 63:32] of the byte address of the head of the Task Descriptor List in system memory. 						The size of the task descriptor list is 32 * [Task Descrip-tor size + Transfer Descriptor size] as configured by Host driver. 						This register is reserved when using 32-bit addressing mode. 						" range="31 - 0" rwaccess="R/W"/>
	</register>
	<register id="SDHC_WRAP__CTL_CFG__CTLCFG_cq_task_door_bell" acronym="SDHC_WRAP__CTL_CFG__CTLCFG_cq_task_door_bell" offset="0x228" width="32" description="Using this register, software triggers CQE to process a new task.
					">
		<bitfield id="CQTDB_VAL" width="32" begin="31" end="0" resetval="0x0" description=" 						Command Queueing Task Doorbell Software shall configure TDLBA and TDLBAU, and enable CQE in CQCFG before using this register. 						Writing 1 to bit n of this register triggers CQE to start pro-cessing the task encoded in slot n of the TDL. 						CQE always processes tasks in-order according to the order submitted to the list by CQTDBR write transac-tions. 						CQE processes Data Transfer tasks by reading the Task Descriptor and sending QUEUED_TASK_PARAMS[CMD44] and QUEUED_TASK_ADDRESS [CMD45]commands to the device. 						CQE processes DCMD tasks [in slot #31, when enabled]by reading the Task Descriptor, and generating the com-mand encoded by its index and argument. 						The corresponding bit is cleared to 0 by CQE in one of the following events: 						[a] When a task execution is completed [with success or error] 						[b] The task is cleared using CQTCLR register 						[c] All tasks are cleared using CQCTL register 						[d] CQE is disabled using CQCFG register 						Software may initiate multiple tasks at the same time [batch submission] by writing 1 to multiple bits of this register in the same transaction. 						In the case of batch submission: 						CQE shall process the tasks in order of the task index,starting with the lowest index. 						If one or more tasks in the batch are marked with QBR,the ordering of execution will be based on said process-ing order. 						Writing 0 by software shall have no impact on the hard-ware, and will not change the value of the register bit. 						" range="31 - 0" rwaccess="R/W1TS"/>
	</register>
	<register id="SDHC_WRAP__CTL_CFG__CTLCFG_cq_task_comp_notif" acronym="SDHC_WRAP__CTL_CFG__CTLCFG_cq_task_comp_notif" offset="0x22C" width="32" description="This register is used by CQE to notify software about completed tasks.
					">
		<bitfield id="CQTCN_VAL" width="32" begin="31" end="0" resetval="0x0" description="CQE shall set bit n of this register [at the same time it clears bit n of CQTDBR] when a task execution is com-pleted [with success or error]. When receiving interrupt for task completion, software may read this register to know which tasks have finished. After reading this register, software may clear the rele-vant bit fields by writing 1 to the corresponding bits. 						" range="31 - 0" rwaccess="R/W1TC"/>
	</register>
	<register id="SDHC_WRAP__CTL_CFG__CTLCFG_cq_dev_queue_status" acronym="SDHC_WRAP__CTL_CFG__CTLCFG_cq_dev_queue_status" offset="0x230" width="32" description="This register stores the most recent value of the device s queue status.
					">
		<bitfield id="CQDQ_STS" width="32" begin="31" end="0" resetval="0x0" description="Every time the Host controller receives a queue status register [QSR] from the device, it updates this register with the response of status command, i.e. the devices queue status. 						" range="31 - 0" rwaccess="R"/>
	</register>
	<register id="SDHC_WRAP__CTL_CFG__CTLCFG_cq_dev_pending_tasks" acronym="SDHC_WRAP__CTL_CFG__CTLCFG_cq_dev_pending_tasks" offset="0x234" width="32" description="This register indicates to software which tasks are queued in the device, awaiting execution.
					">
		<bitfield id="CQDP_TSKS" width="32" begin="31" end="0" resetval="0x0" description="Bit n of this register is set if and only if QUEUED_TASK_PARAMS [CMD44] and QUEUED_TASK_ADDRESS [CMD45] were sent for this specific task and if this task hasnt been executed yet.CQE shall set this bit after receiving a successful response for CMD45. CQE shall clear this bit after the task has completed execution.Software needs to read this register in the task-discard procedure, when the controller is halted, to determine if the task is queued in the device. If the task is queued,the driver sends a CMDQ_TASK_MGMT [CMD48] to the device ordering it to discard the task. Then software clears the task in the CQE. Only then the software orders CQE to resume its operation using CQCTL register. 						" range="31 - 0" rwaccess="R"/>
	</register>
	<register id="SDHC_WRAP__CTL_CFG__CTLCFG_cq_task_clear" acronym="SDHC_WRAP__CTL_CFG__CTLCFG_cq_task_clear" offset="0x238" width="32" description="This register is used for removing an outstanding task in the CQE. 327. The register should be used only when CQE is in Halt state.
					">
		<bitfield id="CQTCLR" width="32" begin="31" end="0" resetval="0x0" description="Writing 1 to bit n of this register orders CQE to clear a task which software has previously issued.This bit can only be written when CQE is in Halt state as            indicated in CQCFG register Halt bit.When software writes 1 to a bit in this register,CQE updates the value to 1, and starts clearing the data structures related to the task. CQE clears the bit fields                                 [sets a value of 0] in CQTCLR and in CQTDBR once clear operation is complete.Software should poll on the CQTCLR until it is cleared to verify clear operation was complete.Writing to this register only clears the task in the CQE and does not have impact on the device. In order to dis-card the task in the device, host software shall send CMDQ_TASK _MGMT while CQE is still in Halt state.Host driver is not allowed to use this register to clear multiple tasks at the same time. Clearing multiple tasks can be done using CQCTL register.Writing 0 to a register bit shall have no impact. 						" range="31 - 0" rwaccess="R/W"/>
	</register>
	<register id="SDHC_WRAP__CTL_CFG__CTLCFG_cq_send_sts_config1" acronym="SDHC_WRAP__CTL_CFG__CTLCFG_cq_send_sts_config1" offset="0x240" width="32" description="The register controls the when SEND_QUEUE_STATUS commands are sent.
					">
		<bitfield id="CMD_BLK_CNTR" width="4" begin="19" end="16" resetval="0x1" description="This field indicates to CQE when to send SEND_QUEUE_STATUS [CMD13] command to inquire the status of the devices task queue.A value of n means CQE shall send status command on the CMD line, during the transfer of data block BLOCK_CNT-n, on the data lines, where BLOCK_CNT is the number of blocks in the current transaction.A value of 0 means that SEND_QUEUE_STATUS [CMD13] command shall not be sent during the transac-tion. Instead it will be sent only when the data lines are idle.A value of 1 means that STATUS command is to be sent during the last block of the transaction. 						" range="19 - 16" rwaccess="R/W"/> 
		<bitfield id="CMD_IDLE_TIMER" width="16" begin="15" end="0" resetval="0x4096" description="This field indicates to CQE the polling period to use when using periodic SEND_QUEUE_STATUS [CMD13] polling.Periodic polling is used when tasks are pending in the device, but no data transfer is in progress. When a SEND_QUEUE_STATUS response indicating that no task is ready for execution, CQE counts the configured time until it issues the next SEND_QUEUE_STATUS.Timer units are clock periods of theclock whose fre-quency is specified in the Internal Timer Clock Fre-quency field CQCAP register.The minimum value is 0001h [1 clock period] and the maximum value is FFFFh [65535 clock periods]. Default interval is: 4096 clock periods. For example, a CQCAP field value of 0 indicates a 19.2 MHz clock frequency [period = 52.08 ns]. If the setting in CQSST is 1000h, the calcu.lated polling period is 4096*52.08 ns= 213.33 us. 						" range="15 - 0" rwaccess="R/W"/>
	</register>
	<register id="SDHC_WRAP__CTL_CFG__CTLCFG_cq_send_sts_config2" acronym="SDHC_WRAP__CTL_CFG__CTLCFG_cq_send_sts_config2" offset="0x244" width="32" description="This register is used for 333 configuring RCA field in SEND_QUEUE_STATUS command argu-ment.
					">
		<bitfield id="QUEUE_RCA" width="16" begin="15" end="0" resetval="0x0" description="This field provides CQE with the contents of the 16-bit RCA field in SEND_QUEUE_ STATUS [CMD13] com-mand. argument. CQE shall copy this field to bits 31:16 of the argument when transmitting SEND_ QUEUE_STATUS [CMD13] command. 						" range="15 - 0" rwaccess="R/W"/>
	</register>
	<register id="SDHC_WRAP__CTL_CFG__CTLCFG_cq_dcmd_response" acronym="SDHC_WRAP__CTL_CFG__CTLCFG_cq_dcmd_response" offset="0x248" width="32" description="This register is used for passing the response of a DCMD task to software.
					">
		<bitfield id="LAST_RESP" width="32" begin="31" end="0" resetval="0x0" description="This register contains the response of the command generated by the last direct-command [DCMD] task which was sent.CQE shall update this register when it receives the response for a DCMD task. This register is considered valid only after bit 31 of CQT-DBR register is cleared by CQE. 						" range="31 - 0" rwaccess="R"/>
	</register>
	<register id="SDHC_WRAP__CTL_CFG__CTLCFG_cq_resp_err_mask" acronym="SDHC_WRAP__CTL_CFG__CTLCFG_cq_resp_err_mask" offset="0x250" width="32" description="This register controls the generation of Response Error Detection (RED) interrupt.
					">
		<bitfield id="CQRMEM" width="32" begin="31" end="0" resetval="0x4260995200" description="This bit is used as in interrupt mask on the device status filed which is received in R1/R1b responses.Bit Value Description [for any bit i]:1 = When a R1/R1b response is received, with bit i in the device status set, a RED interrupt is generated 0 = When a R1/R1b response is received, bit i in the device status is ignored The reset value of this register is set to trigger an inter-rupt on all Error type bits in the device status, as defined in Section 6.13.NOTE: Responses to CMD13 [SQS] encode the QSR,so they are ignored by this logic 						" range="31 - 0" rwaccess="R/W"/>
	</register>
	<register id="SDHC_WRAP__CTL_CFG__CTLCFG_cq_task_err_info" acronym="SDHC_WRAP__CTL_CFG__CTLCFG_cq_task_err_info" offset="0x254" width="32" description="This register is updated by CQE when an error occurs on data or command related to a task activity. 
					When such error is detected by CQE or indicated by the eMMC controller CQE stores in CQTERRI the task IDs and the command indices of the commands which were executed on
					the 343 command line and data lines when the error occurred.Software is expected to use this information in the error recovery procedure. 
					">
		<bitfield id="DATERR_VALID" width="1" begin="31" end="31" resetval="0x0" description=" 						Data Transfer Error Fields Valid 						This bit is updated when an error is detected by CQE, or indicated by eMMC controller. 						If a data transfer is in progress when the error is detected/indicated, the bit is set to 1. 						If a no data transfer is in progress when the error is detected/indicated, the bit is cleared to 0. 						" range="31" rwaccess="R"/> 
		<bitfield id="DATERR_TASK_ID" width="5" begin="28" end="24" resetval="0x0" description=" 						Data Transfer Error Task ID 						This field indicates the ID of the task which was executed on the data lines when an error occurred. 						The field is updated if a data transfer is in progress when an error is detected by CQE, or indicated by eMMC controller 						" range="28 - 24" rwaccess="R"/> 
		<bitfield id="DATERR_CMD_INDEX" width="6" begin="21" end="16" resetval="0x0" description=" 						Data Transfer Error Command Index 						This field indicates the index of the command which was executed on the data lines when an error occurred. 						The index shall be set to EXECUTE_READ_TASK[CMD46] or EXECUTE_WRITE_TASK [CMD47] accord-ing to the data direction. 						The field is updated if a data transfer is in progress when an error is detected by CQE, or indicated by eMMC controller. 						" range="21 - 16" rwaccess="R"/> 
		<bitfield id="RESP_MODE_VALID" width="1" begin="15" end="15" resetval="0x0" description=" 						Response Mode Error Fields Valid 						This bit is updated when an error is detected by CQE, or indicated by eMMC controller. 						If a command transaction is in progress when the error is detected/indicated, the bit is set to 1. 						If a no command transaction is in progress when the error is detected/indicated, the bit is cleared to 0. 						" range="15" rwaccess="R"/> 
		<bitfield id="RESP_MODE_TASK_ID" width="5" begin="12" end="8" resetval="0x0" description=" 						Response Mode Error Task ID 						This field indicates the ID of the task which was executed on the command line when an error occurred. 						The field is updated if a command transaction is in progress when an error is detected by CQE, or indicated by eMMC controller. 						" range="12 - 8" rwaccess="R"/> 
		<bitfield id="RESP_MODE_CMD_INDEX" width="6" begin="5" end="0" resetval="0x0" description=" 						Response Mode Error Command Index 						This field indicates the index of the command which was executed on the command line when an error occurred. 						The field is updated if a command transaction is in progress when an error is detected by CQE, or indicated by eMMC controller. 						" range="5 - 0" rwaccess="R"/>
	</register>
	<register id="SDHC_WRAP__CTL_CFG__CTLCFG_cq_cmd_resp_index" acronym="SDHC_WRAP__CTL_CFG__CTLCFG_cq_cmd_resp_index" offset="0x258" width="32" description="This register stores the index of the last received command response.
					">
		<bitfield id="LAST_CRI" width="6" begin="5" end="0" resetval="0x0" description="This field stores the index of the last received command response. CQE shall update the value every time a com-mand response is received. 						" range="5 - 0" rwaccess="R"/>
	</register>
	<register id="SDHC_WRAP__CTL_CFG__CTLCFG_cq_cmd_resp_arg" acronym="SDHC_WRAP__CTL_CFG__CTLCFG_cq_cmd_resp_arg" offset="0x25C" width="32" description="This register stores the index of the last received command response.
					">
		<bitfield id="LAST_CRA" width="32" begin="31" end="0" resetval="0x0" description="This field stores the argument of the last received com-mand. CQE shall update the value every time a com-mand response is received. 						" range="31 - 0" rwaccess="R"/>
	</register>
	<register id="SDHC_WRAP__CTL_CFG__CTLCFG_cq_error_task_id" acronym="SDHC_WRAP__CTL_CFG__CTLCFG_cq_error_task_id" offset="0x260" width="32" description="CQ Error Task ID Register
					">
		<bitfield id="TERR_ID" width="5" begin="4" end="0" resetval="0x0" description="Task Error ID 						" range="4 - 0" rwaccess="R"/>
	</register>
</module>