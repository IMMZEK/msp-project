<module name="A53SS0_CORE0_DBG" acronym="" XML_version="1.0" HW_revision="n/a" description="">
	<register id="APBADDR_DBG_CPU0_EDESR" acronym="APBADDR_DBG_CPU0_EDESR" offset="0x20" width="32" description="External Debug Event Status Register">
		<bitfield id="RES0_EDESR_31_3" width="29" begin="31" end="3" resetval="0x0" description="Reserved, RES0." range="31 - 3" rwaccess="R/W"/> 
		<bitfield id="SS" width="1" begin="2" end="2" resetval="0x0" description="Halting step debug event pending. Possible values of this field are:       0              Reading this means that a Halting step debug event is not pending. Writing this means no action.                          1              Reading this means that a Halting step debug event is pending. Writing this clears the pending Halting step debug event.                   " range="2" rwaccess="R/W"/> 
		<bitfield id="RC" width="1" begin="1" end="1" resetval="0x0" description="Reset catch debug event pending. Possible values of this field are:       0              Reading this means that a Reset catch debug event is not pending. Writing this means no action.                          1              Reading this means that a Reset catch debug event is pending. Writing this clears the pending Reset catch debug event.                   " range="1" rwaccess="R/W"/> 
		<bitfield id="OSUC" width="1" begin="0" end="0" resetval="0x0" description="OS unlock debug event pending. Possible values of this field are:       0              Reading this means that an OS unlock catch debug event is not pending. Writing this means no action.                          1              Reading this means that an OS unlock catch debug event is pending. Writing this clears the pending OS unlock catch debug event.                   " range="0" rwaccess="R/W"/>
	</register>
	<register id="APBADDR_DBG_CPU0_EDECR" acronym="APBADDR_DBG_CPU0_EDECR" offset="0x24" width="32" description="External Debug Execution Control Register">
		<bitfield id="RES0_EDECR_31_3" width="29" begin="31" end="3" resetval="0x0" description="Reserved, RES0." range="31 - 3" rwaccess="R/W"/> 
		<bitfield id="SS" width="1" begin="2" end="2" resetval="0x0" description="Halting step enable. Possible values of this field are:       0              Halting step debug event disabled.                          1              Halting step debug event enabled.                   If the value of EDECR.SS is changed when the processor is in Non-debug state, the resulting value of EDECR.SS is UNKNOWN." range="2" rwaccess="R/W"/> 
		<bitfield id="RCE" width="1" begin="1" end="1" resetval="0x0" description="Reset catch enable. Possible values of this field are:       0              Reset catch debug event disabled.                          1              Reset catch debug event enabled.                   " range="1" rwaccess="R/W"/> 
		<bitfield id="OSUCE" width="1" begin="0" end="0" resetval="0x0" description="OS unlock catch enabled. Possible values of this field are:       0              OS unlock catch debug event disabled.                          1              OS unlock catch debug event enabled.                   " range="0" rwaccess="R/W"/>
	</register>
	<register id="APBADDR_DBG_CPU0_EDWAR_31_0" acronym="APBADDR_DBG_CPU0_EDWAR_31_0" offset="0x30" width="32" description="External Debug Watchpoint Address Register (low word)">
		<bitfield id="EDWAR_31_0" width="32" begin="31" end="0" resetval="0x0" description="Watchpoint address. The virtual data address being accessed when a watchpoint debug event was triggered and caused entry to Debug state.UNKNOWN if the processor is not in Debug state, or if Debug state was entered other than for a watchpoint debug event.The address must be within a naturally-aligned block of memory of power-of-two size no larger than the DC ZVA block size." range="31 - 0" rwaccess="R/W"/>
	</register>
	<register id="APBADDR_DBG_CPU0_EDWAR_63_32" acronym="APBADDR_DBG_CPU0_EDWAR_63_32" offset="0x34" width="32" description="External Debug Watchpoint Address Register (high word)">
		<bitfield id="EDWAR_63_32" width="32" begin="31" end="0" resetval="0x0" description="Watchpoint address. The virtual data address being accessed when a watchpoint debug event was triggered and caused entry to Debug state.UNKNOWN if the processor is not in Debug state, or if Debug state was entered other than for a watchpoint debug event.The address must be within a naturally-aligned block of memory of power-of-two size no larger than the DC ZVA block size." range="31 - 0" rwaccess="R/W"/>
	</register>
	<register id="APBADDR_DBG_CPU0_DBGDTRRX_EL0" acronym="APBADDR_DBG_CPU0_DBGDTRRX_EL0" offset="0x80" width="32" description="Debug Data Transfer Register Receive">
		<bitfield id="DBGDTRRX_EL0" width="32" begin="31" end="0" resetval="0x0" description="Update DTRRX. Writes to this register update the value in DTRRX and set RXfull to 1.Reads of this register return the last value written to DTRRX and do not change RXfull." range="31 - 0" rwaccess="R/W"/>
	</register>
	<register id="APBADDR_DBG_CPU0_EDITR" acronym="APBADDR_DBG_CPU0_EDITR" offset="0x84" width="32" description="External Debug Instruction Transfer Register">
		<bitfield id="EDITR" width="32" begin="31" end="0" resetval="0x0" description="Used in Debug state for passing instructions to the processor for execution" range="31 - 0" rwaccess="R/W"/>
	</register>
	<register id="APBADDR_DBG_CPU0_EDSCR" acronym="APBADDR_DBG_CPU0_EDSCR" offset="0x88" width="32" description="External Debug Status and Control Register">
		<bitfield id="RES0_EDSCR_31_31" width="1" begin="31" end="31" resetval="0x0" description="Reserved, RES0." range="31" rwaccess="R/W"/> 
		<bitfield id="RXFULL" width="1" begin="30" end="30" resetval="0x0" description="DTRRX full. This bit is RO." range="30" rwaccess="R/W"/> 
		<bitfield id="TXFULL" width="1" begin="29" end="29" resetval="0x0" description="DTRTX full. This bit is RO." range="29" rwaccess="R/W"/> 
		<bitfield id="ITO" width="1" begin="28" end="28" resetval="0x0" description="EDITR overrun. This bit is RO.If the processor is not in Debug state, this bit is UNKNOWN. ITO is set to 0 on entry to Debug state." range="28" rwaccess="R/W"/> 
		<bitfield id="RXO" width="1" begin="27" end="27" resetval="0x0" description="DTRRX overrun. This bit is RO." range="27" rwaccess="R/W"/> 
		<bitfield id="TXU" width="1" begin="26" end="26" resetval="0x0" description="DTRTX underrun. This bit is RO." range="26" rwaccess="R/W"/> 
		<bitfield id="PIPEADV" width="1" begin="25" end="25" resetval="0x0" description="Pipeline advance. Read-only. Set to 1 every time the processor pipeline retires one or more instructions. Cleared to 0 by a write to EDRCR.CSPA.The architecture does not define precisely when this bit is set to 1. It requires only that this happen periodically in Non-debug state to indicate that software execution is progressing." range="25" rwaccess="R/W"/> 
		<bitfield id="ITE" width="1" begin="24" end="24" resetval="0x0" description="ITR empty. This bit is RO.If the processor is not in Debug state, this bit is UNKNOWN. It is always valid in Debug state." range="24" rwaccess="R/W"/> 
		<bitfield id="INTDIS" width="2" begin="23" end="22" resetval="0x0" description="Interrupt disable. Disables taking interrupts [including virtual interrupts and System Error interrupts] in Non-Debug state.If external invasive debug is disabled, the value of this field is ignored.If external invasive debug is enabled, the possible values of this field are:       00              Do not disable interrupts                          01              Disable interrupts targeting Non-secure EL1.                          10              Disable interrupts targeting only Non-secure EL1 and Non-secure EL2. If external secure invasive debug is enabled, also disable interrupts targeting Secure EL1.                          11              Disable interrupts targeting only Non-secure EL1 and Non-secure EL2. If external secure invasive debug is enabled, also disable all other interrupts.                   The value of INTdis does not affect whether an interrupt is a WFI wake-up event, but can mask an interrupt as a WFE wake-up event.If EL3 and EL2 are not implemented, INTdis[0] is RO and reads the same value as INTdis[1], meaning only the values 0b00 and 0b11 can be selected." range="23 - 22" rwaccess="R/W"/> 
		<bitfield id="TDA" width="1" begin="21" end="21" resetval="0x0" description="Trap debug registers accesses." range="21" rwaccess="R/W"/> 
		<bitfield id="MA" width="1" begin="20" end="20" resetval="0x0" description="Memory access mode. Controls use of memory-access mode for accessing EDITR and the DCC. This bit is ignored if in Non-debug state and set to zero on entry to Debug state.Possible values of this field are:       0              Normal access mode                          1              Memory access mode.                   " range="20" rwaccess="R/W"/> 
		<bitfield id="RES0_EDSCR_19_19" width="1" begin="19" end="19" resetval="0x0" description="Reserved, RES0." range="19" rwaccess="R/W"/> 
		<bitfield id="NS" width="1" begin="18" end="18" resetval="0x0" description="Non-secure status. Read-only. When in Debug state, gives the current security state:       0              Secure state, IsSecure[] == TRUE                          1              Non-secure state, IsSecure[] == FALSE.                   In Non-debug state, this bit is UNKNOWN." range="18" rwaccess="R/W"/> 
		<bitfield id="RES0_EDSCR_17_17" width="1" begin="17" end="17" resetval="0x0" description="Reserved, RES0." range="17" rwaccess="R/W"/> 
		<bitfield id="SDD" width="1" begin="16" end="16" resetval="0x0" description="Secure debug disabled. This bit is RO.On entry to Debug state:If entering in Secure state, SDD is set to 0.If entering in Non-secure state, SDD is set to the inverse of ExternalSecureInvasiveDebugEnabled[].In Debug state, the value of the SDD bit does not change, even if ExternalSecureInvasiveDebugEnabled[] changes.In Non-debug state:SDD returns the inverse of ExternalSecureInvasiveDebugEnabled[]. If the authentication signals that control ExternalSecureInvasiveDebugEnabled[] change, a context synchronization operation is required to guarantee their effect.This bit is unaffected by the Security state of the processor.If EL3 is not implemented and the implementation is Non-secure, this bit is RES1." range="16" rwaccess="R/W"/> 
		<bitfield id="RES0_EDSCR_15_15" width="1" begin="15" end="15" resetval="0x0" description="Reserved, RES0." range="15" rwaccess="R/W"/> 
		<bitfield id="HDE" width="1" begin="14" end="14" resetval="0x0" description="Halting debug mode enable. Possible values of this bit are:       0              Halting debug mode disabled.                          1              Halting debug mode enabled.                   " range="14" rwaccess="R/W"/> 
		<bitfield id="RW" width="4" begin="13" end="10" resetval="0x0" description="Exception level register-width status. Read-only. In Debug state, each bit gives the current register width status of each EL:       1111              All exception levels are AArch64 state.                          1110              EL0 is AArch32 state. All other exception levels are AArch64 state.                          1100              EL0 and EL1 are AArch32 state. All other exception levels are AArch64 state. Never seen if EL2 is not implemented in the current security state.                          1000              EL0, EL1, and, if implemented in the current security state, EL2 are AArch32 state. All other exception levels are AArch64 state.                          0000              All exception levels are set to AArch32 state [32-bit configuration].                   However:If not at EL0: RW[0] == RW[1].If EL2 is not implemented in the current security state: RW[2] == RW[1].If EL3 is not implemented: RW[3] == RW[2].In Non-debug state, this field is RAO." range="13 - 10" rwaccess="R/W"/> 
		<bitfield id="EL" width="2" begin="9" end="8" resetval="0x0" description="Exception level. Read-only. In Debug state, this gives the current EL of the processor.In Non-debug state, this field is RAZ." range="9 - 8" rwaccess="R/W"/> 
		<bitfield id="A" width="1" begin="7" end="7" resetval="0x0" description="System Error interrupt pending. Read-only. In Debug state, indicates whether a SError interrupt is pending:If HCR_EL2.{AMO, TGE} = {1, 0} and in Non-secure EL0 or EL1, a virtual SError interrupt.Otherwise, a physical SError interrupt.       0              No SError interrupt pending.                          1              SError interrupt pending.                   A debugger can read EDSCR to check whether a SError interrupt is pending without having to execute further instructions. A pending SError might indicate data from target memory is corrupted.UNKNOWN in Non-debug state." range="7" rwaccess="R/W"/> 
		<bitfield id="ERR" width="1" begin="6" end="6" resetval="0x0" description="Cumulative error flag. This field is RO. It is set to 1 following exceptions in Debug state and on any signaled overrun or underrun on the DTR or EDITR." range="6" rwaccess="R/W"/> 
		<bitfield id="STATUS" width="6" begin="5" end="0" resetval="0x0" description="Debug status flags. This field is RO.The possible values of this field are:       000010              Processor is in Non-debug state.                          000001              Processor is restarting [exiting Debug state].                          000111              Breakpoint.                          010011              External debug request.                          011011              Halting step, normal.                          011111              Halting step, exclusive.                          100011              OS unlock catch.                          100111              Reset catch.                          101011              Watchpoint.                          101111              HLT instruction.                          110011              Software access to debug register.                          110111              Exception catch.                          111011              Halting step, no syndrome.                   All other values of STATUS are reserved." range="5 - 0" rwaccess="R/W"/>
	</register>
	<register id="APBADDR_DBG_CPU0_DBGDTRTX_EL0" acronym="APBADDR_DBG_CPU0_DBGDTRTX_EL0" offset="0x8C" width="32" description="Debug Data Transfer Register Transmit">
		<bitfield id="DBGDTRTX_EL0" width="32" begin="31" end="0" resetval="0x0" description="Return DTRTX. Reads of this register return the value in DTRTX and clear TXfull to 0.Writes of this register update the value in DTRTX and do not change TXfull." range="31 - 0" rwaccess="R/W"/>
	</register>
	<register id="APBADDR_DBG_CPU0_EDRCR" acronym="APBADDR_DBG_CPU0_EDRCR" offset="0x90" width="32" description="External Debug Reserve Control Register">
		<bitfield id="RES0_EDRCR_31_5" width="27" begin="31" end="5" resetval="0x0" description="Reserved, RES0." range="31 - 5" rwaccess="R/W"/> 
		<bitfield id="CBRRQ" width="1" begin="4" end="4" resetval="0x0" description="Allow imprecise entry to Debug state. The actions on writing to this bit are:       0              No action.                          1              Allow imprecise entry to Debug state, for example by canceling pending bus accesses.                   Setting this bit to 1 allows a debugger to request imprecise entry to Debug state. An External Debug Request debug event must be pending before the debugger sets this bit to 1.This feature is optional. If this feature is not implemented, writes to this bit are ignored." range="4" rwaccess="R/W"/> 
		<bitfield id="CSPA" width="1" begin="3" end="3" resetval="0x0" description="Clear Sticky Pipeline Advance. This bit is used to clear the EDSCR.PipeAdv bit to 0. The actions on writing to this bit are:       0              No action.                          1              Clear the EDSCR.PipeAdv bit to 0.                   " range="3" rwaccess="R/W"/> 
		<bitfield id="CSE" width="1" begin="2" end="2" resetval="0x0" description="Clear Sticky Error. Used to clear the EDSCR cumulative error bits to 0. The actions on writing to this bit are:       0              No action.                          1              Clear the EDSCR.{TXU, RXO, ERR} bits, and, if the processor is in Debug state, the EDSCR.ITO bit, to 0.                   " range="2" rwaccess="R/W"/> 
		<bitfield id="RES0_EDRCR_1_0" width="2" begin="1" end="0" resetval="0x0" description="Reserved, RES0." range="1 - 0" rwaccess="R/W"/>
	</register>
	<register id="APBADDR_DBG_CPU0_EDACR" acronym="APBADDR_DBG_CPU0_EDACR" offset="0x94" width="32" description="External Debug Auxiliary Control Register">
		<bitfield id="RES0_EDACR_31_0" width="32" begin="31" end="0" resetval="0x0" description="Reserved RES0" range="31 - 0" rwaccess="R/W"/>
	</register>
	<register id="APBADDR_DBG_CPU0_EDECCR" acronym="APBADDR_DBG_CPU0_EDECCR" offset="0x98" width="32" description="External Debug Exception Catch Control Register">
		<bitfield id="RES0_EDECCR_31_8" width="24" begin="31" end="8" resetval="0x0" description="Reserved, RES0." range="31 - 8" rwaccess="R/W"/> 
		<bitfield id="NSE" width="4" begin="7" end="4" resetval="0x0" description="Coarse-grained Non-secure exception catch. Possible values of this field are:       0000              Exception catch debug event disabled for Non-secure exception levels.                          0010              Exception catch debug event enabled for Non-secure EL1.                          0100              Exception catch debug event enabled for Non-secure EL2.                          0110              Exception catch debug event enabled for Non-secure EL1 and EL2.                   All other values are reserved. Bits [7,4] are reserved, RES0." range="7 - 4" rwaccess="R/W"/> 
		<bitfield id="SE" width="4" begin="3" end="0" resetval="0x0" description="Coarse-grained Secure exception catch. Possible values of this field are:       0000              Exception catch debug event disabled for Secure exception levels.                          0010              Exception catch debug event enabled for Secure EL1.                          1000              Exception catch debug event enabled for Secure EL3.                          1010              Exception catch debug event enabled for Secure EL1 and EL3.                   All other values are reserved. Bits [2,0] are reserved. RES0. Ignored if ExternalSecureInvasiveDebugEnabled[] == FALSE." range="3 - 0" rwaccess="R/W"/>
	</register>
	<register id="APBADDR_DBG_CPU0_EDPCSR_31_0" acronym="APBADDR_DBG_CPU0_EDPCSR_31_0" offset="0xA0" width="32" description="External Debug Program Counter Sample Register (low word)">
		<bitfield id="EDPCSR_31_0" width="32" begin="31" end="0" resetval="0x0" description="PC Sample low word, EDPCSRlo. Bits [31_0] of the sampled instruction address value. Reading EDPCSRlo has the side-effect of updating EDCIDSR, EDVIDSR, and EDPCSRhi. However:If the processor is in Debug state, or Sample-based profiling is prohibited, EDPCSRlo reads as 0xFFFFFFFF and EDCIDSR, EDVIDSR, and EDPCSRhi become UNKNOWN.If the processor is in Reset state, the sampled value is unknown and EDCIDSR, EDVIDSR and EDPCSRhi become UNKNOWN.If no instruction has been retired since the processor left Reset state, Debug state, or a state where Non-invasive debug is not permitted, the sampled value is UNKNOWN and EDCIDSR, EDVIDSR, and EDPCSRhi become UNKNOWN.For a read of EDPCSRlo from the memory-mapped interface, if EDLSR.SLK == 1, meaning the Software Lock is locked, then the access has no side-effects. That is, EDCIDSR, EDVIDSR, and EDPCSRhi are unchanged." range="31 - 0" rwaccess="R/W"/>
	</register>
	<register id="APBADDR_DBG_CPU0_EDCIDSR" acronym="APBADDR_DBG_CPU0_EDCIDSR" offset="0xA4" width="32" description="External Debug Context ID Sample Register">
		<bitfield id="CONTEXTIDR" width="32" begin="31" end="0" resetval="0x0" description="The sampled value of CONTEXTIDR_EL1, captured on reading the low half of EDPCSR.If EL3 is implemented and using AArch32 then CONTEXTIDR is a Banked register, and EDCIDSR samples the current Banked copy of CONTEXTIDR." range="31 - 0" rwaccess="R/W"/>
	</register>
	<register id="APBADDR_DBG_CPU0_EDVIDSR" acronym="APBADDR_DBG_CPU0_EDVIDSR" offset="0xA8" width="32" description="External Debug Virtual Context Sample Register">
		<bitfield id="NS" width="1" begin="31" end="31" resetval="0x0" description="Non-secure state sample. Indicates the security state associated with the most recent EDPCSR sample." range="31" rwaccess="R/W"/> 
		<bitfield id="E2" width="1" begin="30" end="30" resetval="0x0" description="Exception level 2 status sample. Indicates whether the most recent EDPCSR sample was associated with EL2. If EDVIDSR.NS == 0, this bit is 0." range="30" rwaccess="R/W"/> 
		<bitfield id="E3" width="1" begin="29" end="29" resetval="0x0" description="Exception level 3 status sample. Indicates whether the most recent EDPCSR sample was associated with AArch64 EL3. If EDVIDSR.NS == 1 or the processor was in AArch32 state when EDPCSR was read, this bit is 0." range="29" rwaccess="R/W"/> 
		<bitfield id="HV" width="1" begin="28" end="28" resetval="0x0" description="EDPCSR high half valid. Indicates whether bits [63_32] of the most recent EDPCSR sample are valid. If EDVIDSR.HV == 0, the value of EDPCSR[63_32] is RAZ." range="28" rwaccess="R/W"/> 
		<bitfield id="RES0_EDVIDSR_27_8" width="20" begin="27" end="8" resetval="0x0" description="Reserved, RES0." range="27 - 8" rwaccess="R/W"/> 
		<bitfield id="VMID" width="8" begin="7" end="0" resetval="0x0" description="VMID sample. The value of VTTBR_EL2.VMID associated with the most recent EDPCSR sample. If EDVIDSR.NS == 0 or EDVIDSR.E2 == 1, this field is RAZ." range="7 - 0" rwaccess="R/W"/>
	</register>
	<register id="APBADDR_DBG_CPU0_EDPCSR_63_32" acronym="APBADDR_DBG_CPU0_EDPCSR_63_32" offset="0xAC" width="32" description="External Debug Program Counter Sample Register (high word)">
		<bitfield id="EDPCSR_63_32" width="32" begin="31" end="0" resetval="0x0" description="PC Sample high word, EDPCSRhi. If EDVIDSR.HV == 0 then this field is RAZ, otherwise bits [63_32] of the sampled PC." range="31 - 0" rwaccess="R/W"/>
	</register>
	<register id="APBADDR_DBG_CPU0_OSLAR_EL1" acronym="APBADDR_DBG_CPU0_OSLAR_EL1" offset="0x300" width="32" description="OS Lock Access Register">
		<bitfield id="RES0_OSLAR_EL1_31_1" width="31" begin="31" end="1" resetval="0x0" description="Reserved, RES0." range="31 - 1" rwaccess="R/W"/> 
		<bitfield id="OSLK" width="1" begin="0" end="0" resetval="0x0" description="On writes to OSLAR_EL1, bit[0] is copied to the OS lock.Use EDPRSR.OSLK to check the current status of the lock." range="0" rwaccess="R/W"/>
	</register>
	<register id="APBADDR_DBG_CPU0_EDPRCR" acronym="APBADDR_DBG_CPU0_EDPRCR" offset="0x310" width="32" description="External Debug Power/Reset Control Register">
		<bitfield id="RES0_EDPRCR_31_4" width="28" begin="31" end="4" resetval="0x0" description="Reserved, RES0." range="31 - 4" rwaccess="R/W"/> 
		<bitfield id="COREPURQ" width="1" begin="3" end="3" resetval="0x0" description="Core powerup request. Allows a debugger to request that the power controller power up the core, enabling access to the debug register in the Core power domain. The actions on writing to this bit are:       0              No effect.                          1              Request the power controller to powerup the core.                   In an implementation that includes the recommended external debug interface, this bit drives the DBGPWRUPREQ signal.This bit can be read and written when the Core power domain is powered off.The power controller must not allow the Core power domain to switch off while this bit is one." range="3" rwaccess="R/W"/> 
		<bitfield id="RES0_EDPRCR_2_2" width="1" begin="2" end="2" resetval="0x0" description="Reserved, RES0." range="2" rwaccess="R/W"/> 
		<bitfield id="CWRR" width="1" begin="1" end="1" resetval="0x0" description="Warm reset request. Write only bit that reads as zero. The actions on writing to this bit are:       0              No action.                          1              Request Warm reset.                   The processor ignores writes to this bit if any of the following are the case:ExternalInvasiveDebugEnabled[] == FALSE, EL3 is not implemented, and the processor is Non-secure.ExternalSecureInvasiveDebugEnabled[] == FALSE and one of the following is true:EL3 is implemented.The processor is Secure.The Core power domain is either completely off or in a low-power state where the Core power domain registers cannot be accessed.DoubleLockStatus[] == TRUE [OS Double Lock is set].OSLSR.OSLK == 1 [OS lock is locked].In an implementation that includes the recommended external debug interface, this bit drives the DBGRSTREQ signal." range="1" rwaccess="R/W"/> 
		<bitfield id="CORENPDRQ" width="1" begin="0" end="0" resetval="0x0" description="Core no powerdown request. Requests emulation of powerdown. Possible values of this bit are:       0              On a powerdown request, the system powers down the Core power domain.                          1              On a powerdown request, the system emulates powerdown of the Core power domain. In this emulation mode the Core power domain is not actually powered down.                   " range="0" rwaccess="R/W"/>
	</register>
	<register id="APBADDR_DBG_CPU0_EDPRSR" acronym="APBADDR_DBG_CPU0_EDPRSR" offset="0x314" width="32" description="External Debug Processor Status Register">
		<bitfield id="RES0_EDPRSR_31_12" width="20" begin="31" end="12" resetval="0x0" description="Reserved, RES0." range="31 - 12" rwaccess="R/W"/> 
		<bitfield id="SDR" width="1" begin="11" end="11" resetval="0x0" description="Sticky debug restart. Set to 1 when the processor exits Debug state and cleared to 0 following reads of EDPRSR.       0              The processor has not restarted since EDPRSR was last read.                          1              The processor has restarted since EDPRSR was last read.                   This bit is UNKNOWN on reads if either of EDPRSR.{DLK, R} is 1, or EDPRSR.PU is 0.This bit clears to 0 when following a read of EDPRSR." range="11" rwaccess="R/W"/> 
		<bitfield id="SPMAD" width="1" begin="10" end="10" resetval="0x0" description="Sticky EPMAD error. Set to 1 if an access returns an error because AllowExternalPMUAccess[] == FALSE.       0              No accesses to the external performance monitors registers have failed since EDPRSR was last read.                          1              At least one access to the external performance monitors registers has failed since EDPRSR was last read.                   This bit is UNKNOWN on reads if either of EDPRSR.{DLK, R} is 1, or EDPRSR.PU is 0.This bit clears to 0 when following a read of EDPRSR." range="10" rwaccess="R/W"/> 
		<bitfield id="EPMAD" width="1" begin="9" end="9" resetval="0x0" description="External performance monitors access disable status.       0              External performance monitors access enabled.                          1              External performance monitors access disabled.                   If external performance monitors access is not implemented, EPMAD is RAO. This bit is UNKNOWN on reads if either of EDPRSR.{DLK, R} is 1, or EDPRSR.PU is 0." range="9" rwaccess="R/W"/> 
		<bitfield id="SDAD" width="1" begin="8" end="8" resetval="0x0" description="Sticky EDAD error. Set to 1 if an access returns an error because AllowExternalDebugAccess[] == FALSE.       0              No accesses to the external debug registers have failed since EDPRSR was last read.                          1              At least one access to the external debug registers has failed since EDPRSR was last read.                   This bit is UNKNOWN on reads if either of EDPRSR.{DLK, R} is 1, or EDPRSR.PU is 0.This bit clears to 0 following a read of EDPRSR." range="8" rwaccess="R/W"/> 
		<bitfield id="EDAD" width="1" begin="7" end="7" resetval="0x0" description="External debug access disable status.       0              External debug access enabled.                          1              External debug access disabled.                   This bit is UNKNOWN on reads if either of EDPRSR.{DLK, R} is 1, or EDPRSR.PU is 0." range="7" rwaccess="R/W"/> 
		<bitfield id="DLK" width="1" begin="6" end="6" resetval="0x0" description="OS Double Lock status bit.       0              OSDLR_EL1.DLK == 0 or EDPRCR.CORENPDRQ == 1 or the processor is in Debug state.                          1              OSDLR_EL1.DLK == 1 and EDPRCR.CORENPDRQ == 0 and the processor is in Non-debug state.                   This bit is UNKNOWN on reads if EDPRSR.PU is 0." range="6" rwaccess="R/W"/> 
		<bitfield id="OSLK" width="1" begin="5" end="5" resetval="0x0" description="OS lock status bit. A read of this bit returns the value of OSLSR_EL1.OSLK.This bit is UNKNOWN on reads if either of EDPRSR.{DLK, R} is 1 or EDPRSR.PU is 0." range="5" rwaccess="R/W"/> 
		<bitfield id="HALTED" width="1" begin="4" end="4" resetval="0x0" description="Halted status bit. Possible values are:       0              EDSCR.STATUS is 0b000010 [processor in Non-debug state].                          1              EDSCR.STATUS is not 0b000010.                   This bit is UNKNOWN on reads if EDPRSR.PU is 0. " range="4" rwaccess="R/W"/> 
		<bitfield id="SR" width="1" begin="3" end="3" resetval="0x0" description="Sticky core reset status bit. Possible values are:       0              The non-debug logic of the processor is not in reset state and has not been reset since the last time EDPRSR was read.                          1              The non-debug logic of the processor is in reset state or has been reset since the last time EDPRSR was read.                   This bit is UNKNOWN on reads if EDPRSR.DLK is 1 or EDPRSR.PU is 0.This bit clears to 0 following a read of EDPRSR if the non-debug logic of the processor is not in reset state." range="3" rwaccess="R/W"/> 
		<bitfield id="R" width="1" begin="2" end="2" resetval="0x0" description="Core reset status bit. Possible values are:       0              The non-debug logic of the processor is not in reset state.                          1              The non-debug logic of the processor is in reset state.                   This bit is UNKNOWN on reads if either EDPRSR.DLK is 1 or EDPRSR.PU is 0." range="2" rwaccess="R/W"/> 
		<bitfield id="SPD" width="1" begin="1" end="1" resetval="0x1" description="Sticky core power-down status bit.This bit is set to 1 on Cold reset to indicate the state of the debug registers has been lost. Since a Cold reset is required on powering up the processor, this usually indicates the Core power domain has been completely powered off.Possible values are:       0              If the Core power domain is off [EDPRSR.PU is 0], it is not known whether the state of the debug registers in the Core power domain is lost. Otherwise, the Core power domain is on, and the state of the debug registers in the Core power domain has not been lost.                          1              The state of the debug registers in the Core power domain is lost.                   This bit is UNKNOWN on reads if both EDPRSR.DLK and EDPRSR.PU are 1.This bit clears to 0 following a read of EDPRSR if the processor is not in the powered down state. There are two logical power off states for the Core power domain:RetentionThe states of the debug registers, including EDPRSR.SPD, in the Core power domain is preserved, and restored on leaving retention state.Power-downThe states of the debug registers in the Core power domain is lost, and a Cold reset is asserted on leaving power-down state.In these states, it is IMPLEMENTATION DEFINED whether:EDPRSR.SPD shows whether the state of the debug registers in the Core power domain has been lost since the last time EDPRSR was read when the Core power domain was on.EDPRSR.SPD reads-as-zero.EDPRSR.SPD is not cleared following a read of EDPRSR in these states.This means it is IMPLEMENTATION DEFINED whether a processor implements EDPRSR.SPD as:Fixed RAZ when in one or both of the retention and power-down states.Retaining its previous value when in the retention state.Fixed RAO in the power-down state.Note that this definition does not allow EDPRSR.SPD to be fixed RAO in the low-power retention state, as the state of the debug registers in the Core power domain is not lost by entering this state. However, the bit can be read as 1 in this state if the state of the registers was lost before entering this state [i.e. EDPRSR has not been read since the last Cold reset].ARM recommends that an implementation make EDPRSR.SPD fixed RAO when in the power-down state, particularly if it does not support a low-power retention state." range="1" rwaccess="R/W"/> 
		<bitfield id="PU" width="1" begin="0" end="0" resetval="0x1" description="Core power-up status bit. Indicates whether the Core power domain debug registers can be accessed:       0              Core is in a low-power or power-down state where the debug registers cannot be accessed.                          1              Core is in a power-up state where the debug registers can be accessed.                   " range="0" rwaccess="R/W"/>
	</register>
	<register id="APBADDR_DBG_CPU0_DBGBVR0_EL1_31_0" acronym="APBADDR_DBG_CPU0_DBGBVR0_EL1_31_0" offset="0x400" width="32" description="Debug Breakpoint Value Registers. Holds a virtual address or a VMID and/or a context ID for use in breakpoint matching. Forms breakpoint n together with control register DBGBCR0_EL1. Multiple uses of this register refer to ARMv8">
		<bitfield id="DBGBVR0_EL1_31_0" width="32" begin="31" end="0" resetval="0x0" description="Holds a virtual address or a VMID and/or a context ID for use in breakpoint matching" range="31 - 0" rwaccess="R/W"/>
	</register>
	<register id="APBADDR_DBG_CPU0_DBGBVR0_EL1_63_32" acronym="APBADDR_DBG_CPU0_DBGBVR0_EL1_63_32" offset="0x404" width="32" description="Debug Breakpoint Extended Value Registers. Holds a virtual address or a VMID and/or a context ID for use in breakpoint matching. Forms breakpoint n together with control register DBGBCR0_EL1. Multiple uses of this register refer to ARMv8">
		<bitfield id="DBGBVR0_EL1_63_32" width="32" begin="31" end="0" resetval="0x0" description="Holds a virtual address or a VMID and/or a context ID for use in breakpoint matching" range="31 - 0" rwaccess="R/W"/>
	</register>
	<register id="APBADDR_DBG_CPU0_DBGBCR0_EL1" acronym="APBADDR_DBG_CPU0_DBGBCR0_EL1" offset="0x408" width="32" description="Debug Breakpoint Control Register 0">
		<bitfield id="RES0_DBGBCR0_EL1_31_24" width="8" begin="31" end="24" resetval="0x0" description="Reserved, RES0." range="31 - 24" rwaccess="R/W"/> 
		<bitfield id="BT" width="4" begin="23" end="20" resetval="0x0" description="Breakpoint Type. Possible values are:       0000              Unlinked instruction address match.                          0001              Linked instruction address match.                          0010              Unlinked context ID match.                          0011              Linked context ID match                          0100              Unlinked instruction address mismatch.                          0101              Linked instruction address mismatch.                          1000              Unlinked VMID match.                          1001              Linked VMID match.                          1010              Unlinked VMID and context ID match.                          1011              Linked VMID and context ID match.                   The field breaks down as follows:BT[3:1]: Base type.000Match address. DBGBVR&#60;n>_EL1 is the address of an instruction.010Mismatch address. Behaves as type 0b000 if in an AArch64 translation, or if halting debug-mode is enabled and halting is allowed. Otherwise, DBGBVR&#60;n>_EL1 is the address of an instruction to be stepped.001Match context ID. DBGBVR&#60;n>_EL1[31_0] is a context ID.100Match VMID. DBGBVR&#60;n>_EL1[39:32] is a VMID.101Match VMID and context ID. DBGBVR&#60;n>_EL1[31_0] is a context ID, and DBGBVR&#60;n>_EL1[39:32] is a VMID.BT[0]: Enable linking.If the breakpoint is not context-aware, BT[3] and BT[1] are RES0. If EL2 is not implemented, BT[3] is RES0. If EL1 using AArch32 is not implemented, BT[2] is RES0.The values 011x and 11xx are reserved, but must behave as if the breakpoint is disabled. Software must not rely on this property as the behavior of reserved values might change in a future revision of the architecture." range="23 - 20" rwaccess="R/W"/> 
		<bitfield id="LBN" width="4" begin="19" end="16" resetval="0x0" description="Linked breakpoint number. For Linked address matching breakpoints, this specifies the index of the Context-matching breakpoint linked to." range="19 - 16" rwaccess="R/W"/> 
		<bitfield id="SSC" width="2" begin="15" end="14" resetval="0x0" description="Security state control. Determines the security states under which a breakpoint debug event for breakpoint n is generated. This field must be interpreted along with the HMC and PMC fields." range="15 - 14" rwaccess="R/W"/> 
		<bitfield id="HMC" width="1" begin="13" end="13" resetval="0x0" description="Higher mode control. Determines the debug perspective for deciding when a breakpoint debug event for breakpoint n is generated. This field must be interpreted along with the SSC and PMC fields." range="13" rwaccess="R/W"/> 
		<bitfield id="RES0_DBGBCR0_EL1_12_9" width="4" begin="12" end="9" resetval="0x0" description="Reserved, RES0." range="12 - 9" rwaccess="R/W"/> 
		<bitfield id="BAS" width="4" begin="8" end="5" resetval="0x0" description="Byte address select. Defines which half-words an address-matching breakpoint matches, regardless of the instruction set and execution state. In an AArch64-only implementation, this field is reserved, RES1. Otherwise:BAS[2] and BAS[0] are read/write.BAS[3] and BAS[1] are read-only copies of BAS[2] and BAS[0] respectively.The values 0b0011 and 0b1100 are only supported if AArch32 is supported at any exception level.The permitted values depend on the breakpoint type.For Address match breakpoints in either AArch32 or AArch64 state:BASMatch instruction atConstraint for debuggers0b0011DBGBVR&#60;n>_EL1Use for T32 and T32EE instructions.0b1100DBGBVR&#60;n>_EL1+2Use for T32 and T32EE instructions.0b1111DBGBVR&#60;n>_EL1Use for A64 and A32 instructions.0b0000 is reserved and must behave as if the breakpoint is disabled or map to a permitted value.For Address mismatch breakpoints in an AArch32 stage 1 translation regime:BASStep instruction atConstraint for debuggers0b0000-Use for a match anywhere breakpoint.0b0011DBGBVR&#60;n>_EL1Use for stepping T32 and T32EE instructions.0b1100DBGBVR&#60;n>_EL1+2Use for stepping T32 and T32EE instructions.0b1111DBGBVR&#60;n>_EL1Use for stepping A64 and A32 instructions.For Context matching breakpoints, this field is RES1 and ignored." range="8 - 5" rwaccess="R/W"/> 
		<bitfield id="RES0_DBGBCR0_EL1_4_3" width="2" begin="4" end="3" resetval="0x0" description="Reserved, RES0." range="4 - 3" rwaccess="R/W"/> 
		<bitfield id="PMC" width="2" begin="2" end="1" resetval="0x0" description="Privilege mode control. Determines the exception level or levels at which a breakpoint debug event for breakpoint n is generated. This field must be interpreted along with the SSC and HMC fields." range="2 - 1" rwaccess="R/W"/> 
		<bitfield id="E" width="1" begin="0" end="0" resetval="0x0" description="Enable breakpoint DBGBVR&#60;n>_EL1. Possible values are:       0              Breakpoint disabled.                          1              Breakpoint enabled.                   " range="0" rwaccess="R/W"/>
	</register>
	<register id="APBADDR_DBG_CPU0_DBGBVR1_EL1_31_0" acronym="APBADDR_DBG_CPU0_DBGBVR1_EL1_31_0" offset="0x410" width="32" description="Debug Breakpoint Value Registers. Holds a virtual address or a VMID and/or a context ID for use in breakpoint matching. Forms breakpoint n together with control register DBGBCR1_EL1. Multiple uses of this register refer to ARMv8">
		<bitfield id="DBGBVR1_EL1_31_0" width="32" begin="31" end="0" resetval="0x0" description="Holds a virtual address or a VMID and/or a context ID for use in breakpoint matching" range="31 - 0" rwaccess="R/W"/>
	</register>
	<register id="APBADDR_DBG_CPU0_DBGBVR1_EL1_63_32" acronym="APBADDR_DBG_CPU0_DBGBVR1_EL1_63_32" offset="0x414" width="32" description="Debug Breakpoint Extended Value Registers. Holds a virtual address or a VMID and/or a context ID for use in breakpoint matching. Forms breakpoint n together with control register DBGBCR1_EL1. Multiple uses of this register refer to ARMv8">
		<bitfield id="DBGBVR1_EL1_63_32" width="32" begin="31" end="0" resetval="0x0" description="Holds a virtual address or a VMID and/or a context ID for use in breakpoint matching" range="31 - 0" rwaccess="R/W"/>
	</register>
	<register id="APBADDR_DBG_CPU0_DBGBCR1_EL1" acronym="APBADDR_DBG_CPU0_DBGBCR1_EL1" offset="0x418" width="32" description="Debug Breakpoint Control Register 1">
		<bitfield id="RES0_DBGBCR1_EL1_31_24" width="8" begin="31" end="24" resetval="0x0" description="Reserved, RES0." range="31 - 24" rwaccess="R/W"/> 
		<bitfield id="BT" width="4" begin="23" end="20" resetval="0x0" description="Breakpoint Type. Possible values are:       0000              Unlinked instruction address match.                          0001              Linked instruction address match.                          0010              Unlinked context ID match.                          0011              Linked context ID match                          0100              Unlinked instruction address mismatch.                          0101              Linked instruction address mismatch.                          1000              Unlinked VMID match.                          1001              Linked VMID match.                          1010              Unlinked VMID and context ID match.                          1011              Linked VMID and context ID match.                   The field breaks down as follows:BT[3:1]: Base type.000Match address. DBGBVR&#60;n>_EL1 is the address of an instruction.010Mismatch address. Behaves as type 0b000 if in an AArch64 translation, or if halting debug-mode is enabled and halting is allowed. Otherwise, DBGBVR&#60;n>_EL1 is the address of an instruction to be stepped.001Match context ID. DBGBVR&#60;n>_EL1[31_0] is a context ID.100Match VMID. DBGBVR&#60;n>_EL1[39:32] is a VMID.101Match VMID and context ID. DBGBVR&#60;n>_EL1[31_0] is a context ID, and DBGBVR&#60;n>_EL1[39:32] is a VMID.BT[0]: Enable linking.If the breakpoint is not context-aware, BT[3] and BT[1] are RES0. If EL2 is not implemented, BT[3] is RES0. If EL1 using AArch32 is not implemented, BT[2] is RES0.The values 011x and 11xx are reserved, but must behave as if the breakpoint is disabled. Software must not rely on this property as the behavior of reserved values might change in a future revision of the architecture." range="23 - 20" rwaccess="R/W"/> 
		<bitfield id="LBN" width="4" begin="19" end="16" resetval="0x0" description="Linked breakpoint number. For Linked address matching breakpoints, this specifies the index of the Context-matching breakpoint linked to." range="19 - 16" rwaccess="R/W"/> 
		<bitfield id="SSC" width="2" begin="15" end="14" resetval="0x0" description="Security state control. Determines the security states under which a breakpoint debug event for breakpoint n is generated. This field must be interpreted along with the HMC and PMC fields." range="15 - 14" rwaccess="R/W"/> 
		<bitfield id="HMC" width="1" begin="13" end="13" resetval="0x0" description="Higher mode control. Determines the debug perspective for deciding when a breakpoint debug event for breakpoint n is generated. This field must be interpreted along with the SSC and PMC fields." range="13" rwaccess="R/W"/> 
		<bitfield id="RES0_DBGBCR1_EL1_12_9" width="4" begin="12" end="9" resetval="0x0" description="Reserved, RES0." range="12 - 9" rwaccess="R/W"/> 
		<bitfield id="BAS" width="4" begin="8" end="5" resetval="0x0" description="Byte address select. Defines which half-words an address-matching breakpoint matches, regardless of the instruction set and execution state. In an AArch64-only implementation, this field is reserved, RES1. Otherwise:BAS[2] and BAS[0] are read/write.BAS[3] and BAS[1] are read-only copies of BAS[2] and BAS[0] respectively.The values 0b0011 and 0b1100 are only supported if AArch32 is supported at any exception level.The permitted values depend on the breakpoint type.For Address match breakpoints in either AArch32 or AArch64 state:BASMatch instruction atConstraint for debuggers0b0011DBGBVR&#60;n>_EL1Use for T32 and T32EE instructions.0b1100DBGBVR&#60;n>_EL1+2Use for T32 and T32EE instructions.0b1111DBGBVR&#60;n>_EL1Use for A64 and A32 instructions.0b0000 is reserved and must behave as if the breakpoint is disabled or map to a permitted value.For Address mismatch breakpoints in an AArch32 stage 1 translation regime:BASStep instruction atConstraint for debuggers0b0000-Use for a match anywhere breakpoint.0b0011DBGBVR&#60;n>_EL1Use for stepping T32 and T32EE instructions.0b1100DBGBVR&#60;n>_EL1+2Use for stepping T32 and T32EE instructions.0b1111DBGBVR&#60;n>_EL1Use for stepping A64 and A32 instructions.For Context matching breakpoints, this field is RES1 and ignored." range="8 - 5" rwaccess="R/W"/> 
		<bitfield id="RES0_DBGBCR1_EL1_4_3" width="2" begin="4" end="3" resetval="0x0" description="Reserved, RES0." range="4 - 3" rwaccess="R/W"/> 
		<bitfield id="PMC" width="2" begin="2" end="1" resetval="0x0" description="Privilege mode control. Determines the exception level or levels at which a breakpoint debug event for breakpoint n is generated. This field must be interpreted along with the SSC and HMC fields." range="2 - 1" rwaccess="R/W"/> 
		<bitfield id="E" width="1" begin="0" end="0" resetval="0x0" description="Enable breakpoint DBGBVR&#60;n>_EL1. Possible values are:       0              Breakpoint disabled.                          1              Breakpoint enabled.                   " range="0" rwaccess="R/W"/>
	</register>
	<register id="APBADDR_DBG_CPU0_DBGBVR2_EL1_31_0" acronym="APBADDR_DBG_CPU0_DBGBVR2_EL1_31_0" offset="0x420" width="32" description="Debug Breakpoint Value Registers. Holds a virtual address or a VMID and/or a context ID for use in breakpoint matching. Forms breakpoint n together with control register DBGBCR2_EL1. Multiple uses of this register refer to ARMv8">
		<bitfield id="DBGBVR2_EL1_31_0" width="32" begin="31" end="0" resetval="0x0" description="Holds a virtual address or a VMID and/or a context ID for use in breakpoint matching" range="31 - 0" rwaccess="R/W"/>
	</register>
	<register id="APBADDR_DBG_CPU0_DBGBVR2_EL1_63_32" acronym="APBADDR_DBG_CPU0_DBGBVR2_EL1_63_32" offset="0x424" width="32" description="Debug Breakpoint Extended Value Registers. Holds a virtual address or a VMID and/or a context ID for use in breakpoint matching. Forms breakpoint n together with control register DBGBCR2_EL1. Multiple uses of this register refer to ARMv8">
		<bitfield id="DBGBVR2_EL1_63_32" width="32" begin="31" end="0" resetval="0x0" description="Holds a virtual address or a VMID and/or a context ID for use in breakpoint matching" range="31 - 0" rwaccess="R/W"/>
	</register>
	<register id="APBADDR_DBG_CPU0_DBGBCR2_EL1" acronym="APBADDR_DBG_CPU0_DBGBCR2_EL1" offset="0x428" width="32" description="Debug Breakpoint Control Register 2">
		<bitfield id="RES0_DBGBCR2_EL1_31_24" width="8" begin="31" end="24" resetval="0x0" description="Reserved, RES0." range="31 - 24" rwaccess="R/W"/> 
		<bitfield id="BT" width="4" begin="23" end="20" resetval="0x0" description="Breakpoint Type. Possible values are:       0000              Unlinked instruction address match.                          0001              Linked instruction address match.                          0010              Unlinked context ID match.                          0011              Linked context ID match                          0100              Unlinked instruction address mismatch.                          0101              Linked instruction address mismatch.                          1000              Unlinked VMID match.                          1001              Linked VMID match.                          1010              Unlinked VMID and context ID match.                          1011              Linked VMID and context ID match.                   The field breaks down as follows:BT[3:1]: Base type.000Match address. DBGBVR&#60;n>_EL1 is the address of an instruction.010Mismatch address. Behaves as type 0b000 if in an AArch64 translation, or if halting debug-mode is enabled and halting is allowed. Otherwise, DBGBVR&#60;n>_EL1 is the address of an instruction to be stepped.001Match context ID. DBGBVR&#60;n>_EL1[31_0] is a context ID.100Match VMID. DBGBVR&#60;n>_EL1[39:32] is a VMID.101Match VMID and context ID. DBGBVR&#60;n>_EL1[31_0] is a context ID, and DBGBVR&#60;n>_EL1[39:32] is a VMID.BT[0]: Enable linking.If the breakpoint is not context-aware, BT[3] and BT[1] are RES0. If EL2 is not implemented, BT[3] is RES0. If EL1 using AArch32 is not implemented, BT[2] is RES0.The values 011x and 11xx are reserved, but must behave as if the breakpoint is disabled. Software must not rely on this property as the behavior of reserved values might change in a future revision of the architecture." range="23 - 20" rwaccess="R/W"/> 
		<bitfield id="LBN" width="4" begin="19" end="16" resetval="0x0" description="Linked breakpoint number. For Linked address matching breakpoints, this specifies the index of the Context-matching breakpoint linked to." range="19 - 16" rwaccess="R/W"/> 
		<bitfield id="SSC" width="2" begin="15" end="14" resetval="0x0" description="Security state control. Determines the security states under which a breakpoint debug event for breakpoint n is generated. This field must be interpreted along with the HMC and PMC fields." range="15 - 14" rwaccess="R/W"/> 
		<bitfield id="HMC" width="1" begin="13" end="13" resetval="0x0" description="Higher mode control. Determines the debug perspective for deciding when a breakpoint debug event for breakpoint n is generated. This field must be interpreted along with the SSC and PMC fields." range="13" rwaccess="R/W"/> 
		<bitfield id="RES0_DBGBCR2_EL1_12_9" width="4" begin="12" end="9" resetval="0x0" description="Reserved, RES0." range="12 - 9" rwaccess="R/W"/> 
		<bitfield id="BAS" width="4" begin="8" end="5" resetval="0x0" description="Byte address select. Defines which half-words an address-matching breakpoint matches, regardless of the instruction set and execution state. In an AArch64-only implementation, this field is reserved, RES1. Otherwise:BAS[2] and BAS[0] are read/write.BAS[3] and BAS[1] are read-only copies of BAS[2] and BAS[0] respectively.The values 0b0011 and 0b1100 are only supported if AArch32 is supported at any exception level.The permitted values depend on the breakpoint type.For Address match breakpoints in either AArch32 or AArch64 state:BASMatch instruction atConstraint for debuggers0b0011DBGBVR&#60;n>_EL1Use for T32 and T32EE instructions.0b1100DBGBVR&#60;n>_EL1+2Use for T32 and T32EE instructions.0b1111DBGBVR&#60;n>_EL1Use for A64 and A32 instructions.0b0000 is reserved and must behave as if the breakpoint is disabled or map to a permitted value.For Address mismatch breakpoints in an AArch32 stage 1 translation regime:BASStep instruction atConstraint for debuggers0b0000-Use for a match anywhere breakpoint.0b0011DBGBVR&#60;n>_EL1Use for stepping T32 and T32EE instructions.0b1100DBGBVR&#60;n>_EL1+2Use for stepping T32 and T32EE instructions.0b1111DBGBVR&#60;n>_EL1Use for stepping A64 and A32 instructions.For Context matching breakpoints, this field is RES1 and ignored." range="8 - 5" rwaccess="R/W"/> 
		<bitfield id="RES0_DBGBCR2_EL1_4_3" width="2" begin="4" end="3" resetval="0x0" description="Reserved, RES0." range="4 - 3" rwaccess="R/W"/> 
		<bitfield id="PMC" width="2" begin="2" end="1" resetval="0x0" description="Privilege mode control. Determines the exception level or levels at which a breakpoint debug event for breakpoint n is generated. This field must be interpreted along with the SSC and HMC fields." range="2 - 1" rwaccess="R/W"/> 
		<bitfield id="E" width="1" begin="0" end="0" resetval="0x0" description="Enable breakpoint DBGBVR&#60;n>_EL1. Possible values are:       0              Breakpoint disabled.                          1              Breakpoint enabled.                   " range="0" rwaccess="R/W"/>
	</register>
	<register id="APBADDR_DBG_CPU0_DBGBVR3_EL1_31_0" acronym="APBADDR_DBG_CPU0_DBGBVR3_EL1_31_0" offset="0x430" width="32" description="Debug Breakpoint Value Registers. Holds a virtual address or a VMID and/or a context ID for use in breakpoint matching. Forms breakpoint n together with control register DBGBCR3_EL1. Multiple uses of this register refer to ARMv8">
		<bitfield id="DBGBVR3_EL1_31_0" width="32" begin="31" end="0" resetval="0x0" description="Holds a virtual address or a VMID and/or a context ID for use in breakpoint matching" range="31 - 0" rwaccess="R/W"/>
	</register>
	<register id="APBADDR_DBG_CPU0_DBGBVR3_EL1_63_32" acronym="APBADDR_DBG_CPU0_DBGBVR3_EL1_63_32" offset="0x434" width="32" description="Debug Breakpoint Extended Value Registers. Holds a virtual address or a VMID and/or a context ID for use in breakpoint matching. Forms breakpoint n together with control register DBGBCR3_EL1. Multiple uses of this register refer to ARMv8">
		<bitfield id="DBGBVR3_EL1_63_32" width="32" begin="31" end="0" resetval="0x0" description="Holds a virtual address or a VMID and/or a context ID for use in breakpoint matching" range="31 - 0" rwaccess="R/W"/>
	</register>
	<register id="APBADDR_DBG_CPU0_DBGBCR3_EL1" acronym="APBADDR_DBG_CPU0_DBGBCR3_EL1" offset="0x438" width="32" description="Debug Breakpoint Control Register 3">
		<bitfield id="RES0_DBGBCR3_EL1_31_24" width="8" begin="31" end="24" resetval="0x0" description="Reserved, RES0." range="31 - 24" rwaccess="R/W"/> 
		<bitfield id="BT" width="4" begin="23" end="20" resetval="0x0" description="Breakpoint Type. Possible values are:       0000              Unlinked instruction address match.                          0001              Linked instruction address match.                          0010              Unlinked context ID match.                          0011              Linked context ID match                          0100              Unlinked instruction address mismatch.                          0101              Linked instruction address mismatch.                          1000              Unlinked VMID match.                          1001              Linked VMID match.                          1010              Unlinked VMID and context ID match.                          1011              Linked VMID and context ID match.                   The field breaks down as follows:BT[3:1]: Base type.000Match address. DBGBVR&#60;n>_EL1 is the address of an instruction.010Mismatch address. Behaves as type 0b000 if in an AArch64 translation, or if halting debug-mode is enabled and halting is allowed. Otherwise, DBGBVR&#60;n>_EL1 is the address of an instruction to be stepped.001Match context ID. DBGBVR&#60;n>_EL1[31_0] is a context ID.100Match VMID. DBGBVR&#60;n>_EL1[39:32] is a VMID.101Match VMID and context ID. DBGBVR&#60;n>_EL1[31_0] is a context ID, and DBGBVR&#60;n>_EL1[39:32] is a VMID.BT[0]: Enable linking.If the breakpoint is not context-aware, BT[3] and BT[1] are RES0. If EL2 is not implemented, BT[3] is RES0. If EL1 using AArch32 is not implemented, BT[2] is RES0.The values 011x and 11xx are reserved, but must behave as if the breakpoint is disabled. Software must not rely on this property as the behavior of reserved values might change in a future revision of the architecture." range="23 - 20" rwaccess="R/W"/> 
		<bitfield id="LBN" width="4" begin="19" end="16" resetval="0x0" description="Linked breakpoint number. For Linked address matching breakpoints, this specifies the index of the Context-matching breakpoint linked to." range="19 - 16" rwaccess="R/W"/> 
		<bitfield id="SSC" width="2" begin="15" end="14" resetval="0x0" description="Security state control. Determines the security states under which a breakpoint debug event for breakpoint n is generated. This field must be interpreted along with the HMC and PMC fields." range="15 - 14" rwaccess="R/W"/> 
		<bitfield id="HMC" width="1" begin="13" end="13" resetval="0x0" description="Higher mode control. Determines the debug perspective for deciding when a breakpoint debug event for breakpoint n is generated. This field must be interpreted along with the SSC and PMC fields." range="13" rwaccess="R/W"/> 
		<bitfield id="RES0_DBGBCR3_EL1_12_9" width="4" begin="12" end="9" resetval="0x0" description="Reserved, RES0." range="12 - 9" rwaccess="R/W"/> 
		<bitfield id="BAS" width="4" begin="8" end="5" resetval="0x0" description="Byte address select. Defines which half-words an address-matching breakpoint matches, regardless of the instruction set and execution state. In an AArch64-only implementation, this field is reserved, RES1. Otherwise:BAS[2] and BAS[0] are read/write.BAS[3] and BAS[1] are read-only copies of BAS[2] and BAS[0] respectively.The values 0b0011 and 0b1100 are only supported if AArch32 is supported at any exception level.The permitted values depend on the breakpoint type.For Address match breakpoints in either AArch32 or AArch64 state:BASMatch instruction atConstraint for debuggers0b0011DBGBVR&#60;n>_EL1Use for T32 and T32EE instructions.0b1100DBGBVR&#60;n>_EL1+2Use for T32 and T32EE instructions.0b1111DBGBVR&#60;n>_EL1Use for A64 and A32 instructions.0b0000 is reserved and must behave as if the breakpoint is disabled or map to a permitted value.For Address mismatch breakpoints in an AArch32 stage 1 translation regime:BASStep instruction atConstraint for debuggers0b0000-Use for a match anywhere breakpoint.0b0011DBGBVR&#60;n>_EL1Use for stepping T32 and T32EE instructions.0b1100DBGBVR&#60;n>_EL1+2Use for stepping T32 and T32EE instructions.0b1111DBGBVR&#60;n>_EL1Use for stepping A64 and A32 instructions.For Context matching breakpoints, this field is RES1 and ignored." range="8 - 5" rwaccess="R/W"/> 
		<bitfield id="RES0_DBGBCR3_EL1_4_3" width="2" begin="4" end="3" resetval="0x0" description="Reserved, RES0." range="4 - 3" rwaccess="R/W"/> 
		<bitfield id="PMC" width="2" begin="2" end="1" resetval="0x0" description="Privilege mode control. Determines the exception level or levels at which a breakpoint debug event for breakpoint n is generated. This field must be interpreted along with the SSC and HMC fields." range="2 - 1" rwaccess="R/W"/> 
		<bitfield id="E" width="1" begin="0" end="0" resetval="0x0" description="Enable breakpoint DBGBVR&#60;n>_EL1. Possible values are:       0              Breakpoint disabled.                          1              Breakpoint enabled.                   " range="0" rwaccess="R/W"/>
	</register>
	<register id="APBADDR_DBG_CPU0_DBGBVR4_EL1_31_0" acronym="APBADDR_DBG_CPU0_DBGBVR4_EL1_31_0" offset="0x440" width="32" description="Debug Breakpoint Value Registers. Holds a virtual address or a VMID and/or a context ID for use in breakpoint matching. Forms breakpoint n together with control register DBGBCR4_EL1. Multiple uses of this register refer to ARMv8">
		<bitfield id="DBGBVR4_EL1_31_0" width="32" begin="31" end="0" resetval="0x0" description="Holds a virtual address or a VMID and/or a context ID for use in breakpoint matching" range="31 - 0" rwaccess="R/W"/>
	</register>
	<register id="APBADDR_DBG_CPU0_DBGBVR4_EL1_63_32" acronym="APBADDR_DBG_CPU0_DBGBVR4_EL1_63_32" offset="0x444" width="32" description="Debug Breakpoint Extended Value Registers. Holds a virtual address or a VMID and/or a context ID for use in breakpoint matching. Forms breakpoint n together with control register DBGBCR4_EL1. Multiple uses of this register refer to ARMv8">
		<bitfield id="DBGBVR4_EL1_63_32" width="32" begin="31" end="0" resetval="0x0" description="Holds a virtual address or a VMID and/or a context ID for use in breakpoint matching" range="31 - 0" rwaccess="R/W"/>
	</register>
	<register id="APBADDR_DBG_CPU0_DBGBCR4_EL1" acronym="APBADDR_DBG_CPU0_DBGBCR4_EL1" offset="0x448" width="32" description="Debug Breakpoint Control Register 4">
		<bitfield id="RES0_DBGBCR4_EL1_31_24" width="8" begin="31" end="24" resetval="0x0" description="Reserved, RES0." range="31 - 24" rwaccess="R/W"/> 
		<bitfield id="BT" width="4" begin="23" end="20" resetval="0x0" description="Breakpoint Type. Possible values are:       0000              Unlinked instruction address match.                          0001              Linked instruction address match.                          0010              Unlinked context ID match.                          0011              Linked context ID match                          0100              Unlinked instruction address mismatch.                          0101              Linked instruction address mismatch.                          1000              Unlinked VMID match.                          1001              Linked VMID match.                          1010              Unlinked VMID and context ID match.                          1011              Linked VMID and context ID match.                   The field breaks down as follows:BT[3:1]: Base type.000Match address. DBGBVR&#60;n>_EL1 is the address of an instruction.010Mismatch address. Behaves as type 0b000 if in an AArch64 translation, or if halting debug-mode is enabled and halting is allowed. Otherwise, DBGBVR&#60;n>_EL1 is the address of an instruction to be stepped.001Match context ID. DBGBVR&#60;n>_EL1[31_0] is a context ID.100Match VMID. DBGBVR&#60;n>_EL1[39:32] is a VMID.101Match VMID and context ID. DBGBVR&#60;n>_EL1[31_0] is a context ID, and DBGBVR&#60;n>_EL1[39:32] is a VMID.BT[0]: Enable linking.If the breakpoint is not context-aware, BT[3] and BT[1] are RES0. If EL2 is not implemented, BT[3] is RES0. If EL1 using AArch32 is not implemented, BT[2] is RES0.The values 011x and 11xx are reserved, but must behave as if the breakpoint is disabled. Software must not rely on this property as the behavior of reserved values might change in a future revision of the architecture." range="23 - 20" rwaccess="R/W"/> 
		<bitfield id="LBN" width="4" begin="19" end="16" resetval="0x0" description="Linked breakpoint number. For Linked address matching breakpoints, this specifies the index of the Context-matching breakpoint linked to." range="19 - 16" rwaccess="R/W"/> 
		<bitfield id="SSC" width="2" begin="15" end="14" resetval="0x0" description="Security state control. Determines the security states under which a breakpoint debug event for breakpoint n is generated. This field must be interpreted along with the HMC and PMC fields." range="15 - 14" rwaccess="R/W"/> 
		<bitfield id="HMC" width="1" begin="13" end="13" resetval="0x0" description="Higher mode control. Determines the debug perspective for deciding when a breakpoint debug event for breakpoint n is generated. This field must be interpreted along with the SSC and PMC fields." range="13" rwaccess="R/W"/> 
		<bitfield id="RES0_DBGBCR4_EL1_12_9" width="4" begin="12" end="9" resetval="0x0" description="Reserved, RES0." range="12 - 9" rwaccess="R/W"/> 
		<bitfield id="BAS" width="4" begin="8" end="5" resetval="0x0" description="Byte address select. Defines which half-words an address-matching breakpoint matches, regardless of the instruction set and execution state. In an AArch64-only implementation, this field is reserved, RES1. Otherwise:BAS[2] and BAS[0] are read/write.BAS[3] and BAS[1] are read-only copies of BAS[2] and BAS[0] respectively.The values 0b0011 and 0b1100 are only supported if AArch32 is supported at any exception level.The permitted values depend on the breakpoint type.For Address match breakpoints in either AArch32 or AArch64 state:BASMatch instruction atConstraint for debuggers0b0011DBGBVR&#60;n>_EL1Use for T32 and T32EE instructions.0b1100DBGBVR&#60;n>_EL1+2Use for T32 and T32EE instructions.0b1111DBGBVR&#60;n>_EL1Use for A64 and A32 instructions.0b0000 is reserved and must behave as if the breakpoint is disabled or map to a permitted value.For Address mismatch breakpoints in an AArch32 stage 1 translation regime:BASStep instruction atConstraint for debuggers0b0000-Use for a match anywhere breakpoint.0b0011DBGBVR&#60;n>_EL1Use for stepping T32 and T32EE instructions.0b1100DBGBVR&#60;n>_EL1+2Use for stepping T32 and T32EE instructions.0b1111DBGBVR&#60;n>_EL1Use for stepping A64 and A32 instructions.For Context matching breakpoints, this field is RES1 and ignored." range="8 - 5" rwaccess="R/W"/> 
		<bitfield id="RES0_DBGBCR4_EL1_4_3" width="2" begin="4" end="3" resetval="0x0" description="Reserved, RES0." range="4 - 3" rwaccess="R/W"/> 
		<bitfield id="PMC" width="2" begin="2" end="1" resetval="0x0" description="Privilege mode control. Determines the exception level or levels at which a breakpoint debug event for breakpoint n is generated. This field must be interpreted along with the SSC and HMC fields." range="2 - 1" rwaccess="R/W"/> 
		<bitfield id="E" width="1" begin="0" end="0" resetval="0x0" description="Enable breakpoint DBGBVR&#60;n>_EL1. Possible values are:       0              Breakpoint disabled.                          1              Breakpoint enabled.                   " range="0" rwaccess="R/W"/>
	</register>
	<register id="APBADDR_DBG_CPU0_DBGBVR5_EL1_31_0" acronym="APBADDR_DBG_CPU0_DBGBVR5_EL1_31_0" offset="0x450" width="32" description="Debug Breakpoint Value Registers. Holds a virtual address or a VMID and/or a context ID for use in breakpoint matching. Forms breakpoint n together with control register DBGBCR5_EL1. Multiple uses of this register refer to ARMv8">
		<bitfield id="DBGBVR5_EL1_31_0" width="32" begin="31" end="0" resetval="0x0" description="Holds a virtual address or a VMID and/or a context ID for use in breakpoint matching" range="31 - 0" rwaccess="R/W"/>
	</register>
	<register id="APBADDR_DBG_CPU0_DBGBVR5_EL1_63_32" acronym="APBADDR_DBG_CPU0_DBGBVR5_EL1_63_32" offset="0x454" width="32" description="Debug Breakpoint Extended Value Registers. Holds a virtual address or a VMID and/or a context ID for use in breakpoint matching. Forms breakpoint n together with control register DBGBCR5_EL1. Multiple uses of this register refer to ARMv8">
		<bitfield id="DBGBVR5_EL1_63_32" width="32" begin="31" end="0" resetval="0x0" description="Holds a virtual address or a VMID and/or a context ID for use in breakpoint matching" range="31 - 0" rwaccess="R/W"/>
	</register>
	<register id="APBADDR_DBG_CPU0_DBGBCR5_EL1" acronym="APBADDR_DBG_CPU0_DBGBCR5_EL1" offset="0x458" width="32" description="Debug Breakpoint Control Register 5">
		<bitfield id="RES0_DBGBCR5_EL1_31_24" width="8" begin="31" end="24" resetval="0x0" description="Reserved, RES0." range="31 - 24" rwaccess="R/W"/> 
		<bitfield id="BT" width="4" begin="23" end="20" resetval="0x0" description="Breakpoint Type. Possible values are:       0000              Unlinked instruction address match.                          0001              Linked instruction address match.                          0010              Unlinked context ID match.                          0011              Linked context ID match                          0100              Unlinked instruction address mismatch.                          0101              Linked instruction address mismatch.                          1000              Unlinked VMID match.                          1001              Linked VMID match.                          1010              Unlinked VMID and context ID match.                          1011              Linked VMID and context ID match.                   The field breaks down as follows:BT[3:1]: Base type.000Match address. DBGBVR&#60;n>_EL1 is the address of an instruction.010Mismatch address. Behaves as type 0b000 if in an AArch64 translation, or if halting debug-mode is enabled and halting is allowed. Otherwise, DBGBVR&#60;n>_EL1 is the address of an instruction to be stepped.001Match context ID. DBGBVR&#60;n>_EL1[31_0] is a context ID.100Match VMID. DBGBVR&#60;n>_EL1[39:32] is a VMID.101Match VMID and context ID. DBGBVR&#60;n>_EL1[31_0] is a context ID, and DBGBVR&#60;n>_EL1[39:32] is a VMID.BT[0]: Enable linking.If the breakpoint is not context-aware, BT[3] and BT[1] are RES0. If EL2 is not implemented, BT[3] is RES0. If EL1 using AArch32 is not implemented, BT[2] is RES0.The values 011x and 11xx are reserved, but must behave as if the breakpoint is disabled. Software must not rely on this property as the behavior of reserved values might change in a future revision of the architecture." range="23 - 20" rwaccess="R/W"/> 
		<bitfield id="LBN" width="4" begin="19" end="16" resetval="0x0" description="Linked breakpoint number. For Linked address matching breakpoints, this specifies the index of the Context-matching breakpoint linked to." range="19 - 16" rwaccess="R/W"/> 
		<bitfield id="SSC" width="2" begin="15" end="14" resetval="0x0" description="Security state control. Determines the security states under which a breakpoint debug event for breakpoint n is generated. This field must be interpreted along with the HMC and PMC fields." range="15 - 14" rwaccess="R/W"/> 
		<bitfield id="HMC" width="1" begin="13" end="13" resetval="0x0" description="Higher mode control. Determines the debug perspective for deciding when a breakpoint debug event for breakpoint n is generated. This field must be interpreted along with the SSC and PMC fields." range="13" rwaccess="R/W"/> 
		<bitfield id="RES0_DBGBCR5_EL1_12_9" width="4" begin="12" end="9" resetval="0x0" description="Reserved, RES0." range="12 - 9" rwaccess="R/W"/> 
		<bitfield id="BAS" width="4" begin="8" end="5" resetval="0x0" description="Byte address select. Defines which half-words an address-matching breakpoint matches, regardless of the instruction set and execution state. In an AArch64-only implementation, this field is reserved, RES1. Otherwise:BAS[2] and BAS[0] are read/write.BAS[3] and BAS[1] are read-only copies of BAS[2] and BAS[0] respectively.The values 0b0011 and 0b1100 are only supported if AArch32 is supported at any exception level.The permitted values depend on the breakpoint type.For Address match breakpoints in either AArch32 or AArch64 state:BASMatch instruction atConstraint for debuggers0b0011DBGBVR&#60;n>_EL1Use for T32 and T32EE instructions.0b1100DBGBVR&#60;n>_EL1+2Use for T32 and T32EE instructions.0b1111DBGBVR&#60;n>_EL1Use for A64 and A32 instructions.0b0000 is reserved and must behave as if the breakpoint is disabled or map to a permitted value.For Address mismatch breakpoints in an AArch32 stage 1 translation regime:BASStep instruction atConstraint for debuggers0b0000-Use for a match anywhere breakpoint.0b0011DBGBVR&#60;n>_EL1Use for stepping T32 and T32EE instructions.0b1100DBGBVR&#60;n>_EL1+2Use for stepping T32 and T32EE instructions.0b1111DBGBVR&#60;n>_EL1Use for stepping A64 and A32 instructions.For Context matching breakpoints, this field is RES1 and ignored." range="8 - 5" rwaccess="R/W"/> 
		<bitfield id="RES0_DBGBCR5_EL1_4_3" width="2" begin="4" end="3" resetval="0x0" description="Reserved, RES0." range="4 - 3" rwaccess="R/W"/> 
		<bitfield id="PMC" width="2" begin="2" end="1" resetval="0x0" description="Privilege mode control. Determines the exception level or levels at which a breakpoint debug event for breakpoint n is generated. This field must be interpreted along with the SSC and HMC fields." range="2 - 1" rwaccess="R/W"/> 
		<bitfield id="E" width="1" begin="0" end="0" resetval="0x0" description="Enable breakpoint DBGBVR&#60;n>_EL1. Possible values are:       0              Breakpoint disabled.                          1              Breakpoint enabled.                   " range="0" rwaccess="R/W"/>
	</register>
	<register id="APBADDR_DBG_CPU0_DBGWVR0_EL1_31_0" acronym="APBADDR_DBG_CPU0_DBGWVR0_EL1_31_0" offset="0x800" width="32" description="Debug Watchpoint Value Register 0">
		<bitfield id="VA" width="30" begin="31" end="2" resetval="0x0" description="Bits[48:2] of the address value for comparison.ARM deprecates setting DBGWVR&#60;n>_EL1[2] == 1." range="31 - 2" rwaccess="R/W"/> 
		<bitfield id="RES0_DBGWVR0_EL1_31_0_1_0" width="2" begin="1" end="0" resetval="0x0" description="Reserved, RES0." range="1 - 0" rwaccess="R/W"/>
	</register>
	<register id="APBADDR_DBG_CPU0_DBGWVR0_EL1_63_32" acronym="APBADDR_DBG_CPU0_DBGWVR0_EL1_63_32" offset="0x804" width="32" description="Debug Watchpoint Extended Value Register 0">
		<bitfield id="RESS" width="15" begin="31" end="17" resetval="0x0" description="Reserved, Sign extended. Hardwired to the value of the sign bit, bit [48]. Hardware and software must treat this field as RES0 if bit[48] is 0, and as RES1 if bit[48] is 1." range="31 - 17" rwaccess="R/W"/> 
		<bitfield id="VA" width="17" begin="16" end="0" resetval="0x0" description="Bits[48:2] of the address value for comparison.ARM deprecates setting DBGWVR&#60;n>_EL1[2] == 1." range="16 - 0" rwaccess="R/W"/>
	</register>
	<register id="APBADDR_DBG_CPU0_DBGWCR0_EL1" acronym="APBADDR_DBG_CPU0_DBGWCR0_EL1" offset="0x808" width="32" description="Debug Watchpoint Control Register 0">
		<bitfield id="RES0_DBGWCR0_EL1_31_29" width="3" begin="31" end="29" resetval="0x0" description="Reserved, RES0." range="31 - 29" rwaccess="R/W"/> 
		<bitfield id="MASK" width="5" begin="28" end="24" resetval="0x0" description="Address mask. Only objects up to 2GB can be watched using a single mask.       00000              No mask.                          00001              Reserved.                          00010              Reserved.                   Other values mask the corresponding number of address bits, from 0b00011 masking 3 address bits [0x00000007 mask for address] to 0b11111 masking 31 address bits [0x7FFFFFFF mask for address]." range="28 - 24" rwaccess="R/W"/> 
		<bitfield id="RES0_DBGWCR0_EL1_23_21" width="3" begin="23" end="21" resetval="0x0" description="Reserved, RES0." range="23 - 21" rwaccess="R/W"/> 
		<bitfield id="WT" width="1" begin="20" end="20" resetval="0x0" description="Watchpoint type. Possible values are:       0              Unlinked data address match.                          1              Linked data address match.                   " range="20" rwaccess="R/W"/> 
		<bitfield id="LBN" width="4" begin="19" end="16" resetval="0x0" description="Linked breakpoint number. For Linked data address watchpoints, this specifies the index of the Context-matching breakpoint linked to." range="19 - 16" rwaccess="R/W"/> 
		<bitfield id="SSC" width="2" begin="15" end="14" resetval="0x0" description="Security state control. Determines the security states under which a watchpoint debug event for watchpoint n is generated. This field must be interpreted along with the HMC and PAC fields." range="15 - 14" rwaccess="R/W"/> 
		<bitfield id="HMC" width="1" begin="13" end="13" resetval="0x0" description="Higher mode control. Determines the debug perspective for deciding when a watchpoint debug event for watchpoint n is generated. This field must be interpreted along with the SSC and PAC fields." range="13" rwaccess="R/W"/> 
		<bitfield id="BAS" width="8" begin="12" end="5" resetval="0x0" description="Byte address select. Each bit of this field selects whether a byte from within the word or double-word addressed by DBGWVR&#60;n>_EL1 is being watched.BASDescriptionxxxxxxx1Match byte at DBGWVR&#60;n>_EL1xxxxxx1xMatch byte at DBGWVR&#60;n>_EL1+1xxxxx1xxMatch byte at DBGWVR&#60;n>_EL1+2xxxx1xxxMatch byte at DBGWVR&#60;n>_EL1+3In cases where DBGWVR&#60;n>_EL1 addresses a double-word:BASDescription, if DBGWVR&#60;n>_EL1[2] == 0xxx1xxxxMatch byte at DBGWVR&#60;n>_EL1+4xx1xxxxxMatch byte at DBGWVR&#60;n>_EL1+5x1xxxxxxMatch byte at DBGWVR&#60;n>_EL1+61xxxxxxxMatch byte at DBGWVR&#60;n>_EL1+7If DBGWVR&#60;n>_EL1[2] == 1, only BAS[3:0] is used. ARM deprecates setting DBGWVR&#60;n>_EL1 == 1.The valid values for BAS are 0b0000000, or a binary number all of whose set bits are contiguous. All other values are reserved and must not be used by software.If BAS is zero, no bytes are watched by this watchpoint.Ignored if E is 0." range="12 - 5" rwaccess="R/W"/> 
		<bitfield id="LSC" width="2" begin="4" end="3" resetval="0x0" description="Load/store control. This field enables watchpoint matching on the type of access being made. Possible values of this field are:       01              Match instructions that load from a watchpointed address.                          10              Match instructions that store to a watchpointed address.                          11              Match instructions that load from or store to a watchpointed address.                   All other values are reserved, but must behave as if the watchpoint is disabled. Software must not rely on this property as the behavior of reserved values might change in a future revision of the architecture.Ignored if E is 0." range="4 - 3" rwaccess="R/W"/> 
		<bitfield id="PAC" width="2" begin="2" end="1" resetval="0x0" description="Privilege of access control. Determines the exception level or levels at which a watchpoint debug event for watchpoint n is generated. This field must be interpreted along with the SSC and HMC fields." range="2 - 1" rwaccess="R/W"/> 
		<bitfield id="E" width="1" begin="0" end="0" resetval="0x0" description="Enable watchpoint n. Possible values are:       0              Watchpoint disabled.                          1              Watchpoint enabled.                   " range="0" rwaccess="R/W"/>
	</register>
	<register id="APBADDR_DBG_CPU0_DBGWVR1_EL1_31_0" acronym="APBADDR_DBG_CPU0_DBGWVR1_EL1_31_0" offset="0x810" width="32" description="Debug Watchpoint Value Register 1">
		<bitfield id="VA" width="30" begin="31" end="2" resetval="0x0" description="Bits[48:2] of the address value for comparison.ARM deprecates setting DBGWVR&#60;n>_EL1[2] == 1." range="31 - 2" rwaccess="R/W"/> 
		<bitfield id="RES0_DBGWVR1_EL1_31_0_1_0" width="2" begin="1" end="0" resetval="0x0" description="Reserved, RES0." range="1 - 0" rwaccess="R/W"/>
	</register>
	<register id="APBADDR_DBG_CPU0_DBGWVR1_EL1_63_32" acronym="APBADDR_DBG_CPU0_DBGWVR1_EL1_63_32" offset="0x814" width="32" description="Debug Watchpoint Extended Value Register 1">
		<bitfield id="RESS" width="15" begin="31" end="17" resetval="0x0" description="Reserved, Sign extended. Hardwired to the value of the sign bit, bit [48]. Hardware and software must treat this field as RES0 if bit[48] is 0, and as RES1 if bit[48] is 1." range="31 - 17" rwaccess="R/W"/> 
		<bitfield id="VA" width="17" begin="16" end="0" resetval="0x0" description="Bits[48:2] of the address value for comparison.ARM deprecates setting DBGWVR&#60;n>_EL1[2] == 1." range="16 - 0" rwaccess="R/W"/>
	</register>
	<register id="APBADDR_DBG_CPU0_DBGWCR1_EL1" acronym="APBADDR_DBG_CPU0_DBGWCR1_EL1" offset="0x818" width="32" description="Debug Watchpoint Control Register 1">
		<bitfield id="RES0_DBGWCR1_EL1_31_29" width="3" begin="31" end="29" resetval="0x0" description="Reserved, RES0." range="31 - 29" rwaccess="R/W"/> 
		<bitfield id="MASK" width="5" begin="28" end="24" resetval="0x0" description="Address mask. Only objects up to 2GB can be watched using a single mask.       00000              No mask.                          00001              Reserved.                          00010              Reserved.                   Other values mask the corresponding number of address bits, from 0b00011 masking 3 address bits [0x00000007 mask for address] to 0b11111 masking 31 address bits [0x7FFFFFFF mask for address]." range="28 - 24" rwaccess="R/W"/> 
		<bitfield id="RES0_DBGWCR1_EL1_23_21" width="3" begin="23" end="21" resetval="0x0" description="Reserved, RES0." range="23 - 21" rwaccess="R/W"/> 
		<bitfield id="WT" width="1" begin="20" end="20" resetval="0x0" description="Watchpoint type. Possible values are:       0              Unlinked data address match.                          1              Linked data address match.                   " range="20" rwaccess="R/W"/> 
		<bitfield id="LBN" width="4" begin="19" end="16" resetval="0x0" description="Linked breakpoint number. For Linked data address watchpoints, this specifies the index of the Context-matching breakpoint linked to." range="19 - 16" rwaccess="R/W"/> 
		<bitfield id="SSC" width="2" begin="15" end="14" resetval="0x0" description="Security state control. Determines the security states under which a watchpoint debug event for watchpoint n is generated. This field must be interpreted along with the HMC and PAC fields." range="15 - 14" rwaccess="R/W"/> 
		<bitfield id="HMC" width="1" begin="13" end="13" resetval="0x0" description="Higher mode control. Determines the debug perspective for deciding when a watchpoint debug event for watchpoint n is generated. This field must be interpreted along with the SSC and PAC fields." range="13" rwaccess="R/W"/> 
		<bitfield id="BAS" width="8" begin="12" end="5" resetval="0x0" description="Byte address select. Each bit of this field selects whether a byte from within the word or double-word addressed by DBGWVR&#60;n>_EL1 is being watched.BASDescriptionxxxxxxx1Match byte at DBGWVR&#60;n>_EL1xxxxxx1xMatch byte at DBGWVR&#60;n>_EL1+1xxxxx1xxMatch byte at DBGWVR&#60;n>_EL1+2xxxx1xxxMatch byte at DBGWVR&#60;n>_EL1+3In cases where DBGWVR&#60;n>_EL1 addresses a double-word:BASDescription, if DBGWVR&#60;n>_EL1[2] == 0xxx1xxxxMatch byte at DBGWVR&#60;n>_EL1+4xx1xxxxxMatch byte at DBGWVR&#60;n>_EL1+5x1xxxxxxMatch byte at DBGWVR&#60;n>_EL1+61xxxxxxxMatch byte at DBGWVR&#60;n>_EL1+7If DBGWVR&#60;n>_EL1[2] == 1, only BAS[3:0] is used. ARM deprecates setting DBGWVR&#60;n>_EL1 == 1.The valid values for BAS are 0b0000000, or a binary number all of whose set bits are contiguous. All other values are reserved and must not be used by software.If BAS is zero, no bytes are watched by this watchpoint.Ignored if E is 0." range="12 - 5" rwaccess="R/W"/> 
		<bitfield id="LSC" width="2" begin="4" end="3" resetval="0x0" description="Load/store control. This field enables watchpoint matching on the type of access being made. Possible values of this field are:       01              Match instructions that load from a watchpointed address.                          10              Match instructions that store to a watchpointed address.                          11              Match instructions that load from or store to a watchpointed address.                   All other values are reserved, but must behave as if the watchpoint is disabled. Software must not rely on this property as the behavior of reserved values might change in a future revision of the architecture.Ignored if E is 0." range="4 - 3" rwaccess="R/W"/> 
		<bitfield id="PAC" width="2" begin="2" end="1" resetval="0x0" description="Privilege of access control. Determines the exception level or levels at which a watchpoint debug event for watchpoint n is generated. This field must be interpreted along with the SSC and HMC fields." range="2 - 1" rwaccess="R/W"/> 
		<bitfield id="E" width="1" begin="0" end="0" resetval="0x0" description="Enable watchpoint n. Possible values are:       0              Watchpoint disabled.                          1              Watchpoint enabled.                   " range="0" rwaccess="R/W"/>
	</register>
	<register id="APBADDR_DBG_CPU0_DBGWVR2_EL1_31_0" acronym="APBADDR_DBG_CPU0_DBGWVR2_EL1_31_0" offset="0x820" width="32" description="Debug Watchpoint Value Register 2">
		<bitfield id="VA" width="30" begin="31" end="2" resetval="0x0" description="Bits[48:2] of the address value for comparison.ARM deprecates setting DBGWVR&#60;n>_EL1[2] == 1." range="31 - 2" rwaccess="R/W"/> 
		<bitfield id="RES0_DBGWVR2_EL1_31_0_1_0" width="2" begin="1" end="0" resetval="0x0" description="Reserved, RES0." range="1 - 0" rwaccess="R/W"/>
	</register>
	<register id="APBADDR_DBG_CPU0_DBGWVR2_EL1_63_32" acronym="APBADDR_DBG_CPU0_DBGWVR2_EL1_63_32" offset="0x824" width="32" description="Debug Watchpoint Extended Value Register 2">
		<bitfield id="RESS" width="15" begin="31" end="17" resetval="0x0" description="Reserved, Sign extended. Hardwired to the value of the sign bit, bit [48]. Hardware and software must treat this field as RES0 if bit[48] is 0, and as RES1 if bit[48] is 1." range="31 - 17" rwaccess="R/W"/> 
		<bitfield id="VA" width="17" begin="16" end="0" resetval="0x0" description="Bits[48:2] of the address value for comparison.ARM deprecates setting DBGWVR&#60;n>_EL1[2] == 1." range="16 - 0" rwaccess="R/W"/>
	</register>
	<register id="APBADDR_DBG_CPU0_DBGWCR2_EL1" acronym="APBADDR_DBG_CPU0_DBGWCR2_EL1" offset="0x828" width="32" description="Debug Watchpoint Control Register 2">
		<bitfield id="RES0_DBGWCR2_EL1_31_29" width="3" begin="31" end="29" resetval="0x0" description="Reserved, RES0." range="31 - 29" rwaccess="R/W"/> 
		<bitfield id="MASK" width="5" begin="28" end="24" resetval="0x0" description="Address mask. Only objects up to 2GB can be watched using a single mask.       00000              No mask.                          00001              Reserved.                          00010              Reserved.                   Other values mask the corresponding number of address bits, from 0b00011 masking 3 address bits [0x00000007 mask for address] to 0b11111 masking 31 address bits [0x7FFFFFFF mask for address]." range="28 - 24" rwaccess="R/W"/> 
		<bitfield id="RES0_DBGWCR2_EL1_23_21" width="3" begin="23" end="21" resetval="0x0" description="Reserved, RES0." range="23 - 21" rwaccess="R/W"/> 
		<bitfield id="WT" width="1" begin="20" end="20" resetval="0x0" description="Watchpoint type. Possible values are:       0              Unlinked data address match.                          1              Linked data address match.                   " range="20" rwaccess="R/W"/> 
		<bitfield id="LBN" width="4" begin="19" end="16" resetval="0x0" description="Linked breakpoint number. For Linked data address watchpoints, this specifies the index of the Context-matching breakpoint linked to." range="19 - 16" rwaccess="R/W"/> 
		<bitfield id="SSC" width="2" begin="15" end="14" resetval="0x0" description="Security state control. Determines the security states under which a watchpoint debug event for watchpoint n is generated. This field must be interpreted along with the HMC and PAC fields." range="15 - 14" rwaccess="R/W"/> 
		<bitfield id="HMC" width="1" begin="13" end="13" resetval="0x0" description="Higher mode control. Determines the debug perspective for deciding when a watchpoint debug event for watchpoint n is generated. This field must be interpreted along with the SSC and PAC fields." range="13" rwaccess="R/W"/> 
		<bitfield id="BAS" width="8" begin="12" end="5" resetval="0x0" description="Byte address select. Each bit of this field selects whether a byte from within the word or double-word addressed by DBGWVR&#60;n>_EL1 is being watched.BASDescriptionxxxxxxx1Match byte at DBGWVR&#60;n>_EL1xxxxxx1xMatch byte at DBGWVR&#60;n>_EL1+1xxxxx1xxMatch byte at DBGWVR&#60;n>_EL1+2xxxx1xxxMatch byte at DBGWVR&#60;n>_EL1+3In cases where DBGWVR&#60;n>_EL1 addresses a double-word:BASDescription, if DBGWVR&#60;n>_EL1[2] == 0xxx1xxxxMatch byte at DBGWVR&#60;n>_EL1+4xx1xxxxxMatch byte at DBGWVR&#60;n>_EL1+5x1xxxxxxMatch byte at DBGWVR&#60;n>_EL1+61xxxxxxxMatch byte at DBGWVR&#60;n>_EL1+7If DBGWVR&#60;n>_EL1[2] == 1, only BAS[3:0] is used. ARM deprecates setting DBGWVR&#60;n>_EL1 == 1.The valid values for BAS are 0b0000000, or a binary number all of whose set bits are contiguous. All other values are reserved and must not be used by software.If BAS is zero, no bytes are watched by this watchpoint.Ignored if E is 0." range="12 - 5" rwaccess="R/W"/> 
		<bitfield id="LSC" width="2" begin="4" end="3" resetval="0x0" description="Load/store control. This field enables watchpoint matching on the type of access being made. Possible values of this field are:       01              Match instructions that load from a watchpointed address.                          10              Match instructions that store to a watchpointed address.                          11              Match instructions that load from or store to a watchpointed address.                   All other values are reserved, but must behave as if the watchpoint is disabled. Software must not rely on this property as the behavior of reserved values might change in a future revision of the architecture.Ignored if E is 0." range="4 - 3" rwaccess="R/W"/> 
		<bitfield id="PAC" width="2" begin="2" end="1" resetval="0x0" description="Privilege of access control. Determines the exception level or levels at which a watchpoint debug event for watchpoint n is generated. This field must be interpreted along with the SSC and HMC fields." range="2 - 1" rwaccess="R/W"/> 
		<bitfield id="E" width="1" begin="0" end="0" resetval="0x0" description="Enable watchpoint n. Possible values are:       0              Watchpoint disabled.                          1              Watchpoint enabled.                   " range="0" rwaccess="R/W"/>
	</register>
	<register id="APBADDR_DBG_CPU0_DBGWVR3_EL1_31_0" acronym="APBADDR_DBG_CPU0_DBGWVR3_EL1_31_0" offset="0x830" width="32" description="Debug Watchpoint Value Register 3">
		<bitfield id="VA" width="30" begin="31" end="2" resetval="0x0" description="Bits[48:2] of the address value for comparison.ARM deprecates setting DBGWVR&#60;n>_EL1[2] == 1." range="31 - 2" rwaccess="R/W"/> 
		<bitfield id="RES0_DBGWVR3_EL1_31_0_1_0" width="2" begin="1" end="0" resetval="0x0" description="Reserved, RES0." range="1 - 0" rwaccess="R/W"/>
	</register>
	<register id="APBADDR_DBG_CPU0_DBGWVR3_EL1_63_32" acronym="APBADDR_DBG_CPU0_DBGWVR3_EL1_63_32" offset="0x834" width="32" description="Debug Watchpoint Extended Value Register 3">
		<bitfield id="RESS" width="15" begin="31" end="17" resetval="0x0" description="Reserved, Sign extended. Hardwired to the value of the sign bit, bit [48]. Hardware and software must treat this field as RES0 if bit[48] is 0, and as RES1 if bit[48] is 1." range="31 - 17" rwaccess="R/W"/> 
		<bitfield id="VA" width="17" begin="16" end="0" resetval="0x0" description="Bits[48:2] of the address value for comparison.ARM deprecates setting DBGWVR&#60;n>_EL1[2] == 1." range="16 - 0" rwaccess="R/W"/>
	</register>
	<register id="APBADDR_DBG_CPU0_DBGWCR3_EL1" acronym="APBADDR_DBG_CPU0_DBGWCR3_EL1" offset="0x838" width="32" description="Debug Watchpoint Control Register 3">
		<bitfield id="RES0_DBGWCR3_EL1_31_29" width="3" begin="31" end="29" resetval="0x0" description="Reserved, RES0." range="31 - 29" rwaccess="R/W"/> 
		<bitfield id="MASK" width="5" begin="28" end="24" resetval="0x0" description="Address mask. Only objects up to 2GB can be watched using a single mask.       00000              No mask.                          00001              Reserved.                          00010              Reserved.                   Other values mask the corresponding number of address bits, from 0b00011 masking 3 address bits [0x00000007 mask for address] to 0b11111 masking 31 address bits [0x7FFFFFFF mask for address]." range="28 - 24" rwaccess="R/W"/> 
		<bitfield id="RES0_DBGWCR3_EL1_23_21" width="3" begin="23" end="21" resetval="0x0" description="Reserved, RES0." range="23 - 21" rwaccess="R/W"/> 
		<bitfield id="WT" width="1" begin="20" end="20" resetval="0x0" description="Watchpoint type. Possible values are:       0              Unlinked data address match.                          1              Linked data address match.                   " range="20" rwaccess="R/W"/> 
		<bitfield id="LBN" width="4" begin="19" end="16" resetval="0x0" description="Linked breakpoint number. For Linked data address watchpoints, this specifies the index of the Context-matching breakpoint linked to." range="19 - 16" rwaccess="R/W"/> 
		<bitfield id="SSC" width="2" begin="15" end="14" resetval="0x0" description="Security state control. Determines the security states under which a watchpoint debug event for watchpoint n is generated. This field must be interpreted along with the HMC and PAC fields." range="15 - 14" rwaccess="R/W"/> 
		<bitfield id="HMC" width="1" begin="13" end="13" resetval="0x0" description="Higher mode control. Determines the debug perspective for deciding when a watchpoint debug event for watchpoint n is generated. This field must be interpreted along with the SSC and PAC fields." range="13" rwaccess="R/W"/> 
		<bitfield id="BAS" width="8" begin="12" end="5" resetval="0x0" description="Byte address select. Each bit of this field selects whether a byte from within the word or double-word addressed by DBGWVR&#60;n>_EL1 is being watched.BASDescriptionxxxxxxx1Match byte at DBGWVR&#60;n>_EL1xxxxxx1xMatch byte at DBGWVR&#60;n>_EL1+1xxxxx1xxMatch byte at DBGWVR&#60;n>_EL1+2xxxx1xxxMatch byte at DBGWVR&#60;n>_EL1+3In cases where DBGWVR&#60;n>_EL1 addresses a double-word:BASDescription, if DBGWVR&#60;n>_EL1[2] == 0xxx1xxxxMatch byte at DBGWVR&#60;n>_EL1+4xx1xxxxxMatch byte at DBGWVR&#60;n>_EL1+5x1xxxxxxMatch byte at DBGWVR&#60;n>_EL1+61xxxxxxxMatch byte at DBGWVR&#60;n>_EL1+7If DBGWVR&#60;n>_EL1[2] == 1, only BAS[3:0] is used. ARM deprecates setting DBGWVR&#60;n>_EL1 == 1.The valid values for BAS are 0b0000000, or a binary number all of whose set bits are contiguous. All other values are reserved and must not be used by software.If BAS is zero, no bytes are watched by this watchpoint.Ignored if E is 0." range="12 - 5" rwaccess="R/W"/> 
		<bitfield id="LSC" width="2" begin="4" end="3" resetval="0x0" description="Load/store control. This field enables watchpoint matching on the type of access being made. Possible values of this field are:       01              Match instructions that load from a watchpointed address.                          10              Match instructions that store to a watchpointed address.                          11              Match instructions that load from or store to a watchpointed address.                   All other values are reserved, but must behave as if the watchpoint is disabled. Software must not rely on this property as the behavior of reserved values might change in a future revision of the architecture.Ignored if E is 0." range="4 - 3" rwaccess="R/W"/> 
		<bitfield id="PAC" width="2" begin="2" end="1" resetval="0x0" description="Privilege of access control. Determines the exception level or levels at which a watchpoint debug event for watchpoint n is generated. This field must be interpreted along with the SSC and HMC fields." range="2 - 1" rwaccess="R/W"/> 
		<bitfield id="E" width="1" begin="0" end="0" resetval="0x0" description="Enable watchpoint n. Possible values are:       0              Watchpoint disabled.                          1              Watchpoint enabled.                   " range="0" rwaccess="R/W"/>
	</register>
	<register id="APBADDR_DBG_CPU0_MIDR_EL1" acronym="APBADDR_DBG_CPU0_MIDR_EL1" offset="0xD00" width="32" description="Main ID Register">
		<bitfield id="IMPLEMENTER" width="8" begin="31" end="24" resetval="0x65" description="The Implementer code. This field must hold an implementer code that has been assigned by ARM." range="31 - 24" rwaccess="R/W"/> 
		<bitfield id="VARIANT" width="4" begin="23" end="20" resetval="0x0" description="An IMPLEMENTATION DEFINED variant number. Typically this field is used to distinguish between different product variants or major revisions of a product." range="23 - 20" rwaccess="R/W"/> 
		<bitfield id="ARCHITECTURE" width="4" begin="19" end="16" resetval="0x15" description=" " range="19 - 16" rwaccess="R/W"/> 
		<bitfield id="PARTNUM" width="12" begin="15" end="4" resetval="0x3331" description="An IMPLEMENTATION DEFINED primary part number for the device. On processors implemented by ARM if the top four bits of the primary part number are 0x0 or 0x7 the variant and architecture are encoded differently" range="15 - 4" rwaccess="R/W"/> 
		<bitfield id="REVISION" width="4" begin="3" end="0" resetval="0x4" description="An IMPLEMENTATION DEFINED revision number for the device" range="3 - 0" rwaccess="R/W"/>
	</register>
	<register id="APBADDR_DBG_CPU0_ID_AA64PFR0_EL1_31_0" acronym="APBADDR_DBG_CPU0_ID_AA64PFR0_EL1_31_0" offset="0xD20" width="32" description="Processor Feature Register 0 (low word)">
		<bitfield id="RES0_ID_AA64PFR0_EL1_31_0_31_28" width="4" begin="31" end="28" resetval="0x0" description="Reserved, RES0." range="31 - 28" rwaccess="R/W"/> 
		<bitfield id="GIC" width="4" begin="27" end="24" resetval="0x1" description="GIC system register interface. Permitted values are:       0000              No GIC system registers are supported.                          0001              GICv3 system registers are supported.                   All other values are reserved." range="27 - 24" rwaccess="R/W"/> 
		<bitfield id="ADVSIMD" width="4" begin="23" end="20" resetval="0x0" description="Advanced SIMD. Permitted values are:       0000              Advanced SIMD is implemented.                          1111              Advanced SIMD is not implemented.                   All other values are reserved." range="23 - 20" rwaccess="R/W"/> 
		<bitfield id="FP" width="4" begin="19" end="16" resetval="0x0" description="Floating-point. Permitted values are:       0000              Floating-point is implemented.                          1111              Floating-point is not implemented.                   All other values are reserved." range="19 - 16" rwaccess="R/W"/> 
		<bitfield id="EL3" width="4" begin="15" end="12" resetval="0x2" description="EL3 exception level handling. Permitted values are:       0000              EL3 is not implemented.                          0001              EL3 can be executed in AArch64 state only.                          0010              EL3 can be executed in either AArch64 or AArch32 state.                   All other values are reserved." range="15 - 12" rwaccess="R/W"/> 
		<bitfield id="EL2" width="4" begin="11" end="8" resetval="0x2" description="EL2 exception level handling. Permitted values are:       0000              EL2 is not implemented.                          0001              EL2 can be executed in AArch64 state only.                          0010              EL2 can be executed in either AArch64 or AArch32 state.                   All other values are reserved." range="11 - 8" rwaccess="R/W"/> 
		<bitfield id="EL1" width="4" begin="7" end="4" resetval="0x2" description="EL1 exception level handling. Permitted values are:       0000              EL1 is not implemented.                          0001              EL1 can be executed in AArch64 state only.                          0010              EL1 can be executed in either AArch64 or AArch32 state.                   All other values are reserved." range="7 - 4" rwaccess="R/W"/> 
		<bitfield id="EL0" width="4" begin="3" end="0" resetval="0x2" description="EL0 exception level handling. Permitted values are:       0000              EL0 is not implemented.                          0001              EL0 can be executed in AArch64 state only.                          0010              EL0 can be executed in either AArch64 or AArch32 state.                   All other values are reserved." range="3 - 0" rwaccess="R/W"/>
	</register>
	<register id="APBADDR_DBG_CPU0_ID_AA64PFR0_EL1_63_32" acronym="APBADDR_DBG_CPU0_ID_AA64PFR0_EL1_63_32" offset="0xD24" width="32" description="Processor Feature Register 0 (high word)">
		<bitfield id="RES0_ID_AA64PFR0_EL1_63_32_31_0" width="32" begin="31" end="0" resetval="0x0" description="Reserved, RES0." range="31 - 0" rwaccess="R/W"/>
	</register>
	<register id="APBADDR_DBG_CPU0_ID_AA64DFR0_EL1_31_0" acronym="APBADDR_DBG_CPU0_ID_AA64DFR0_EL1_31_0" offset="0xD28" width="32" description="Debug Feature Register 0 (low word)">
		<bitfield id="CTX_CMPS" width="4" begin="31" end="28" resetval="0x1" description="Number of breakpoints that are context-aware, minus 1. These are the highest numbered breakpoints." range="31 - 28" rwaccess="R/W"/> 
		<bitfield id="RES0_ID_AA64DFR0_EL1_31_0_27_24" width="4" begin="27" end="24" resetval="0x0" description="Reserved, RES0." range="27 - 24" rwaccess="R/W"/> 
		<bitfield id="WRPS" width="4" begin="23" end="20" resetval="0x3" description="Number of watchpoints, minus 1. The value of 0b0000 is reserved." range="23 - 20" rwaccess="R/W"/> 
		<bitfield id="RES0_ID_AA64DFR0_EL1_31_0_19_16" width="4" begin="19" end="16" resetval="0x0" description="Reserved, RES0." range="19 - 16" rwaccess="R/W"/> 
		<bitfield id="BRPS" width="4" begin="15" end="12" resetval="0x5" description="Number of breakpoints, minus 1. The value of 0b0000 is reserved." range="15 - 12" rwaccess="R/W"/> 
		<bitfield id="PMUVER" width="4" begin="11" end="8" resetval="0x1" description="Performance Monitors extension version. Indicates whether system register interface to Performance Monitors extension is implemented. Permitted values are:       0000              Performance Monitors extension system registers not implemented.                          0001              Performance Monitors extension system registers implemented, PMUv3.                          1111              IMPLEMENTATION DEFINED form of performance monitors supported, PMUv3 not supported.                   All other values are reserved." range="11 - 8" rwaccess="R/W"/> 
		<bitfield id="TRACEVER" width="4" begin="7" end="4" resetval="0x0" description="Trace extension. Indicates whether system register interface to Trace extension is implemented. Permitted values are:       0000              Trace extension system registers not implemented.                          0001              Trace extension system registers implemented.                   All other values are reserved.A value of 0b0000 only indicates that no system register interface to the trace extension is implemented. A trace extension may nevertheless be implemented without a system register interface." range="7 - 4" rwaccess="R/W"/> 
		<bitfield id="DEBUGVER" width="4" begin="3" end="0" resetval="0x6" description="Debug architecture version. Indicates presence of v8-A debug architecture.       0110              v8-A debug architecture.                   All other values are reserved." range="3 - 0" rwaccess="R/W"/>
	</register>
	<register id="APBADDR_DBG_CPU0_ID_AA64DFR0_EL1_63_32" acronym="APBADDR_DBG_CPU0_ID_AA64DFR0_EL1_63_32" offset="0xD2C" width="32" description="Debug Feature Register 0 (high word)">
		<bitfield id="RES0_ID_AA64DFR0_EL1_63_32_31_0" width="32" begin="31" end="0" resetval="0x0" description="Reserved, RES0." range="31 - 0" rwaccess="R/W"/>
	</register>
	<register id="APBADDR_DBG_CPU0_ID_AA64ISAR0_EL1_31_0" acronym="APBADDR_DBG_CPU0_ID_AA64ISAR0_EL1_31_0" offset="0xD30" width="32" description="Instruction Set Attribute Register 0 (low word)">
		<bitfield id="RES0_ID_AA64ISAR0_EL1_31_0_31_20" width="12" begin="31" end="20" resetval="0x0" description="Reserved, RES0." range="31 - 20" rwaccess="R/W"/> 
		<bitfield id="CRC32" width="4" begin="19" end="16" resetval="0x1" description="CRC32 instructions in AArch64. Possible values of this field are:       0000              No CRC32 instructions implemented.                          0001              CRC32B, CRC32H, CRC32W, CRC32X, CRC32CB, CRC32CH, CRC32CW, and CRC32CX instructions implemented.                   All other values are reserved.This field must have the same value as ID_ISAR5.CRC32. The architecture requires that if CRC32 is supported in one Execution state, it must be supported in both Execution states." range="19 - 16" rwaccess="R/W"/> 
		<bitfield id="SHA2" width="4" begin="15" end="12" resetval="0x1" description="SHA2 instructions in AArch64. Possible values of this field are:       0000              No SHA2 instructions implemented.                          0001              SHA256H, SHA256H2, SHA256SU0, and SHA256SU1 instructions implemented.                   All other values are reserved." range="15 - 12" rwaccess="R/W"/> 
		<bitfield id="SHA1" width="4" begin="11" end="8" resetval="0x1" description="SHA1 instructions in AArch64. Possible values of this field are:       0000              No SHA1 instructions implemented.                          0001              SHA1C, SHA1P, SHA1M, SHA1H, SHA1SU0, and SHA1SU1 instructions implemented.                   All other values are reserved." range="11 - 8" rwaccess="R/W"/> 
		<bitfield id="AES" width="4" begin="7" end="4" resetval="0x2" description="AES instructions in AArch64. Possible values of this field are:       0000              No AES instructions implemented.                          0001              AESE, AESD, AESMC, and AESIMC instructions implemented.                          0010              As for 0b0001, plus PMULL/PMULL2 instructions operating on 64-bit data quantities.                   " range="7 - 4" rwaccess="R/W"/> 
		<bitfield id="RES0_ID_AA64ISAR0_EL1_31_0_3_0" width="4" begin="3" end="0" resetval="0x0" description="Reserved, RES0." range="3 - 0" rwaccess="R/W"/>
	</register>
	<register id="APBADDR_DBG_CPU0_ID_AA64ISAR0_EL1_63_32" acronym="APBADDR_DBG_CPU0_ID_AA64ISAR0_EL1_63_32" offset="0xD34" width="32" description="Instruction Set Attribute Register 0 (high word)">
		<bitfield id="RES0_ID_AA64ISAR0_EL1_63_32_31_0" width="32" begin="31" end="0" resetval="0x0" description="Reserved, RES0." range="31 - 0" rwaccess="R/W"/>
	</register>
	<register id="APBADDR_DBG_CPU0_ID_AA64MMFR0_EL1_31_0" acronym="APBADDR_DBG_CPU0_ID_AA64MMFR0_EL1_31_0" offset="0xD38" width="32" description="Memory Model Feature Register 0 (low word)">
		<bitfield id="TGRAN4" width="4" begin="31" end="28" resetval="0x0" description="Support for 4 Kbyte memory translation granule size. Permitted values are:       0000              4 KB granule supported.                          1111              4 KB granule not supported.                   All other values are reserved." range="31 - 28" rwaccess="R/W"/> 
		<bitfield id="TGRAN64" width="4" begin="27" end="24" resetval="0x0" description="Support for 64 Kbyte memory translation granule size. Permitted values are:       0000              64 KB granule supported.                          1111              64 KB granule not supported.                   All other values are reserved." range="27 - 24" rwaccess="R/W"/> 
		<bitfield id="TGRAN16" width="4" begin="23" end="20" resetval="0x0" description="Support for 16 Kbyte memory translation granule size. Permitted values are:       0000              16 KB granule not supported.                          0001              16 KB granule supported.                   All other values are reserved." range="23 - 20" rwaccess="R/W"/> 
		<bitfield id="BIGENDEL0" width="4" begin="19" end="16" resetval="0x0" description="Mixed-endian support at EL0 only. Permitted values are:       0000              No mixed-endian support at EL0. The SCTLR_EL1.E0E bit has a fixed value.                          0001              Mixed-endian support at EL0. The SCTLR_EL1.E0E bit can be configured.                   All other values are reserved.This field is invalid and is RES0 if the BigEnd field, bits [11:8], is not 0b0000." range="19 - 16" rwaccess="R/W"/> 
		<bitfield id="SNSMEM" width="4" begin="15" end="12" resetval="0x1" description="Secure versus Non-secure Memory distinction. Permitted values are:       0000              Does not support a distinction between Secure and Non-secure Memory.                          0001              Does support a distinction between Secure and Non-secure Memory.                   All other values are reserved." range="15 - 12" rwaccess="R/W"/> 
		<bitfield id="BIGEND" width="4" begin="11" end="8" resetval="0x1" description="Mixed-endian configuration support. Permitted values are:       0000              No mixed-endian support. The SCTLR_ELx.EE bits have a fixed value. See the BigEndEL0 field, bits[19:16], for whether EL0 supports mixed-endian.                          0001              Mixed-endian support. The SCTLR_ELx.EE and SCTLR_EL1.E0E bits can be configured.                   All other values are reserved." range="11 - 8" rwaccess="R/W"/> 
		<bitfield id="ASIDBITS" width="4" begin="7" end="4" resetval="0x2" description="Number of ASID bits. Permitted values are:       0000              8 bits.                          0010              16 bits.                   All other values are reserved." range="7 - 4" rwaccess="R/W"/> 
		<bitfield id="PARANGE" width="4" begin="3" end="0" resetval="0x2" description="Physical Address range supported. Permitted values are:       0000              32 bits, 4 GB.                          0001              36 bits, 64 GB.                          0010              40 bits, 1 TB.                          0011              42 bits, 4 TB.                          0100              44 bits, 16 TB.                          0101              48 bits, 256 TB.                   All other values are reserved." range="3 - 0" rwaccess="R/W"/>
	</register>
	<register id="APBADDR_DBG_CPU0_ID_AA64MMFR0_EL1_63_32" acronym="APBADDR_DBG_CPU0_ID_AA64MMFR0_EL1_63_32" offset="0xD3C" width="32" description="Memory Model Feature Register 0 (high word)">
		<bitfield id="RES0_ID_AA64MMFR0_EL1_63_32_31_0" width="32" begin="31" end="0" resetval="0x0" description="Reserved, RES0." range="31 - 0" rwaccess="R/W"/>
	</register>
	<register id="APBADDR_DBG_CPU0_ID_AA64PFR1_EL1_31_0" acronym="APBADDR_DBG_CPU0_ID_AA64PFR1_EL1_31_0" offset="0xD40" width="32" description="Processor Feature Register 1 (low word)">
		<bitfield id="RES0_ID_AA64PFR1_EL1_31_0_31_0" width="32" begin="31" end="0" resetval="0x0" description="Reserved, RES0." range="31 - 0" rwaccess="R/W"/>
	</register>
	<register id="APBADDR_DBG_CPU0_ID_AA64PFR1_EL1_63_32" acronym="APBADDR_DBG_CPU0_ID_AA64PFR1_EL1_63_32" offset="0xD44" width="32" description="Processor Feature Register 1 (high word)">
		<bitfield id="RES0_ID_AA64PFR1_EL1_63_32_31_0" width="32" begin="31" end="0" resetval="0x0" description="Reserved, RES0." range="31 - 0" rwaccess="R/W"/>
	</register>
	<register id="APBADDR_DBG_CPU0_ID_AA64DFR1_EL1_31_0" acronym="APBADDR_DBG_CPU0_ID_AA64DFR1_EL1_31_0" offset="0xD48" width="32" description="Auxiliary Feature Register 1 (low word)">
		<bitfield id="RES0_ID_AA64DFR1_EL1_31_0_31_0" width="32" begin="31" end="0" resetval="0x0" description="Reserved, RES0." range="31 - 0" rwaccess="R/W"/>
	</register>
	<register id="APBADDR_DBG_CPU0_ID_AA64DFR1_EL1_63_32" acronym="APBADDR_DBG_CPU0_ID_AA64DFR1_EL1_63_32" offset="0xD4C" width="32" description="Auxiliary Feature Register 1 (high word)">
		<bitfield id="RES0_ID_AA64DFR1_EL1_63_32_31_0" width="32" begin="31" end="0" resetval="0x0" description="Reserved, RES0." range="31 - 0" rwaccess="R/W"/>
	</register>
	<register id="APBADDR_DBG_CPU0_ID_AA64ISAR1_EL1_31_0" acronym="APBADDR_DBG_CPU0_ID_AA64ISAR1_EL1_31_0" offset="0xD50" width="32" description="Instruction Set Attribute Register 1 (low word)">
		<bitfield id="RES0_ID_AA64ISAR1_EL1_31_0_31_0" width="32" begin="31" end="0" resetval="0x0" description="Reserved, RES0." range="31 - 0" rwaccess="R/W"/>
	</register>
	<register id="APBADDR_DBG_CPU0_ID_AA64ISAR1_EL1_63_32" acronym="APBADDR_DBG_CPU0_ID_AA64ISAR1_EL1_63_32" offset="0xD54" width="32" description="Instruction Set Attribute Register 1 (high word)">
		<bitfield id="RES0_ID_AA64ISAR1_EL1_63_32_31_0" width="32" begin="31" end="0" resetval="0x0" description="Reserved, RES0." range="31 - 0" rwaccess="R/W"/>
	</register>
	<register id="APBADDR_DBG_CPU0_ID_AA64MMFR1_EL1_31_0" acronym="APBADDR_DBG_CPU0_ID_AA64MMFR1_EL1_31_0" offset="0xD58" width="32" description="Memory Model Feature Register 1 (low word)">
		<bitfield id="RES0_ID_AA64MMFR1_EL1_31_0_31_0" width="32" begin="31" end="0" resetval="0x0" description="Reserved, RES0." range="31 - 0" rwaccess="R/W"/>
	</register>
	<register id="APBADDR_DBG_CPU0_ID_AA64MMFR1_EL1_63_32" acronym="APBADDR_DBG_CPU0_ID_AA64MMFR1_EL1_63_32" offset="0xD5C" width="32" description="Memory Model Feature Register 1 (high word)">
		<bitfield id="RES0_ID_AA64MMFR1_EL1_63_32_31_0" width="32" begin="31" end="0" resetval="0x0" description="Reserved, RES0." range="31 - 0" rwaccess="R/W"/>
	</register>
	<register id="APBADDR_DBG_CPU0_EDITCTRL" acronym="APBADDR_DBG_CPU0_EDITCTRL" offset="0xF00" width="32" description="External Debug Integration mode Control Register">
		<bitfield id="RES0_EDITCTRL_31_1" width="31" begin="31" end="1" resetval="0x0" description="Reserved, RES0." range="31 - 1" rwaccess="R/W"/> 
		<bitfield id="IME" width="1" begin="0" end="0" resetval="0x0" description="Integration mode enable. When IME == 1, the device reverts to an integration mode to enable integration testing or topology detection. The integration mode behavior is IMPLEMENTATION DEFINED.       0              Normal operation.                          1              Integration mode enabled.                   " range="0" rwaccess="R/W"/>
	</register>
	<register id="APBADDR_DBG_CPU0_DBGCLAIMSET_EL1" acronym="APBADDR_DBG_CPU0_DBGCLAIMSET_EL1" offset="0xFA0" width="32" description="Debug Claim Tag Set Register">
		<bitfield id="RES0_DBGCLAIMSET_EL1_31_8" width="24" begin="31" end="8" resetval="0x0" description="Reserved, RAZ/SBZ. Software can rely on these bits reading as zero, and must use a should-be-zero policy on writes. Implementations must ignore writes." range="31 - 8" rwaccess="R/W"/> 
		<bitfield id="CLAIM" width="8" begin="7" end="0" resetval="0x255" description="Claim set bits. RAO.Writing a 1 to one of these bits sets the corresponding CLAIM bit to 1. This is an indirect write to the CLAIM bits.A single write operation can set multiple bits to 1. Writing 0 to one of these bits has no effect." range="7 - 0" rwaccess="R/W"/>
	</register>
	<register id="APBADDR_DBG_CPU0_DBGCLAIMCLR_EL1" acronym="APBADDR_DBG_CPU0_DBGCLAIMCLR_EL1" offset="0xFA4" width="32" description="Debug Claim Tag Clear Register">
		<bitfield id="RES0_DBGCLAIMCLR_EL1_31_8" width="24" begin="31" end="8" resetval="0x0" description="Reserved, RAZ/SBZ. Software can rely on these bits reading as zero, and must use a should-be-zero policy on writes. Implementations must ignore writes." range="31 - 8" rwaccess="R/W"/> 
		<bitfield id="CLAIM" width="8" begin="7" end="0" resetval="0x0" description="Claim clear bits. Reading this field returns the current value of the CLAIM bits.Writing a 1 to one of these bits clears the corresponding CLAIM bit to 0. This is an indirect write to the CLAIM bits.A single write operation can clear multiple bits to 0. Writing 0 to one of these bits has no effect." range="7 - 0" rwaccess="R/W"/>
	</register>
	<register id="APBADDR_DBG_CPU0_EDDEVAFF0" acronym="APBADDR_DBG_CPU0_EDDEVAFF0" offset="0xFA8" width="32" description="External Debug Device Affinity Register 0">
		<bitfield id="EDDEVAFF0" width="32" begin="31" end="0" resetval="0x2147483648" description="MPIDR_EL1 low half. Read-only copy of the low half of MPIDR_EL1, as seen from the highest implemented exception level." range="31 - 0" rwaccess="R/W"/>
	</register>
	<register id="APBADDR_DBG_CPU0_EDDEVAFF1" acronym="APBADDR_DBG_CPU0_EDDEVAFF1" offset="0xFAC" width="32" description="External Debug Device Affinity Register 1">
		<bitfield id="EDDEVAFF1" width="32" begin="31" end="0" resetval="0x0" description="MPIDR_EL1 high half. Read-only copy of the high half of MPIDR_EL1, as seen from the highest implemented exception level." range="31 - 0" rwaccess="R/W"/>
	</register>
	<register id="APBADDR_DBG_CPU0_EDLAR" acronym="APBADDR_DBG_CPU0_EDLAR" offset="0xFB0" width="32" description="External Debug Lock Access Register">
		<bitfield id="KEY" width="32" begin="31" end="0" resetval="0x0" description="Lock Access control. Writing the key value 0xC5ACCE55 to this field unlocks the lock, enabling write accesses to this component's registers through a memory-mapped interface.Writing any other value to this register locks the lock, disabling write accesses to this component's registers through a memory mapped interface." range="31 - 0" rwaccess="R/W"/>
	</register>
	<register id="APBADDR_DBG_CPU0_EDLSR" acronym="APBADDR_DBG_CPU0_EDLSR" offset="0xFB4" width="32" description="External Debug Lock Status Register">
		<bitfield id="RES0_EDLSR_31_3" width="29" begin="31" end="3" resetval="0x0" description="Reserved, RES0." range="31 - 3" rwaccess="R/W"/> 
		<bitfield id="NTT" width="1" begin="2" end="2" resetval="0x0" description="Not thirty-two bit access required. RAZ." range="2" rwaccess="R/W"/> 
		<bitfield id="SLK" width="1" begin="1" end="1" resetval="0x0" description="Software lock status for this component. For an access to LSR that is not a memory-mapped access, or when the software lock is not implemented, this field is RES0.For memory-mapped accesses when the software lock is implemented, possible values of this field are:       0              Lock clear. Writes are permitted to this component's registers.                          1              Lock set. Writes to this component's registers are ignored, and reads have no side effects.                   " range="1" rwaccess="R/W"/> 
		<bitfield id="SLI" width="1" begin="0" end="0" resetval="0x0" description="Software lock implemented. For an access to LSR that is not a memory-mapped access, this field is RAZ. For memory-mapped accesses, the value of this field is IMPLEMENTATION DEFINED. Permitted values are:       0              Software lock not implemented or not memory-mapped access.                          1              Software lock implemented and memory-mapped access.                   " range="0" rwaccess="R/W"/>
	</register>
	<register id="APBADDR_DBG_CPU0_DBGAUTHSTATUS_EL1" acronym="APBADDR_DBG_CPU0_DBGAUTHSTATUS_EL1" offset="0xFB8" width="32" description="Debug Authentication Status register">
		<bitfield id="RES0_DBGAUTHSTATUS_EL1_31_8" width="24" begin="31" end="8" resetval="0x0" description="Reserved, RES0." range="31 - 8" rwaccess="R/W"/> 
		<bitfield id="SNID" width="2" begin="7" end="6" resetval="0x2" description="Secure non-invasive debug. Possible values of this field are:       00              Not implemented. EL3 is not implemented and the processor is Non-secure.                          10              Implemented and disabled. ExternalSecureNoninvasiveDebugEnabled[] == FALSE.                          11              Implemented and enabled. ExternalSecureNoninvasiveDebugEnabled[] == TRUE.                   Other values are reserved." range="7 - 6" rwaccess="R/W"/> 
		<bitfield id="SID" width="2" begin="5" end="4" resetval="0x2" description="Secure invasive debug. Possible values of this field are:       00              Not implemented. EL3 is not implemented and the processor is Non-secure.                          10              Implemented and disabled. ExternalSecureInvasiveDebugEnabled[] == FALSE.                          11              Implemented and enabled. ExternalSecureInvasiveDebugEnabled[] == TRUE.                   Other values are reserved." range="5 - 4" rwaccess="R/W"/> 
		<bitfield id="NSNID" width="2" begin="3" end="2" resetval="0x2" description="Non-secure non-invasive debug. Possible values of this field are:       00              Not implemented. EL3 is not implemented and the processor is Secure.                          10              Implemented and disabled. ExternalNoninvasiveDebugEnabled[] == FALSE.                          11              Implemented and enabled. ExternalNoninvasiveDebugEnabled[] == TRUE.                   Other values are reserved." range="3 - 2" rwaccess="R/W"/> 
		<bitfield id="NSID" width="2" begin="1" end="0" resetval="0x2" description="Non-secure invasive debug. Possible values of this field are:       00              Not implemented. EL3 is not implemented and the processor is Secure.                          10              Implemented and disabled. ExternalInvasiveDebugEnabled[] == FALSE.                          11              Implemented and enabled. ExternalInvasiveDebugEnabled[] == TRUE.                   Other values are reserved." range="1 - 0" rwaccess="R/W"/>
	</register>
	<register id="APBADDR_DBG_CPU0_EDDEVARCH" acronym="APBADDR_DBG_CPU0_EDDEVARCH" offset="0xFBC" width="32" description="External Debug Device Architecture Register">
		<bitfield id="ARCHITECT" width="11" begin="31" end="21" resetval="0x571" description="Defines the architecture of the component. For debug, this is ARM Limited.Bits [31:28] are the JEP 106 continuation code, 0x4.Bits [27:21] are the JEP 106 ID code, 0x3B." range="31 - 21" rwaccess="R/W"/> 
		<bitfield id="PRESENT" width="1" begin="20" end="20" resetval="0x1" description="When set to 1, indicates that the DEVARCH is present.This field is 1 in v8-A." range="20" rwaccess="R/W"/> 
		<bitfield id="REVISION" width="4" begin="19" end="16" resetval="0x0" description="Defines the architecture revision. For architectures defined by ARM this is the minor revision.For debug, the revision defined by v8-A is 0x0.All other values are reserved." range="19 - 16" rwaccess="R/W"/> 
		<bitfield id="ARCHID" width="16" begin="15" end="0" resetval="0x27157" description="Defines this part to be a v8-A debug component. For architectures defined by ARM this is further subdivided.For debug:Bits [15:12] are the architecture version, 0x6.Bits [11:0] are the architecture part number, 0xA15.This corresponds to debug architecture version v8-A." range="15 - 0" rwaccess="R/W"/>
	</register>
	<register id="APBADDR_DBG_CPU0_EDDEVID2" acronym="APBADDR_DBG_CPU0_EDDEVID2" offset="0xFC0" width="32" description="External Debug Device ID Register 2">
		<bitfield id="RES0_EDDEVID2_31_0" width="32" begin="31" end="0" resetval="0x0" description="Reserved, RES0." range="31 - 0" rwaccess="R/W"/>
	</register>
	<register id="APBADDR_DBG_CPU0_EDDEVID1" acronym="APBADDR_DBG_CPU0_EDDEVID1" offset="0xFC4" width="32" description="External Debug Device ID Register 1">
		<bitfield id="RES0_EDDEVID1_31_4" width="28" begin="31" end="4" resetval="0x0" description="Reserved, RES0." range="31 - 4" rwaccess="R/W"/> 
		<bitfield id="PCSROFFSET" width="4" begin="3" end="0" resetval="0x2" description="This field indicates the offset applied to PC samples returned by reads of EDPCSR. Permitted values of this field in v8-A are:       0000              EDPCSR not implemented.                          0010              EDPCSR implemented, and samples have no offset applied and do not sample the instruction set state in AArch32 state.                   " range="3 - 0" rwaccess="R/W"/>
	</register>
	<register id="APBADDR_DBG_CPU0_EDDEVID" acronym="APBADDR_DBG_CPU0_EDDEVID" offset="0xFC8" width="32" description="External Debug Device ID Register 0">
		<bitfield id="RES0_EDDEVID_31_28" width="4" begin="31" end="28" resetval="0x0" description="Reserved, RES0." range="31 - 28" rwaccess="R/W"/> 
		<bitfield id="AUXREGS" width="4" begin="27" end="24" resetval="0x0" description="Indicates support for Auxiliary registers. Permitted values for this field are:       0000              None supported.                          0001              Support for External Debug Auxiliary Control Register, EDACR.                   All other values are reserved." range="27 - 24" rwaccess="R/W"/> 
		<bitfield id="RES0_EDDEVID_23_4" width="20" begin="23" end="4" resetval="0x0" description="Reserved, RES0." range="23 - 4" rwaccess="R/W"/> 
		<bitfield id="PCSAMPLE" width="4" begin="3" end="0" resetval="0x3" description="Indicates the level of Sample-based profiling support using external debug registers 40 through 43. Permitted values of this field in v8-A are:       0000              Architecture-defined form of Sample-based profiling not implemented.                          0010              EDPCSR and EDCIDSR are implemented [only permitted if EL3 and EL2 are not implemented].                          0011              EDPCSR, EDCIDSR, and EDVIDSR are implemented.                   All other values are reserved." range="3 - 0" rwaccess="R/W"/>
	</register>
	<register id="APBADDR_DBG_CPU0_EDDEVTYPE" acronym="APBADDR_DBG_CPU0_EDDEVTYPE" offset="0xFCC" width="32" description="External Debug Device Type Register">
		<bitfield id="RES0_EDDEVTYPE_31_8" width="24" begin="31" end="8" resetval="0x0" description="Reserved, RES0." range="31 - 8" rwaccess="R/W"/> 
		<bitfield id="SUB" width="4" begin="7" end="4" resetval="0x1" description="Subtype. Must read as 0x1 to indicate this is a processor component." range="7 - 4" rwaccess="R/W"/> 
		<bitfield id="MAJOR" width="4" begin="3" end="0" resetval="0x5" description="Major type. Must read as 0x5 to indicate this is a debug logic component." range="3 - 0" rwaccess="R/W"/>
	</register>
	<register id="APBADDR_DBG_CPU0_EDPIDR4" acronym="APBADDR_DBG_CPU0_EDPIDR4" offset="0xFD0" width="32" description="External Debug Peripheral Identification Register 4">
		<bitfield id="RES0_EDPIDR4_31_8" width="24" begin="31" end="8" resetval="0x0" description="Reserved, RES0." range="31 - 8" rwaccess="R/W"/> 
		<bitfield id="SIZE" width="4" begin="7" end="4" resetval="0x0" description="Size of the component. RAZ. Log2 of the number of 4KB pages from the start of the component to the end of the component ID registers." range="7 - 4" rwaccess="R/W"/> 
		<bitfield id="DES_2" width="4" begin="3" end="0" resetval="0x4" description="Designer, JEP106 continuation code, least significant nibble. For ARM Limited, this field is 0b0100." range="3 - 0" rwaccess="R/W"/>
	</register>
	<register id="APBADDR_DBG_CPU0_EDPIDR0" acronym="APBADDR_DBG_CPU0_EDPIDR0" offset="0xFE0" width="32" description="External Debug Peripheral Identification Register 0">
		<bitfield id="RES0_EDPIDR0_31_8" width="24" begin="31" end="8" resetval="0x0" description="Reserved, RES0." range="31 - 8" rwaccess="R/W"/> 
		<bitfield id="PART_0" width="8" begin="7" end="0" resetval="0x3" description="Part number, least significant byte." range="7 - 0" rwaccess="R/W"/>
	</register>
	<register id="APBADDR_DBG_CPU0_EDPIDR1" acronym="APBADDR_DBG_CPU0_EDPIDR1" offset="0xFE4" width="32" description="External Debug Peripheral Identification Register 1">
		<bitfield id="RES0_EDPIDR1_31_8" width="24" begin="31" end="8" resetval="0x0" description="Reserved, RES0." range="31 - 8" rwaccess="R/W"/> 
		<bitfield id="DES_0" width="4" begin="7" end="4" resetval="0x11" description="Designer, least significant nibble of JEP106 ID code. For ARM Limited, this field is 0b1011." range="7 - 4" rwaccess="R/W"/> 
		<bitfield id="PART_1" width="4" begin="3" end="0" resetval="0x13" description="Part number, most significant nibble." range="3 - 0" rwaccess="R/W"/>
	</register>
	<register id="APBADDR_DBG_CPU0_EDPIDR2" acronym="APBADDR_DBG_CPU0_EDPIDR2" offset="0xFE8" width="32" description="External Debug Peripheral Identification Register 2">
		<bitfield id="RES0_EDPIDR2_31_8" width="24" begin="31" end="8" resetval="0x0" description="Reserved, RES0." range="31 - 8" rwaccess="R/W"/> 
		<bitfield id="REVISION" width="4" begin="7" end="4" resetval="0x4" description="Part major revision. Parts can also use this field to extend Part number to 16-bits." range="7 - 4" rwaccess="R/W"/> 
		<bitfield id="JEDEC" width="1" begin="3" end="3" resetval="0x1" description="RAO. Indicates a JEP106 identity code is used." range="3" rwaccess="R/W"/> 
		<bitfield id="DES_1" width="3" begin="2" end="0" resetval="0x3" description="Designer, most significant bits of JEP106 ID code. For ARM Limited, this field is 0b011." range="2 - 0" rwaccess="R/W"/>
	</register>
	<register id="APBADDR_DBG_CPU0_EDPIDR3" acronym="APBADDR_DBG_CPU0_EDPIDR3" offset="0xFEC" width="32" description="External Debug Peripheral Identification Register 3">
		<bitfield id="RES0_EDPIDR3_31_8" width="24" begin="31" end="8" resetval="0x0" description="Reserved, RES0." range="31 - 8" rwaccess="R/W"/> 
		<bitfield id="REVAND" width="4" begin="7" end="4" resetval="0x0" description="Part minor revision. Parts using EDPIDR2.REVISION as an extension to the Part number must use this field as a major revision number." range="7 - 4" rwaccess="R/W"/> 
		<bitfield id="CMOD" width="4" begin="3" end="0" resetval="0x0" description="Customer modified. Indicates someone other than the Designer has modified the component." range="3 - 0" rwaccess="R/W"/>
	</register>
	<register id="APBADDR_DBG_CPU0_EDCIDR0" acronym="APBADDR_DBG_CPU0_EDCIDR0" offset="0xFF0" width="32" description="External Debug Component Identification Register 0">
		<bitfield id="RES0_EDCIDR0_31_8" width="24" begin="31" end="8" resetval="0x0" description="Reserved, RES0." range="31 - 8" rwaccess="R/W"/> 
		<bitfield id="PRMBL_0" width="8" begin="7" end="0" resetval="0x13" description="Preamble. Must read as 0x0D." range="7 - 0" rwaccess="R/W"/>
	</register>
	<register id="APBADDR_DBG_CPU0_EDCIDR1" acronym="APBADDR_DBG_CPU0_EDCIDR1" offset="0xFF4" width="32" description="External Debug Component Identification Register 1">
		<bitfield id="RES0_EDCIDR1_31_8" width="24" begin="31" end="8" resetval="0x0" description="Reserved, RES0." range="31 - 8" rwaccess="R/W"/> 
		<bitfield id="CLASS" width="4" begin="7" end="4" resetval="0x9" description="Component class. Reads as 0x9, debug component." range="7 - 4" rwaccess="R/W"/> 
		<bitfield id="PRMBL_1" width="4" begin="3" end="0" resetval="0x0" description="Preamble. RAZ." range="3 - 0" rwaccess="R/W"/>
	</register>
	<register id="APBADDR_DBG_CPU0_EDCIDR2" acronym="APBADDR_DBG_CPU0_EDCIDR2" offset="0xFF8" width="32" description="External Debug Component Identification Register 2">
		<bitfield id="RES0_EDCIDR2_31_8" width="24" begin="31" end="8" resetval="0x0" description="Reserved, RES0." range="31 - 8" rwaccess="R/W"/> 
		<bitfield id="PRMBL_2" width="8" begin="7" end="0" resetval="0x5" description="Preamble. Must read as 0x05." range="7 - 0" rwaccess="R/W"/>
	</register>
	<register id="APBADDR_DBG_CPU0_EDCIDR3" acronym="APBADDR_DBG_CPU0_EDCIDR3" offset="0xFFC" width="32" description="External Debug Component Identification Register 3">
		<bitfield id="RES0_EDCIDR3_31_8" width="24" begin="31" end="8" resetval="0x0" description="Reserved, RES0." range="31 - 8" rwaccess="R/W"/> 
		<bitfield id="PRMBL_3" width="8" begin="7" end="0" resetval="0x177" description="Preamble. Must read as 0xB1." range="7 - 0" rwaccess="R/W"/>
	</register>
</module>