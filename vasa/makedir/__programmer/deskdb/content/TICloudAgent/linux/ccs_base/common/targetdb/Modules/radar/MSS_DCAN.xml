<?xml version="1.0" encoding="UTF-8" standalone="yes"?>


<module description="MSS_DCAN" id="MSS_DCAN">
  
  
  <register acronym="CTL" description="CAN Control Register  The Bus-Off recovery sequence (refer to CAN specification) cannot be shortened by setting or resetting Init bit. If the module goes Bus-Off, it will automatically set the Init bit and stop all bus activities. When the Init bit is cleared by the application again, the module will then wait for 129 occurrences of Bus Idle (129 * 11 consecutive recessive bits) before resuming normal operation. At the end of the bus-off recovery sequence, the error counters will be reset. After the Init bit is reset, each time when a sequence of 11 recessive bits is monitored, a Bit0 error code is written to the error and status register, enabling the CPU to check whether the CAN bus is stuck at dominant or continuously disturbed, and to monitor the proceeding of the bus-off recovery sequence." id="CTL" offset="0x0" width="32">
    
  <bitfield begin="31" description="Reserved" end="26" id="Reserved1" rwaccess="R" width="6"></bitfield>
    
  <bitfield begin="25" description="Automatic wake up on bus activity when in local power-down mode. Note: The CAN message, which initiates the bus activity, cannot be received. This means that the first message received in power down and automatic wake-up mode, will be lost." end="25" id="WUBA" rwaccess="RW" width="1">
    <bitenum description="Detection of a dominant CAN bus level while in local power-down mode is enabled. On occurrence of a dominant CAN bus level, the wake up sequence is started." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="No detection of a dominant CAN bus level while in local power-down mode." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="24" description="Request for local low power-down mode" end="24" id="PDR" rwaccess="RW" width="1">
    <bitenum description="Local power-down mode has been requested by application. The DCAN will acknowledge the local power-down mode by setting bit PDA in the error and status register. The local clocks will be turned off by DCAN internal logic." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="No application request for local low power-down mode. If the application has cleared this bit while DCAN in local power-down mode, also the Init bit has to be cleared." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="23" description="Reserved" end="21" id="Reserved2" rwaccess="R" width="3"></bitfield>
    
  <bitfield begin="20" description="Enable DMA request line for IF3. Note: A pending DMA request for IF3 remains active until first access to one of the IF3 registers." end="20" id="DE3" rwaccess="RW" width="1">
    <bitenum description="Enabled" id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="Disabled" id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="19" description="Enable DMA request line for IF2. Note: A pending DMA request for IF2 remains active until first access to one of the IF2 registers." end="19" id="DE2" rwaccess="RW" width="1">
    <bitenum description="Enabled" id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="Disabled" id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="18" description="Enable DMA request line for IF1. Note: A pending DMA request for IF1 remains active until first access to one of the IF1 registers." end="18" id="DE1" rwaccess="RW" width="1">
    <bitenum description="Enabled" id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="Disabled" id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="17" description="Interrupt line 1 enable" end="17" id="IE1" rwaccess="RW" width="1">
    <bitenum description="Enabled - interrupts will assert line DCAN1INT to one; line remains active until pending interrupts are processed." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="Disabled - Module interrupt DCAN1INT is always low." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="16" description="Internal init state while debug access" end="16" id="InitDbg" rwaccess="R" width="1">
    <bitenum description="Debug mode requested and internally entered; the DCAN is ready for debug accesses." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="Not in debug mode, or debug mode requested but not entered." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="15" description="SW reset enable. Note: To execute software reset, the following procedure is necessary: (a) Set Init bit to shut down CAN communication and (b) Set SWR bit additionally to Init bit." end="15" id="SWR" rwaccess="RW" width="1">
    <bitenum description="Module is forced to reset state. This bit will automatically get cleared after execution of SW reset after one OCP clock cycle." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="Normal Operation" id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="14" description="Reserved" end="14" id="Reserved3" rwaccess="R" width="1"></bitfield>
    
  <bitfield begin="13" description="Parity on/off. 5 = Parity function disabled. Others = Parity function enabled." end="10" id="PMD" rwaccess="RW" width="4"></bitfield>
    
  <bitfield begin="9" description="Auto-Bus-On enable" end="9" id="ABO" rwaccess="RW" width="1">
    <bitenum description="The Auto-Bus-On feature is enabled" id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="The Auto-Bus-On feature is disabled" id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="8" description="Interruption debug support enable" end="8" id="IDS" rwaccess="RW" width="1">
    <bitenum description="When Debug/Suspend mode is requested, DCAN will interrupt any transmission or reception, and enter Debug/Suspend mode immediately." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="When Debug/Suspend mode is requested, DCAN will wait for a started transmission or reception to be completed before entering Debug/Suspend mode" id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="7" description="Test mode enable" end="7" id="Test" rwaccess="RW" width="1">
    <bitenum description="Test Mode" id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="Normal Operation" id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="6" description="Configuration change enable" end="6" id="CCE" rwaccess="RW" width="1">
    <bitenum description="The CPU has write access to the configuration registers (when Init bit is set)." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="The CPU has no write access to the configuration registers." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="5" description="Disable automatic retransmission" end="5" id="DAR" rwaccess="RW" width="1">
    <bitenum description="Automatic retransmission disabled." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="Automatic retransmission of not successful messages enabled." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="4" description="Reserved" end="4" id="Reserved4" rwaccess="R" width="1"></bitfield>
    
  <bitfield begin="3" description="Error interrupt enable" end="3" id="EIE" rwaccess="RW" width="1">
    <bitenum description="Enabled - PER, BOff and EWarn bits can generate an interrupt at DCAN0INT line and affect the interrupt register." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="Disabled - PER, BOff and EWarn bits can not generate an interrupt." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="2" description="Status change interrupt enable" end="2" id="SIE" rwaccess="RW" width="1">
    <bitenum description="Enabled - WakeUpPnd, RxOk, TxOk and LEC can generate an interrupt at DCAN0INT line and affect the interrupt register." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="Disabled - WakeUpPnd, RxOk, TxOk and LEC bits can not generate an interrupt." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="1" description="Interrupt line 0 enable" end="1" id="IE0" rwaccess="RW" width="1">
    <bitenum description="Enabled - interrupts will assert line DCAN0INT to one; line remains active until pending interrupts are processed." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="Disabled - Module interrupt DCAN0INT is always low." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="0" description="Initialization" end="0" id="Init" rwaccess="RW" width="1">
    <bitenum description="Initialization mode is entered" id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="Normal operation" id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
  </register>
  
  
  <register acronym="ES" description="Status Register  Interrupts are generated by bits PER, BOff and EWarn (if EIE bit in CAN control register is set) and by bits WakeUpPnd, RxOk, TxOk, and LEC (if SIE bit in CAN control register is set). A change of bit EPass will not generate an interrupt. Reading the error and status register clears the WakeUpPnd, PER, RxOk and TxOk bits and set the LEC to value '7.' Additionally, the status interrupt value (0x8000) in the interrupt register will be replaced by the next lower priority interrupt value. The EOI for all other interrupts (DCANINT0 and DCANINT1) are automatically handled by hardware. For debug support, the auto clear functionality of error and status register (clear of status flags by read) is disabled when in debug/suspend mode." id="ES" offset="0x4" width="32">
    
  <bitfield begin="31" description="Reserved" end="11" id="Reserved1" rwaccess="R" width="21"></bitfield>
    
  <bitfield begin="10" description="Local power-down mode acknowledge" end="10" id="PDA" rwaccess="R" width="1">
    <bitenum description="Application request for setting DCAN to local power-down mode was successful. DCAN is in local power-down mode." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="DCAN is not in local power-down mode." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="9" description="Wake up pending. This bit can be used by the CPU to identify the DCAN as the source to wake up the system. This bit will be reset if error and status register is read." end="9" id="WakeUp_Pnd" rwaccess="R" width="1">
    <bitenum description="DCAN has initiated a wake up of the system due to dominant CAN bus while module power down." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="No Wake Up is requested by DCAN." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="8" description="Parity error detected. This bit will be reset if error and status register is read." end="8" id="PER" rwaccess="R" width="1">
    <bitenum description="The parity check mechanism has detected a parity error in the Message RAM." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="No parity error has been detected since last read access." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="7" description="Bus-Off state" end="7" id="BOff" rwaccess="R" width="1">
    <bitenum description="The CAN module is in bus-off state." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="The CAN module is not bus-off state." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="6" description="Warning state" end="6" id="EWarn" rwaccess="R" width="1">
    <bitenum description="At least one of the error counters has reached the error warning limit of 96." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="Both error counters are below the error warning limit of 96." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="5" description="Error passive state" end="5" id="EPass" rwaccess="R" width="1">
    <bitenum description="The CAN core is in the error passive state as defined in the CAN Specification." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="On CAN Bus error, the DCAN could send active error frames." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="4" description="Received a message successfully. This bit will be reset if error and status register is read." end="4" id="RxOk" rwaccess="R" width="1">
    <bitenum description="A message has been successfully received since the last time when this bit was reset by a read access of the CPU (independent of the result of acceptance filtering)." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="No message has been successfully received since the last time when this bit was read by the CPU. This bit is never reset by DCAN internal events." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="3" description="Transmitted a message successfully. This bit will be reset if error and status register is read." end="3" id="TxOk" rwaccess="R" width="1">
    <bitenum description="A message has been successfully transmitted (error free and acknowledged by at least one other node) since the last time when this bit was reset by a read access of the CPU." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="No message has been successfully transmitted since the last time when this bit was read by the CPU. This bit is never reset by DCAN internal events." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="2" description="Last error code. The LEC field indicates the type of the last error on the CAN bus. This field will be cleared to '0' when a message has been transferred (reception or transmission) without error." end="0" id="LEC" rwaccess="R" width="3">
    <bitenum description="No CAN bus event was detected since the last time the CPU read the error and status register. Any read access to the error and status register re-initializes the LEC to value '7.'" id="en_8_0x7" token="en_8_0x7" value="0x7"></bitenum>
    <bitenum description="CRC error. In a received message, the CRC check sum was incorrect. (CRC received for an incoming message does not match the calculated CRC for the received data)." id="en_7_0x6" token="en_7_0x6" value="0x6"></bitenum>
    <bitenum description="Bit0 error. During the transmission of a message (or acknowledge bit, or active error flag, or overload flag), the device wanted to send a dominant level (logical value '0'), but the monitored bus level was recessive. During Bus-Off recovery, this status is set each time a sequence of 11 recessive bits has been monitored. This enables the CPU to monitor the proceeding of the Bus-Off recovery sequence (indicating the bus is not stuck at dominant or continuously disturbed)." id="en_6_0x5" token="en_6_0x5" value="0x5"></bitenum>
    <bitenum description="Bit1 error. During the transmission of a message (with the exception of the arbitration field), the device wanted to send a recessive level (bit of logical value '1'), but the monitored bus value was dominant." id="en_5_0x4" token="en_5_0x4" value="0x4"></bitenum>
    <bitenum description="Ack error. The message this CAN core transmitted was not acknowledged by another node." id="en_4_0x3" token="en_4_0x3" value="0x3"></bitenum>
    <bitenum description="Form error. A fixed format part of a received frame has the wrong format." id="en_3_0x2" token="en_3_0x2" value="0x2"></bitenum>
    <bitenum description="Stuff error. More than five equal bits in a row have been detected in a part of a received message where this is not allowed." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="No error" id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
  </register>
  
  
  <register acronym="ERRC" description="Error Counter Register" id="ERRC" offset="0x8" width="32">
    
  <bitfield begin="31" description="Reserved" end="16" id="Reserved1" rwaccess="R" width="16"></bitfield>
    
  <bitfield begin="15" description="Receive error passive" end="15" id="RP" rwaccess="R" width="1">
    <bitenum description="The receive error counter has reached the error passive level as defined in the CAN specification." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="The receive error counter is below the error passive level." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="14" description="Receive error counter. Actual state of the receive error counter (values from 0 to 255)." end="8" id="REC" rwaccess="R" width="7"></bitfield>
    
  <bitfield begin="7" description="Transmit error counter. Actual state of the transmit error counter (values from 0 to 255)." end="0" id="TEC" rwaccess="R" width="8"></bitfield>
  </register>
  
  
  <register acronym="BTR" description="Bit Timing/BRP Extension Register  This register is only writable if CCE and Init bits in the CAN control register are set. The CAN bit time may be programmed in the range of 8 to 25 time quanta. The CAN time quantum may be programmed in the range of 1 to1024 CAN_CLK periods. With a CAN_CLK of 8 MHz and BRPE = 0x00, the reset value of 0x00002301 configures the DCAN for a bit rate of 500kBit/s." id="BTR" offset="0xC" width="32">
    
  <bitfield begin="31" description="Reserved" end="20" id="Reserved1" rwaccess="R" width="12"></bitfield>
    
  <bitfield begin="19" description="Baud rate prescaler extension. Valid programmed values are 0 to 15. By programming BRPE the baud rate prescaler can be extended to values up to 1024." end="16" id="BRPE" rwaccess="R" width="4"></bitfield>
    
  <bitfield begin="15" description="Reserved" end="15" id="Reserved2" rwaccess="R" width="1"></bitfield>
    
  <bitfield begin="14" description="Time segment after the sample point. Valid programmed values are 0 to 7. The actual TSeg2 value which is interpreted for the bit timing will be the programmed TSeg2 value + 1." end="12" id="TSeg2" rwaccess="RW" width="3"></bitfield>
    
  <bitfield begin="11" description="Time segment before the sample point. Valid programmed values are 1 to 15. The actual TSeg1 value interpreted for the bit timing will be the programmed TSeg1 value + 1." end="8" id="TSeg1" rwaccess="RW" width="4"></bitfield>
    
  <bitfield begin="7" description="Synchronization Jump Width. Valid programmed values are 0 to 3. The actual SJW value interpreted for the synchronization will be the programmed SJW value + 1." end="6" id="SJW" rwaccess="RW" width="2"></bitfield>
    
  <bitfield begin="5" description="Baud rate prescaler. Value by which the CAN_CLK frequency is divided for generating the bit time quanta. The bit time is built up from a multiple of this quanta. Valid programmed values are 0 to 63. The actual BRP value interpreted for the bit timing will be the programmed BRP value + 1." end="0" id="BRP" rwaccess="RW" width="6"></bitfield>
  </register>
  
  
  <register acronym="INT" description="Interrupt Register" id="INT" offset="0x10" width="32">
    
  <bitfield begin="31" description="Reserved" end="24" id="Reserved1" rwaccess="R" width="8"></bitfield>
    
  <bitfield begin="23" description="Interrupt 1 Identifier (indicates the message object with the highest pending interrupt). If several interrupts are pending, the CAN interrupt register will point to the pending interrupt with the highest priority. The DCAN1INT interrupt line remains active until Int1ID reaches value 0 (the cause of the interrupt is reset) or until IE1 is cleared. A message interrupt is cleared by clearing the message object's IntPnd bit. Among the message interrupts, the message object's interrupt priority decreases with increasing message number." end="16" id="Int1ID" rwaccess="R" width="8">
    <bitenum description="Number of message object which caused the interrupt." id="en_3_0x80" token="en_3_0x80" value="0x80"></bitenum>
    <bitenum description="No interrupt is pending." id="en_2_0x0" token="en_2_0x0" value="0x0"></bitenum>
    <bitenum description="Unused." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="15" description="Interrupt Identifier (the number here indicates the source of the interrupt). If several interrupts are pending, the CAN interrupt register will point to the pending interrupt with the highest priority. The DCAN0INT interrupt line remains active until Int0ID reaches value 0 (the cause of the interrupt is reset) or until IE0 is cleared. The Status interrupt has the highest priority. Among the message interrupts, the message object's interrupt priority decreases with increasing message number." end="0" id="Int0ID" rwaccess="R" width="16">
    <bitenum description="Error and status register value is not 0x07." id="en_5_0x1F40" token="en_5_0x1F40" value="0x1F40"></bitenum>
    <bitenum description="Number of message object which caused the interrupt." id="en_4_0x0080" token="en_4_0x0080" value="0x0080"></bitenum>
    <bitenum description="Unused." id="en_3_0x0" token="en_3_0x0" value="0x0"></bitenum>
    <bitenum description="No interrupt is pending." id="en_2_0x0" token="en_2_0x0" value="0x0"></bitenum>
    <bitenum description="Unused (values 0081 to 7FFF)." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
  </register>
  
  
  <register acronym="TEST" description="Test Register  For all test modes, the test bit in CAN control register needs to be set to one. If test bit is set, the RDA, EXL, Tx1, Tx0, LBack and Silent bits are writable. Bit Rx monitors the state of pin CAN_RX and therefore is only readable. All test register functions are disabled when test bit is cleared. The test register is only writable if test bit in CAN control register is set. Setting Tx[1:0] other than '00' will disturb message transfer. When the internal loop-back mode is active (bit LBack is set), bit EXL will be ignored." id="TEST" offset="0x14" width="32">
    
  <bitfield begin="31" description="Reserved" end="10" id="Reserved1" rwaccess="R" width="22"></bitfield>
    
  <bitfield begin="9" description="RAM direct access enable" end="9" id="RDA" rwaccess="RW" width="1">
    <bitenum description="Direct access to the RAM is enabled while in test mode" id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="Normal operation" id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="8" description="External loopback mode" end="8" id="EXL" rwaccess="RW" width="1">
    <bitenum description="Enabled" id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="Disabled" id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="7" description="Receive pin. Monitors the actual value of the CAN_RX pin" end="7" id="Rx" rwaccess="R" width="1">
    <bitenum description="The CAN bus is recessive" id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="The CAN bus is dominant" id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="6" description="Control of CAN_TX pin." end="5" id="Tx" rwaccess="RW" width="2">
    <bitenum description="CAN_TX pin drives a recessive value." id="en_4_0xB" token="en_4_0xB" value="0xB"></bitenum>
    <bitenum description="CAN_TX pin drives a dominant value." id="en_3_0xA" token="en_3_0xA" value="0xA"></bitenum>
    <bitenum description="Sample point can be monitored at CAN_TX pin." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="Normal operation, CAN_TX is controlled by the CAN core." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="4" description="Loopback mode" end="4" id="LBack" rwaccess="RW" width="1">
    <bitenum description="Enabled" id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="Disabled" id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="3" description="Silent mode" end="3" id="Silent" rwaccess="RW" width="1">
    <bitenum description="Enabled" id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="Disabled" id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="2" description="Reserved" end="0" id="Reserved2" rwaccess="R" width="3"></bitfield>
  </register>
  
  
  <register acronym="Reserved_1" id="Reserved_1" offset="0x18" width="32">
    
  <bitfield begin="31" description="Reserved" end="0" id="Reserved" rwaccess="R" width="32"></bitfield>
  </register>
  
  
  <register acronym="PERR" description="Parity Error Code Register  If a parity error is detected, the PER flag will be set in the error and status register. This bit is not reset by the parity check mechanism; it must be reset by reading the error and status register. In addition to the PER flag, the parity error code register will indicate the memory area where the parity error has been detected (message number and word number). If more than one word with a parity error was detected, the highest word number with a parity error will be displayed. After a parity error has been detected, the register will hold the last error code until power is removed." id="PERR" offset="0x1C" width="32">
    
  <bitfield begin="31" description="Reserved" end="11" id="Reserved1" rwaccess="R" width="21"></bitfield>
    
  <bitfield begin="10" description="Word number where parity error has been detected." end="8" id="Word_Number" rwaccess="R" width="3">
    <bitenum description="RDA word number (1 to 5) of the message object (according to the message RAM representation in RDA mode)." id="en_1_0x05" token="en_1_0x05" value="0x05"></bitenum>
  </bitfield>
    
  <bitfield begin="7" description="Message number." end="0" id="Message_Number" rwaccess="R" width="8">
    <bitenum description="Message object number where parity error has been detected" id="en_1_0x80" token="en_1_0x80" value="0x80"></bitenum>
  </bitfield>
  </register>
  
  
  <register acronym="DCAN_REV_ID" description="DCAN Revision ID" id="DCAN_REV_ID" offset="0x20" width="32">
    
  <bitfield begin="31" description="" end="0" id="NewBitfield" rwaccess="R" width="32"></bitfield>
  </register>
  
  
  <register acronym="ECCDIAG" description="ECC Diagnostic Register" id="ECCDIAG" offset="0x24" width="32">
    
  <bitfield begin="31" description="Reserved" end="4" id="Reserved" rwaccess="R" width="28"></bitfield>
    
  <bitfield begin="3" description="" end="0" id="ECC_DIAG" rwaccess="RW" width="4"></bitfield>
  </register>
  
  
  <register acronym="ECCDIAG_STAT" description="ECC Diagnostic Status Register" id="ECCDIAG_STAT" offset="0x28" width="32">
    
  <bitfield begin="31" description="Reserved" end="9" id="Reserved_2" rwaccess="R" width="23"></bitfield>
    
  <bitfield begin="8" description="" end="8" id="DEFLG_DIAG" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="7" description="Reserved" end="1" id="Reserved_1" rwaccess="R" width="7"></bitfield>
    
  <bitfield begin="0" description="" end="0" id="SEFLG_DIAG" rwaccess="RW" width="1"></bitfield>
  </register>
  
  
  <register acronym="ECC_CS" description="ECC Control and Status Register" id="ECC_CS" offset="0x2C" width="32">
    
  <bitfield begin="31" description="Reserved" end="28" id="Reserved_4" rwaccess="R" width="4"></bitfield>
    
  <bitfield begin="27" description="" end="24" id="SBE_EVT_EN" rwaccess="RW" width="4"></bitfield>
    
  <bitfield begin="23" description="Reserved" end="20" id="Reserved_3" rwaccess="R" width="4"></bitfield>
    
  <bitfield begin="19" description="" end="16" id="ECCMODE" rwaccess="RW" width="4"></bitfield>
    
  <bitfield begin="15" description="Reserved" end="9" id="Reserved_2" rwaccess="R" width="7"></bitfield>
    
  <bitfield begin="8" description="" end="8" id="DEFLG" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="7" description="Reserved" end="1" id="Reserved_1" rwaccess="R" width="7"></bitfield>
    
  <bitfield begin="0" description="" end="0" id="SEFLG" rwaccess="RW" width="1"></bitfield>
  </register>
  
  
  <register acronym="ECC_SERR" description="ECC Single Bit Error Code Register" id="ECC_SERR" offset="0x30" width="32">
    
  <bitfield begin="31" description="Reserved" end="8" id="Reserved" rwaccess="R" width="24"></bitfield>
    
  <bitfield begin="7" description="" end="0" id="MSG_NUM" rwaccess="RW" width="8"></bitfield>
  </register>
  
  
  <register acronym="TTCAN1" description="TTCAN1 " id="TTCAN1" offset="0x34" width="32">
    
  <bitfield begin="31" description="Reserved" end="0" id="Reserved" rwaccess="RW" width="32"></bitfield>
  </register>
  
  
  <register acronym="TTCAN2" description="TTCAN2 " id="TTCAN2" offset="0x38" width="32">
    
  <bitfield begin="31" description="Reserved" end="0" id="Reserved" rwaccess="RW" width="32"></bitfield>
  </register>
  
  
  <register acronym="TTCAN3" description="TTCAN3  " id="TTCAN3" offset="0x3C" width="32">
    
  <bitfield begin="31" description="Reserved" end="0" id="Reserved" rwaccess="RW" width="32"></bitfield>
  </register>
  
  
  <register acronym="TTCAN4" description="TTCAN4  " id="TTCAN4" offset="0x40" width="32">
    
  <bitfield begin="31" description="Reserved" end="0" id="Reserved" rwaccess="RW" width="32"></bitfield>
  </register>
  
  
  <register acronym="TTCAN5" description="TTCAN5  " id="TTCAN5" offset="0x44" width="32">
    
  <bitfield begin="31" description="Reserved" end="0" id="Reserved" rwaccess="RW" width="32"></bitfield>
  </register>
  
  
  <register acronym="TTCAN6" description="TTCAN6  " id="TTCAN6" offset="0x48" width="32">
    
  <bitfield begin="31" description="Reserved" end="0" id="Reserved" rwaccess="RW" width="32"></bitfield>
  </register>
  
  
  <register acronym="TTCAN7" description="TTCAN7 " id="TTCAN7" offset="0x4C" width="32">
    
  <bitfield begin="31" description="Reserved" end="0" id="Reserved" rwaccess="RW" width="32"></bitfield>
  </register>
  
  
  <register acronym="TTCAN8" description="TTCAN8  " id="TTCAN8" offset="0x50" width="32">
    
  <bitfield begin="31" description="Reserved" end="0" id="Reserved" rwaccess="RW" width="32"></bitfield>
  </register>
  
  
  <register acronym="TTCAN9" description="TTCAN9  " id="TTCAN9" offset="0x54" width="32">
    
  <bitfield begin="31" description="Reserved" end="0" id="Reserved" rwaccess="RW" width="32"></bitfield>
  </register>
  
  
  <register acronym="TTCAN10" description="TTCAN10  " id="TTCAN10" offset="0x58" width="32">
    
  <bitfield begin="31" description="Reserved" end="0" id="Reserved" rwaccess="RW" width="32"></bitfield>
  </register>
  
  
  <register acronym="TTCAN11" description="TTCAN11 " id="TTCAN11" offset="0x5C" width="32">
    
  <bitfield begin="31" description="Reserved" end="0" id="Reserved" rwaccess="RW" width="32"></bitfield>
  </register>
  
  
  <register acronym="TTCAN12" description="TTCAN12 " id="TTCAN12" offset="0x60" width="32">
    
  <bitfield begin="31" description="Reserved" end="0" id="Reserved" rwaccess="RW" width="32"></bitfield>
  </register>
  
  
  <register acronym="TTCAN13" description="TTCAN13 " id="TTCAN13" offset="0x64" width="32">
    
  <bitfield begin="31" description="Reserved" end="0" id="Reserved" rwaccess="RW" width="32"></bitfield>
  </register>
  
  
  <register acronym="TTCAN14" description="TTCAN14 " id="TTCAN14" offset="0x68" width="32">
    
  <bitfield begin="31" description="Reserved" end="0" id="Reserved" rwaccess="RW" width="32"></bitfield>
  </register>
  
  
  <register acronym="TTCAN15" description="TTCAN15  " id="TTCAN15" offset="0x6C" width="32">
    
  <bitfield begin="31" description="Reserved" end="0" id="Reserved" rwaccess="RW" width="32"></bitfield>
  </register>
  
  
  <register acronym="TTCAN16" description="TTCAN16  " id="TTCAN16" offset="0x70" width="32">
    
  <bitfield begin="31" description="Reserved" end="0" id="Reserved" rwaccess="RW" width="32"></bitfield>
  </register>
  
  
  <register acronym="TTCAN17" description="TTCAN17  " id="TTCAN17" offset="0x74" width="32">
    
  <bitfield begin="31" description="Reserved" end="0" id="Reserved" rwaccess="RW" width="32"></bitfield>
  </register>
  
  
  <register acronym="TTCAN18" description="TTCAN18  " id="TTCAN18" offset="0x78" width="32">
    
  <bitfield begin="31" description="Reserved" end="0" id="Reserved" rwaccess="RW" width="32"></bitfield>
  </register>
  
  
  <register acronym="TTCAN19" description="TTCAN19 " id="TTCAN19" offset="0x7C" width="32">
    
  <bitfield begin="31" description="Reserved" end="0" id="Reserved" rwaccess="RW" width="32"></bitfield>
  </register>
  
  
  <register acronym="ABOTR" description="Auto Bus On Time Register  On write access to the CAN control register while Auto-Bus-On timer is running, the Auto-Bus-On procedure will be aborted. During Debug/Suspend mode, running Auto-Bus-On timer will be paused." id="ABOTR" offset="0x80" width="32">
    
  <bitfield begin="31" description="Number of OCP clock cycles before a Bus-Off recovery sequence is started by clearing the Init bit. This function has to be enabled by setting bit ABO in CAN control register. The Auto-Bus-On timer is realized by a 32 bit counter that starts to count down to zero when the module goes Bus-Off. The counter will be reloaded with the preload value of the ABO time register after this phase." end="0" id="ABO_Time" rwaccess="RW" width="32"></bitfield>
  </register>
  
  
  <register acronym="TXRQ_X" description="Transmission Request X Register  Example 1. Bit 0 of the transmission request X register represents byte 0 of the transmission request 1 register. If one or more bits in this byte are set, bit 0 of the transmission request X register will be set." id="TXRQ_X" offset="0x84" width="32">
    
  <bitfield begin="31" description="Reserved" end="16" id="Reserved1" rwaccess="R" width="16"></bitfield>
    
  <bitfield begin="15" description="TxRqstReg8" end="14" id="TxRqstReg8" rwaccess="R" width="2"></bitfield>
    
  <bitfield begin="13" description="TxRqstReg7" end="12" id="TxRqstReg7" rwaccess="R" width="2"></bitfield>
    
  <bitfield begin="11" description="TxRqstReg6" end="10" id="TxRqstReg6" rwaccess="R" width="2"></bitfield>
    
  <bitfield begin="9" description="TxRqstReg5" end="8" id="TxRqstReg5" rwaccess="R" width="2"></bitfield>
    
  <bitfield begin="7" description="TxRqstReg4" end="6" id="TxRqstReg4" rwaccess="R" width="2"></bitfield>
    
  <bitfield begin="5" description="TxRqstReg3" end="4" id="TxRqstReg3" rwaccess="R" width="2"></bitfield>
    
  <bitfield begin="3" description="TxRqstReg2" end="2" id="TxRqstReg2" rwaccess="R" width="2"></bitfield>
    
  <bitfield begin="1" description="TxRqstReg1" end="0" id="TxRqstReg1" rwaccess="R" width="2"></bitfield>
  </register>
  
  
  <register acronym="TXRQ12" description="Transmission Request Register  The TXRQ12 to TXRQ78 registers hold the TxRqst bits of the implemented message objects. By reading out these bits, the CPU can check for pending transmission requests. The TxRqst bit in a specific message object can be set/reset by the CPU via the IF1/IF2 message interface registers, or by the message handler after reception of a remote frame or after a successful transmission." id="TXRQ12" offset="0x88" width="32">
    
  <bitfield begin="31" description="Transmission request bits (for all message objects)" end="16" id="TxRqs_1" rwaccess="R" width="16">
    <bitenum description="The transmission of this message object is requested and is not yet done." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="No transmission has been requested for this message object." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="15" description="Transmission request bits (for all message objects)" end="0" id="TxRqs_0" rwaccess="R" width="16">
    <bitenum description="The transmission of this message object is requested and is not yet done." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="No transmission has been requested for this message object." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
  </register>
  
  
  <register acronym="TXRQ34" description="Transmission Request Register  The TXRQ12 to TXRQ78 registers hold the TxRqst bits of the implemented message objects. By reading out these bits, the CPU can check for pending transmission requests. The TxRqst bit in a specific message object can be set/reset by the CPU via the IF1/IF2 message interface registers, or by the message handler after reception of a remote frame or after a successful transmission." id="TXRQ34" offset="0x8C" width="32">
    
  <bitfield begin="31" description="Transmission request bits (for all message objects)" end="16" id="TxRqs_1" rwaccess="R" width="16">
    <bitenum description="The transmission of this message object is requested and is not yet done." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="No transmission has been requested for this message object." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="15" description="Transmission request bits (for all message objects)" end="0" id="TxRqs_0" rwaccess="R" width="16">
    <bitenum description="The transmission of this message object is requested and is not yet done." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="No transmission has been requested for this message object." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
  </register>
  
  
  <register acronym="TXRQ56" description="Transmission Request Register  The TXRQ12 to TXRQ78 registers hold the TxRqst bits of the implemented message objects. By reading out these bits, the CPU can check for pending transmission requests. The TxRqst bit in a specific message object can be set/reset by the CPU via the IF1/IF2 message interface registers, or by the message handler after reception of a remote frame or after a successful transmission." id="TXRQ56" offset="0x90" width="32">
    
  <bitfield begin="31" description="Transmission request bits (for all message objects)" end="16" id="TxRqs_1" rwaccess="R" width="16">
    <bitenum description="The transmission of this message object is requested and is not yet done." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="No transmission has been requested for this message object." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="15" description="Transmission request bits (for all message objects)" end="0" id="TxRqs_0" rwaccess="R" width="16">
    <bitenum description="The transmission of this message object is requested and is not yet done." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="No transmission has been requested for this message object." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
  </register>
  
  
  <register acronym="TXRQ78" description="Transmission Request Register  The TXRQ12 to TXRQ78 registers hold the TxRqst bits of the implemented message objects. By reading out these bits, the CPU can check for pending transmission requests. The TxRqst bit in a specific message object can be set/reset by the CPU via the IF1/IF2 message interface registers, or by the message handler after reception of a remote frame or after a successful transmission." id="TXRQ78" offset="0x94" width="32">
    
  <bitfield begin="31" description="Transmission request bits (for all message objects)" end="16" id="TxRqs_1" rwaccess="R" width="16">
    <bitenum description="The transmission of this message object is requested and is not yet done." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="No transmission has been requested for this message object." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="15" description="Transmission request bits (for all message objects)" end="0" id="TxRqs_0" rwaccess="R" width="16">
    <bitenum description="The transmission of this message object is requested and is not yet done." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="No transmission has been requested for this message object." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
  </register>
  
  
  <register acronym="NWDAT_X" description="New Data X Register  With the new data X register, the CPU can detect if one or more bits in the different new data registers are set. Each register bit represents a group of eight message objects. If at least on of the NewDat bits of these message objects are set, the corresponding bit in the new data X register will be set. Example 1. Bit 0 of the new data X register represents byte 0 of the new data 1 register. If one or more bits in this byte are set, bit 0 of the new data X register will be set." id="NWDAT_X" offset="0x98" width="32">
    
  <bitfield begin="31" description="Reserved" end="16" id="Reserved1" rwaccess="R" width="16"></bitfield>
    
  <bitfield begin="15" description="NewDatReg8" end="14" id="NewDatReg8" rwaccess="R" width="2"></bitfield>
    
  <bitfield begin="13" description="NewDatReg7" end="12" id="NewDatReg7" rwaccess="R" width="2"></bitfield>
    
  <bitfield begin="11" description="NewDatReg6" end="10" id="NewDatReg6" rwaccess="R" width="2"></bitfield>
    
  <bitfield begin="9" description="NewDatReg5" end="8" id="NewDatReg5" rwaccess="R" width="2"></bitfield>
    
  <bitfield begin="7" description="NewDatReg4" end="6" id="NewDatReg4" rwaccess="R" width="2"></bitfield>
    
  <bitfield begin="5" description="NewDatReg3" end="4" id="NewDatReg3" rwaccess="R" width="2"></bitfield>
    
  <bitfield begin="3" description="NewDatReg2" end="2" id="NewDatReg2" rwaccess="R" width="2"></bitfield>
    
  <bitfield begin="1" description="NewDatReg1" end="0" id="NewDatReg1" rwaccess="R" width="2"></bitfield>
  </register>
  
  
  <register acronym="NWDAT12" description="New Data Register  These registers hold the NewDat bits of the implemented message objects. By reading out these bits, the CPU can check for new data in the message objects. The NewDat bit of a specific message object can be set/reset by the CPU via the IF1/IF2 interface register sets, or by the message handler after reception of a data frame or after a successful transmission." id="NWDAT12" offset="0x9C" width="32">
    
  <bitfield begin="31" description="New Data Bits (for all message objects)" end="16" id="NewDat_1" rwaccess="R" width="16">
    <bitenum description="The message handler or the CPU has written new data into the data portion of this message object." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="No new data has been written into the data portion of this message object by the message handler since the last time when this flag was cleared by the CPU." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="15" description="New Data Bits (for all message objects)" end="0" id="NewDat_0" rwaccess="R" width="16">
    <bitenum description="The message handler or the CPU has written new data into the data portion of this message object." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="No new data has been written into the data portion of this message object by the message handler since the last time when this flag was cleared by the CPU." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
  </register>
  
  
  <register acronym="NWDAT34" description="New Data Register  These registers hold the NewDat bits of the implemented message objects. By reading out these bits, the CPU can check for new data in the message objects. The NewDat bit of a specific message object can be set/reset by the CPU via the IF1/IF2 interface register sets, or by the message handler after reception of a data frame or after a successful transmission." id="NWDAT34" offset="0xA0" width="32">
    
  <bitfield begin="31" description="New Data Bits (for all message objects)" end="16" id="NewDat_1" rwaccess="R" width="16">
    <bitenum description="The message handler or the CPU has written new data into the data portion of this message object." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="No new data has been written into the data portion of this message object by the message handler since the last time when this flag was cleared by the CPU." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="15" description="New Data Bits (for all message objects)" end="0" id="NewDat_0" rwaccess="R" width="16">
    <bitenum description="The message handler or the CPU has written new data into the data portion of this message object." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="No new data has been written into the data portion of this message object by the message handler since the last time when this flag was cleared by the CPU." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
  </register>
  
  
  <register acronym="NWDAT56" description="New Data Register  These registers hold the NewDat bits of the implemented message objects. By reading out these bits, the CPU can check for new data in the message objects. The NewDat bit of a specific message object can be set/reset by the CPU via the IF1/IF2 interface register sets, or by the message handler after reception of a data frame or after a successful transmission." id="NWDAT56" offset="0xA4" width="32">
    
  <bitfield begin="31" description="New Data Bits (for all message objects)" end="16" id="NewDat_1" rwaccess="R" width="16">
    <bitenum description="The message handler or the CPU has written new data into the data portion of this message object." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="No new data has been written into the data portion of this message object by the message handler since the last time when this flag was cleared by the CPU." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="15" description="New Data Bits (for all message objects)" end="0" id="NewDat_0" rwaccess="R" width="16">
    <bitenum description="The message handler or the CPU has written new data into the data portion of this message object." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="No new data has been written into the data portion of this message object by the message handler since the last time when this flag was cleared by the CPU." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
  </register>
  
  
  <register acronym="NWDAT78" description="New Data Register  These registers hold the NewDat bits of the implemented message objects. By reading out these bits, the CPU can check for new data in the message objects. The NewDat bit of a specific message object can be set/reset by the CPU via the IF1/IF2 interface register sets, or by the message handler after reception of a data frame or after a successful transmission." id="NWDAT78" offset="0xA8" width="32">
    
  <bitfield begin="31" description="New Data Bits (for all message objects)" end="16" id="NewDat_1" rwaccess="R" width="16">
    <bitenum description="The message handler or the CPU has written new data into the data portion of this message object." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="No new data has been written into the data portion of this message object by the message handler since the last time when this flag was cleared by the CPU." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="15" description="New Data Bits (for all message objects)" end="0" id="NewDat_0" rwaccess="R" width="16">
    <bitenum description="The message handler or the CPU has written new data into the data portion of this message object." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="No new data has been written into the data portion of this message object by the message handler since the last time when this flag was cleared by the CPU." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
  </register>
  
  
  <register acronym="INTPND_X" description="Interrupt Pending X Register  With the interrupt pending X register, the CPU can detect if one or more bits in the different interrupt pending registers are set. Each bit of this register represents a group of eight message objects. If at least one of the IntPnd bits of these message objects are set, the corresponding bit in the interrupt pending X register will be set. Example 2. Bit 0 of the interrupt pending X register represents byte 0 of the interrupt pending 1 register. If one or more bits in this byte are set, bit 0 of the interrupt pending X register will be set." id="INTPND_X" offset="0xAC" width="32">
    
  <bitfield begin="31" description="Reserved" end="16" id="Reserved1" rwaccess="R" width="16"></bitfield>
    
  <bitfield begin="15" description="IntPndReg8" end="14" id="IntPndReg8" rwaccess="R" width="2"></bitfield>
    
  <bitfield begin="13" description="IntPndReg7" end="12" id="IntPndReg7" rwaccess="R" width="2"></bitfield>
    
  <bitfield begin="11" description="IntPndReg6" end="10" id="IntPndReg6" rwaccess="R" width="2"></bitfield>
    
  <bitfield begin="9" description="IntPndReg5" end="8" id="IntPndReg5" rwaccess="R" width="2"></bitfield>
    
  <bitfield begin="7" description="IntPndReg4" end="6" id="IntPndReg4" rwaccess="R" width="2"></bitfield>
    
  <bitfield begin="5" description="IntPndReg3" end="4" id="IntPndReg3" rwaccess="R" width="2"></bitfield>
    
  <bitfield begin="3" description="IntPndReg2" end="2" id="IntPndReg2" rwaccess="R" width="2"></bitfield>
    
  <bitfield begin="1" description="IntPndReg1" end="0" id="IntPndReg1" rwaccess="R" width="2"></bitfield>
  </register>
  
  
  <register acronym="INTPND12" description="Interrupt Pending Register  These registers hold the IntPnd bits of the implemented message objects. By reading out these bits, the CPU can check for pending interrupts in the message objects. The IntPnd bit of a specific message object can be set/reset by the CPU via the IF1/IF2 interface register sets, or by the message handler after a reception or a successful transmission." id="INTPND12" offset="0xB0" width="32">
    
  <bitfield begin="31" description="Interrupt Pending Bits (for all message objects)" end="16" id="IntPnd_1" rwaccess="R" width="16">
    <bitenum description="This message object is the source of an interrupt." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="This message object is not the source of an interrupt." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="15" description="Interrupt Pending Bits (for all message objects)" end="0" id="IntPnd_0" rwaccess="R" width="16">
    <bitenum description="This message object is the source of an interrupt." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="This message object is not the source of an interrupt." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
  </register>
  
  
  <register acronym="INTPND34" description="Interrupt Pending Register  These registers hold the IntPnd bits of the implemented message objects. By reading out these bits, the CPU can check for pending interrupts in the message objects. The IntPnd bit of a specific message object can be set/reset by the CPU via the IF1/IF2 interface register sets, or by the message handler after a reception or a successful transmission." id="INTPND34" offset="0xB4" width="32">
    
  <bitfield begin="31" description="Interrupt Pending Bits (for all message objects)" end="16" id="IntPnd_1" rwaccess="R" width="16">
    <bitenum description="This message object is the source of an interrupt." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="This message object is not the source of an interrupt." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="15" description="Interrupt Pending Bits (for all message objects)" end="0" id="IntPnd_0" rwaccess="R" width="16">
    <bitenum description="This message object is the source of an interrupt." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="This message object is not the source of an interrupt." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
  </register>
  
  
  <register acronym="INTPND56" description="Interrupt Pending Register  These registers hold the IntPnd bits of the implemented message objects. By reading out these bits, the CPU can check for pending interrupts in the message objects. The IntPnd bit of a specific message object can be set/reset by the CPU via the IF1/IF2 interface register sets, or by the message handler after a reception or a successful transmission." id="INTPND56" offset="0xB8" width="32">
    
  <bitfield begin="31" description="Interrupt Pending Bits (for all message objects)" end="16" id="IntPnd_1" rwaccess="R" width="16">
    <bitenum description="This message object is the source of an interrupt." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="This message object is not the source of an interrupt." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="15" description="Interrupt Pending Bits (for all message objects)" end="0" id="IntPnd_0" rwaccess="R" width="16">
    <bitenum description="This message object is the source of an interrupt." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="This message object is not the source of an interrupt." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
  </register>
  
  
  <register acronym="INTPND78" description="Interrupt Pending Register  These registers hold the IntPnd bits of the implemented message objects. By reading out these bits, the CPU can check for pending interrupts in the message objects. The IntPnd bit of a specific message object can be set/reset by the CPU via the IF1/IF2 interface register sets, or by the message handler after a reception or a successful transmission." id="INTPND78" offset="0xBC" width="32">
    
  <bitfield begin="31" description="Interrupt Pending Bits (for all message objects)" end="16" id="IntPnd_1" rwaccess="R" width="16">
    <bitenum description="This message object is the source of an interrupt." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="This message object is not the source of an interrupt." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="15" description="Interrupt Pending Bits (for all message objects)" end="0" id="IntPnd_0" rwaccess="R" width="16">
    <bitenum description="This message object is the source of an interrupt." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="This message object is not the source of an interrupt." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
  </register>
  
  
  <register acronym="MSGVAL_X" description="Message Valid X Register  With the message valid X register, the CPU can detect if one or more bits in the different message valid registers are set. Each bit of this register represents a group of eight message objects. If at least one of the MsgVal bits of these message objects are set, the corresponding bit in the message valid X register will be set. Example 3. Bit 0 of the message valid X register represents byte 0 of the message valid 1 register. If one or more bits in this byte are set, bit 0 of the message valid X register will be set." id="MSGVAL_X" offset="0xC0" width="32">
    
  <bitfield begin="31" description="Reserved" end="16" id="Reserved1" rwaccess="R" width="16"></bitfield>
    
  <bitfield begin="15" description="MsgValReg8" end="14" id="MsgValReg8" rwaccess="R" width="2"></bitfield>
    
  <bitfield begin="13" description="MsgValReg7" end="12" id="MsgValReg7" rwaccess="R" width="2"></bitfield>
    
  <bitfield begin="11" description="MsgValReg6" end="10" id="MsgValReg6" rwaccess="R" width="2"></bitfield>
    
  <bitfield begin="9" description="MsgValReg5" end="8" id="MsgValReg5" rwaccess="R" width="2"></bitfield>
    
  <bitfield begin="7" description="MsgValReg4" end="6" id="MsgValReg4" rwaccess="R" width="2"></bitfield>
    
  <bitfield begin="5" description="MsgValReg3" end="4" id="MsgValReg3" rwaccess="R" width="2"></bitfield>
    
  <bitfield begin="3" description="MsgValReg2" end="2" id="MsgValReg2" rwaccess="R" width="2"></bitfield>
    
  <bitfield begin="1" description="MsgValReg1" end="0" id="MsgValReg1" rwaccess="R" width="2"></bitfield>
  </register>
  
  
  <register acronym="MSGVAL12" description="Message Valid Register  These registers hold the MsgVal bits of the implemented message objects. By reading out these bits, the CPU can check which message objects are valid. The MsgVal bit of a specific message object can be set/reset by the CPU via the IF1/IF2 interface register sets, or by the message handler after a reception or a successful transmission." id="MSGVAL12" offset="0xC4" width="32">
    
  <bitfield begin="31" description="Message valid bits (for all message objects)" end="16" id="MsgVal_1" rwaccess="R" width="16">
    <bitenum description="This message object is configured and will be considered by the message handler." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="This message object is ignored by the message handler." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="15" description="Message valid bits (for all message objects)" end="0" id="MsgVal_0" rwaccess="R" width="16">
    <bitenum description="This message object is configured and will be considered by the message handler." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="This message object is ignored by the message handler." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
  </register>
  
  
  <register acronym="MSGVAL34" description="Message Valid Register  These registers hold the MsgVal bits of the implemented message objects. By reading out these bits, the CPU can check which message objects are valid. The MsgVal bit of a specific message object can be set/reset by the CPU via the IF1/IF2 interface register sets, or by the message handler after a reception or a successful transmission." id="MSGVAL34" offset="0xC8" width="32">
    
  <bitfield begin="31" description="Message valid bits (for all message objects)" end="16" id="MsgVal_1" rwaccess="R" width="16">
    <bitenum description="This message object is configured and will be considered by the message handler." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="This message object is ignored by the message handler." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="15" description="Message valid bits (for all message objects)" end="0" id="MsgVal_0" rwaccess="R" width="16">
    <bitenum description="This message object is configured and will be considered by the message handler." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="This message object is ignored by the message handler." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
  </register>
  
  
  <register acronym="MSGVAL56" description="Message Valid Register  These registers hold the MsgVal bits of the implemented message objects. By reading out these bits, the CPU can check which message objects are valid. The MsgVal bit of a specific message object can be set/reset by the CPU via the IF1/IF2 interface register sets, or by the message handler after a reception or a successful transmission." id="MSGVAL56" offset="0xCC" width="32">
    
  <bitfield begin="31" description="Message valid bits (for all message objects)" end="16" id="MsgVal_1" rwaccess="R" width="16">
    <bitenum description="This message object is configured and will be considered by the message handler." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="This message object is ignored by the message handler." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="15" description="Message valid bits (for all message objects)" end="0" id="MsgVal_0" rwaccess="R" width="16">
    <bitenum description="This message object is configured and will be considered by the message handler." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="This message object is ignored by the message handler." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
  </register>
  
  
  <register acronym="MSGVAL78" description="Message Valid Register  These registers hold the MsgVal bits of the implemented message objects. By reading out these bits, the CPU can check which message objects are valid. The MsgVal bit of a specific message object can be set/reset by the CPU via the IF1/IF2 interface register sets, or by the message handler after a reception or a successful transmission." id="MSGVAL78" offset="0xD0" width="32">
    
  <bitfield begin="31" description="Message valid bits (for all message objects)" end="16" id="MsgVal_1" rwaccess="R" width="16">
    <bitenum description="This message object is configured and will be considered by the message handler." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="This message object is ignored by the message handler." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="15" description="Message valid bits (for all message objects)" end="0" id="MsgVal_0" rwaccess="R" width="16">
    <bitenum description="This message object is configured and will be considered by the message handler." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="This message object is ignored by the message handler." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
  </register>
  
  
  <register acronym="Reserved_2" id="Reserved_2" offset="0xD4" width="32">
    
  <bitfield begin="31" description="" end="0" id="NewBitfield" rwaccess="R" width="32"></bitfield>
  </register>
  
  
  <register acronym="INTMUX12" description="Interrupt Pending Multiplexer Register  The IntMux flag determine for each message object, which of the two interrupt lines (DCAN0INT or DCAN1INT) will be asserted when the IntPnd of this message object is set. Both interrupt lines can be globally enabled or disabled by setting or clearing IE0 and IE1 bits in CAN control register. The IntPnd bit of a specific message object can be set or reset by the CPU via the IF1/IF2 interface register sets, or by message handler after reception or successful transmission of a frame. This will also affect the Int0ID resp Int1ID flags in the interrupt register." id="INTMUX12" offset="0xD8" width="32">
    
  <bitfield begin="31" description="Multiplexes IntPnd value to either DCAN0INT or DCAN1INT interrupt lines (for all message objects)" end="16" id="IntMux_1" rwaccess="R" width="16">
    <bitenum description="DCAN1INT line is active if corresponding IntPnd flag is one." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="DCAN0INT line is active if corresponding IntPnd flag is one." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="15" description="Multiplexes IntPnd value to either DCAN0INT or DCAN1INT interrupt lines (for all message objects)" end="0" id="IntMux_0" rwaccess="R" width="16">
    <bitenum description="DCAN1INT line is active if corresponding IntPnd flag is one." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="DCAN0INT line is active if corresponding IntPnd flag is one." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
  </register>
  
  
  <register acronym="INTMUX34" description="Interrupt Pending Multiplexer Register  The IntMux flag determine for each message object, which of the two interrupt lines (DCAN0INT or DCAN1INT) will be asserted when the IntPnd of this message object is set. Both interrupt lines can be globally enabled or disabled by setting or clearing IE0 and IE1 bits in CAN control register. The IntPnd bit of a specific message object can be set or reset by the CPU via the IF1/IF2 interface register sets, or by message handler after reception or successful transmission of a frame. This will also affect the Int0ID resp Int1ID flags in the interrupt register." id="INTMUX34" offset="0xDC" width="32">
    
  <bitfield begin="31" description="Multiplexes IntPnd value to either DCAN0INT or DCAN1INT interrupt lines (for all message objects)" end="16" id="IntMux_1" rwaccess="R" width="16">
    <bitenum description="DCAN1INT line is active if corresponding IntPnd flag is one." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="DCAN0INT line is active if corresponding IntPnd flag is one." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="15" description="Multiplexes IntPnd value to either DCAN0INT or DCAN1INT interrupt lines (for all message objects)" end="0" id="IntMux_0" rwaccess="R" width="16">
    <bitenum description="DCAN1INT line is active if corresponding IntPnd flag is one." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="DCAN0INT line is active if corresponding IntPnd flag is one." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
  </register>
  
  
  <register acronym="INTMUX56" description="Interrupt Pending Multiplexer Register  The IntMux flag determine for each message object, which of the two interrupt lines (DCAN0INT or DCAN1INT) will be asserted when the IntPnd of this message object is set. Both interrupt lines can be globally enabled or disabled by setting or clearing IE0 and IE1 bits in CAN control register. The IntPnd bit of a specific message object can be set or reset by the CPU via the IF1/IF2 interface register sets, or by message handler after reception or successful transmission of a frame. This will also affect the Int0ID resp Int1ID flags in the interrupt register." id="INTMUX56" offset="0xE0" width="32">
    
  <bitfield begin="31" description="Multiplexes IntPnd value to either DCAN0INT or DCAN1INT interrupt lines (for all message objects)" end="16" id="IntMux_1" rwaccess="R" width="16">
    <bitenum description="DCAN1INT line is active if corresponding IntPnd flag is one." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="DCAN0INT line is active if corresponding IntPnd flag is one." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="15" description="Multiplexes IntPnd value to either DCAN0INT or DCAN1INT interrupt lines (for all message objects)" end="0" id="IntMux_0" rwaccess="R" width="16">
    <bitenum description="DCAN1INT line is active if corresponding IntPnd flag is one." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="DCAN0INT line is active if corresponding IntPnd flag is one." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
  </register>
  
  
  <register acronym="INTMUX78" description="Interrupt Pending Multiplexer Register  The IntMux flag determine for each message object, which of the two interrupt lines (DCAN0INT or DCAN1INT) will be asserted when the IntPnd of this message object is set. Both interrupt lines can be globally enabled or disabled by setting or clearing IE0 and IE1 bits in CAN control register. The IntPnd bit of a specific message object can be set or reset by the CPU via the IF1/IF2 interface register sets, or by message handler after reception or successful transmission of a frame. This will also affect the Int0ID resp Int1ID flags in the interrupt register." id="INTMUX78" offset="0xE4" width="32">
    
  <bitfield begin="31" description="Multiplexes IntPnd value to either DCAN0INT or DCAN1INT interrupt lines (for all message objects)" end="16" id="IntMux_1" rwaccess="R" width="16">
    <bitenum description="DCAN1INT line is active if corresponding IntPnd flag is one." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="DCAN0INT line is active if corresponding IntPnd flag is one." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="15" description="Multiplexes IntPnd value to either DCAN0INT or DCAN1INT interrupt lines (for all message objects)" end="0" id="IntMux_0" rwaccess="R" width="16">
    <bitenum description="DCAN1INT line is active if corresponding IntPnd flag is one." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="DCAN0INT line is active if corresponding IntPnd flag is one." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
  </register>
  
  
  <register acronym="Reserved_3" id="Reserved_3" offset="0xE8" width="32">
    
  <bitfield begin="31" description="Reserved" end="0" id="Reserved" rwaccess="R" width="32"></bitfield>
  </register>
  
  
  <register acronym="Reserved_4" id="Reserved_4" offset="0xEC" width="32">
    
  <bitfield begin="31" description="Reserved" end="0" id="Reserved" rwaccess="R" width="32"></bitfield>
  </register>
  
  
  <register acronym="Reserved_5" id="Reserved_5" offset="0xF0" width="32">
    
  <bitfield begin="31" description="Reserved" end="0" id="Reserved" rwaccess="R" width="32"></bitfield>
  </register>
  
  
  <register acronym="Reserved_6" id="Reserved_6" offset="0xF4" width="32">
    
  <bitfield begin="31" description="Reserved" end="0" id="Reserved" rwaccess="R" width="32"></bitfield>
  </register>
  
  
  <register acronym="Reserved_7" id="Reserved_7" offset="0xF8" width="32">
    
  <bitfield begin="31" description="Reserved" end="0" id="Reserved" rwaccess="R" width="32"></bitfield>
  </register>
  
  
  <register acronym="Reserved_8" id="Reserved_8" offset="0xFC" width="32">
    
  <bitfield begin="31" description="Reserved" end="0" id="Reserved" rwaccess="R" width="32"></bitfield>
  </register>
  
  
  <register acronym="IF1CMD" description="IF1 Command Register  The IF1 Command Register (IF1CMD) configures and initiates the transfer between the IF1 register sets and the message RAM. It is configurable which portions of the message object should be transferred. A transfer is started when the CPU writes the message number to bits [7:0] of the IF1 command register. With this write operation, the Busy bit is automatically set to '1' to indicate that a transfer is in progress. After 4 to 14 OCP clock cycles, the transfer between the interface register and the message RAM will be completed and the Busy bit is cleared. The maximum number of cycles is needed when the message transfer concurs with a CAN message transmission, acceptance filtering, or message storage. If the CPU writes to both IF1 command registers consecutively (request of a second transfer while first transfer is still in progress), the second transfer will start after the first one has been completed. While Busy bit is one, IF1 register sets are write protected. For debug support, the auto clear functionality of the IF1 command registers (clear of DMAactive flag by r/w) is disabled during Debug/Suspend mode. If an invalid Message Number is written to bits [7:0] of the IF1 command register, the message handler may access an implemented (valid) message object instead." id="IF1CMD" offset="0x100" width="32">
    
  <bitfield begin="31" description="Reserved" end="24" id="Reserved1" rwaccess="R" width="8"></bitfield>
    
  <bitfield begin="23" description="Write/Read" end="23" id="WR_RD" rwaccess="RW" width="1">
    <bitenum description="Direction = Write: Transfer direction is from the IF1 register set to the message object addressed by Message Number (Bits [7:0])." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="Direction = Read: Transfer direction is from the message object addressed by Message Number (Bits [7:0]) to the IF1 register set." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="22" description="Access mask bits" end="22" id="Mask" rwaccess="RW" width="1">
    <bitenum description="Direction = Read: The mask bits (identifier mask + MDir + MXtd) will be transferred from the message object addressed by Message Number (Bits [7:0]) to the IF1 register set. Direction = Write: The mask bits (identifier mask + MDir + MXtd) will be transferred from the IF1 register set to the message object addressed by Message Number (Bits [7:0])." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="Mask bits will not be changed" id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="21" description="Access arbitration bits" end="21" id="Arb" rwaccess="RW" width="1">
    <bitenum description="Direction = Read: The Arbitration bits (Identifier + Dir + Xtd + MsgVal) will be transferred from the message object addressed by Message Number (Bits [7:0]) to the corresponding IF1 register set. Direction = Write: The Arbitration bits (Identifier + Dir + Xtd + MsgVal) will be transferred from the IF1 register set to the message object addressed by Message Number (Bits [7:0])." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="Arbitration bits will not be changed" id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="20" description="Access control bits. If the TxRqst/NewDat bit in this register(Bit [18]) is set, the TxRqst/ NewDat bit in the IF1 message control register will be ignored." end="20" id="Control" rwaccess="RW" width="1">
    <bitenum description="Direction = Read: The message control bits will be transferred from the message object addressed by message number (Bits [7:0]) to the IF1 register set. Direction = Write: The message control bits will be transferred from the IF1 register set to the message object addressed by message number (Bits [7:0])." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="Control bits will not be changed" id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="19" description="Clear interrupt pending bit" end="19" id="ClrIntPnd" rwaccess="RW" width="1">
    <bitenum description="Direction = Read: Clears IntPnd bit in the message object. Direction = Write: This bit is ignored. Copying of IntPnd flag from IF1 Registers to message RAM can only be controlled by the control flag (Bit [20])." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="IntPnd bit will not be changed" id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="18" description="Access transmission request bit. Note: If a CAN transmission is requested by setting TxRqst/NewDat in this register, the TxRqst/NewDat bits in the message object will be set to one independent of the values in IF1 message control Register. Note: A read access to a message object can be combined with the reset of the control bits IntPnd and NewDat. The values of these bits transferred to the IF1 message control register always reflect the status before resetting them." end="18" id="TxRqst_NewDat" rwaccess="RW" width="1">
    <bitenum description="Direction = Read: Clears NewDat bit in the message object. Direction = Write: Sets TxRqst/NewDat in message object." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="Direction = Read: NewDat bit will not be changed. Direction = Write: TxRqst/NewDat bit will be handled according to the control bit." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="17" description="Access Data Bytes 0 to 3." end="17" id="Data_A" rwaccess="RW" width="1">
    <bitenum description="Direction = Read: The data bytes 0-3 will be transferred from the message object addressed by the Message Number (Bits [7:0]) to the corresponding IF1 register set. Direction = Write: The data bytes 0-3 will be transferred from the IF1 register set to the message object addressed by the Message Number (Bits [7:0]). Note: The duration of the message transfer is independent of the number of bytes to be transferred." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="Data Bytes 0-3 will not be changed." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="16" description="Access Data Bytes 4 to 7." end="16" id="Data_B" rwaccess="RW" width="1">
    <bitenum description="Direction = Read: The data bytes 4-7 will be transferred from the message object addressed by Message Number (Bits [7:0]) to the corresponding IF1 register set. Direction = Write: The data bytes 4-7 will be transferred from the IF1 register set to the message object addressed by message number (Bits [7:0]). Note: The duration of the message transfer is independent of the number of bytes to be transferred." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="Data Bytes 4-7 will not be changed." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="15" description="Busy flag. This bit is set to one after the message number has been written to bits 7 to 0. IF1 register set will be write protected. The bit is cleared after read/write action has been finished." end="15" id="Busy" rwaccess="RW" width="1">
    <bitenum description="Transfer between IF1 register set and message RAM is in progress." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="No transfer between IF1 register set and message RAM is in progress." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="14" description="Activation of DMA feature for subsequent internal IF1 update. Note: Due to the auto reset feature of the DMAactive bit, this bit has to be set for each subsequent DMA cycle separately." end="14" id="DMAactive" rwaccess="RW" width="1">
    <bitenum description="DMA is requested after completed transfer between IF1 register set and message RAM. The DMA request remains active until the first read or write to one of the IF1 registers; an exception is a write to Message Number (Bits [7:0]) when DMAactive is one." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="DMA request line is independent of IF1 activities." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="13" description="Reserved" end="8" id="Reserved2" rwaccess="R" width="6"></bitfield>
    
  <bitfield begin="7" description="Number of message object in message RAM which is used for data transfer." end="0" id="Message_Number" rwaccess="RW" width="8">
    <bitenum description="Invalid message numbers (value 81 to FF)." id="en_5_0x51" token="en_5_0x51" value="0x51"></bitenum>
    <bitenum description="Valid message number." id="en_4_0x50" token="en_4_0x50" value="0x50"></bitenum>
    <bitenum description="Valid message numbers (value 01 to 80)." id="en_3_0x1" token="en_3_0x1" value="0x1"></bitenum>
    <bitenum description="Invalid message numbers." id="en_2_0x0" token="en_2_0x0" value="0x0"></bitenum>
    <bitenum description="Invalid message number." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
  </register>
  
  
  <register acronym="IF1MSK" description="IF1 Mask Register  The bits of the IF1 mask registers mirror the mask bits of a message object. While Busy bit of IF1 command register is one, IF1 register set is write protected." id="IF1MSK" offset="0x104" width="32">
    
  <bitfield begin="31" description="Mask Extended Identifier. When 11 bit (standard) identifiers are used for a message object, the identifiers of received data frames are written into bits ID28 to ID18. For acceptance filtering, only these bits together with mask bits Msk28 to Msk18 are considered." end="31" id="MXtd" rwaccess="RW" width="1">
    <bitenum description="The extended identifier bit (IDE) is used for acceptance filtering." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="The extended identifier bit (IDE) has no effect on the acceptance filtering." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="30" description="Mask Message Direction" end="30" id="MDir" rwaccess="RW" width="1">
    <bitenum description="The message direction bit (Dir) is used for acceptance filtering." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="The message direction bit (Dir) has no effect on the acceptance filtering." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="29" description="Reserved" end="29" id="Reserved1" rwaccess="R" width="1"></bitfield>
    
  <bitfield begin="28" description="Identifier Mask" end="0" id="Msk" rwaccess="RW" width="29">
    <bitenum description="The corresponding bit in the identifier of the message object is used for acceptance filtering." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="The corresponding bit in the identifier of the message object is not used for acceptance filtering (don't care)." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
  </register>
  
  
  <register acronym="IF1ARB" description="IF1 Arbitration Register  The bits of the IF1 arbitration registers mirror the arbitration bits of a message object. While Busy bit of IF1 command register is one, IF1 register set is write protected." id="IF1ARB" offset="0x108" width="32">
    
  <bitfield begin="31" description="Message valid. The CPU should reset the MsgVal bit of all unused Messages Objects during the initialization before it resets bit Init in the CAN control register. This bit must also be reset before the identifier ID28 to ID0, the control bits Xtd, Dir or DLC3 to DLC0 are modified, or if the messages object is no longer required." end="31" id="MsgVal" rwaccess="RW" width="1">
    <bitenum description="The message object is to be used by the message handler." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="The message object is ignored by the message handler." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="30" description="Extended identifier" end="30" id="Xtd" rwaccess="RW" width="1">
    <bitenum description="The 29-bit (extended) Identifier is used for this message object." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="The 11-bit (standard) Identifier is used for this message object." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="29" description="Message direction" end="29" id="Dir" rwaccess="RW" width="1">
    <bitenum description="Direction = transmit: On TxRqst, the respective message object is transmitted as a data frame. On reception of a remote frame with matching identifier, the TxRqst bit of this message object is set (if RmtEn = 1)." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="Direction = receive: On TxRqst, a remote frame with the identifier of this message object is transmitted. On reception of a data frame with matching identifier, this message is stored in this message object." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="28" description="Message identifier. ID28 to ID0 is equal to 29 bit identifier (extended frame) ID28 to ID18 is equal to 11 bit identifier (standard frame)" end="0" id="ID28_to_ID0" rwaccess="RW" width="29"></bitfield>
  </register>
  
  
  <register acronym="IF1MCTL" description="IF1 Message Control Register  The bits of the IF1 message control registers mirror the message control bits of a message object. While Busy bit of IF1 command register is one, IF1 register set is write protected." id="IF1MCTL" offset="0x10C" width="32">
    
  <bitfield begin="31" description="Reserved" end="16" id="Reserved1" rwaccess="RW" width="16"></bitfield>
    
  <bitfield begin="15" description="New data" end="15" id="NewDat" rwaccess="RW" width="1">
    <bitenum description="The message handler or the CPU has written new data into the data portion of this message object." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="No new data has been written into the data portion of this message object by the message handler since the last time when this flag was cleared by the CPU." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="14" description="Message lost (only valid for message objects with direction = receive)" end="14" id="MsgLst" rwaccess="RW" width="1">
    <bitenum description="The message handler stored a new message into this object when NewDat was still set, so the previous message has been overwritten." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="No message lost since the last time when this bit was reset by the CPU." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="13" description="Interrupt pending" end="13" id="IntPnd" rwaccess="RW" width="1">
    <bitenum description="This message object is the source of an interrupt. The Interrupt Identifier in the interrupt register will point to this message object if there is no other interrupt source with higher priority." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="This message object is not the source of an interrupt." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="12" description="Use acceptance mask. If the UMask bit is set to one, the message object's mask bits have to be programmed during initialization of the message object before MsgVal is set to one." end="12" id="UMask" rwaccess="RW" width="1">
    <bitenum description="Use mask (Msk[28:0], MXtd, and MDir) for acceptance filtering" id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="Mask ignored" id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="11" description="Transmit interrupt enable" end="11" id="TxIE" rwaccess="RW" width="1">
    <bitenum description="IntPnd will be triggered after the successful transmission of a frame." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="IntPnd will not be triggered after the successful transmission of a frame." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="10" description="Receive interrupt enable" end="10" id="RxIE" rwaccess="RW" width="1">
    <bitenum description="IntPnd will be triggered after the successful reception of a frame." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="IntPnd will not be triggered after the successful reception of a frame." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="9" description="Remote enable" end="9" id="RmtEn" rwaccess="RW" width="1">
    <bitenum description="At the reception of a remote frame, TxRqst is set." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="At the reception of a remote frame, TxRqst is not changed." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="8" description="Transmit request" end="8" id="TxRqst" rwaccess="RW" width="1">
    <bitenum description="The transmission of this message object is requested and is not yet done." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="This message object is not waiting for a transmission." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="7" description="Data frame has 0 to 8 data bits. Note: This bit is used to concatenate multiple message objects to build a FIFO Buffer. For single message objects (not belonging to a FIFO Buffer), this bit must always be set to one." end="7" id="EoB" rwaccess="RW" width="1">
    <bitenum description="Note: The data length code of a message object must be defined the same as in all the corresponding objects with the same identifier at other nodes. When the message handler stores a data frame, it will write the DLC to the value given by the received message." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="Data frame has 8 data bytes." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="6" description="Reserved" end="4" id="Reserved2" rwaccess="RW" width="3"></bitfield>
    
  <bitfield begin="3" description="Data length code. Note: The data length code of a message object must be defined the same as in all the corresponding objects with the same identifier at other nodes. When the message handler stores a data frame, it will write the DLC to the value given by the received message." end="0" id="DLC" rwaccess="RW" width="4">
    <bitenum description="Data frame has 8 data bytes." id="en_2_0x15" token="en_2_0x15" value="0x15"></bitenum>
    <bitenum description="Data frame has 0 8 data bits." id="en_1_0x8" token="en_1_0x8" value="0x8"></bitenum>
  </bitfield>
  </register>
  
  
  <register acronym="IF1DATA" description="IF1 Data A Register  The data bytes of CAN messages are stored in the IF1 registers in the following order: (1) In a CAN data frame, Data 0 is the first, and Data 7 is the last byte to be transmitted or received. (2) In CAN's serial bit stream, the MSB of each byte will be transmitted first." id="IF1DATA" offset="0x110" width="32">
    
  <bitfield begin="31" description="Data 3." end="24" id="Data_3" rwaccess="RW" width="8"></bitfield>
    
  <bitfield begin="23" description="Data 2." end="16" id="Data_2" rwaccess="RW" width="8"></bitfield>
    
  <bitfield begin="15" description="Data 1." end="8" id="Data_1" rwaccess="RW" width="8"></bitfield>
    
  <bitfield begin="7" description="Data 0." end="0" id="Data_0" rwaccess="RW" width="8"></bitfield>
  </register>
  
  
  <register acronym="IF1DATB" description="IF1 Data B Register  The data bytes of CAN messages are stored in the IF1 registers in the following order: (1) In a CAN data frame, Data 0 is the first, and Data 7 is the last byte to be transmitted or received. (2) In CAN's serial bit stream, the MSB of each byte will be transmitted first." id="IF1DATB" offset="0x114" width="32">
    
  <bitfield begin="31" description="Data 7." end="24" id="Data_7" rwaccess="RW" width="8"></bitfield>
    
  <bitfield begin="23" description="Data 6." end="16" id="Data_6" rwaccess="RW" width="8"></bitfield>
    
  <bitfield begin="15" description="Data 5." end="8" id="Data_5" rwaccess="RW" width="8"></bitfield>
    
  <bitfield begin="7" description="Data 4." end="0" id="Data_4" rwaccess="RW" width="8"></bitfield>
  </register>
  
  
  <register acronym="Reserved_9" id="Reserved_9" offset="0x118" width="32">
    
  <bitfield begin="31" description="Reserved" end="0" id="Reserved" rwaccess="R" width="32"></bitfield>
  </register>
  
  
  <register acronym="Reserved_10" id="Reserved_10" offset="0x11C" width="32">
    
  <bitfield begin="31" description="Reserved" end="0" id="Reserved" rwaccess="R" width="32"></bitfield>
  </register>
  
  
  <register acronym="IF2CMD" description="IF2 Command Register  The IF2 Command Register (IF1CMD) configures and initiates the transfer between the IF2 register sets and the message RAM. It is configurable which portions of the message object should be transferred. A transfer is started when the CPU writes the message number to bits [7:0] of the IF2 command register. With this write operation, the Busy bit is automatically set to '1' to indicate that a transfer is in progress. After 4 to 14 OCP clock cycles, the transfer between the interface register and the message RAM will be completed and the Busy bit is cleared. The maximum number of cycles is needed when the message transfer concurs with a CAN message transmission, acceptance filtering, or message storage. If the CPU writes to both IF2 command registers consecutively (request of a second transfer while first transfer is still in progress), the second transfer will start after the first one has been completed. While Busy bit is one, IF2 register sets are write protected. For debug support, the auto clear functionality of the IF2 command registers (clear of DMAactive flag by r/w) is disabled during Debug/Suspend mode. If an invalid Message Number is written to bits [7:0] of the IF2 command register, the message handler may access an implemented (valid) message object instead." id="IF2CMD" offset="0x120" width="32">
    
  <bitfield begin="31" description="Reserved" end="24" id="Reserved1" rwaccess="R" width="8"></bitfield>
    
  <bitfield begin="23" description="Write/Read" end="23" id="WR_RD" rwaccess="RW" width="1">
    <bitenum description="Direction = Write: Transfer direction is from the IF2 register set to the message object addressed by Message Number (Bits [7:0])." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="Direction = Read: Transfer direction is from the message object addressed by Message Number (Bits [7:0]) to the IF2 register set." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="22" description="Access mask bits" end="22" id="Mask" rwaccess="RW" width="1">
    <bitenum description="Direction = Read: The mask bits (identifier mask + MDir + MXtd) will be transferred from the message object addressed by Message Number (Bits [7:0]) to the IF2 register set. Direction = Write: The mask bits (identifier mask + MDir + MXtd) will be transferred from the IF2 register set to the message object addressed by Message Number (Bits [7:0])." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="Mask bits will not be changed" id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="21" description="Access arbitration bits" end="21" id="Arb" rwaccess="RW" width="1">
    <bitenum description="Direction = Read: The Arbitration bits (Identifier + Dir + Xtd + MsgVal) will be transferred from the message object addressed by Message Number (Bits [7:0]) to the corresponding IF2 register set. Direction = Write: The Arbitration bits (Identifier + Dir + Xtd + MsgVal) will be transferred from the IF2 register set to the message object addressed by Message Number (Bits [7:0])." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="Arbitration bits will not be changed" id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="20" description="Access control bits. If the TxRqst/NewDat bit in this register(Bit [18]) is set, the TxRqst/ NewDat bit in the IF2 message control register will be ignored." end="20" id="Control" rwaccess="RW" width="1">
    <bitenum description="Direction = Read: The message control bits will be transferred from the message object addressed by message number (Bits [7:0]) to the IF2 register set. Direction = Write: The message control bits will be transferred from the IF2 register set to the message object addressed by message number (Bits [7:0])." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="Control bits will not be changed" id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="19" description="Clear interrupt pending bit" end="19" id="ClrIntPnd" rwaccess="RW" width="1">
    <bitenum description="Direction = Read: Clears IntPnd bit in the message object. Direction = Write: This bit is ignored. Copying of IntPnd flag from IF2 Registers to message RAM can only be controlled by the control flag (Bit [20])." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="IntPnd bit will not be changed" id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="18" description="Access transmission request bit. Note: If a CAN transmission is requested by setting TxRqst/NewDat in this register, the TxRqst/NewDat bits in the message object will be set to one independent of the values in IF2 message control Register. Note: A read access to a message object can be combined with the reset of the control bits IntPnd and NewDat. The values of these bits transferred to the IF2 message control register always reflect the status before resetting them." end="18" id="TxRqst_NewDat" rwaccess="RW" width="1">
    <bitenum description="Direction = Read: Clears NewDat bit in the message object. Direction = Write: Sets TxRqst/NewDat in message object." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="Direction = Read: NewDat bit will not be changed. Direction = Write: TxRqst/NewDat bit will be handled according to the control bit." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="17" description="Access Data Bytes 0 to 3." end="17" id="Data_A" rwaccess="RW" width="1">
    <bitenum description="Direction = Read: The data bytes 0-3 will be transferred from the message object addressed by the Message Number (Bits [7:0]) to the corresponding IF2 register set. Direction = Write: The data bytes 0-3 will be transferred from the IF2 register set to the message object addressed by the Message Number (Bits [7:0]). Note: The duration of the message transfer is independent of the number of bytes to be transferred." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="Data Bytes 0-3 will not be changed." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="16" description="Access Data Bytes 4 to 7." end="16" id="Data_B" rwaccess="RW" width="1">
    <bitenum description="Direction = Read: The data bytes 4-7 will be transferred from the message object addressed by Message Number (Bits [7:0]) to the corresponding IF2 register set. Direction = Write: The data bytes 4-7 will be transferred from the IF2 register set to the message object addressed by message number (Bits [7:0]). Note: The duration of the message transfer is independent of the number of bytes to be transferred." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="Data Bytes 4-7 will not be changed." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="15" description="Busy flag. This bit is set to one after the message number has been written to bits 7 to 0. IF2 register set will be write protected. The bit is cleared after read/write action has been finished." end="15" id="Busy" rwaccess="RW" width="1">
    <bitenum description="Transfer between IF2 register set and message RAM is in progress." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="No transfer between IF2 register set and message RAM is in progress." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="14" description="Activation of DMA feature for subsequent internal IF2 update. Note: Due to the auto reset feature of the DMAactive bit, this bit has to be set for each subsequent DMA cycle separately." end="14" id="DMAactive" rwaccess="RW" width="1">
    <bitenum description="DMA is requested after completed transfer between IF2 register set and message RAM. The DMA request remains active until the first read or write to one of the IF2 registers; an exception is a write to Message Number (Bits [7:0]) when DMAactive is one." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="DMA request line is independent of IF2 activities." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="13" description="Reserved" end="8" id="Reserved2" rwaccess="R" width="6"></bitfield>
    
  <bitfield begin="7" description="Number of message object in message RAM which is used for data transfer." end="0" id="Message_Number" rwaccess="RW" width="8">
    <bitenum description="Invalid message numbers (values 81 to FF)." id="en_5_0x51" token="en_5_0x51" value="0x51"></bitenum>
    <bitenum description="Valid message number." id="en_4_0x50" token="en_4_0x50" value="0x50"></bitenum>
    <bitenum description="Valid message numbers (values 01 to 80)." id="en_3_0x1" token="en_3_0x1" value="0x1"></bitenum>
    <bitenum description="Invalid message number." id="en_2_0x0" token="en_2_0x0" value="0x0"></bitenum>
    <bitenum description="Invalid message number." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
  </register>
  
  
  <register acronym="IF2MSK" description="IF2 Mask Register  The bits of the IF2 mask registers mirror the mask bits of a message object. While Busy bit of IF2 command register is one, IF2 register set is write protected." id="IF2MSK" offset="0x124" width="32">
    
  <bitfield begin="31" description="Mask Extended Identifier. When 11 bit (standard) identifiers are used for a message object, the identifiers of received data frames are written into bits ID28 to ID18. For acceptance filtering, only these bits together with mask bits Msk28 to Msk18 are considered." end="31" id="MXtd" rwaccess="RW" width="1">
    <bitenum description="The extended identifier bit (IDE) is used for acceptance filtering." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="The extended identifier bit (IDE) has no effect on the acceptance filtering." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="30" description="Mask Message Direction" end="30" id="MDir" rwaccess="RW" width="1">
    <bitenum description="The message direction bit (Dir) is used for acceptance filtering." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="The message direction bit (Dir) has no effect on the acceptance filtering." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="29" description="Reserved" end="29" id="Reserved1" rwaccess="R" width="1"></bitfield>
    
  <bitfield begin="28" description="Identifier Mask" end="0" id="Msk" rwaccess="RW" width="29">
    <bitenum description="The corresponding bit in the identifier of the message object is used for acceptance filtering." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="The corresponding bit in the identifier of the message object is not used for acceptance filtering (don't care)." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
  </register>
  
  
  <register acronym="IF2ARB" description="IF2 Arbitration Register  The bits of the IF2 arbitration registers mirror the arbitration bits of a message object. While Busy bit of IF2 command register is one, IF2 register set is write protected." id="IF2ARB" offset="0x128" width="32">
    
  <bitfield begin="31" description="Message valid. The CPU should reset the MsgVal bit of all unused Messages Objects during the initialization before it resets bit Init in the CAN control register. This bit must also be reset before the identifier ID28 to ID0, the control bits Xtd, Dir or DLC3 to DLC0 are modified, or if the messages object is no longer required." end="31" id="MsgVal" rwaccess="RW" width="1">
    <bitenum description="The message object is to be used by the message handler." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="The message object is ignored by the message handler." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="30" description="Extended identifier" end="30" id="Xtd" rwaccess="RW" width="1">
    <bitenum description="The 29-bit (extended) Identifier is used for this message object." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="The 11-bit (standard) Identifier is used for this message object." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="29" description="Message direction" end="29" id="Dir" rwaccess="RW" width="1">
    <bitenum description="Direction = transmit: On TxRqst, the respective message object is transmitted as a data frame. On reception of a remote frame with matching identifier, the TxRqst bit of this message object is set (if RmtEn = 1)." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="Direction = receive: On TxRqst, a remote frame with the identifier of this message object is transmitted. On reception of a data frame with matching identifier, this message is stored in this message object." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="28" description="Message identifier. ID28 to ID0 is equal to 29-bit identifier (extended frame) ID28 to ID18 is equal to 11-bit identifier (standard frame)" end="0" id="ID28_to_ID0" rwaccess="RW" width="29"></bitfield>
  </register>
  
  
  <register acronym="IF2MCTL" description="IF2 Message Control Register  The bits of the IF2 message control registers mirror the message control bits of a message object. While Busy bit of IF2 command register is one, IF2 register set is write protected." id="IF2MCTL" offset="0x12C" width="32">
    
  <bitfield begin="31" description="Reserved" end="16" id="Reserved1" rwaccess="RW" width="16"></bitfield>
    
  <bitfield begin="15" description="New data" end="15" id="NewDat" rwaccess="RW" width="1">
    <bitenum description="The message handler or the CPU has written new data into the data portion of this message object." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="No new data has been written into the data portion of this message object by the message handler since the last time when this flag was cleared by the CPU." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="14" description="Message lost (only valid for message objects with direction = receive)" end="14" id="MsgLst" rwaccess="RW" width="1">
    <bitenum description="The message handler stored a new message into this object when NewDat was still set, so the previous message has been overwritten." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="No message lost since the last time when this bit was reset by the CPU." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="13" description="Interrupt pending" end="13" id="IntPnd" rwaccess="RW" width="1">
    <bitenum description="This message object is the source of an interrupt. The Interrupt Identifier in the interrupt register will point to this message object if there is no other interrupt source with higher priority." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="This message object is not the source of an interrupt." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="12" description="Use acceptance mask. If the UMask bit is set to one, the message object's mask bits have to be programmed during initialization of the message object before MsgVal is set to one." end="12" id="UMask" rwaccess="RW" width="1">
    <bitenum description="Use mask (Msk[28:0], MXtd, and MDir) for acceptance filtering" id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="Mask ignored" id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="11" description="Transmit interrupt enable" end="11" id="TxIE" rwaccess="RW" width="1">
    <bitenum description="IntPnd will be triggered after the successful transmission of a frame." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="IntPnd will not be triggered after the successful transmission of a frame." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="10" description="Receive interrupt enable" end="10" id="RxIE" rwaccess="RW" width="1">
    <bitenum description="IntPnd will be triggered after the successful reception of a frame." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="IntPnd will not be triggered after the successful reception of a frame." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="9" description="Remote enable" end="9" id="RmtEn" rwaccess="RW" width="1">
    <bitenum description="At the reception of a remote frame, TxRqst is set." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="At the reception of a remote frame, TxRqst is not changed." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="8" description="Transmit request" end="8" id="TxRqst" rwaccess="RW" width="1">
    <bitenum description="The transmission of this message object is requested and is not yet done." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="This message object is not waiting for a transmission." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="7" description="Data frame has 0 to 8 data bits. Note: This bit is used to concatenate multiple message objects to build a FIFO Buffer. For single message objects (not belonging to a FIFO Buffer), this bit must always be set to one." end="7" id="EoB" rwaccess="RW" width="1">
    <bitenum description="Note: The data length code of a message object must be defined the same as in all the corresponding objects with the same identifier at other nodes. When the message handler stores a data frame, it will write the DLC to the value given by the received message." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="Data frame has 8 data bytes." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="6" description="Reserved" end="4" id="Reserved2" rwaccess="RW" width="3"></bitfield>
    
  <bitfield begin="3" description="Data length code. Note: The data length code of a message object must be defined the same as in all the corresponding objects with the same identifier at other nodes. When the message handler stores a data frame, it will write the DLC to the value given by the received message." end="0" id="DLC" rwaccess="RW" width="4">
    <bitenum description="Data frame has 8 data bytes." id="en_2_0x15" token="en_2_0x15" value="0x15"></bitenum>
    <bitenum description="Data frame has 0 8 data bits." id="en_1_0x8" token="en_1_0x8" value="0x8"></bitenum>
  </bitfield>
  </register>
  
  
  <register acronym="IF2DATA" description="IF2 Data A Register  The data bytes of CAN messages are stored in the IF2 registers in the following order: (1) In a CAN data frame, Data 0 is the first, and Data 7 is the last byte to be transmitted or received. (2) In CAN's serial bit stream, the MSB of each byte will be transmitted first." id="IF2DATA" offset="0x130" width="32">
    
  <bitfield begin="31" description="Data 3." end="24" id="Data_3" rwaccess="RW" width="8"></bitfield>
    
  <bitfield begin="23" description="Data 2." end="16" id="Data_2" rwaccess="RW" width="8"></bitfield>
    
  <bitfield begin="15" description="Data 1." end="8" id="Data_1" rwaccess="RW" width="8"></bitfield>
    
  <bitfield begin="7" description="Data 0." end="0" id="Data_0" rwaccess="RW" width="8"></bitfield>
  </register>
  
  
  <register acronym="IF2DATB" description="IF2 Data B Register  The data bytes of CAN messages are stored in the IF2 registers in the following order: (1) In a CAN data frame, Data 0 is the first, and Data 7 is the last byte to be transmitted or received. (2) In CAN's serial bit stream, the MSB of each byte will be transmitted first." id="IF2DATB" offset="0x134" width="32">
    
  <bitfield begin="31" description="Data 7." end="24" id="Data_7" rwaccess="RW" width="8"></bitfield>
    
  <bitfield begin="23" description="Data 6." end="16" id="Data_6" rwaccess="RW" width="8"></bitfield>
    
  <bitfield begin="15" description="Data 5." end="8" id="Data_5" rwaccess="RW" width="8"></bitfield>
    
  <bitfield begin="7" description="Data 4." end="0" id="Data_4" rwaccess="RW" width="8"></bitfield>
  </register>
  
  
  <register acronym="Reserved_11" id="Reserved_11" offset="0x138" width="32">
    
  <bitfield begin="31" description="Reserved" end="0" id="Reserved" rwaccess="R" width="32"></bitfield>
  </register>
  
  
  <register acronym="Reserved_12" id="Reserved_12" offset="0x13C" width="32">
    
  <bitfield begin="31" description="Reserved" end="0" id="Reserved" rwaccess="R" width="32"></bitfield>
  </register>
  
  
  <register acronym="IF3OBS" description="IF3 Observation Register  The IF3 register set can automatically be updated with received message objects without the need to initiate the transfer from message RAM by CPU. The observation flags (Bits [4:0]) in the IF3 observation register are used to determine, which data sections of the IF3 interface register set have to be read in order to complete a DMA read cycle. After all marked data sections are read, the DCAN is enabled to update the IF3 interface register set with new data. Any access order of single bytes or half-words is supported. When using byte or half-word accesses, a data section is marked as completed, if all bytes are read. Note: If IF3 Update Enable is used and no Observation flag is set, the corresponding message objects will be copied to IF3 without activating the DMA request line and without waiting for DMA read accesses. A write access to this register aborts a pending DMA cycle by resetting the DMA line and enables updating of IF3 interface register set with new data. To avoid data inconsistency, the DMA controller should be disabled before reconfiguring IF3 observation register. The status of the current read-cycle can be observed via status flags (Bits [12:8]). If an interrupt line is available for IF3, an interrupt will be generated by IF3Upd flag. See the device-specific data sheet for the availability of this interrupt source. With this interrupt, the observation status bits and the IF3Upd bit could be used by the application to realize the notification about new IF3 content in polling or interrupt mode." id="IF3OBS" offset="0x140" width="32">
    
  <bitfield begin="31" description="Reserved" end="16" id="Reserved1" rwaccess="R" width="16"></bitfield>
    
  <bitfield begin="15" description="IF3 Update Data" end="15" id="IF3_Upd" rwaccess="R" width="1">
    <bitenum description="New data has been loaded since last IF3 read." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="No new data has been loaded since last IF3 read." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="14" description="Reserved" end="13" id="Reserved2" rwaccess="R" width="2"></bitfield>
    
  <bitfield begin="12" description="IF3 Status of Data B read access" end="12" id="IF3_SDB" rwaccess="R" width="1">
    <bitenum description="Data B section has still data to be read out." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="All Data B bytes are already read out, or are not marked to be read." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="11" description="IF3 Status of Data A read access" end="11" id="IF3_SDA" rwaccess="R" width="1">
    <bitenum description="Data A section has still data to be read out." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="All Data A bytes are already read out, or are not marked to be read." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="10" description="IF3 Status of control bits read access" end="10" id="IF3_SC" rwaccess="R" width="1">
    <bitenum description="Control section has still data to be read out." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="All control section bytes are already read out, or are not marked to be read." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="9" description="IF3 Status of Arbitration data read access" end="9" id="IF3_SA" rwaccess="R" width="1">
    <bitenum description="Arbitration section has still data to be read out." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="All Arbitration data bytes are already read out, or are not marked to be read." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="8" description="IF3 Status of Mask data read access" end="8" id="IF3_SM" rwaccess="R" width="1">
    <bitenum description="Mask section has still data to be read out." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="All mask data bytes are already read out, or are not marked to be read." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="7" description="Reserved" end="5" id="Reserved3" rwaccess="R" width="3"></bitfield>
    
  <bitfield begin="4" description="Data B read observation" end="4" id="DataB" rwaccess="RW" width="1">
    <bitenum description="Data B section has to be read to enable next IF3 update." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="Data B section has not to be read." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="3" description="Data A read observation" end="3" id="DataA" rwaccess="RW" width="1">
    <bitenum description="Data A section has to be read to enable next IF3 update." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="Data A section has not to be read." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="2" description="Ctrl read observation" end="2" id="Ctrl" rwaccess="RW" width="1">
    <bitenum description="Ctrl section has to be read to enable next IF3 update." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="Ctrl section has not to be read." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="1" description="Arbitration data read observation" end="1" id="Arb" rwaccess="RW" width="1">
    <bitenum description="Arbitration data has to be read to enable next IF3 update." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="Arbitration data has not to be read." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="0" description="Mask data read observation" end="0" id="Mask" rwaccess="RW" width="1">
    <bitenum description="Mask data has to be read to enable next IF3 update." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="Mask data has not to be read." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
  </register>
  
  
  <register acronym="IF3MSK" description="IF3 Mask Register" id="IF3MSK" offset="0x144" width="32">
    
  <bitfield begin="31" description="Mask Extended Identifier. When 11 bit (standard) identifiers are used for a message object, the identifiers of received data frames are written into bits ID28 to ID18. For acceptance filtering, only these bits together with mask bits Msk28 to Msk18 are considered." end="31" id="MXtd" rwaccess="R" width="1">
    <bitenum description="The extended identifier bit (IDE) is used for acceptance filtering." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="The extended identifier bit (IDE) has no effect on the acceptance filtering." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="30" description="Mask Message Direction" end="30" id="MDir" rwaccess="R" width="1">
    <bitenum description="The message direction bit (Dir) is used for acceptance filtering." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="The message direction bit (Dir) has no effect on the acceptance filtering." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="29" description="Reserved" end="29" id="Reserved1" rwaccess="R" width="1"></bitfield>
    
  <bitfield begin="28" description="Identifier Mask" end="0" id="Msk" rwaccess="RW" width="29">
    <bitenum description="The corresponding bit in the identifier of the message object is used for acceptance filtering." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="The corresponding bit in the identifier of the message object is not used for acceptance filtering (don't care)." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
  </register>
  
  
  <register acronym="IF3ARB" description="IF3 Arbitration Register" id="IF3ARB" offset="0x148" width="32">
    
  <bitfield begin="31" description="Message Valid. The CPU should reset the MsgVal bit of all unused Messages Objects during the initialization before it resets bit Init in the CAN control register. This bit must also be reset before the identifier ID28 to ID0, the control bits Xtd, Dir or DLC3 to DLC0 are modified, or if the messages object is no longer required." end="31" id="MsgVal" rwaccess="R" width="1">
    <bitenum description="The message object is to be used by the message handler." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="The message object is ignored by the message handler." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="30" description="Extended Identifier" end="30" id="Xtd" rwaccess="R" width="1">
    <bitenum description="The 29-bit (extended) Identifier is used for this message object." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="The 11-bit (standard) Identifier is used for this message object." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="29" description="Message Direction" end="29" id="Dir" rwaccess="R" width="1">
    <bitenum description="Direction = transmit: On TxRqst, the respective message object is transmitted as a data frame. On reception of a remote frame with matching identifier, the TxRqst bit of this message object is set (if RmtEn = 1)." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="Direction = receive: On TxRqst, a remote frame with the identifier of this message object is transmitted. On reception of a data frame with matching identifier, this message is stored in this message object." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="28" description="Message Identifier. ID28 to ID0 is equal to 29 bit Identifier (extended frame). ID28 to ID18 is equal to 11 bit Identifier (standard frame)." end="0" id="ID28_to_ID0" rwaccess="R" width="29"></bitfield>
  </register>
  
  
  <register acronym="IF3MCTL" description="IF3 Message Control Register" id="IF3MCTL" offset="0x14C" width="32">
    
  <bitfield begin="31" description="Reserved" end="16" id="Reserved1" rwaccess="R" width="16"></bitfield>
    
  <bitfield begin="15" description="New Data" end="15" id="NewDat" rwaccess="R" width="1">
    <bitenum description="The message handler or the CPU has written new data into the data portion of this message object." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="No new data has been written into the data portion of this message object by the message handler since the last time when this flag was cleared by the CPU." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="14" description="Message Lost (only valid for message objects with direction = receive)" end="14" id="MsgLst" rwaccess="R" width="1">
    <bitenum description="The message handler stored a new message into this object when NewDat was still set, so the previous message has been overwritten." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="No message lost since the last time when this bit was reset by the CPU." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="13" description="Interrupt Pending" end="13" id="IntPnd" rwaccess="R" width="1">
    <bitenum description="This message object is the source of an interrupt. The Interrupt Identifier in the interrupt register will point to this message object if there is no other interrupt source with higher priority." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="This message object is not the source of an interrupt." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="12" description="Use Acceptance Mask" end="12" id="UMask" rwaccess="R" width="1">
    <bitenum description="Use mask (Msk[28:0], MXtd, and MDir) for acceptance filtering. If the UMask bit is set to one, the message object's mask bits have to be programmed during initialization of the message object before MsgVal is set to one." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="Mask ignored" id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="11" description="Transmit Interrupt enable" end="11" id="TxIE" rwaccess="R" width="1">
    <bitenum description="IntPnd will be triggered after the successful transmission of a frame." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="IntPnd will not be triggered after the successful transmission of a frame." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="10" description="Receive Interrupt enable" end="10" id="RxIE" rwaccess="R" width="1">
    <bitenum description="IntPnd will be triggered after the successful reception of a frame." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="IntPnd will not be triggered after the successful reception of a frame." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="9" description="Remote enable" end="9" id="RmtEn" rwaccess="R" width="1">
    <bitenum description="At the reception of a remote frame, TxRqst is set." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="At the reception of a remote frame, TxRqst is not changed." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="8" description="Transmit Request" end="8" id="TxRqst" rwaccess="R" width="1">
    <bitenum description="The transmission of this message object is requested and is not yet done." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="This message object is not waiting for a transmission." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="7" description="Data frame has 0 to 8 data bits. Note: This bit is used to concatenate multiple message objects to build a FIFO Buffer. For single message objects (not belonging to a FIFO Buffer), this bit must always be set to one." end="7" id="EoB" rwaccess="R" width="1">
    <bitenum description="Note: The data length code of a message object must be defined the same as in all the corresponding objects with the same identifier at other nodes. When the message handler stores a data frame, it will write the DLC to the value given by the received message." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="Data frame has 8 data bytes." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="6" description="Reserved" end="4" id="Reserved2" rwaccess="R" width="3"></bitfield>
    
  <bitfield begin="3" description="Data Length Code. Note: The data length code of a message object must be defined the same as in all the corresponding objects with the same identifier at other nodes. When the message handler stores a data frame, it will write the DLC to the value given by the received message." end="0" id="DLC" rwaccess="R" width="4">
    <bitenum description="Data frame has 8 data bytes." id="en_2_0x15" token="en_2_0x15" value="0x15"></bitenum>
    <bitenum description="Data frame has 0 8 bits." id="en_1_0x8" token="en_1_0x8" value="0x8"></bitenum>
  </bitfield>
  </register>
  
  
  <register acronym="IF3DATA" description="IF3 Data A Register  The data bytes of CAN messages are stored in the IF3 registers in the following order. In a CAN data frame, Data 0 is the first, and Data 7 is the last byte to be transmitted or received. In CAN's serial bit stream, the MSB of each byte will be transmitted first." id="IF3DATA" offset="0x150" width="32">
    
  <bitfield begin="31" description="Data 3." end="24" id="Data_3" rwaccess="R" width="8"></bitfield>
    
  <bitfield begin="23" description="Data 2." end="16" id="Data_2" rwaccess="R" width="8"></bitfield>
    
  <bitfield begin="15" description="Data 1." end="8" id="Data_1" rwaccess="R" width="8"></bitfield>
    
  <bitfield begin="7" description="Data 0." end="0" id="Data_0" rwaccess="R" width="8"></bitfield>
  </register>
  
  
  <register acronym="IF3DATB" description="IF3 Data B Register  The data bytes of CAN messages are stored in the IF3 registers in the following order. In a CAN data frame, Data 0 is the first, and Data 7 is the last byte to be transmitted or received. In CAN's serial bit stream, the MSB of each byte will be transmitted first." id="IF3DATB" offset="0x154" width="32">
    
  <bitfield begin="31" description="Data 7." end="24" id="Data_7" rwaccess="R" width="8"></bitfield>
    
  <bitfield begin="23" description="Data 6." end="16" id="Data_6" rwaccess="R" width="8"></bitfield>
    
  <bitfield begin="15" description="Data 5." end="8" id="Data_5" rwaccess="R" width="8"></bitfield>
    
  <bitfield begin="7" description="Data 4." end="0" id="Data_4" rwaccess="R" width="8"></bitfield>
  </register>
  
  
  <register acronym="Reserved_13" id="Reserved_13" offset="0x158" width="32">
    
  <bitfield begin="31" description="Reserved" end="0" id="Reserved" rwaccess="R" width="32"></bitfield>
  </register>
  
  
  <register acronym="Reserved_14" id="Reserved_14" offset="0x15C" width="32">
    
  <bitfield begin="31" description="Reserved" end="0" id="Reserved" rwaccess="R" width="32"></bitfield>
  </register>
  
  
  <register acronym="IF3UPD12" description="IF3 Update Enable Register  The automatic update functionality of the IF3 register set can be configured for each message object. A message object is enabled for automatic IF3 update, if the dedicated IF3UpdEn flag is set. This means that an active NewDat flag of this message object (e.g due to reception of a CAN frame) will trigger an automatic copy of the whole message object to IF3 register set. IF3 Update enable should not be set for transmit objects." id="IF3UPD12" offset="0x160" width="32">
    
  <bitfield begin="31" description="IF3 Update Enabled (for all message objects)" end="16" id="IF3UpdEn_1" rwaccess="RW" width="16">
    <bitenum description="Automatic IF3 update is enabled for this message object. A message object is scheduled to be copied to IF3 register set, if NewDat flag of the message object is active." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="Automatic IF3 update is disabled for this message object." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="15" description="IF3 Update Enabled (for all message objects)" end="0" id="IF3UpdEn_0" rwaccess="RW" width="16">
    <bitenum description="Automatic IF3 update is enabled for this message object. A message object is scheduled to be copied to IF3 register set, if NewDat flag of the message object is active." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="Automatic IF3 update is disabled for this message object." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
  </register>
  
  
  <register acronym="IF3UPD34" description="IF3 Update Enable Register  The automatic update functionality of the IF3 register set can be configured for each message object. A message object is enabled for automatic IF3 update, if the dedicated IF3UpdEn flag is set. This means that an active NewDat flag of this message object (e.g due to reception of a CAN frame) will trigger an automatic copy of the whole message object to IF3 register set. IF3 Update enable should not be set for transmit objects." id="IF3UPD34" offset="0x164" width="32">
    
  <bitfield begin="31" description="IF3 Update Enabled (for all message objects)" end="16" id="IF3UpdEn_1" rwaccess="RW" width="16">
    <bitenum description="Automatic IF3 update is enabled for this message object. A message object is scheduled to be copied to IF3 register set, if NewDat flag of the message object is active." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="Automatic IF3 update is disabled for this message object." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="15" description="IF3 Update Enabled (for all message objects)" end="0" id="IF3UpdEn_0" rwaccess="RW" width="16">
    <bitenum description="Automatic IF3 update is enabled for this message object. A message object is scheduled to be copied to IF3 register set, if NewDat flag of the message object is active." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="Automatic IF3 update is disabled for this message object." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
  </register>
  
  
  <register acronym="IF3UPD56" description="IF3 Update Enable Register  The automatic update functionality of the IF3 register set can be configured for each message object. A message object is enabled for automatic IF3 update, if the dedicated IF3UpdEn flag is set. This means that an active NewDat flag of this message object (e.g due to reception of a CAN frame) will trigger an automatic copy of the whole message object to IF3 register set. IF3 Update enable should not be set for transmit objects." id="IF3UPD56" offset="0x168" width="32">
    
  <bitfield begin="31" description="IF3 Update Enabled (for all message objects)" end="16" id="IF3UpdEn_1" rwaccess="RW" width="16">
    <bitenum description="Automatic IF3 update is enabled for this message object. A message object is scheduled to be copied to IF3 register set, if NewDat flag of the message object is active." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="Automatic IF3 update is disabled for this message object." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="15" description="IF3 Update Enabled (for all message objects)" end="0" id="IF3UpdEn_0" rwaccess="RW" width="16">
    <bitenum description="Automatic IF3 update is enabled for this message object. A message object is scheduled to be copied to IF3 register set, if NewDat flag of the message object is active." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="Automatic IF3 update is disabled for this message object." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
  </register>
  
  
  <register acronym="IF3UPD78" description="IF3 Update Enable Register  The automatic update functionality of the IF3 register set can be configured for each message object. A message object is enabled for automatic IF3 update, if the dedicated IF3UpdEn flag is set. This means that an active NewDat flag of this message object (e.g due to reception of a CAN frame) will trigger an automatic copy of the whole message object to IF3 register set. IF3 Update enable should not be set for transmit objects." id="IF3UPD78" offset="0x16C" width="32">
    
  <bitfield begin="31" description="IF3 Update Enabled (for all message objects)" end="16" id="IF3UpdEn_1" rwaccess="RW" width="16">
    <bitenum description="Automatic IF3 update is enabled for this message object. A message object is scheduled to be copied to IF3 register set, if NewDat flag of the message object is active." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="Automatic IF3 update is disabled for this message object." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="15" description="IF3 Update Enabled (for all message objects)" end="0" id="IF3UpdEn_0" rwaccess="RW" width="16">
    <bitenum description="Automatic IF3 update is enabled for this message object. A message object is scheduled to be copied to IF3 register set, if NewDat flag of the message object is active." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="Automatic IF3 update is disabled for this message object." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
  </register>
  
  
  <register acronym="Reserved_15" id="Reserved_15" offset="0x170" width="32">
    
  <bitfield begin="31" description="Reserved" end="0" id="Reserved" rwaccess="R" width="32"></bitfield>
  </register>
  
  
  <register acronym="Reserved_16" id="Reserved_16" offset="0x174" width="32">
    
  <bitfield begin="31" description="Reserved" end="0" id="Reserved" rwaccess="R" width="32"></bitfield>
  </register>
  
  
  <register acronym="Reserved_17" id="Reserved_17" offset="0x178" width="32">
    
  <bitfield begin="31" description="Reserved" end="0" id="Reserved" rwaccess="R" width="32"></bitfield>
  </register>
  
  
  <register acronym="Reserved_18" id="Reserved_18" offset="0x17C" width="32">
    
  <bitfield begin="31" description="Reserved" end="0" id="Reserved" rwaccess="R" width="32"></bitfield>
  </register>
  
  
  <register acronym="Reserved_19" id="Reserved_19" offset="0x180" width="32">
    
  <bitfield begin="31" description="Reserved" end="0" id="Reserved" rwaccess="R" width="32"></bitfield>
  </register>
  
  
  <register acronym="Reserved_20" id="Reserved_20" offset="0x184" width="32">
    
  <bitfield begin="31" description="Reserved" end="0" id="Reserved" rwaccess="R" width="32"></bitfield>
  </register>
  
  
  <register acronym="Reserved_21" id="Reserved_21" offset="0x188" width="32">
    
  <bitfield begin="31" description="Reserved" end="0" id="Reserved" rwaccess="R" width="32"></bitfield>
  </register>
  
  
  <register acronym="Reserved_22" id="Reserved_22" offset="0x18C" width="32">
    
  <bitfield begin="31" description="Reserved" end="0" id="Reserved" rwaccess="R" width="32"></bitfield>
  </register>
  
  
  <register acronym="Reserved_23" id="Reserved_23" offset="0x190" width="32">
    
  <bitfield begin="31" description="Reserved" end="0" id="Reserved" rwaccess="R" width="32"></bitfield>
  </register>
  
  
  <register acronym="Reserved_24" id="Reserved_24" offset="0x194" width="32">
    
  <bitfield begin="31" description="Reserved" end="0" id="Reserved" rwaccess="R" width="32"></bitfield>
  </register>
  
  
  <register acronym="Reserved_25" id="Reserved_25" offset="0x198" width="32">
    
  <bitfield begin="31" description="Reserved" end="0" id="Reserved" rwaccess="R" width="32"></bitfield>
  </register>
  
  
  <register acronym="Reserved_26" id="Reserved_26" offset="0x19C" width="32">
    
  <bitfield begin="31" description="Reserved" end="0" id="Reserved" rwaccess="R" width="32"></bitfield>
  </register>
  
  
  <register acronym="Reserved_27" id="Reserved_27" offset="0x1A0" width="32">
    
  <bitfield begin="31" description="Reserved" end="0" id="Reserved" rwaccess="R" width="32"></bitfield>
  </register>
  
  
  <register acronym="Reserved_28" id="Reserved_28" offset="0x1A4" width="32">
    
  <bitfield begin="31" description="Reserved" end="0" id="Reserved" rwaccess="R" width="32"></bitfield>
  </register>
  
  
  <register acronym="Reserved_29" id="Reserved_29" offset="0x1A8" width="32">
    
  <bitfield begin="31" description="Reserved" end="0" id="Reserved" rwaccess="R" width="32"></bitfield>
  </register>
  
  
  <register acronym="Reserved_30" id="Reserved_30" offset="0x1AC" width="32">
    
  <bitfield begin="31" description="Reserved" end="0" id="Reserved" rwaccess="R" width="32"></bitfield>
  </register>
  
  
  <register acronym="Reserved_31" id="Reserved_31" offset="0x1B0" width="32">
    
  <bitfield begin="31" description="Reserved" end="0" id="Reserved" rwaccess="R" width="32"></bitfield>
  </register>
  
  
  <register acronym="Reserved_32" id="Reserved_32" offset="0x1B4" width="32">
    
  <bitfield begin="31" description="Reserved" end="0" id="Reserved" rwaccess="R" width="32"></bitfield>
  </register>
  
  
  <register acronym="Reserved_33" id="Reserved_33" offset="0x1B8" width="32">
    
  <bitfield begin="31" description="Reserved" end="0" id="Reserved" rwaccess="R" width="32"></bitfield>
  </register>
  
  
  <register acronym="Reserved_34" id="Reserved_34" offset="0x1BC" width="32">
    
  <bitfield begin="31" description="Reserved" end="0" id="Reserved" rwaccess="R" width="32"></bitfield>
  </register>
  
  
  <register acronym="Reserved_35" id="Reserved_35" offset="0x1C0" width="32">
    
  <bitfield begin="31" description="Reserved" end="0" id="Reserved" rwaccess="R" width="32"></bitfield>
  </register>
  
  
  <register acronym="Reserved_36" id="Reserved_36" offset="0x1C4" width="32">
    
  <bitfield begin="31" description="Reserved" end="0" id="Reserved" rwaccess="R" width="32"></bitfield>
  </register>
  
  
  <register acronym="Reserved_37" id="Reserved_37" offset="0x1C8" width="32">
    
  <bitfield begin="31" description="Reserved" end="0" id="Reserved" rwaccess="R" width="32"></bitfield>
  </register>
  
  
  <register acronym="Reserved_38" id="Reserved_38" offset="0x1CC" width="32">
    
  <bitfield begin="31" description="Reserved" end="0" id="Reserved" rwaccess="R" width="32"></bitfield>
  </register>
  
  
  <register acronym="Reserved_39" id="Reserved_39" offset="0x1D0" width="32">
    
  <bitfield begin="31" description="Reserved" end="0" id="Reserved" rwaccess="R" width="32"></bitfield>
  </register>
  
  
  <register acronym="Reserved_40" id="Reserved_40" offset="0x1D4" width="32">
    
  <bitfield begin="31" description="Reserved" end="0" id="Reserved" rwaccess="R" width="32"></bitfield>
  </register>
  
  
  <register acronym="Reserved_41" id="Reserved_41" offset="0x1D8" width="32">
    
  <bitfield begin="31" description="Reserved" end="0" id="Reserved" rwaccess="R" width="32"></bitfield>
  </register>
  
  
  <register acronym="Reserved_42" id="Reserved_42" offset="0x1DC" width="32">
    
  <bitfield begin="31" description="Reserved" end="0" id="Reserved" rwaccess="R" width="32"></bitfield>
  </register>
  
  
  <register acronym="TIOC" description="CAN TX IO Control Register  The CAN_TX pin of the DCAN module can be used as general purpose IO pin if CAN function is not needed. The values of the IO control registers are only writable if Init bit of the CAN control register is set. The OD, Func, Dir and Out bits of the CAN TX IO control register are forced to certain values when Init bit of CAN control register is reset (see bit descriptions)." id="TIOC" offset="0x1E0" width="32">
    
  <bitfield begin="31" description="Reserved" end="19" id="Reserved1" rwaccess="R" width="13"></bitfield>
    
  <bitfield begin="18" description="CAN_TX pull up/pull down select. This bit is only active when CAN_TX is configured to be an input." end="18" id="PU" rwaccess="RW" width="1">
    <bitenum description="CAN_TX pull up is selected, when pull logic is active (PD = 0)." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="CAN_TX pull down is selected, when pull logic is active (PD = 0)." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="17" description="CAN_TX pull disable. This bit is only active when CAN_TX is configured to be an input." end="17" id="PD" rwaccess="RW" width="1">
    <bitenum description="CAN_TX pull is disabled" id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="CAN_TX pull is active" id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="16" description="CAN_TX open drain enable. This bit is only active when CAN_TX is configured to be in GIO mode (TIOC.Func=0). Forced to '0' if Init bit of CAN control register is reset." end="16" id="OD" rwaccess="RW" width="1">
    <bitenum description="The CAN_TX pin is configured in open drain mode." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="The CAN_TX pin is configured in push/pull mode." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="15" description="Reserved" end="4" id="Reserved2" rwaccess="R" width="12"></bitfield>
    
  <bitfield begin="3" description="CAN_TX function. This bit changes the function of the CAN_TX pin. Forced to '1' if Init bit of CAN control register is reset." end="3" id="Func" rwaccess="RW" width="1">
    <bitenum description="CAN_TX pin is in functional mode (as an output to transmit CAN data)." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="CAN_TX pin is in GIO mode." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="2" description="CAN_TX data direction. This bit controls the direction of the CAN_TX pin when it is configured to be in GIO mode only (TIOC.Func=0). Forced to '1' if Init bit of CAN control register is reset." end="2" id="Dir" rwaccess="RW" width="1">
    <bitenum description="The CAN_TX pin is an output" id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="The CAN_TX pin is an input." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="1" description="CAN_TX data out write. This bit is only active when CAN_TX pin is configured to be in GIO mode (TIOC.Func = 0) and configured to be an output pin (TIOC.Dir = 1). The value of this bit indicates the value to be output to the CAN_TX pin. Forced to Tx output of the CAN core, if Init bit of CAN control register is reset." end="1" id="Out" rwaccess="RW" width="1">
    <bitenum description="The CAN_TX pin is driven to logic high" id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="The CAN_TX pin is driven to logic low" id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="0" description="CAN_TX data in. Note: When CAN_TX pin is connected to a CAN transceiver, an external pullup resistor has to be used to ensure that the CAN bus will not be disturbed (e.g. while reset of the DCAN module)." end="0" id="In" rwaccess="R" width="1">
    <bitenum description="The CAN_TX pin is at logic high" id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="The CAN_TX pin is at logic low" id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
  </register>
  
  
  <register acronym="RIOC" description="CAN RX IO Control Register  The CAN_RX pin of the DCAN module can be used as general purpose IO pin if CAN function is not needed. The values of the IO control registers are writable only if Init bit of CAN control register is set. The OD, Func and Dir bits of the CAN RX IO control register are forced to certain values when the Init bit of CAN control register is reset (see bit descriptions)." id="RIOC" offset="0x1E4" width="32">
    
  <bitfield begin="31" description="Reserved" end="19" id="Reserved1" rwaccess="R" width="13"></bitfield>
    
  <bitfield begin="18" description="CAN_RX pull up/pull down select. This bit is only active when CAN_RX is configured to be an input." end="18" id="PU" rwaccess="RW" width="1">
    <bitenum description="CAN_T=RX pull up is selected, when pull logic is active(PD = 0)." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="CAN_RX pull down is selected, when pull logic is active (PD = 0)." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="17" description="CAN_RX pull disable. This bit is only active when CAN_TX is configured to be an input." end="17" id="PD" rwaccess="RW" width="1">
    <bitenum description="CAN_RX pull is disabled" id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="CAN_RX pull is active" id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="16" description="CAN_RX open drain enable. This bit is only active when CAN_RX is configured to be in GIO mode (TIOC.Func=0). Forced to '0' if Init bit of CAN control register is reset." end="16" id="OD" rwaccess="RW" width="1">
    <bitenum description="The CAN_RX pin is configured in open drain mode." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="The CAN_RX pin is configured in push/pull mode." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="15" description="Reserved" end="4" id="Reserved2" rwaccess="R" width="12"></bitfield>
    
  <bitfield begin="3" description="CAN_RX function. This bit changes the function of the CAN_RX pin. Forced to '1' if Init bit of CAN control register is reset." end="3" id="Func" rwaccess="RW" width="1">
    <bitenum description="CAN_RX pin is in functional mode (as an output to transmit CAN data)." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="CAN_RX pin is in GIO mode." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="2" description="CAN_RX data direction. This bit controls the direction of the CAN_RX pin when it is configured to be in GIO mode only (TIOC.Func=0). Forced to '1' if Init bit of CAN control register is reset." end="2" id="Dir" rwaccess="RW" width="1">
    <bitenum description="The CAN_RX pin is an output" id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="The CAN_RX pin is an input." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="1" description="CAN_RX data out write. This bit is only active when CAN_RX pin is configured to be in GIO mode (TIOC.Func = 0) and configured to be an output pin (TIOC.Dir = 1). The value of this bit indicates the value to be output to the CAN_RX pin. Forced to Tx output of the CAN core, if Init bit of CAN control register is reset." end="1" id="Out" rwaccess="RW" width="1">
    <bitenum description="The CAN_RX pin is driven to logic high" id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="The CAN_RX pin is driven to logic low" id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="0" description="CAN_RX data in. Note: When CAN_RX pin is connected to a CAN transceiver, an external pullup resistor has to be used to ensure that the CAN bus will not be disturbed (for example, while reset of the DCAN module)." end="0" id="In" rwaccess="R" width="1">
    <bitenum description="The CAN_RX pin is at logic high" id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="The CAN_RX pin is at logic low" id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
  </register>
</module>
