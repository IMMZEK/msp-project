<?xml version="1.0" encoding="UTF-8" standalone="yes"?>


<module description="UART" id="UART">
  
  
  <register acronym="UART_IER_CIR" description="" id="UART_IER_CIR" offset="0x0" width="32"></register>
  
  
  <register acronym="UART_IER_IRDA" description="The following interrupt enable register (IER) description is for IrDA mode. The IrDA IER is selected with a register bit setting of LCR[7] = 0. In IrDA mode, EFR[4] has no impact on the access to IER[7:4]. The IrDA interrupt enable register (IER) can be programmed to enable/disable any interrupt. There are 8 types of interrupt in these modes, received EOF, LSR interrupt, TX status, status FIFO interrupt, RX overrun, last byte in RX FIFO, THR interrupt, and RHR interrupt. Each interrupt can be enabled/disabled individually. The TXSTATUSIT interrupt reflects two possible conditions. The MDR2[0] bit should be read to determine the status in the event of this interrupt." id="UART_IER_IRDA" offset="0x4" width="16">
    
  <bitfield begin="15" description=" " end="8" id="RESERVED_1" rwaccess="R" width="8"></bitfield>
    
  <bitfield begin="7" description=" EOFIT" end="7" id="EOFIT" rwaccess="RW" width="1">
    <bitenum description="Enables the received EOF interrupt." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="Disables the received EOF interrupt." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="6" description=" LINESTSIT" end="6" id="LINESTSIT" rwaccess="RW" width="1">
    <bitenum description="Enables the receiver line status interrupt." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="Disables the receiver line status interrupt." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="5" description=" TXSTATUSIT" end="5" id="TXSTSIT" rwaccess="RW" width="1">
    <bitenum description="Enables the TX status interrupt." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="Disables the TX status interrupt." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="4" description=" STSFIFOTRIGIT" end="4" id="STSFIFOTRIGIT" rwaccess="RW" width="1">
    <bitenum description="Enables status FIFO trigger level interrupt." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="Disables status FIFO trigger level interrupt." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="3" description=" RXOVERRUNIT" end="3" id="RXOVERRUNIT" rwaccess="RW" width="1">
    <bitenum description="Enables the RX overrun interrupt." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="Disables the RX overrun interrupt." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="2" description=" LASTRXBYTEIT" end="2" id="LASTRXBYTEIT" rwaccess="RW" width="1">
    <bitenum description="Enables the last byte of frame in RX FIFO interrupt." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="Disables the last byte of frame in RX FIFO interrupt." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="1" description=" THRIT" end="1" id="THRIT" rwaccess="RW" width="1">
    <bitenum description="Enables the THR interrupt." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="Disables the THR interrupt." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="0" description=" RHRIT" end="0" id="RHRIT" rwaccess="RW" width="1">
    <bitenum description="Enables the RHR interrupt." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="Disables the RHR interrupt." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
  </register>
  
  
  <register acronym="UART_EFR" description="The enhanced feature register (EFR) is selected with a register bit setting of LCR[7] = BFh. The enhanced feature register (EFR) enables or disables enhanced features. Most enhanced functions apply only to UART modes, but EFR[4] enables write accesses to FCR[5:4], the TX trigger level, which is also used in IrDA modes." id="UART_EFR" offset="0x8" width="16">
    
  <bitfield begin="15" description=" " end="8" id="RESERVED_1" rwaccess="R" width="8"></bitfield>
    
  <bitfield begin="7" description=" Auto-CTS enable bit (UART mode only)." end="7" id="AUTOCTSEN" rwaccess="RW" width="1">
    <bitenum description="Auto-CTS flow control is enabled; transmission is halted when the CTS (active-low) pin is high (inactive)." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="Normal operation." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="6" description=" Auto-RTS enable bit (UART mode only)." end="6" id="AUTORTSEN" rwaccess="RW" width="1">
    <bitenum description="Auto-RTS flow control is enabled; RTS (active-low) pin goes high (inactive) when the receiver FIFO HALT trigger level, TCR[3:0], is reached and goes low (active) when the receiver FIFO RESTORE transmission trigger level is reached." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="Normal operation." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="5" description=" Special character detect (UART mode only)." end="5" id="SPECIALCHARDETECT" rwaccess="RW" width="1">
    <bitenum description="Special character detect enable. Received data is compared with XOFF2 data. If a match occurs, the received data is transferred to RX FIFO and the IIR[4] bit is set to 1 to indicate that a special character was detected." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="Normal operation." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="4" description=" Enhanced functions write enable bit." end="4" id="ENHANCEDEN" rwaccess="RW" width="1">
    <bitenum description="Enables writing to IER[7:4], FCR[5:4], and MCR[7:5]." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="Disables writing to IER[7:4], FCR[5:4], and MCR[7:5]." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="3" description=" Combinations of software flow control can be selected by programming this bit. [[br]]XON1 and XON2 should be set to different values if the software flow control is enabled. [[br]]The TX and RX software flow control options are as follows. [[br]]EFR[3] = 0, EFR[2] = 0, EFR[1] = X, and EFR[0] = X, then: No transmit flow control. [[br]]EFR[3] = 1, EFR[2] = 0, EFR[1] = X, and EFR[0] = X, then: Transmit XON1, XOFF1. [[br]]EFR[3] = 0, EFR[2] = 1, EFR[1] = X, and EFR[0] = X, then: Transmit XON2, XOFF2. [[br]]EFR[3] = 1, EFR[2] = 1, EFR[1] = X, and EFR[0] = X, then: Transmit XON1, XON2 or XOFF1, XOFF2. [[br]]The XON1 and XON2 characters or the XOFF1 and XOFF2 characters must be transmitted/received sequentially with XON1/XOFF1 followed by XON2/XOFF2. [[br]]EFR[3] = X, EFR[2] = X, EFR[1] = 0, and EFR[0] = 0, then: No receive flow control. [[br]]EFR[3] = X, EFR[2] = X, EFR[1] = 1, and EFR[0] = 0, then: Receiver compares XON1, XOFF1. [[br]]EFR[3] = X, EFR[2] = X, EFR[1] = 0, and EFR[0] = 1, then: Receiver compares XON2, XOFF2. [[br]]EFR[3] = X, EFR[2] = X, EFR[1] = 1, and EFR[0] = 1, then: Receiver compares XON1, XON2 or XOFF1, XOFF2. [[br]]The XON1 and XON2 characters or the XOFF1 and XOFF2 characters must be transmitted/received sequentially with XON1/XOFF1 followed by XON2/XOFF2. [[br]]In IrDA mode, EFR[1] and EFR[0] select the IR address to check (see IR Address Checking)." end="0" id="SWFLOWCTRL" rwaccess="RW" width="4"></bitfield>
  </register>
  
  
  <register acronym="UART_LCR" description="The line control register (LCR) is selected with a bit register setting of LCR[7] = 0, LCR[7] not equal to BFh, or LCR[7] = BFh. As soon as LCR[6] is set to 1, the TX line is forced to 0 and remains in this state as long as LCR[6] = 1." id="UART_LCR" offset="0xC" width="16">
    
  <bitfield begin="15" description=" " end="8" id="RESERVED_1" rwaccess="R" width="8"></bitfield>
    
  <bitfield begin="7" description=" Divisor latch enable." end="7" id="DIV_EN" rwaccess="RW" width="1">
    <bitenum description="Divisor latch enable. Allows access to DLL and DLH." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="Normal operating condition." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="6" description=" Break control bit. [[br]]Note: When LCR[6] is set to 1, the TX line is forced to 0 and remains in this state as long as LCR[6] = 1. " end="6" id="BREAK_EN" rwaccess="RW" width="1">
    <bitenum description="Forces the transmitter output to go low to alert the communication terminal." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="Normal operating condition." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="5" description=" If LCR[3] = 1, then:" end="5" id="PARITY_TYPE2" rwaccess="RW" width="1">
    <bitenum description="If LCR[5] = 1 and LCR[4] = 0, the parity bit is forced to 1 in the transmitted and received data. If LCR[5] = 1 and LCR[4] = 1, the parity bit is forced to 0 in the transmitted and received data." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="If LCR[5] = 0, LCR[4] selects the forced parity format." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="4" description=" If LCR[3] = 1, then:" end="4" id="PARITY_TYPE1" rwaccess="RW" width="1">
    <bitenum description="Even parity is generated." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="Odd parity is generated." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="3" description=" Parity bit." end="3" id="PARITY_EN" rwaccess="RW" width="1">
    <bitenum description="A parity bit is generated during transmission, and the receiver checks for received parity." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="No parity." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="2" description=" Specifies the number of stop bits." end="2" id="NB_STOP" rwaccess="RW" width="1">
    <bitenum description="1.5 stop bits (word length = 5) or 2 stop bits (word length = 6, 7, 8)." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="1 stop bit (word length = 5, 6, 7, 8)." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="1" description=" Specifies the word length to be transmitted or received." end="0" id="CHAR_LENGTH" rwaccess="RW" width="2">
    <bitenum description="8 bit" id="en_4_0x3" token="en_4_0x3" value="0x3"></bitenum>
    <bitenum description="7 bits" id="en_3_0x2" token="en_3_0x2" value="0x2"></bitenum>
    <bitenum description="6 bits" id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="5 bits" id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
  </register>
  
  
  <register acronym="UART_MCR" description="The modem control register (MCR) is selected with a register bit setting of LCR[7] = 0 or LCR[7] not equal to BFh. MCR[7:5] can only be written when EFR[4] = 1. Bits 3-0 control the interface with the modem, data set, or peripheral device that is emulating the modem." id="UART_MCR" offset="0x10" width="16">
    
  <bitfield begin="15" description=" " end="7" id="RESERVED_1" rwaccess="R" width="9"></bitfield>
    
  <bitfield begin="6" description=" Can be written only when EFR[4] = 1." end="6" id="TCRTLR" rwaccess="RW" width="1">
    <bitenum description="Enables access to the TCR and TLR registers." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="No action." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="5" description=" Can be written only when EFR[4] = 1." end="5" id="XONEN" rwaccess="RW" width="1">
    <bitenum description="Enable XON any function." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="Disable XON any function." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="4" description=" Loopback mode enable." end="4" id="LOOPBACKEN" rwaccess="RW" width="1">
    <bitenum description="Enable local loopback mode (internal). In this mode, the MCR[3:0] signals are looped back into MSR[7:4]. The transmit output is looped back to the receive input internally." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="Normal operating mode." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="3" description=" CDSTSCH." end="3" id="CDSTSCH" rwaccess="RW" width="1">
    <bitenum description="In loopback mode, forces DCD (active-low) input low and IRQ outputs to INACTIVE state." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="In loopback mode, forces DCD (active-low) input high and IRQ outputs to INACTIVE state." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="2" description=" RISTSCH." end="2" id="RISTSCH" rwaccess="RW" width="1">
    <bitenum description="In loopback mode, forces RI (active-low) input active (low)." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="In loopback mode, forces RI (active-low) input inactive (high)." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="1" description=" In loopback mode, controls MSR[4]. [[br]]If auto-RTS is enabled, the RTS (active-low) output is controlled by hardware flow control. " end="1" id="RTS" rwaccess="RW" width="1">
    <bitenum description="Force RTS (active-low) output to active (low)." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="Force RTS (active-low) output to inactive (high)." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="0" description=" DTR." end="0" id="DTR" rwaccess="RW" width="1">
    <bitenum description="Force DTR (active-low) output (used in loopback mode) to active (low)." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="Force DTR (active-low) output (used in loopback mode) to inactive (high)." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
  </register>
  
  
  <register acronym="UART_XON2_ADDR2" description="The XON2/ADDR2 registers are selected with a register bit setting of LCR[7] = BFh. In UART mode, XON2 character; in IrDA mode, ADDR2 address 2." id="UART_XON2_ADDR2" offset="0x14" width="16">
    
  <bitfield begin="15" description=" " end="8" id="RESERVED_1" rwaccess="R" width="8"></bitfield>
    
  <bitfield begin="7" description=" Stores the 8 bit XON2 character in UART modes and ADDR2 address 2 in IrDA modes." end="0" id="XONWORD2" rwaccess="RW" width="8"></bitfield>
  </register>
  
  
  <register acronym="UART_TCR" description="The transmission control register (TCR) is selected with a register bit setting of LCR[7] = 0, LCR[7] not equal to BFh, or LCR[7] = BFh. The TCR is accessible only when EFR[4] = 1 and MCR[6] = 1. The transmission control register (TCR) stores the receive FIFO threshold levels to start/stop transmission during hardware flow control. Trigger levels from 0-60 bytes are available with a granularity of 4. Trigger level = 4 x [4-bit register value]. You must ensure that TCR[3:0] > TCR[7:4], whenever auto-RTS or software flow control is enabled to avoid a misoperation of the device. In FIFO interrupt mode with flow control, you have to also ensure that the trigger level to HALT transmission is greater or equal to receive FIFO trigger level (either TLR[7:4] or FCR[7:6]); otherwise, FIFO operation stalls. In FIFO DMA mode with flow control, this concept does not exist because the DMA request is sent each time a byte is received." id="UART_TCR" offset="0x18" width="16">
    
  <bitfield begin="15" description=" " end="8" id="RESERVED_1" rwaccess="R" width="8"></bitfield>
    
  <bitfield begin="7" description=" RX FIFO trigger level to RESTORE transmission (0 to 60)." end="4" id="RXFIFOTRIGSTART" rwaccess="RW" width="4"></bitfield>
    
  <bitfield begin="3" description=" RX FIFO trigger level to HALT transmission (0 to 60)." end="0" id="RXFIFOTRIGHALT" rwaccess="RW" width="4"></bitfield>
  </register>
  
  
  <register acronym="UART_SPR" description="The scratchpad register (SPR) is selected with a register bit setting of LCR[7] = 0 or LCR[7] not equal to BFh. The scratchpad register (SPR) is a read/write register that does not control the module. It is a scratchpad register used to hold temporary data." id="UART_SPR" offset="0x1C" width="16">
    
  <bitfield begin="15" description=" " end="8" id="RESERVED_1" rwaccess="R" width="8"></bitfield>
    
  <bitfield begin="7" description=" Scratchpad register." end="0" id="SPR_WORD" rwaccess="RW" width="8"></bitfield>
  </register>
  
  
  <register acronym="UART_MDR1" description="The mode definition register 1 (MDR1) is selected with a register bit setting of LCR[7] = 0, LCR[7] not equal to BFh, or LCR[7] = BFh. The mode of operation is programmed by writing to MDR1[2:0]; therefore, the mode definition register 1 (MDR1) must be programmed on startup after configuration of the configuration registers (DLL, DLH, and LCR). The value of MDR1[2:0] must not be changed again during normal operation. If the module is disabled by setting the MODESELECT field to 7h, interrupt requests can still be generated unless disabled through the interrupt enable register (IER). In this case, UART mode interrupts are visible. Reading the interrupt identification register (IIR) shows the UART mode interrupt flags." id="UART_MDR1" offset="0x20" width="16">
    
  <bitfield begin="15" description=" " end="8" id="RESERVED_1" rwaccess="R" width="8"></bitfield>
    
  <bitfield begin="7" description=" IrDA mode only." end="7" id="FRMENDMODE" rwaccess="RW" width="1">
    <bitenum description="Set EOT bit method." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="Frame-length method." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="6" description=" MIR/FIR modes only." end="6" id="SIPMODE" rwaccess="RW" width="1">
    <bitenum description="Automatic SIP mode: SIP is generated after each transmission." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="Manual SIP mode: SIP is generated with the control of ACREG[3]." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="5" description=" Store and control the transmission." end="5" id="SCT" rwaccess="RW" width="1">
    <bitenum description="Starts the infrared transmission with the control of ACREG[2]. Note: Before starting any transmission, there must be no reception ongoing." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="Starts the infrared transmission when a value is written to the THR register." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="4" description=" Used to configure the infrared transceiver." end="4" id="SETTXIR" rwaccess="RW" width="1">
    <bitenum description="TXIR pin output is forced high (not dependant of MDR2[7] value)." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="If MDR2[7] = 0, no action; if MDR2[7] = 1, TXIR pin output is forced low." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="3" description=" IrDA/CIR sleep mode." end="3" id="IRSLEEP" rwaccess="RW" width="1">
    <bitenum description="IrDA/CIR sleep mode enabled." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="IrDA/CIR sleep mode disabled." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="2" description=" UART/IrDA/CIR mode selection." end="0" id="MODESELECT" rwaccess="RW" width="3">
    <bitenum description="Disable (default state)." id="en_8_0x7" token="en_8_0x7" value="0x7"></bitenum>
    <bitenum description="CIR mode." id="en_7_0x6" token="en_7_0x6" value="0x6"></bitenum>
    <bitenum description="FIR mode." id="en_6_0x5" token="en_6_0x5" value="0x5"></bitenum>
    <bitenum description="MIR mode." id="en_5_0x4" token="en_5_0x4" value="0x4"></bitenum>
    <bitenum description="UART 13x mode." id="en_4_0x3" token="en_4_0x3" value="0x3"></bitenum>
    <bitenum description="UART 16x auto-baud." id="en_3_0x2" token="en_3_0x2" value="0x2"></bitenum>
    <bitenum description="SIR mode." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="UART 16x mode." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
  </register>
  
  
  <register acronym="UART_MDR2" description="The mode definition register 2 (MDR2) is selected with a register bit setting of LCR[7] = 0, LCR[7] not equal to BFh, or LCR[7] = BFh. The MDR2[0] bit describes the status of the TX status interrupt in IIR[5]. The IRTXUNDERRUN bit must be read after a TX status interrupt occurs. The MDR2[2:1] bits set the trigger level for the frame status FIFO (8 entries) and must be programmed before the mode is programmed in MDR1[2:0]. The MDR2[6] bit gives the flexibility to invert the RX pin inside the UART module to ensure that the protocol at the input of the transceiver module has the same polarity at module level. By default, the RX pin is inverted because most of transceiver invert the IR receive pin." id="UART_MDR2" offset="0x24" width="16">
    
  <bitfield begin="15" description=" " end="8" id="RESERVED_1" rwaccess="R" width="8"></bitfield>
    
  <bitfield begin="7" description=" Provides alternate functionality for MDR1[4]." end="7" id="SETTXIRALT" rwaccess="RW" width="1">
    <bitenum description="Alternate mode for SETTXIR" id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="Normal mode" id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="6" description=" Only for IR mode (IrDA and CIR). [[br]]Invert RX pin in the module before the voting or sampling system logic of the infrared block. [[br]]This does not affect the RX path in UART modem modes. " end="6" id="IRRXINVERT" rwaccess="RW" width="1">
    <bitenum description="No inversion is performed." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="Inversion is performed." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="5" description=" CIR pulse modulation definition. [[br]]Defines high level of the pulse width associated with a digit: " end="4" id="CIRPULSEMODE" rwaccess="RW" width="2">
    <bitenum description="Pulse width of 6 from 12 cycles." id="en_4_0x3" token="en_4_0x3" value="0x3"></bitenum>
    <bitenum description="Pulse width of 5 from 12 cycles." id="en_3_0x2" token="en_3_0x2" value="0x2"></bitenum>
    <bitenum description="Pulse width of 4 from 12 cycles." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="Pulse width of 3 from 12 cycles." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="3" description=" UART mode only. [[br]]Used to allow pulse shaping in UART mode. " end="3" id="UARTPULSE" rwaccess="RW" width="1">
    <bitenum description="UART mode with pulse shaping." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="Normal UART mode." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="2" description=" Only for IrDA mode. [[br]]Frame status FIFO threshold select: " end="1" id="STSFIFOTRIG" rwaccess="RW" width="2">
    <bitenum description="8 entries" id="en_4_0x3" token="en_4_0x3" value="0x3"></bitenum>
    <bitenum description="7 entries" id="en_3_0x2" token="en_3_0x2" value="0x2"></bitenum>
    <bitenum description="4 entries" id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="1 entry" id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="0" description=" IrDA transmission status interrupt. [[br]]When the TX status interrupt (IIR[5]) occurs, the meaning of the interrupt is: " end="0" id="IRTXUNDERRUN" rwaccess="R" width="1">
    <bitenum description="An underrun occurred. The last bit of the frame was transmitted but with an underrun error. The bit is reset to 0 when the RESUME register is read." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="The last bit of the frame was transmitted successfully without error." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
  </register>
  
  
  <register acronym="UART_TXFLL" description="The transmit frame length low register (TXFLL) is selected with a register bit setting of LCR[7] = 0, LCR[7] not equal to BFh, or LCR[7] = BFh. The transmit frame length low register (TXFLL) and the TXFLH register hold the 13-bit transmit frame length (expressed in bytes). TXFLL holds the LSBs and TXFLH holds the MSBs. The frame length value is used if the frame length method of frame closing is used." id="UART_TXFLL" offset="0x28" width="16">
    
  <bitfield begin="15" description=" " end="8" id="RESERVED_1" rwaccess="R" width="8"></bitfield>
    
  <bitfield begin="7" description=" LSB register used to specify the frame length." end="0" id="TXFLL" rwaccess="W" width="8"></bitfield>
  </register>
  
  
  <register acronym="UART_RESUME" description="The RESUME register is selected with a register bit setting of LCR[7] = 0, LCR[7] not equal to BFh, or LCR[7] = BFh. The RESUME register is used to clear internal flags, which halt transmission/reception when an underrun/overrun error occurs. Reading this register resumes the halted operation. This register does not physically exist and always reads as 00." id="UART_RESUME" offset="0x2C" width="16">
    
  <bitfield begin="15" description=" " end="8" id="RESERVED_1" rwaccess="R" width="8"></bitfield>
    
  <bitfield begin="7" description=" Dummy read to restart the TX or RX, value 0 to FFh." end="0" id="RESUME" rwaccess="R" width="8"></bitfield>
  </register>
  
  
  <register acronym="UART_RXFLL" description="The received frame length low register (RXFLL) is selected with a register bit setting of LCR[7] = 0, LCR[7] not equal to BFh, or LCR[7] = BFh. The received frame length low register (RXFLL) and the RXFLH register hold the 12-bit receive maximum frame length. RXFLL holds the LSBs and RXFLH holds the MSBs. If the intended maximum receive frame length is n bytes, program RXFLL and RXFLH to be n + 3 in SIR or MIR modes and n + 6 in FIR mode (+3 and +6 are the result of frame format with CRC and stop flag; two bytes are associated with the FIR stop flag)." id="UART_RXFLL" offset="0x30" width="16">
    
  <bitfield begin="15" description=" " end="8" id="RESERVED_1" rwaccess="R" width="8"></bitfield>
    
  <bitfield begin="7" description=" LSB register used to specify the frame length in reception, value 0 to FFh." end="0" id="RXFLL" rwaccess="W" width="8"></bitfield>
  </register>
  
  
  <register acronym="UART_SFREGH" description="The status FIFO register high (SFREGH) is selected with a register bit setting of LCR[7] = 0, LCR[7] not equal to BFh, or LCR[7] = BFh. The frame lengths of received frames are written into the status FIFO. This information can be read by reading the status FIFO register low (SFREGL) and the status FIFO register high (SFREGH). These registers do not physically exist. The LSBs are read from SFREGL and the MSBs are read from SFREGH. Reading these registers does not alter the status FIFO read pointer. These registers must be read before the pointer is incremented by reading the SFLSR." id="UART_SFREGH" offset="0x34" width="16">
    
  <bitfield begin="15" description=" " end="4" id="RESERVED_1" rwaccess="R" width="12"></bitfield>
    
  <bitfield begin="3" description=" MSB part of the frame length, value 0 to Fh." end="0" id="SFREGH" rwaccess="R" width="4"></bitfield>
  </register>
  
  
  <register acronym="UART_BLR" description="The BOF control register (BLR) is selected with a register bit setting of LCR[7] = 0. The BLR[6] bit is used to select whether C0h or FFh start patterns are to be used, when multiple start flags are required in SIR mode. If only one start flag is required, this is always C0h. If n start flags are required, either (n - 1) C0h or (n -1) FFh flags are sent, followed by a single C0h flag (immediately preceding the first data byte)." id="UART_BLR" offset="0x38" width="16">
    
  <bitfield begin="15" description=" " end="8" id="RESERVED_1" rwaccess="R" width="8"></bitfield>
    
  <bitfield begin="7" description=" Status FIFO reset. [[br]]This bit is self-clearing." end="7" id="STSFIFORESET" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="6" description=" SIR xBOF select." end="6" id="XBOFTYPE" rwaccess="RW" width="1">
    <bitenum description="C0h start pattern is used." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="FFh start pattern is used." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="5" description=" " end="0" id="RESERVED_2" rwaccess="R" width="6"></bitfield>
  </register>
  
  
  <register acronym="UART_ACREG" description="The auxiliary control register (ACREG) is selected with a register bit setting of LCR[7] = 0. If transmit FIFO is not empty and MDR1[5] = 1, IrDA starts a new transfer with data of previous frame as soon as abort frame has been sent. Therefore, TX FIFO must be reset before sending an abort frame. It is recommended to disable TX FIFO underrun capability by masking corresponding underrun interrupt. When disabling underrun by setting ACREG[4] = 1, unknown data is sent over TX line." id="UART_ACREG" offset="0x3C" width="16">
    
  <bitfield begin="15" description=" " end="8" id="RESERVED_1" rwaccess="R" width="8"></bitfield>
    
  <bitfield begin="7" description=" SIR pulse-width select:" end="7" id="PULSETYPE" rwaccess="RW" width="1">
    <bitenum description="1.6 microseconds" id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="3/16 of baud-rate pulse width" id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="6" description=" Primary output used to configure transceivers. [[br]]Connected to the SD/MODE input pin of IrDA transceivers. " end="6" id="SDMOD" rwaccess="RW" width="1">
    <bitenum description="SD pin is set to low." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="SD pin is set to high." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="5" description=" Disable RX input." end="5" id="DISIRRX" rwaccess="RW" width="1">
    <bitenum description="Disables RX input (permanent state; independent of transmit)." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="Normal operation (RX input automatically disabled during transmit, but enabled outside of transmit operation)." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="4" description=" Disable TX underrun." end="4" id="DISTXUNDERRUN" rwaccess="RW" width="1">
    <bitenum description="Long stop bits can be transmitted." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="Long stop bits cannot be transmitted. TX underrun is enabled." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="3" description=" MIR/FIR modes only. [[br]]Send serial infrared interaction pulse (SIP). [[br]]If this bit is set during an MIR/FIR transmission, the SIP is sent at the end of it. [[br]]This bit is automatically cleared at the end of the SIP transmission. " end="3" id="SENDSIP" rwaccess="RW" width="1">
    <bitenum description="Send SIP pulse." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="No action." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="2" description=" Store and control TX start. [[br]]When MDR1[5] = 1 and the LH writes 1 to this bit, the TX state-machine starts frame transmission. [[br]]This bit is self-clearing." end="2" id="SCTXEN" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="1" description=" Frame abort. [[br]]The LH can intentionally abort transmission of a frame by writing 1 to this bit. [[br]]Neither the end flag nor the CRC bits are appended to the frame." end="1" id="ABORTEN" rwaccess="RW" width="1"></bitfield>
    
  <bitfield begin="0" description=" EOT (end-of-transmission) bit. [[br]]The LH writes 1 to this bit just before it writes the last byte to the TX FIFO in the set-EOT bit frame-closing method. [[br]]This bit is automatically cleared when the LH writes to the THR (TX FIFO)." end="0" id="EOTEN" rwaccess="RW" width="1"></bitfield>
  </register>
  
  
  <register acronym="UART_SCR" description="The supplementary control register (SCR) is selected with a register bit setting of LCR[7] = 0, LCR[7] not equal to BFh, or LCR[7] = BFh. Bit 4 enables the wake-up interrupt, but this interrupt is not mapped into the IIR register. Therefore, when an interrupt occurs and there is no interrupt pending in the IIR register, the SSR[1] bit must be checked. To clear the wake-up interrupt, bit SCR[4] must be reset to 0." id="UART_SCR" offset="0x40" width="16">
    
  <bitfield begin="15" description=" " end="8" id="RESERVED_1" rwaccess="R" width="8"></bitfield>
    
  <bitfield begin="7" description=" RXTRIGGRANU1" end="7" id="RXTRIGGRANU1" rwaccess="RW" width="1">
    <bitenum description="Enables the granularity of 1 for trigger RX level." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="Disables the granularity of 1 for trigger RX level." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="6" description=" TXTRIGGRANU1" end="6" id="TXTRIGGRANU1" rwaccess="RW" width="1">
    <bitenum description="Enables the granularity of 1 for trigger TX level." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="Disables the granularity of 1 for trigger TX level." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="5" description=" DSRIT" end="5" id="DSRIT" rwaccess="RW" width="1">
    <bitenum description="Enables DSR (active-low) interrupt." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="Disables DSR (active-low) interrupt." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="4" description=" RX CTS wake-up enable." end="4" id="RXCTSDSRWAKEUPEN" rwaccess="RW" width="1">
    <bitenum description="Waits for a falling edge of RX, CTS (active-low), or DSR (active-low) pins to generate an interrupt." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="Disables the WAKE UP interrupt and clears SSR[1]." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="3" description=" TXEMPTYCTLIT" end="3" id="TXEMPTYCTLIT" rwaccess="RW" width="1">
    <bitenum description="THR interrupt is generated when TX FIFO and TX shift register are empty." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="Normal mode for THR interrupt." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="2" description=" Specifies the DMA mode valid if SCR[0] = 1, then:" end="1" id="DMAMODE2" rwaccess="RW" width="2">
    <bitenum description="DMA mode 3 (UARTnDMAREQ[0] in TX)" id="en_4_0x3" token="en_4_0x3" value="0x3"></bitenum>
    <bitenum description="DMA mode 2 (UARTnDMAREQ[0] in RX)" id="en_3_0x2" token="en_3_0x2" value="0x2"></bitenum>
    <bitenum description="DMA mode 1 (UARTnDMAREQ[0] in TX, UARTnDMAREQ[1] in RX)" id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="DMA mode 0 (no DMA)." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="0" description=" DMAMODECT" end="0" id="DMAMODECTL" rwaccess="RW" width="1">
    <bitenum description="The DMAMODE is set with SCR[2:1]." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="The DMAMODE is set with FCR[3]." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
  </register>
  
  
  <register acronym="UART_SSR" description="The supplementary status register (SSR) is selected with a register bit setting of LCR[7] = 0, LCR[7] not equal to BFh, or LCR[7] = BFh. Bit 1 is reset only when SCR[4] is reset to 0." id="UART_SSR" offset="0x44" width="16">
    
  <bitfield begin="15" description=" " end="3" id="RESERVED_1" rwaccess="R" width="13"></bitfield>
    
  <bitfield begin="2" description=" DMACOUNTERRST." end="2" id="DMACTRRST" rwaccess="RW" width="1">
    <bitenum description="The DMA counter will be reset, if the corresponding FIFO is reset (via FCR[1] or FCR[2])." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="The DMA counter will not be reset, if the corresponding FIFO is reset (via FCR[1] or FCR[2])." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="1" description=" Pin falling edge detection: Reset only when SCR[4] is reset to 0." end="1" id="RXCTSDSRWAKEUPSTS" rwaccess="R" width="1">
    <bitenum description="A falling edge occurred on RX, CTS (active-low), or DSR (active-low)." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="No falling-edge event on RX, CTS (active-low), and DSR (active-low)." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="0" description=" TXFIFOFULL." end="0" id="TXFIFOFULL" rwaccess="R" width="1">
    <bitenum description="TX FIFO is full." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="TX FIFO is not full." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
  </register>
  
  
  <register acronym="UART_EBLR" description="The BOF length register (EBLR) is selected with a register bit setting of LCR[7] = 0. In IrDA SIR operation, the BOF length register (EBLR) specifies the number of BOF + xBOFs to transmit. The value set into this register must consider the BOF character; therefore, to send only one BOF with no XBOF, this register must be set to 1. To send one BOF with n XBOFs, this register must be set to n + 1. Furthermore, the value 0 sends 1 BOF plus 255 XBOFs. In IrDA MIR mode, the BOF length register (EBLR) specifies the number of additional start flags (MIR protocol mandates a minimum of 2 start flags). In CIR mode, the BOF length register (EBLR) specifies the number of consecutive zeros to be received before generating the RXSTOP interrupt (IIR[2]). All the received zeros are stored in the RX FIFO. When the register is cleared to 0, this feature is deactivated and always in reception state, which is disabled by setting the ACREG[5] bit to 1. If the RX_STOP interrupt occurs before a byte boundary, the remaining bits of the last byte are filled with zeros and then passed into the RX FIFO." id="UART_EBLR" offset="0x48" width="16">
    
  <bitfield begin="15" description=" " end="8" id="RESERVED_1" rwaccess="R" width="8"></bitfield>
    
  <bitfield begin="7" description=" IrDA mode: This register allows definition of up to 176 xBOFs, the maximum required by IrDA specification. [[br]]CIR mode: This register specifies the number of consecutive zeros to be received before generating the RXSTOP interrupt (IIR[2]). [[br]] " end="0" id="EBLR" rwaccess="RW" width="8">
    <bitenum description="Generate RXSTOP interrupt after receiving 255 zero bits." id="en_3_0xFF" token="en_3_0xFF" value="0xFF"></bitenum>
    <bitenum description="Generate RXSTOP interrupt after receiving 1 zero bit." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="Feature disabled." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
  </register>
  
  
  <register acronym="UART_MVR" description="The module version register (MVR) is selected with a register bit setting of LCR[7] = 0, LCR[7] not equal to BFh, or LCR[7] = BFh. The reset value is fixed by hardware and corresponds to the RTL revision of this module. A reset has no effect on the value returned." id="UART_MVR" offset="0x50" width="16">
    
  <bitfield begin="15" description=" " end="8" id="RESERVED_1" rwaccess="R" width="8"></bitfield>
    
  <bitfield begin="7" description=" Major revision number of the module." end="4" id="MAJORREV" rwaccess="R" width="4"></bitfield>
    
  <bitfield begin="3" description=" Minor revision number of the module." end="0" id="MINORREV" rwaccess="R" width="4"></bitfield>
  </register>
  
  
  <register acronym="UART_SYSC" description="The system configuration register (SYSC) is selected with a register bit setting of LCR[7] = 0, LCR[7] not equal to BFh, or LCR[7] = BFh. The AUTOIDLE bit controls a power-saving technique to reduce the logic power consumption of the module interface; that is, when the feature is enabled, the interface clock is gated off until the module interface is accessed. When the SOFTRESET bit is set high, it causes a full device reset." id="UART_SYSC" offset="0x54" width="16">
    
  <bitfield begin="15" description=" " end="5" id="RESERVED_1" rwaccess="R" width="11"></bitfield>
    
  <bitfield begin="4" description=" Power management req/ack control." end="3" id="IDLEMODE" rwaccess="RW" width="2">
    <bitenum description="Smart idle Wakeup: Acknowledgement to an idle request is given based in the internal activity of the module. The module is allowed to generate wakeup request. Only available on UART0." id="en_4_0x3" token="en_4_0x3" value="0x3"></bitenum>
    <bitenum description="Smart idle: Acknowledgement to an idle request is given based in the internal activity of the module." id="en_3_0x2" token="en_3_0x2" value="0x2"></bitenum>
    <bitenum description="No-idle: Idle request is never acknowledged." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="Force idle: Idle request is acknowledged unconditionally." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="2" description=" Wakeup control." end="2" id="ENAWAKEUP" rwaccess="RW" width="1">
    <bitenum description="Wakeup capability is enabled." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="Wakeup is disabled." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="1" description=" Software reset. [[br]]Set this bit to 1 to trigger a module reset. [[br]]This bit is automatically reset by the hardware. [[br]]Read returns 0. " end="1" id="SOFTRESET" rwaccess="RW" width="1">
    <bitenum description="Module is reset." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="Normal mode." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="0" description=" Internal interface clock-gating strategy." end="0" id="AUTOIDLE" rwaccess="RW" width="1">
    <bitenum description="Reserved." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="Clock is running." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
  </register>
  
  
  <register acronym="UART_SYSS" description="The system status register (SYSS) is selected with a register bit setting of LCR[7] = 0, LCR[7] not equal to BFh, or LCR[7] = BFh." id="UART_SYSS" offset="0x58" width="16">
    
  <bitfield begin="15" description=" " end="1" id="RESERVED_1" rwaccess="R" width="15"></bitfield>
    
  <bitfield begin="0" description=" Internal reset monitoring." end="0" id="RESETDONE" rwaccess="R" width="1">
    <bitenum description="Reset complete." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="Internal module reset is ongoing." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
  </register>
  
  
  <register acronym="UART_WER" description="The wake-up enable register (WER) is selected with a register bit setting of LCR[7] = 0, LCR[7] not equal to BFh, or LCR[7] = BFh. The wake-up enable register (WER) is used to mask and unmask a UART event that subsequently notifies the system. An event is any activity in the logic that can cause an interrupt and/or an activity that requires the system to wake up. Even if wakeup is disabled for certain events, if these events are also an interrupt to the UART, the UART still registers the interrupt as such." id="UART_WER" offset="0x5C" width="16">
    
  <bitfield begin="15" description=" " end="8" id="RESERVED_1" rwaccess="R" width="8"></bitfield>
    
  <bitfield begin="7" description=" Wake-up interrupt." end="7" id="TXWAKEUPEN" rwaccess="RW" width="1">
    <bitenum description="Event can wake up the system: Event can be: THRIT or TXDMA request and/or TXSATUSIT." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="Event is not allowed to wake up the system." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="6" description=" Receiver line status interrupt." end="6" id="RLS_INTR" rwaccess="RW" width="1">
    <bitenum description="Event can wake up the system." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="Event is not allowed to wake up the system." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="5" description=" RHR interrupt." end="5" id="RHR_INTR" rwaccess="RW" width="1">
    <bitenum description="Event can wake up the system." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="Event is not allowed to wake up the system." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="4" description=" RX_ACTIVITY." end="4" id="RX_ACTIVITY" rwaccess="RW" width="1">
    <bitenum description="Event can wake up the system." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="Event is not allowed to wake up the system." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="3" description=" DCD_ACTIVITY." end="3" id="DCD_ACTIVITY" rwaccess="RW" width="1">
    <bitenum description="Event can wake up the system." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="Event is not allowed to wake up the system." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="2" description=" RI_ACTIVITY." end="2" id="RI_ACTIVITY" rwaccess="RW" width="1">
    <bitenum description="Event can wake up the system." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="Event is not allowed to wake up the system." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="1" description=" DSR_ACTIVITY." end="1" id="DSR_ACTIVITY" rwaccess="RW" width="1">
    <bitenum description="Event can wake up the system." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="Event is not allowed to wake up the system." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="0" description=" CTS_ACTIVITY." end="0" id="CTS_ACTIVITY" rwaccess="RW" width="1">
    <bitenum description="Event can wake up the system." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="Event is not allowed to wake up the system." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
  </register>
  
  
  <register acronym="UART_CFPS" description="The carrier frequency prescaler register (CFPS) is selected with a register bit setting of LCR[7] = 0, LCR[7] not equal to BFh, or LCR[7] = BFh. Since the consumer IR (CIR) works at modulation rates of 30-56.8 kHz, the 48 MHz clock must be prescaled before the clock can drive the IR logic. The carrier frequency prescaler register (CFPS) sets the divisor rate to give a range to accommodate the remote control requirements in BAUD multiples of 12x. The value of the CFPS at reset is 105 decimal (69h), which equates to a 38.1 kHz output from starting conditions. The 48 MHz carrier is prescaled by the CFPS that is then divided by the 12x BAUD multiple." id="UART_CFPS" offset="0x60" width="16">
    
  <bitfield begin="15" description=" " end="8" id="RESERVED_1" rwaccess="R" width="8"></bitfield>
    
  <bitfield begin="7" description=" System clock frequency prescaler at (12x multiple). [[br]]CFPS = 0 is not supported. [[br]]Examples for CFPS values follow. [[br]]Target Frequency (kHz) = 30, CFPS (decimal) = 133, Actual Frequency (kHz) = 30.08. [[br]]Target Frequency (kHz) = 32.75, CFPS (decimal) = 122, Actual Frequency (kHz) = 32.79. [[br]]Target Frequency (kHz) = 36, CFPS (decimal) = 111, Actual Frequency (kHz) = 36.04. [[br]]Target Frequency (kHz) = 36.7, CFPS (decimal) = 109, Actual Frequency (kHz) = 36.69. [[br]]Target Frequency (kHz) = 38, CFPS (decimal) = 105, Actual Frequency (kHz) = 38.1. [[br]]Target Frequency (kHz) = 40, CFPS (decimal) = 100, Actual Frequency (kHz) = 40. [[br]]Target Frequency (kHz) = 56.8, CFPS (decimal) = 70, Actual Frequency (kHz) = 57.14." end="0" id="CFPS" rwaccess="RW" width="8"></bitfield>
  </register>
  
  
  <register acronym="UART_RXFIFO_LVL" description="" id="UART_RXFIFO_LVL" offset="0x64" width="16">
    
  <bitfield begin="15" description=" " end="8" id="RESERVED_1" rwaccess="R" width="8"></bitfield>
    
  <bitfield begin="7" description=" Level of the RX FIFO" end="0" id="RXFIFO_LVL" rwaccess="R" width="8"></bitfield>
  </register>
  
  
  <register acronym="UART_TXFIFO_LVL" description="" id="UART_TXFIFO_LVL" offset="0x68" width="16">
    
  <bitfield begin="15" description=" " end="8" id="RESERVED_1" rwaccess="R" width="8"></bitfield>
    
  <bitfield begin="7" description=" Level of the TX FIFO" end="0" id="TXFIFO_LVL" rwaccess="R" width="8"></bitfield>
  </register>
  
  
  <register acronym="UART_IER2" description="The IER2 enables RX/TX FIFOs empty corresponding interrupts." id="UART_IER2" offset="0x6C" width="16">
    
  <bitfield begin="15" description=" " end="2" id="RESERVED_1" rwaccess="R" width="14"></bitfield>
    
  <bitfield begin="1" description=" EN_TXFIFO_EMPTY." end="1" id="EN_TXFIFO_EMPTY" rwaccess="RW" width="1">
    <bitenum description="Enables EN_TXFIFO_EMPTY interrupt." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="Disables EN_TXFIFO_EMPTY interrupt." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="0" description=" Number of bits by characters." end="0" id="EN_RXFIFO_EMPTY" rwaccess="RW" width="1">
    <bitenum description="Enables EN_RXFIFO_EMPTY interrupt." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="Disables EN_RXFIFO_EMPTY interrupt." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
  </register>
  
  
  <register acronym="UART_ISR2" description="The interrupt status register 2 (ISR2) is selected with a register bit setting of LCR[7] = 0, LCR[7] not equal to BFh, or LCR[7] = BFh. The ISR2 displays the status of RX/TX FIFOs empty corresponding interrupts." id="UART_ISR2" offset="0x70" width="16">
    
  <bitfield begin="15" description=" " end="2" id="RESERVED_1" rwaccess="R" width="14"></bitfield>
    
  <bitfield begin="1" description=" TXFIFO_EMPTY_STS." end="1" id="TXFIFO_EMPTY_STS" rwaccess="RW" width="1">
    <bitenum description="TXFIFO_EMPTY interrupt pending." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="TXFIFO_EMPTY interrupt not pending." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="0" description=" RXFIFO_EMPTY_STS." end="0" id="RXFIFO_EMPTY_STS" rwaccess="RW" width="1">
    <bitenum description="RXFIFO_EMPTY interrupt pending." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="RXFIFO_EMPTY interrupt not pending." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
  </register>
  
  
  <register acronym="UART_FREQ_SEL" description="" id="UART_FREQ_SEL" offset="0x74" width="16">
    
  <bitfield begin="15" description=" " end="8" id="RESERVED_1" rwaccess="R" width="8"></bitfield>
    
  <bitfield begin="7" description=" Sets the sample per bit if non default frequency is used. [[br]]MDR3[1] must be set to 1 after this value is set. [[br]]Must be equal or higher then 6." end="0" id="FREQ_SEL" rwaccess="RW" width="8"></bitfield>
  </register>
  
  
  <register acronym="UART_MDR3" description="The mode definition register 3 (MDR3) is selected with a register bit setting of LCR[7] = 0, LCR[7] not equal to BFh, or LCR[7] = BFh. The DISABLE_CIR_RX_DEMOD register bit will force the CIR receiver to bypass demodulation of received data if set. See the CIR Mode Block Components. The NONDEFAULT_FREQ register bit allows the user to set sample per bit by writing it into FREQ_SEL register. Set it if non-default (48 MHz) fclk frequency is used to achieve a less than 2% error rate. Changing this bit (to any value) will automatically disable the device by setting MDR[2:0] to 111 ." id="UART_MDR3" offset="0x80" width="16">
    
  <bitfield begin="15" description=" " end="3" id="RESERVED_1" rwaccess="R" width="13"></bitfield>
    
  <bitfield begin="2" description=" SET_DMA_TX_THRESHOLD." end="2" id="SET_DMA_TX_THR" rwaccess="RW" width="1">
    <bitenum description="Enable to set different TX DMA threshold in the TX DMA Threshold register." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="Disable use of TX DMA Threshold register. Use 64-TX trigger as DMA threshold." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="1" description=" NONDEFAULT_FREQ." end="1" id="NONDEFAULT_FREQ" rwaccess="RW" width="1">
    <bitenum description="Enables using NONDEFAULT fclk frequencies (set FREQ_SEL and DLH/DLL)." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="Disables using NONDEFAULT fclk frequencies." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
    
  <bitfield begin="0" description=" DISABLE_CIR_RX_DEMOD." end="0" id="DISABLE_CIR_RX_DEMOD" rwaccess="RW" width="1">
    <bitenum description="Disables CIR RX demodulation." id="en_2_0x1" token="en_2_0x1" value="0x1"></bitenum>
    <bitenum description="Enables CIR RX demodulation." id="en_1_0x0" token="en_1_0x0" value="0x0"></bitenum>
  </bitfield>
  </register>
  
  
  <register acronym="UART_TX_DMA_THR" description="The TX DMA threshold register is selected with a register bit setting of LCR[7] = 0, LCR[7] not equal to BFh, or LCR[7] = BFh." id="UART_TX_DMA_THR" offset="0x84" width="16">
    
  <bitfield begin="15" description=" " end="6" id="RESERVED_1" rwaccess="R" width="10"></bitfield>
    
  <bitfield begin="5" description=" Used to manually set the TX DMA threshold level. [[br]]UART_MDR3[2] SET_TX_DMA_THRESHOLD must be 1 and must be value + tx_trigger_level = 64 (TX FIFO size). [[br]]If not, 64_tx_trigger_level will be used without modifying the value of this register." end="0" id="TX_DMA_THR" rwaccess="RW" width="6"></bitfield>
  </register>
</module>
