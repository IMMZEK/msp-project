/********************************************************************/
/* f280025.gel                                                     */
/* Version 1.00.00.00                                               */
/*                                                                  */
/* This GEL file is to be used with the TMS320f280025 DSP.         */
/* Changes may be required to support specific hardware designs.    */
/*                                                                  */
/* Code Composer Studio supports six reserved GEL functions that    */
/* automatically get executed if they are defined. They are:        */
/*                                                                  */
/* StartUp()              - Executed whenever CCS is invoked        */
/* OnReset()              - Executed after Debug->Reset CPU         */
/* OnRestart()            - Executed after Debug->Restart           */
/* OnPreFileLoaded()      - Executed before File->Load Program      */
/* OnFileLoaded()         - Executed after File->Load Program       */
/* OnTargetConnect()      - Executed after Debug->Connect           */
/*                                                                  */
/********************************************************************/

#define FLASH_ECC_ENABLE            0x5FB00
#define DCSM_BANK0_Z1_OTPBASE       0x78000
#define DCSM_BANK0_Z2_OTPBASE       0x78200
#define WATCHDOG_CNTRL              0x7029
#define WATCHDOG_KEY                0x7025
#define NMI_CFG                     0x7060
#define Z1_LINKPOINTR1_0            0x0
#define Z1_LINKPOINTR2_0            0x4
#define Z1_LINKPOINTR3_0            0x8
#define Z2_LINKPOINTR1_0            0x0
#define Z2_LINKPOINTR2_0            0x4  
#define Z2_LINKPOINTR3_0            0x8  
#define SECDC                       0x703F0  
#define Z1_PSWDLOCK                 0x10  
#define Z1_CRCLOCK                  0x14  
#define Z1_JTAGLOCK                 0x18  
#define Z1OTP_BOOTPIN_CONFIG        0x0C
#define Z1OTP_GPREG2                0x0E
#define Z1OTP_BOOTDEF_LOW           0x1C
#define Z1OTP_BOOTDEF_HIGH          0x1E
#define Z2_PSWDLOCK                 0x10
#define Z2_CRCLOCK                  0x14
#define Z2_JTAGLOCK                 0x18
#define Z2OTP_BOOTPIN_CONFIG        0x0C
#define Z2OTP_GPREG2                0x0E
#define Z2OTP_BOOTDEF_LOW           0x1C
#define Z2OTP_BOOTDEF_HIGH          0x1E
#define DCSM_Z1_BASE                0x5F000
#define DCSM_Z2_BASE                0x5F040
#define DCSM_Z1_LINKPOINTER1        0x0
#define DCSM_Z1_CSMKEY0             0x10        // Zone 1 CSM Key 0
#define DCSM_Z1_CSMKEY1             0x12        // Zone 1 CSM Key 1
#define DCSM_Z1_CSMKEY2             0x14        // Zone 1 CSM Key 2
#define DCSM_Z1_CSMKEY3             0x16        // Zone 1 CSM Key 3
#define DCSM_Z2_CSMKEY0             0x10        // Zone 2 CSM Key 0
#define DCSM_Z2_CSMKEY1             0x12        // Zone 2 CSM Key 1
#define DCSM_Z2_CSMKEY2             0x14        // Zone 2 CSM Key 2
#define DCSM_Z2_CSMKEY3             0x16        // Zone 2 CSM Key 3
#define GPIO_CTRL_BASE              0x7C00
#define GPIO_O_GPAMUX2              0x8         // GPIO A Mux 2 Register (GPIO16
                                                // to 31)
#define GPIO_O_GPAGMUX2             0x22        // GPIO A Peripheral Group Mux
                                                // (GPIO16 to 31)
#define GPIO_O_GPALOCK              0x3C        // GPIO A Lock Configuration
                                             // Register (GPIO0 to 31)                                              
#define GPIO_O_GPAPUD               0xC
#define GPIO_O_GPBPUD               0x4C
#define DEVCFG_BASE 0x0005D000
#define TI_OTP_PARTID_L             (0x70200)
#define TI_OTP_PARTID_H             (0x70202)
#define TI_OTP_CPUROM_DC1           (0x7020C)
#define TI_OTP_CPUROM_DC2           (0x7020D)
#define TI_OTP_CPUROM_DC3           (0x7020E)
#define TI_OTP_CPUROM_DC4           (0x7020F)
#define TI_OTP_PKG_TYPE             0x70204
#define PKG_TYPE_KEY                0x5A
#define TI_OTP_REG_DC01             (0x70205)
#define TI_OTP_REG_DC03             (0x70206)
#define TI_OTP_REG_DC15             (0x70207)
#define TI_OTP_REG_DC21             (0x70208)
#define DCX_ALWAYS_ENABLED          0xFFFFFFFF
#define DCX_ENABLE_HIGH             0xFFFF0000
#define SYSCTL_O_PARTIDL            0x8         // Lower 32-bit of Device PART
                                               // Identification Number
#define SYSCTL_O_PARTIDH            0xA         // Upper 32-bit of Device PART
                                               // Identification Number
#define SYSCTL_O_DC1              0x12U        // Device Capability: Processing
                                               // Block Customization                                               
#define SYSCTL_O_DC3                0x16        // Device Capability: ETPWM
#define SYSCTL_O_DC4                0x18        // Device Capability: ECAP
#define SYSCTL_O_DC5                0x1A        // Device Capability: EQEP
#define SYSCTL_O_DC8                0x20        // Device Capability: SCI
#define SYSCTL_O_DC9                0x22        // Device Capability: SPI
#define SYSCTL_O_DC10               0x24        // Device Capability: I2C
#define SYSCTL_O_DC11               0x26        // Device Capability: CAN
#define SYSCTL_O_DC14               0x2C        // Device Capability: ADC
#define SYSCTL_O_DC15               0x2E        // Device Capability: CMPSS
#define SYSCTL_O_DC18               0x34        // Device Capability: Lx.1 SRAM
                                                // Customization
#define SYSCTL_O_DC20               0x38        // Device Capability: GSx SRAM
                                                // Customization
#define SYSCTL_O_DC21               0x3A        // Device Capability: CLB
#define SYSCTL_O_DC22               0x3C        // Device Capability: FSI
#define SYSCTL_O_DC23               0x3E        // Device Capability: LIN
#define SYSCTL_O_DC24               0x40        // Device Capability: PMBUS
#define SYSCTL_O_DC25               0x42        // Device Capability: DCC
#define SYSCTL_O_DC27               0x46        // Device Capability: BGCRC
#define SYSCTL_O_DC28               0x48        // Device Capability: HIC
#define SYSCTL_O_CPUROM_DC1         0x140       // Device Capabiity registers
                                                // for ROM
#define SYSCTL_O_CPUROM_DC2         0x142       // Device Capabiity registers
                                                // for ROM
#define SYSCTL_O_CPUROM_DC3         0x144       // Device Capabiity registers
                                                // for ROM
#define SYSCTL_O_CPUROM_DC4         0x146       // Device Capabiity registers
                                                // for ROM
#define SYSCTL_O_PKGTYPE            0x12E 
#define MEMCFG_BASE                 0x0005F400
#define MEMCFG_O_DXINIT             0x12
#define MEMCFG_O_LSXINIT            0x32
#define MEMCFG_O_GSXINIT            0x52
#define MEMCFG_O_GSXINITDONE        0x54  

#define CPUSYS_BASE            0x0005D300U
#define SYSCTL_O_PCLKCR0       0x22U   // Peripheral Clock Gating Registers
#define SYSCTL_PCLKCR0_ERAD        0x1000000U   // ERAD module clock enable


StartUp()
{

}

OnReset(int nErrorCode)
{

    *(int *)FLASH_ECC_ENABLE = 0;       /* Disable Flash ECC */
    *(int *)WATCHDOG_CNTRL = 0x68;          /* Disable WD */
    
    *(unsigned long *)NMI_CFG = 0x0001;  /* Enable NMI */
    
    SetupDCSM();                        /* Initialize DCSM */

    SetupErrorStatusPin();              /* setup error status pin */
    
    Device_Config();
    
    Device_UnbondedGPIO_Pullup();
    
    ERAD_Clock_Enable();
  
    if (GEL_IsInRealtimeMode())     /* If in real-time-mode */
    {
    }
    else                            /* Put device into C28x Mode */
    {
      C28x_Mode();   
    }

}

OnRestart(int nErrorCode)
{
/* CCS will call OnRestart() when you do a Debug->Restart and   */
/* after you load a new file*/
    if (GEL_IsInRealtimeMode())     /* If in real-time-mode */
    {
    }
    else                            /* Put device into C28x Mode */
    {
      C28x_Mode();   
    }
     IER = 0;
     IFR = 0;
}

OnPreFileLoaded()
{
    GEL_Reset();
}

OnFileLoaded(int nErrorCode, int bSymbolsOnly)
{

}

OnTargetConnect()
{

    *(int *)(MEMCFG_BASE + MEMCFG_O_DXINIT)  = 0x0003;      /* RAM INIT FOR M0/M1 Memory        */
    *(int *)(MEMCFG_BASE + MEMCFG_O_LSXINIT) =0x00F0;      /* RAM INIT FOR LS4..LS7  Memory    */
    *(int *)(MEMCFG_BASE + MEMCFG_O_GSXINIT) =0x0001;      /* RAM INIT FOR GS0.Memory     */
    
    while(!(*(int *) (MEMCFG_BASE + MEMCFG_O_GSXINITDONE) == 0x1)); //Wait for InitDone Status
    
    GEL_TextOut("\n\nRAM initialization done\n\n");

    if (GEL_IsInRealtimeMode())     /* If in real-time-mode */
    {
    }
    else                            /* Put device into C28x Mode */
    {
        C28x_Mode();   
    }

    f280025_Memory_Map();        /* Initialize the CCS memory map */

    /* Check to see if CCS has been started-up with the DSP already */
    /* running in real-time mode.  The user can add whatever        */
    /* custom initialization stuff they want to each case.          */

    if (GEL_IsInRealtimeMode())     /* Do real-time mode target initialization */
    {

    }
    else                            /* Do stop-mode target initialization */
    {
        GEL_Reset();                /* Reset DSP */
    }
}


/********************************************************************/
/* These functions are useful to engage/disengage realtime          */
/* emulation mode during debug.  They save the user from having to  */
/* manually perform these steps in CCS.                             */
/********************************************************************/
menuitem "Realtime Emulation Control";

hotmenu Run_Realtime_with_Reset()
{
    GEL_Reset();                /* Reset the DSP */
    ST1 = ST1 & 0xFFFD;         /* clear DBGM bit in ST1 */
    GEL_EnableRealtime();       /* Enable Realtime mode */
    GEL_Run();                  /* Run the DSP */
}
hotmenu Run_Realtime_with_Restart()
{
    GEL_Restart();              /* Reset the DSP */
    ST1 = ST1 & 0xFFFD;         /* clear DBGM bit in ST1 */
    GEL_EnableRealtime();       /* Enable Realtime mode */
    GEL_Run();                  /* Run the DSP */
}
hotmenu Full_Halt()
{
    GEL_DisableRealtime();      /* Disable Realtime mode */
    GEL_Halt();                 /* Halt the DSP */
}
hotmenu Full_Halt_with_Reset()
{
    GEL_DisableRealtime();      /* Disable Realtime mode */
    GEL_Halt();                 /* Halt the DSP */
    GEL_Reset();                /* Reset the DSP */
}

/*********************************************************************/
/*                         f280025 Memory Map                       */
/*                                                                   */
/*********************************************************************/
menuitem "Initialize Memory Map";

hotmenu f280025_Memory_Map()
{
    /* GEL_MapReset(); */
    GEL_MapOn();

    /* Program memory maps */
    GEL_MapAddStr(0x00000000,0, 0x400, "R|W|AS2",0);                     /*   M0 RAM (with ECC) (2 KByte)                             */
    GEL_MapAddStr(0x00000400,0, 0x400, "R|W|AS2",0);                     /*   M1 RAM (with ECC) (2 KByte)                             */
    GEL_MapAddStr(0x0000A000,0, 0x800, "R|W|AS2",0);                     /*   LS4 RAM (with PARITY) (4KBytes)                         */
    GEL_MapAddStr(0x0000A800,0, 0x800, "R|W|AS2",0);                     /*   LS5 RAM (with PARITY) (4KBytes)                         */   
    GEL_MapAddStr(0x0000B000,0, 0x800, "R|W|AS2",0);                     /*   LS6 RAM (with PARITY) (4KBytes)                         */    
    GEL_MapAddStr(0x0000B800,0, 0x800, "R|W|AS2",0);                     /*   LS7 RAM (with PARITY) (4KBytes)                         */    
    GEL_MapAddStr(0x0000C000,0, 0x2000, "R|W|AS2",0);                    /*   GS0 RAM (with PARITY) (16KBytes)                        */
    GEL_MapAddStr(0x00070000,0, 0x400, "R|AS2",0);                       /*   TI OTP BANK1 (2 KBytes)                                 */
    GEL_MapAddStr(0x00078000,0, 0x400, "R|AS2",0);                       /*   USER OTP BANK1 (2 KBytes)                               */
    GEL_MapAddStr(0x00080000,0, 0x10000, "R|AS2",0);                     /*   FLASH BANK1 (128 KBytes)                                */
    GEL_MapAddStr(0x003E8000,0, 0x8000, "R|AS2",0);                      /*   Secure ROM (64 KBytes)                                  */
    GEL_MapAddStr(0x003F0000,0, 0x10000, "R|AS2",0);                     /*   Boot ROM (master) (128 KBytes)                          */
    /* Data memory maps */
    GEL_MapAddStr(0x00000000,1, 0x400, "R|W|AS2",0);                     /*   M0 RAM (with ECC) (2 KByte)                             */
    GEL_MapAddStr(0x00000400,1, 0x400, "R|W|AS2",0);                     /*   M1 RAM (with ECC) (2 KByte)                             */
    GEL_MapAddStr(0x00000800,1, 0x200, "R|W|AS2",0);                     /*   Peripheral Space (512 Bytes)                            */
    GEL_MapAddStr(0x00000B00,1, 0x20, "R|AS2",0);                        /*   ADC1 Result Registers                                   */
    GEL_MapAddStr(0x00000B40,1, 0x20, "R|AS2",0);                        /*   ADC3 Result Registers                                   */



    GEL_MapAddStr(0x00000C00,1, 0x18, "R|W|AS2",0);                      /*   CPU Timer Registers                                     */
    GEL_MapAddStr(0x00000CE0,1, 0x20, "R|AS2",0);                        /*   PIE Registers                                           */
    GEL_MapAddStr(0x00000D00,1, 0x1C0, "R|W|AS2",0);                     /*   PIE Vectors                                             */
    GEL_MapAddStr(0x00000F00,1, 0x100, "R|W|AS2",0);                     /*   FPU Registers                                           */
    GEL_MapAddStr(0x00001000,1, 0x200, "R|W|AS2",0);                     /*   DMA Registers                                           */

    GEL_MapAddStr(0x00004000,1, 0x700, "R|W|AS2",0);                     /*   EPWM Peripheral Space                                   */
    GEL_MapAddStr(0x00005100,1, 0x80, "R|W|AS2",0);                      /*   EQEP Peripheral Space                                   */
    GEL_MapAddStr(0x00005200,1, 0xC0, "R|W|AS2",0);                      /*   ECAP Peripheral Space                                   */
    GEL_MapAddStr(0x00005C80,1, 0x80, "R|W|AS2",0);                      /*   CMPSS Peripheral Space                                  */
    GEL_MapAddStr(0x00006100,1, 0x20, "R|W|AS2",0);                      /*   SPI Registers                                           */
    GEL_MapAddStr(0x00006340,1, 0x40, "R|W|AS2",0);                      /*   BGCRC Registers                                         */
    GEL_MapAddStr(0x00006400,1, 0x20, "R|W|AS2",0);                      /*   PMBUS Registers                                         */
    GEL_MapAddStr(0x00006500,1, 0x200, "R|W|AS2",0);                     /*   HIC,FSI Registers                                       */
    GEL_MapAddStr(0x00006A00,1, 0x200, "R|W|AS2",0);                     /*   LIN Registers                                           */
    GEL_MapAddStr(0x00007000,1, 0x40, "R|W|AS2",0);                      /*   Watchdog Registers                                      */
    GEL_MapAddStr(0x00007060,1, 0x20, "R|W|AS2",0);                      /*   NMI,Interrupt Registers                                 */
    GEL_MapAddStr(0x00007200,1, 0x10, "R|W|AS2",0);                      /*   SCI Registers                                           */
    GEL_MapAddStr(0x00007300,1, 0x80, "R|W|AS2",0);                      /*   I2C Registers                                           */
    GEL_MapAddStr(0x00007400,1, 0x80, "R|W|AS2",0);                      /*   ADC1 Config Registers                                   */
    GEL_MapAddStr(0x00007500,1, 0x80, "R|W|AS2",0);                      /*   ADC3 Config Registers                                   */
    GEL_MapAddStr(0x00007900,1, 0x700, "R|W|AS2",0);                     /*   GPIO Mux Select Registers                               */
    GEL_MapAddStr(0x0000A000,1, 0x800, "R|W|AS2",0);                     /*   LS4 RAM (with PARITY) (4KBytes)                         */
    GEL_MapAddStr(0x0000A800,1, 0x800, "R|W|AS2",0);                     /*   LS5 RAM (with PARITY) (4KBytes)                         */   
    GEL_MapAddStr(0x0000B000,1, 0x800, "R|W|AS2",0);                     /*   LS6 RAM (with PARITY) (4KBytes)                         */    
    GEL_MapAddStr(0x0000B800,1, 0x800, "R|W|AS2",0);                     /*   LS7 RAM (with PARITY) (4KBytes)                         */    
    GEL_MapAddStr(0x0000C000,1, 0x800, "R|W|AS2",0);                     /*   GS0 RAM                                                 */
    GEL_MapAddStr(0x00048000,1, 0x800, "R|W|AS4",0);                     /*   CANA Registers                                          */
    GEL_MapAddStr(0x0005D000,1, 0x800, "R|W|AS2",0);                     /*   Device Config Registers                                 */
    GEL_MapAddStr(0x0005E000,1, 0x700, "R|W|AS2",0);                     /*   System Diagnostics Registers                            */
    GEL_MapAddStr(0x0005E700,1, 0x80,  "R|W|AS4",0);                     /*   DCC0,1 Registers                                          */
    GEL_MapAddStr(0x0005E800,1, 0x800, "R|W|AS2",0);                     /*   Enhanced Debug Registers                                */
    GEL_MapAddStr(0x0005F000,1, 0x400, "R|W|AS2",0);                     /*   Security Registers                                      */
    GEL_MapAddStr(0x0005F400,1, 0x400, "R|W|AS2",0);                     /*   RAM Config Registers                                    */
    GEL_MapAddStr(0x0005F800,1, 0x300, "R|W|AS2",0);                     /*   Flash Wrapper Registers                                 */
    GEL_MapAddStr(0x0005FB00,1, 0x40, "R|W|AS2",0);                      /*   Flash Wrapper ECC Registers                             */
    
    GEL_MapAddStr(0x00070000,1, 0x400, "R|AS2",0);                       /*   TI OTP BANK1 (2 KBytes)                                 */
    GEL_MapAddStr(0x00078000,1, 0x400, "R|AS2",0);                       /*   USER OTP BANK1 (2 KBytes)                               */
    GEL_MapAddStr(0x00080000,1, 0x10000, "R|AS2",0);                     /*   FLASH BANK1 (128 KBytes)                                */
    GEL_MapAddStr(0x003E8000,1, 0x8000, "R|AS2",0);                      /*   Secure ROM (64 KBytes)                                  */
    GEL_MapAddStr(0x003F0000,1, 0x10000, "R|AS2",0);                     /*   Boot ROM (master) (128 KBytes)                          */
    GEL_MapAddStr(0x01070000,1, 0x80, "R|AS2",0);                        /*   TI OTP BANK1 ECC (256 Bytes)                            */
    GEL_MapAddStr(0x01071000,1, 0x80, "R|AS2",0);                        /*   USER OTP BANK1 ECC (256 Bytes)                          */
    GEL_MapAddStr(0x01080000,1, 0x2000, "R|AS2",0);                      /*   FLASH BANK1 ECC (16 KBytes)                             */
     /* Peripheral memory maps */
    GEL_MapAddStr(0x00006A00,3, 0x200, "R|W|AS2",0);                     /*   LIN Registers                                           */
    GEL_MapAddStr(0x00048000,3, 0x800, "R|W|AS4",0);                     /*   CANA Registers                                          */
    GEL_MapAddStr(0x0005E700,3, 0x80, "R|W|AS4",0);                      /*   DCC0,1 Registers                                          */
      
    GEL_TextOut("\nMemory Map Initialization Complete\n"); 
}

/********************************************************************/
/* The ESTOP0 fill functions are useful for debug.  They fill the   */
/* RAM with software breakpoints that will trap runaway code.       */
/********************************************************************/
hotmenu Fill_f280025_RAM_with_ESTOP0()
{
    GEL_MemoryFill(0x000000,1,0x000800,0x7625);      /* Fill M0/M1  */
    
    GEL_MemoryFill(0x00A000,1,0x000800,0x7625);      /* Fill L4  */
    GEL_MemoryFill(0x00A800,1,0x000800,0x7625);      /* Fill L5  */
    GEL_MemoryFill(0x00B000,1,0x000800,0x7625);      /* Fill L6  */
    GEL_MemoryFill(0x00B800,1,0x000800,0x7625);      /* Fill L7     */
    GEL_MemoryFill(0x00C000,1,0x000800,0x7625);      /* Fill G0  */   
}

/********************************************************************/
/*              TI OTP and USER OTP Memory Dump                     */
/********************************************************************/
menuitem "OTP Dump";
hotmenu OTP_Dump()
{
    GEL_MemorySave(0x00070000,1, 0x400, "TI_OTP_Bank1.dat");
    GEL_MemorySave(0x00078000,1, 0x400, "USER_OTP_Bank1.dat");
               
    GEL_TextOut("\n********************************************************************** 
                 \nTI OTP and USER OTP Memory Dump Complete!  
                 \nFile Output Directory: <CCS Install Directory>\\ccs<version>\\eclipse 
                 \n                       (e.g. C:\ti\ccs910\ccs\eclipse

                 \n**********************************************************************\n"); 
}

/********************************************************************/
menuitem "Watchdog";
hotmenu Disable_WD()
{
    *WATCHDOG_CNTRL = *WATCHDOG_CNTRL | 0x0068;                /* Set the WDDIS bit */
    *WATCHDOG_KEY = 0x0055;                          /* Service the WD    */
    *WATCHDOG_KEY = 0x00AA;                          /*  once to be safe. */
    GEL_TextOut("\nWatchdog Timer Disabled");
}



/********************************************************************/
menuitem "Addressing Modes";

hotmenu C28x_Mode()
{
    ST1 = ST1 & (~0x0100);      /*   AMODE = 0  */
    ST1 = ST1 | 0x0200;         /* OBJMODE = 1  */
}

hotmenu C24x_Mode()
{
    ST1 = ST1 | 0x0100;         /*   AMODE = 1  */
    ST1 = ST1 | 0x0200;         /* OBJMODE = 1  */
}

hotmenu C27x_Mode()
{
    ST1 = ST1 & (~0x0100);      /*   AMODE = 0  */
    ST1 = ST1 & (~0x0200);      /* OBJMODE = 0  */
}






/********************************************************************/
/* EMU Boot Mode - Set Boot Mode During Debug                       */
/********************************************************************/
menuitem "EMU Boot Mode Select"
hotmenu EMU_BOOT_RAM()
{
    *(unsigned long *)0xD00 = 0x5AFFFFFF;
    *0xD04 = 0x0005;
}
hotmenu EMU_BOOT_FLASH()
{
    *(unsigned long *)0xD00 = 0x5AFFFFFF;
    *0xD04 = 0x0003;
}



hotmenu SetupDCSM()
{
    int i;
    int j;
    unsigned long LinkPointer;
    unsigned long *ZoneSelBlockPtr;
    unsigned long *Z1_ZoneSelBlockPtr;
    unsigned long *Z2_ZoneSelBlockPtr;
    int bitpos;
    int zerofound;

    GEL_TextOut("... DCSM Initialization Start ... \n");

    XAR0 = *(unsigned long *)(DCSM_BANK0_Z1_OTPBASE + Z1_LINKPOINTR1_0); // Read BANK0 Z1 Linkpointer1
    XAR0 = *(unsigned long *)(DCSM_BANK0_Z1_OTPBASE + Z1_LINKPOINTR2_0); // Read BANK0 Z1 Linkpointer2
    XAR0 = *(unsigned long *)(DCSM_BANK0_Z1_OTPBASE + Z1_LINKPOINTR3_0); // Read BANK0 Z1 Linkpointer3 
    XAR0 = *(unsigned long *)(DCSM_BANK0_Z2_OTPBASE + Z2_LINKPOINTR1_0); // Read BANK1 Z2 Linkpointer1
    XAR0 = *(unsigned long *)(DCSM_BANK0_Z2_OTPBASE + Z2_LINKPOINTR2_0); // Read BANK1 Z2 Linkpointer2
    XAR0 = *(unsigned long *)(DCSM_BANK0_Z2_OTPBASE + Z2_LINKPOINTR3_0); // Read BANK1 Z2 Linkpointer3
    XAR0 = *(unsigned long *)SECDC; // Read SECDC   
    XAR0 = *(unsigned long *)(DCSM_BANK0_Z1_OTPBASE + Z1_PSWDLOCK); // Read Z1 PSWDLOCK
    XAR0 = *(unsigned long *)(DCSM_BANK0_Z1_OTPBASE + Z1_JTAGLOCK); // Read Z1 JTAGLOCK
    XAR0 = *(unsigned long *)(DCSM_BANK0_Z1_OTPBASE + Z1_CRCLOCK); // Read Z1 CRCLOCK
    XAR0 = *(unsigned long *)(DCSM_BANK0_Z1_OTPBASE + Z1OTP_BOOTPIN_CONFIG); // Read Z1 BOOTPIN CONFIG

    XAR0 = *(unsigned long *)(DCSM_BANK0_Z1_OTPBASE + Z1OTP_GPREG2); // Read Z1 GPREG1 TBD
    XAR0 = *(unsigned long *)(DCSM_BANK0_Z1_OTPBASE + Z1OTP_BOOTDEF_LOW); // Read Z1 BOOT DEF LOW
    XAR0 = *(unsigned long *)(DCSM_BANK0_Z1_OTPBASE + Z1OTP_BOOTDEF_HIGH); // Read Z1 BOOT DEF HIGH

    XAR0 = *(unsigned long *)(DCSM_BANK0_Z2_OTPBASE + Z2_PSWDLOCK); // Read Z2 PSWDLOCK
    XAR0 = *(unsigned long *)(DCSM_BANK0_Z2_OTPBASE + Z2_JTAGLOCK); // Read Z2 JTAGLOCK
    XAR0 = *(unsigned long *)(DCSM_BANK0_Z2_OTPBASE + Z2_CRCLOCK); // Read Z2 CRCLOCK

    XAR0 = *(unsigned long *)(DCSM_BANK0_Z2_OTPBASE + Z2OTP_BOOTPIN_CONFIG); // Read Z2 BOOTPIN CONFIG

    XAR0 = *(unsigned long *)(DCSM_BANK0_Z2_OTPBASE + Z2OTP_GPREG2); // Read Z2 GPREG2
    XAR0 = *(unsigned long *)(DCSM_BANK0_Z2_OTPBASE + Z2OTP_BOOTDEF_LOW); // Read Z2 BOOTDEF LOW
    XAR0 = *(unsigned long *)(DCSM_BANK0_Z2_OTPBASE + Z2OTP_BOOTDEF_HIGH); // Read Z2 BOOTDEF HIGH

    for (j=0;j<2;j++)
    {   
        bitpos = 28;
        zerofound = 0;
        
        LinkPointer = *(unsigned long *)(DCSM_Z1_BASE + DCSM_Z1_LINKPOINTER1 + (j * 256));         /* Read Z1-Linkpointer out of Z1-LINKPOINTER register */
//      GEL_TextOut("Value of Link Pointer is -%x-\n",,,,, LinkPointer);
        LinkPointer = LinkPointer << 3;                             /* Bits 31 and 30 as most-significant 0 are invalid LinkPointer options */
        while ((zerofound == 0) && (bitpos > -1))
        {
                if ((LinkPointer & 0x80000000) == 0)
            {
                zerofound = 1;
                ZoneSelBlockPtr = (unsigned long *)((DCSM_BANK0_Z1_OTPBASE + DCSM_Z1_LINKPOINTER1 + ((bitpos + 3)*16)));            
            }
            else
            {
                    bitpos--;
                LinkPointer = LinkPointer << 1;
            }
        }
        if (zerofound == 0)
        {
                ZoneSelBlockPtr = (unsigned long *)(DCSM_BANK0_Z1_OTPBASE + 0x20);
        }
    
        /* Perform dummy reads of the Zone Select Block locations */
        for (i = 0; i < 8; i++)
        {
                XAR0 =  *ZoneSelBlockPtr; 
            ZoneSelBlockPtr++;
        }
    }


    for (j=0;j<2;j++)
    {   
        bitpos = 28;
        zerofound = 0;
        LinkPointer = *(unsigned long *)(DCSM_Z2_BASE + DCSM_Z1_LINKPOINTER1 + (j * 256));         /* Read Z1-Linkpointer out of Z1-LINKPOINTER register */
        LinkPointer = LinkPointer << 3;                             /* Bits 31 and 30 as most-sigificant 0 are invalid LinkPointer options */
        while ((zerofound == 0) && (bitpos > -1))
        {
                if ((LinkPointer & 0x80000000) == 0)
            {
                zerofound = 1;
                ZoneSelBlockPtr = (unsigned long *)((DCSM_BANK0_Z2_OTPBASE + ((bitpos + 3)*16)));           
            }
            else
            {
                    bitpos--;
                LinkPointer = LinkPointer << 1;
            }
        }
        if (zerofound == 0)
        {
                ZoneSelBlockPtr = (unsigned long *)(DCSM_BANK0_Z2_OTPBASE + 0x20);
        }
    
        /* Perform dummy reads of the Zone Select Block locations */
        for (i = 0; i < 8; i++)
        {
                XAR0 =  *ZoneSelBlockPtr; 
            ZoneSelBlockPtr++;
        }
    }   

    GEL_TextOut("... DCSM Initialization Done ...\n");
    /* Write passwords to the KEY registers.  0xFFFFFFFF's are dummy passwords.
        User should replace them with the correct password for their DSP */

    *(unsigned long *)(DCSM_Z1_BASE + DCSM_Z1_CSMKEY0) = 0xFFFFFFFF;
    *(unsigned long *)(DCSM_Z1_BASE + DCSM_Z1_CSMKEY1) = 0x47FFFFFF;
    *(unsigned long *)(DCSM_Z1_BASE + DCSM_Z1_CSMKEY2) = 0xFFFFFFFF;
    *(unsigned long *)(DCSM_Z1_BASE + DCSM_Z1_CSMKEY3) = 0xFFFFFFFF;
                      
    *(unsigned long *)(DCSM_Z2_BASE + DCSM_Z2_CSMKEY0) = 0xFFFFFFFF;
    *(unsigned long *)(DCSM_Z2_BASE + DCSM_Z2_CSMKEY1) = 0xe3FFFFFF;
    *(unsigned long *)(DCSM_Z2_BASE + DCSM_Z2_CSMKEY2) = 0xFFFFFFFF;
    *(unsigned long *)(DCSM_Z2_BASE + DCSM_Z2_CSMKEY3) = 0xFFFFFFFF;
}

hotmenu SetupErrorStatusPin()
{
    unsigned long pin_number;
    unsigned long key_programmed=0;
    
    if(((*(unsigned long *)(DCSM_Z2_BASE + Z2OTP_GPREG2) & (unsigned long)0xFF000000) >> 24) == 0x5A)
    {
        pin_number = ((*(unsigned long *)(DCSM_Z2_BASE + Z2OTP_GPREG2) & (unsigned long)0x00000030) >> 4);
        key_programmed = 1 ;
    }
    if(((*(unsigned long *)(DCSM_Z1_BASE + Z1OTP_GPREG2) & (unsigned long)0xFF000000) >> 24) == 0x5A)
    {
        pin_number = ((*(unsigned long *)(DCSM_Z1_BASE + Z1OTP_GPREG2) & (unsigned long)0x00000030) >> 4);
        key_programmed = 1;
    }
    
    if(((*(unsigned long *)(DCSM_Z1_BASE + Z1OTP_GPREG2) & (unsigned long)0xFF000000) >> 24) == 0x5A)
    {
        //set ERROR_STS pin if enabled by user
        if(pin_number == 0x0)
        {
            GEL_TextOut("Error Status Pin: GPIO24\n");
            //configure GPIO24 for Error Status Pin
            //write to GPAMUX2
            *(unsigned long *)(GPIO_CTRL_BASE + GPIO_O_GPAMUX2) &= ~((unsigned long)0x03 << 16);
            *(unsigned long *)(GPIO_CTRL_BASE + GPIO_O_GPAMUX2) |= ((unsigned long)0x01 << 16);
            //write to GPAGMUX2
            *(unsigned long *)(GPIO_CTRL_BASE + GPIO_O_GPAGMUX2) &= ~((unsigned long)0x03 << 16);
            *(unsigned long *)(GPIO_CTRL_BASE + GPIO_O_GPAGMUX2) |= ((unsigned long)0x03 << 16);
            //lock GPIO24
            *(unsigned long *)(GPIO_CTRL_BASE + GPIO_O_GPALOCK) |= ((unsigned long)0x01 << 24);     
        }
        else if(pin_number == 0x1)
        {
            GEL_TextOut("Error Status Pin: GPIO28\n");
            //configure GPIO28 for Error Status Pin
            //write to GPAMUX2
            *(unsigned long *)(GPIO_CTRL_BASE + GPIO_O_GPAMUX2) &= ~((unsigned long)0x03 << 24);
            *(unsigned long *)(GPIO_CTRL_BASE + GPIO_O_GPAMUX2) |= ((unsigned long)0x01 << 24);
            //write to GPAGMUX2
            *(unsigned long *)(GPIO_CTRL_BASE + GPIO_O_GPAGMUX2) &= ~((unsigned long)0x03 << 24);
            *(unsigned long *)(GPIO_CTRL_BASE + GPIO_O_GPAGMUX2) |= ((unsigned long)0x03 << 24);
            //lock GPIO28
            *(unsigned long *)(GPIO_CTRL_BASE + GPIO_O_GPALOCK) |= ((unsigned long)0x01 << 28);
        }
        else if(pin_number == 0x2)
        {
            GEL_TextOut("Error Status Pin: GPIO29\n");
            //configure GPIO29 for Error Status Pin
            //write to GPAMUX2
            *(unsigned long *)(GPIO_CTRL_BASE + GPIO_O_GPAMUX2) &= ~((unsigned long)0x03 << 26);
            *(unsigned long *)(GPIO_CTRL_BASE + GPIO_O_GPAMUX2) |= ((unsigned long)0x01 << 26);
            //write to GPAGMUX2
            *(unsigned long *)(GPIO_CTRL_BASE + GPIO_O_GPAGMUX2) &= ~((unsigned long)0x03 << 26);
            *(unsigned long *)(GPIO_CTRL_BASE + GPIO_O_GPAGMUX2) |= ((unsigned long)0x03 << 26);
            //lock GPIO29
            *(unsigned long *)(GPIO_CTRL_BASE + GPIO_O_GPALOCK) |= ((unsigned long)0x01 << 29);
        }
    }
}

menuitem "Device Configuration"
hotmenu Device_Config()
{

    *(unsigned long *)(DEVCFG_BASE + SYSCTL_O_PARTIDL)   = *(unsigned long *)TI_OTP_PARTID_L;    // LOAD PARTIDL Value
    *(unsigned long *)(DEVCFG_BASE + SYSCTL_O_PARTIDH )  = *(unsigned long *)TI_OTP_PARTID_H;    // LOAD PARTIDH Value

    //Load Device capability
    *(unsigned long *)(DEVCFG_BASE + SYSCTL_O_DC4)    = DCX_ALWAYS_ENABLED;
    *(unsigned long *)(DEVCFG_BASE + SYSCTL_O_DC5)    = DCX_ALWAYS_ENABLED;
    *(unsigned long *)(DEVCFG_BASE + SYSCTL_O_DC8)    = DCX_ALWAYS_ENABLED;
    *(unsigned long *)(DEVCFG_BASE + SYSCTL_O_DC9)    = DCX_ALWAYS_ENABLED;
    *(unsigned long *)(DEVCFG_BASE + SYSCTL_O_DC10)   = DCX_ALWAYS_ENABLED;
    *(unsigned long *)(DEVCFG_BASE + SYSCTL_O_DC11)   = DCX_ALWAYS_ENABLED;
    *(unsigned long *)(DEVCFG_BASE + SYSCTL_O_DC14)   = DCX_ALWAYS_ENABLED;
    *(unsigned long *)(DEVCFG_BASE + SYSCTL_O_DC18)   = DCX_ALWAYS_ENABLED;
    *(unsigned long *)(DEVCFG_BASE + SYSCTL_O_DC20)   = DCX_ALWAYS_ENABLED;
    *(unsigned long *)(DEVCFG_BASE + SYSCTL_O_DC22)   = DCX_ALWAYS_ENABLED;
    *(unsigned long *)(DEVCFG_BASE + SYSCTL_O_DC23)   = DCX_ALWAYS_ENABLED;
    *(unsigned long *)(DEVCFG_BASE + SYSCTL_O_DC24)   = DCX_ALWAYS_ENABLED;
    *(unsigned long *)(DEVCFG_BASE + SYSCTL_O_DC25)   = DCX_ALWAYS_ENABLED;
    *(unsigned long *)(DEVCFG_BASE + SYSCTL_O_DC27)   = DCX_ALWAYS_ENABLED;
    *(unsigned long *)(DEVCFG_BASE + SYSCTL_O_DC28)   = DCX_ALWAYS_ENABLED;

    *(unsigned long *)(DEVCFG_BASE + SYSCTL_O_DC1) =  (DCX_ENABLE_HIGH | *(unsigned long *)TI_OTP_REG_DC01);
    *(unsigned long *)(DEVCFG_BASE + SYSCTL_O_DC3) =  (DCX_ENABLE_HIGH | *(unsigned long *)TI_OTP_REG_DC03);
    *(unsigned long *)(DEVCFG_BASE + SYSCTL_O_DC15) = (DCX_ENABLE_HIGH | *(unsigned long *)TI_OTP_REG_DC15);
    *(unsigned long *)(DEVCFG_BASE + SYSCTL_O_DC21) = (DCX_ENABLE_HIGH | *(unsigned long *)TI_OTP_REG_DC21);
    //Load CPUROM_DCx
    *(unsigned long *)(DEVCFG_BASE + SYSCTL_O_CPUROM_DC1)   = (DCX_ENABLE_HIGH | *(unsigned long *)TI_OTP_CPUROM_DC1);    // LOAD CPUROM_DC1 Value  
    *(unsigned long *)(DEVCFG_BASE + SYSCTL_O_CPUROM_DC2)   = (DCX_ENABLE_HIGH | *(unsigned long *)TI_OTP_CPUROM_DC2);    // LOAD CPUROM_DC2 Value  
    *(unsigned long *)(DEVCFG_BASE + SYSCTL_O_CPUROM_DC3)   = (DCX_ENABLE_HIGH | *(unsigned long *)TI_OTP_CPUROM_DC3);    // LOAD CPUROM_DC3 Value  
    *(unsigned long *)(DEVCFG_BASE + SYSCTL_O_CPUROM_DC4)   = (DCX_ENABLE_HIGH | *(unsigned long *)TI_OTP_CPUROM_DC4);    // LOAD CPUROM_DC4 Value  


    //Load PKGTYPE -  only if KEY is programmed
    if (((unsigned long)(*(unsigned long *)TI_OTP_PKG_TYPE & 0xFF00U) >> 8) == PKG_TYPE_KEY)
    {
        *(unsigned long *)(DEVCFG_BASE + SYSCTL_O_PKGTYPE) = (((unsigned long)PKG_TYPE_KEY << 24) |
                                                             ((*(unsigned long *)TI_OTP_PKG_TYPE) & (unsigned long)0x00000000F));          
    }
}
/******* Unbonded GPIO Pull up ***********/
   
enable_unbonded_pullups_64_Q_pin()
{
    //Write 0 to unbonded pin in order to pull-up.
    //if an available pin is already pulled-up, then the pin stays pulled-up.
    //Logical AND with 0 does both of these.
    //
    // Unbonded: 12-15,25-27,30,31,34,42-46,61-63
    // Bonded: 0-11,16-19,22-24,28,29,32,33,35,37,39-41
    //
    *(unsigned long *)(GPIO_CTRL_BASE + GPIO_O_GPAPUD) &= 0x31FF0FFF;
    *(unsigned long *)(GPIO_CTRL_BASE + GPIO_O_GPBPUD) &= 0x1FFF83FB;

}
enable_unbonded_pullups_64_pin()
{
    //Write 0 to unbonded pin in order to pull-up.
    //if an available pin is already pulled-up, then the pin stays pulled-up.
    //Logical AND with 0 does both of these.
    //
    // Unbonded: 14,15,25-27,30,31,34,42-46,61-63
    // Bonded: 0-13,16-19,22-24,28,29,32,33,35,37,39-41
    //
    *(unsigned long *)(GPIO_CTRL_BASE + GPIO_O_GPAPUD) &= 0x31FF3FFF;
    *(unsigned long *)(GPIO_CTRL_BASE + GPIO_O_GPBPUD) &= 0x1FFF83FB;
}
enable_unbonded_pullups_80_P_pin()
{
    //Write 0 to unbonded pin in order to pull-up.
    //if an available pin is already pulled-up, then the pin stays pulled-up.
    //Logical AND with 0 does both of these.
    //
    // Unbonded: 39,42,43,61-63
    // Bonded: 0-7,9-19,22-35,37,41,44-46
    //
    *(unsigned long *)(GPIO_CTRL_BASE + GPIO_O_GPAPUD) &= 0xFFFFFFFF;
    *(unsigned long *)(GPIO_CTRL_BASE + GPIO_O_GPBPUD) &= 0x1FFFF27F;
}

//
// Enable pullups for the unbonded GPIOs on the 80 pin Qual package.
//
enable_unbonded_pullups_80_Q_pin()
{
    //Write 0 to unbonded pin in order to pull-up.
    //if an available pin is already pulled-up, then the pin stays pulled-up.
    //Logical AND with 0 does both of these.
    // Unbonded: 61-63
    // Bonded: 0-19,22-35,37,39-46
    //
    *(unsigned long *)(GPIO_CTRL_BASE + GPIO_O_GPAPUD) &= 0xFFFFFFFF;
    *(unsigned long *)(GPIO_CTRL_BASE + GPIO_O_GPBPUD) &= 0x1FFFFFFF;
}



Device_UnbondedGPIO_Pullup()
{
    unsigned long pin_count;
    
   if (((unsigned long)(*(unsigned long *)TI_OTP_PKG_TYPE & 0xFF00) >> 8) == PKG_TYPE_KEY)
   {
        pin_count = (*(unsigned long *)TI_OTP_PKG_TYPE & 0x0000F);

            if(pin_count == 6)
                    enable_unbonded_pullups_64_Q_pin();
            if(pin_count == 7)
                    enable_unbonded_pullups_64_pin();
            if(pin_count == 8)
                    enable_unbonded_pullups_80_Q_pin();
            if(pin_count == 9)
                    enable_unbonded_pullups_80_P_pin();
    }
}

/********************************************************************/
/* ERAD Clock Enable                                                 */
/* Allows debugger to enable HW breakpoints                          */
/********************************************************************/
menuitem "ERAD Clock Enable"
hotmenu ERAD_Clock_Enable()
{
	*(unsigned long *)(CPUSYS_BASE + SYSCTL_O_PCLKCR0) |= SYSCTL_PCLKCR0_ERAD;
}


/*** End of file ***/
