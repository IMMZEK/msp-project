<?xml version="1.0" encoding="UTF-8"?>
<module id="mmchs" HW_revision="">
    <register id="HL_REV" width="32" offset="0x0" description="IP Revision Identifier (X.Y.R) Used by software to track features bugs and compatibility">
        <bitfield id="SCHEME" description="" begin="31" end="30" width="2" rwaccess="R/W">
        </bitfield>
        <bitfield id="FUNC" description="Function indicates a software compatible module family. If there is no level of software compatibility a new Func number (and hence REVISION) should be assigned." begin="27" end="16" width="12" rwaccess="R/W">
        </bitfield>
        <bitfield id="R_RTL" description="RTL Version (R) maintained by IP design owner. RTL follows a numbering such as X.Y.R.Z which are explained in this table. R changes ONLY when: (1) PDS uploads occur which may have been due to spec changes (2) Bug fixes occur (3) Resets to '0' when X or Y changes. Design team has an internal 'Z' (customer invisible) number which increments on every drop that happens due to DV and RTL updates. Z resets to 0 when R increments." begin="15" end="11" width="5" rwaccess="R/W">
        </bitfield>
        <bitfield id="X_MAJOR" description="Major Revision (X) maintained by IP specification owner. X changes ONLY when: (1) There is a major feature addition. An example would be adding Master Mode to Utopia Level2. The Func field (or Class/Type in old PID format) will remain the same. X does NOT change due to: (1) Bug fixes (2) Change in feature parameters." begin="10" end="8" width="3" rwaccess="R/W">
        </bitfield>
        <bitfield id="CUSTOM" description="" begin="7" end="6" width="2" rwaccess="R/W">
        </bitfield>
        <bitfield id="Y_MINOR" description="Minor Revision (Y) maintained by IP specification owner. Y changes ONLY when: (1) Features are scaled (up or down). Flexibility exists in that this feature scalability may either be represented in the Y change or a specific register in the IP that indicates which features are exactly available. (2) When feature creeps from Is-Not list to Is list. But this may not be the case once it sees silicon; in which case X will change. Y does NOT change due to: (1) Bug fixes (2) Typos or clarifications (3) major functional/feature change/addition/deletion. Instead these changes may be reflected via R S X as applicable. Spec owner maintains a customer-invisible number 'S' which changes due to: (1) Typos/clarifications (2) Bug documentation. Note that this bug is not due to a spec change but due to implementation. Nevertheless the spec tracks the IP bugs. An RTL release (say for silicon PG1.1) that occurs due to bug fix should document the corresponding spec number (X.Y.S) in its release notes." begin="5" end="0" width="6" rwaccess="R/W">
        </bitfield>
    </register>
    <register id="HL_HWINFO" width="32" offset="0x4" description="Information about the IP module's hardware configuration i.e. typically the module's HDL generics (if any). Actual field format and encoding is up to the module's designer to decide.">
        <bitfield id="MEM_SIZE" description="" begin="5" end="2" width="4" rwaccess="R/W">
        </bitfield>
    </register>
    <register id="HL_SYSCONFIG" width="32" offset="0x10" description="Clock management configuration">
        <bitfield id="STANDBYMODE" description="Configuration of the local initiator state management mode. By definition initiator may generate read/write transaction as long as it is out of STANDBY state. 0x0 Force-standby mode: local initiator is unconditionally placed in standby state.Backup mode for debug only. 0x1 No-standby mode: local initiator is unconditionally placed out of standby state.Backup mode for debug only. 0x2 Smart-standby mode: local initiator standby status depends on local conditions i.e. the module's functional requirement from the initiator.IP module shall not generate (initiator-related) wakeup events. 0x3 &amp;quot;Smart-Standby wakeup-capable mode: local initiator standby status depends on local conditions i.e. the module's functional requirement from the initiator. IP module may generate (master-related) wakeup events when in standby state.Mode is only relevant if the appropriate IP module &amp;quot;&amp;quot;mwakeup&amp;quot;&amp;quot; output is implemented.&amp;quot;" begin="5" end="4" width="2" rwaccess="R/W">
        </bitfield>
        <bitfield id="IDLEMODE" description="Configuration of the local target state management mode. By definition target can handle read/write transaction as long as it is out of IDLE state. 0x0 Force-idle mode: local target's idle state follows (acknowledges) the system's idle requests unconditionally i.e. regardless of the IP module's internal requirements.Backup mode for debug only. 0x1 No-idle mode: local target never enters idle state.Backup mode for debug only. 0x2 Smart-idle mode: local target's idle state eventually follows (acknowledges) the system's idle requests depending on the IP module's internal requirements.IP module shall not generate (IRQ- or DMA-request-related) wakeup events. 0x3 &amp;quot;Smart-idle wakeup-capable mode: local target's idle state eventually follows (acknowledges) the system's idle requests depending on the IP module's internal requirements.IP module may generate (IRQ- or DMA-request-related) wakeup events when in idle state.Mode is only relevant if the appropriate IP module &amp;quot;&amp;quot;swakeup&amp;quot;&amp;quot; output(s) is (are) implemented.&amp;quot;" begin="3" end="2" width="2" rwaccess="R/W">
        </bitfield>
    </register>
    <register id="SYSCONFIG" width="32" offset="0x110" description="System Configuration Register This register allows controlling various parameters of the OCP interface.">
        <bitfield id="STANDBYMODE" description="Master interface power Management standby/wait control. The bit field is only useful when generic parameter MADMA_EN (Master ADMA enable) is set as active otherwise it is a read only register read a '0'. 0x0 Force-standby. Mstandby is forced unconditionnaly. 0x1 No-standby. Mstandby is never asserted. 0x2 Smart-standby mode: local initiator standby status depends on local conditions i.e. the module's functional requirement from the initiator.IP module shall not generate (initiator-related) wakeup events. 0x3 Smart-Standby wakeup-capable mode: &amp;quot;local initiator standby status depends on local conditions i.e. the module's functional requirement from the initiator. IP module may generate (master-related) wakeup events when in standby state.Mode is only relevant if the appropriate IP module &amp;quot;&amp;quot;mwakeup&amp;quot;&amp;quot; output is implemented.&amp;quot;" begin="13" end="12" width="2" rwaccess="R/W">
        </bitfield>
        <bitfield id="CLOCKACTIVITY" description="Clocks activity during wake up mode period. Bit8: OCP interface clock Bit9: Functional clock 0x0 OCP and Functional clock may be switched off. 0x1 OCP clock is maintained. Functional clock may be switched-off. 0x2 Functional clock is maintained. OCP clock may be switched-off. 0x3 OCP and Functional clocks are maintained." begin="9" end="8" width="2" rwaccess="R/W">
        </bitfield>
        <bitfield id="SIDLEMODE" description="Power management 0x0 If an idle request is detected the MMCHS acknowledges it unconditionally and goes in Inactive mode. Interrupt and DMA requests are unconditionally de-asserted. 0x1 If an idle request is detected the request is ignored and the module keeps on behaving normally. 0x2 Smart-idle mode: local target's idle state eventually follows (acknowledges) the system's idle requests depending on the IP module's internal requirements.IP module shall not generate (IRQ- or DMA-request-related) wakeup events. 0x3 Smart-idle wakeup-capable mode: &amp;quot;local target's idle state eventually follows (acknowledges) the system's idle requests depending on the IP module's internal requirements.IP module may generate (IRQ- or DMA-request-related) wakeup events when in idle state.Mode is only relevant if the appropriate IP module &amp;quot;&amp;quot;swakeup&amp;quot;&amp;quot; output(s) is (are) implemented.&amp;quot;" begin="4" end="3" width="2" rwaccess="R/W">
        </bitfield>
    </register>
    <register id="SYSSTATUS" width="32" offset="0x114" description="System Status Register This register provides status information about the module excluding the interrupt status information">
    </register>
    <register id="CSRE" width="32" offset="0x124" description="Card status response error This register enables the host controller to detect card status errors of response type R1 R1b for all cards and of R5 R5b and R6 response for cards types SD or SDIO. When a bit MMCHS_CSRE[i] is set to 1 if the corresponding bit at the same position in the response MMCHS_RSP0[i] is set to 1 the host controller indicates a card error (MMCHS_STAT[CERR]) interrupt status to avoid the host driver reading the response register (MMCHS_RSP0). Note: No automatic card error detection for autoCMD12 is implemented; the host system has to check autoCMD12 response register (MMCHS_RESP76) for possible card errors.">
    </register>
    <register id="SYSTEST" width="32" offset="0x128" description="System Test register This register is used to control the signals that connect to I/O pins when the module is configured in system test (SYSTEST) mode for boundary connectivity verification. Note: In SYSTEST mode a write into MMCHS_CMD register will not start a transfer. The buffer behaves as a stack accessible only by the local host (push and pop operations). In this mode the Transfer Block Size (MMCHS_BLK[BLEN]) and the Blocks count for current transfer (MMCHS_BLK[NBLK]) are needed to generate a Buffer write ready interrupt (MMCHS_STAT[BWR]) or a Buffer read ready interrupt (MMCHS_STAT[BRR]) and DMA requests if enabled.">
    </register>
    <register id="CON" width="32" offset="0x12C" description="Configuration register This register is used: - to select the functional mode or the SYSTEST mode for any card. - to send an initialization sequence to any card. - to enable the detection on DAT[1] of a card interrupt for SDIO cards only. and also to configure : - specific data and command transfers for MMC cards only. - the parameters related to the card detect and write protect input signals.">
        <bitfield id="DVAL" description="Debounce filter value All cards This register is used to define a debounce period to filter the card detect input signal (SDCD). The usage of the card detect input signal (SDCD) is optional and depends on the system integration and the type of the connector housing that accommodates the card. 0x0 33 us debounce period 0x1 231 us debounce period 0x2 1 ms debounce period 0x3 84 ms debounce period" begin="10" end="9" width="2" rwaccess="R/W">
        </bitfield>
    </register>
    <register id="PWCNT" width="32" offset="0x130" description="Power counter register This register is used to program a mmc counter to delay command transfers after activating the PAD power this value depends on PAD characteristics and voltage.">
        <bitfield id="PWRCNT" description="Power counter register. This register is used to introduce a delay between the PAD ACTIVE pin assertion and the command issued. 0x0000 No additional delay added 0x0001 TCF delay (card clock period) 0x0002 TCF x 2 delay (card clock period) 0xFFFE TCF x 65534 delay (card clock period) 0xFFFF TCF x 65535 delay (card clock period)" begin="15" end="0" width="16" rwaccess="R/W">
        </bitfield>
    </register>
    <register id="BLK" width="32" offset="0x204" description="Transfer Length Configuration register MMCHS_BLK[BLEN] is the block size register. MMCHS_BLK[NBLK] is the block count register. This register shall be used for any card.">
        <bitfield id="NBLK" description="Blocks count for current transfer This register is enabled when Block count Enable (MMCHS_CMD[BCE]) is set to 1 and is valid only for multiple block transfers. Setting the block count to 0 results no data blocks being transferred. Note: The host controller decrements the block count after each block transfer and stops when the count reaches zero. This register can be accessed only if no transaction is executing (i.e after a transaction has stopped). Read operations during transfers may return an invalid value and write operation will be ignored. In suspend context the number of blocks yet to be transferred can be determined by reading this register. When restoring transfer context prior to issuing a Resume command The local host shall restore the previously saved block count. 0x0000 Stop count 0x0001 1 block 0x0002 2 blocks 0xFFFF 65535 blocks" begin="31" end="16" width="16" rwaccess="R/W">
        </bitfield>
        <bitfield id="BLEN" description="Transfer Block Size. This register specifies the block size for block data transfers. Read operations during transfers may return an invalid value and write operations are ignored. When a CMD12 command is issued to stop the transfer a read of the BLEN field after transfer completion (MMCHS_STAT[TC] set to 1) will not return the true byte number of data length while the stop occurs but the value written in this register before transfer is launched. 0x000 No data transfer 0x001 1 byte block length 0x002 2 bytes block length 0x003 3 bytes block length 0x1FF 511 bytes block length 0x200 512 bytes block length 0x7FF 2047 bytes block length 0x800 2048 bytes block length" begin="11" end="0" width="12" rwaccess="R/W">
        </bitfield>
    </register>
    <register id="ARG" width="32" offset="0x208" description="Command argument Register This register contains command argument specified as bit 39-8 of Command-Format These registers must be initialized prior to sending the command itself to the card (write action into the register MMCHS_CMD register). Only exception is for a command index specifying stuff bits in arguments making a write unnecessary.">
    </register>
    <register id="CMD" width="32" offset="0x20C" description="Command and transfer mode register MMCHS_CMD[31:16] = the command register MMCHS_CMD[15:0] = the transfer mode. This register configures the data and command transfers. A write into the most significant byte send the command. A write into MMCHS_CMD[15:0] registers during data transfer has no effect. This register shall be used for any card. Note: In SYSTEST mode a write into MMCHS_CMD register will not start a transfer.">
        <bitfield id="INDX" description="Command index Binary encoded value from 0 to 63 specifying the command number send to card 0x00 CMD0 or ACMD0 0x01 CMD1 or ACMD1 0x02 CMD2 or ACMD2 0x03 CMD3 or ACMD3 0x04 CMD4 or ACMD4 0x05 CMD5 or ACMD5 0x06 CMD6 or ACMD6 0x07 CMD7 or ACMD7 0x08 CMD8 or ACMD8 0x09 CMD9 or ACMD9 0x0A CMD10 or ACMD10 0x0B CMD11 or ACMD11 0x0C CMD12 or ACMD12 0x0D CMD13 or ACMD13 0x0E CMD14 or ACMD14 0x0F CMD15 or ACMD15 0x10 CMD16 or ACMD16 0x11 CMD17 or ACMD17 0x12 CMD18 or ACMD18 0x13 CMD19 or ACMD19 0x14 CMD20 or ACMD20 0x15 CMD21 or ACMD21 0x16 CMD22 or ACMD22 0x17 CMD23 or ACMD23 0x18 CMD24 or ACMD24 0x19 CMD25 or ACMD25 0x1A CMD26 or ACMD26 0x1B CMD27 or ACMD27 0x1C CMD28 or ACMD28 0x1D CMD29 or ACMD29 0x1E CMD30 or ACMD30 0x1F CMD31 or ACMD31 0x20 CMD32 or ACMD32 0x21 CMD33 or ACMD33 0x22 CMD34 or ACMD34 0x23 CMD35 or ACMD35 0x24 CMD36 or ACMD36 0x25 CMD37 or ACMD37 0x26 CMD38 or ACMD38 0x27 CMD39 or ACMD39 0x28 CMD40 or ACMD40 0x29 CMD41 or ACMD41 0x2A CMD42 or ACMD42 0x2B CMD43 or ACMD43 0x2C CMD44 or ACMD44 0x2D CMD45 or ACMD45 0x2E CMD46 or ACMD46 0x2F CMD47 or ACMD47 0x30 CMD48 or ACMD48 0x31 CMD49 or ACMD49 0x32 CMD50 or ACMD50 0x33 CMD51 or ACMD51 0x34 CMD52 or ACMD52 0x35 CMD53 or ACMD53 0x36 CMD54 or ACMD54 0x37 CMD55 or ACMD55 0x38 CMD56 or ACMD56 0x39 CMD57 or ACMD57 0x3A CMD58 or ACMD58 0x3B CMD59 or ACMD59 0x3C CMD60 or ACMD60 0x3D CMD61 or ACMD61 0x3E CMD62 or ACMD62 0x3F CMD63 or ACMD63" begin="29" end="24" width="6" rwaccess="R/W">
        </bitfield>
        <bitfield id="CMD_TYPE" description="Command type This register specifies three types of special command: Suspend Resume and Abort. These bits shall be set to 00b for all other commands. 0x0 Others Commands 0x1 &amp;quot;CMD52 for writing &amp;quot;&amp;quot;Bus Suspend&amp;quot;&amp;quot; in CCCR&amp;quot; 0x2 &amp;quot;CMD52 for writing &amp;quot;&amp;quot;Function Select&amp;quot;&amp;quot; in CCCR&amp;quot; 0x3 &amp;quot;Abort command CMD12 CMD52 for writing &amp;quot;&amp;quot; I/O Abort&amp;quot;&amp;quot; in CCCR&amp;quot;" begin="23" end="22" width="2" rwaccess="R/W">
        </bitfield>
        <bitfield id="RSP_TYPE" description="Response type This bits defines the response type of the command 0x0 No response 0x1 Response Length 136 bits 0x2 Response Length 48 bits 0x3 Response Length 48 bits with busy after response" begin="17" end="16" width="2" rwaccess="R/W">
        </bitfield>
    </register>
    <register id="RSP10" width="32" offset="0x210" description="Command response[31:0] Register This 32-bit register holds bits positions [31:0] of command response type R1/R1b/R2/R3/R4/R5/R5b/R6">
        <bitfield id="RSP1" description="Command Response [31:16]" begin="31" end="16" width="16" rwaccess="R/W">
        </bitfield>
        <bitfield id="RSP0" description="Command Response [15:0]" begin="15" end="0" width="16" rwaccess="R/W">
        </bitfield>
    </register>
    <register id="RSP32" width="32" offset="0x214" description="Command response[63:32] Register This 32-bit register holds bits positions [63:32] of command response type R2">
        <bitfield id="RSP3" description="Command Response [63:48]" begin="31" end="16" width="16" rwaccess="R/W">
        </bitfield>
        <bitfield id="RSP2" description="Command Response [47:32]" begin="15" end="0" width="16" rwaccess="R/W">
        </bitfield>
    </register>
    <register id="RSP54" width="32" offset="0x218" description="Command response[95:64] Register This 32-bit register holds bits positions [95:64] of command response type R2">
        <bitfield id="RSP5" description="Command Response [95:80]" begin="31" end="16" width="16" rwaccess="R/W">
        </bitfield>
        <bitfield id="RSP4" description="Command Response [79:64]" begin="15" end="0" width="16" rwaccess="R/W">
        </bitfield>
    </register>
    <register id="RSP76" width="32" offset="0x21C" description="Command response[127:96] Register This 32-bit register holds bits positions [127:96] of command response type R2">
        <bitfield id="RSP7" description="Command Response [127:112]" begin="31" end="16" width="16" rwaccess="R/W">
        </bitfield>
        <bitfield id="RSP6" description="Command Response [111:96]" begin="15" end="0" width="16" rwaccess="R/W">
        </bitfield>
    </register>
    <register id="DATA" width="32" offset="0x220" description="Data Register This register is the 32-bit entry point of the buffer for read or write data transfers. The buffer size is 32bits x256(1024 bytes). Bytes within a word are stored and read in little endian format. This buffer can be used as two 512 byte buffers to transfer data efficiently without reducing the throughput. Sequential and contiguous access is necessary to increment the pointer correctly. Random or skipped access is not allowed. In little endian if the local host accesses this register byte-wise or 16bit-wise the least significant byte (bits [7:0]) must always be written/read first. The update of the buffer address is done on the most significant byte write for full 32-bit DATA register or on the most significant byte of the last word of block transfer. Example 1: Byte or 16-bit access Mbyteen[3:0]=0001 (1-byte) =&gt; Mbyteen[3:0]=0010 (1-byte) =&gt; Mbyteen[3:0]=1100 (2-bytes) OK Mbyteen[3:0]=0001 (1-byte) =&gt; Mbyteen[3:0]=0010 (1-byte) =&gt; Mbyteen[3:0]=0100 (1-byte) OK Mbyteen[3:0]=0001 (1-byte) =&gt; Mbyteen[3:0]=0010 (1-byte) =&gt; Mbyteen[3:0]=1000 (1-byte) Bad">
    </register>
    <register id="PSTATE" width="32" offset="0x224" description="Present state register The Host can get status of the Host Controller from this 32-bit read only register.">
        <bitfield id="DLEV" description="DAT[3:0] line signal level DAT[3] =&gt; bit 23 DAT[2] =&gt; bit 22 DAT[1] =&gt; bit 21 DAT[0] =&gt; bit 20 This status is used to check DAT line level to recover from errors and for debugging. This is especially useful in detecting the busy signal level from DAT[0]. The value of these registers after reset depends on the DAT lines level at that time." begin="23" end="20" width="4" rwaccess="R/W">
        </bitfield>
    </register>
    <register id="HCTL" width="32" offset="0x228" description="Control register This register defines the host controls to set power wakeup and transfer parameters. MMCHS_HCTL[31:24] = Wakeup control MMCHS_HCTL[23:16] = Block gap control MMCHS_HCTL[15:8] = Power control MMCHS_HCTL[7:0] = Host control">
        <bitfield id="SDVS" description="SD bus voltage select All cards. The host driver should set to these bits to select the voltage level for the card according to the voltage supported by the system (MMCHS_CAPA[VS18VS30VS33]) before starting a transfer. 0x5 1.8V (Typical) 0x6 3.0V (Typical) 0x7 3.3V (Typical)" begin="11" end="9" width="3" rwaccess="R/W">
        </bitfield>
        <bitfield id="DMAS" description="DMA Select Mode: One of supported DMA modes can be selected. The host driver shall check support of DMA modes by referring the Capabilities register. Use of selected DMA is determined by DMA Enable of the Transfer Mode register. This register is only meaningful when MADMA_EN is set to 1. When MADMA_EN is set to 0 the bit field is read only and returned value is 0. 0x0 Reserved 0x1 Reserved 0x2 32-bit Address ADMA2 is selected 0x3 Reserved" begin="4" end="3" width="2" rwaccess="R/W">
        </bitfield>
    </register>
    <register id="SYSCTL" width="32" offset="0x22C" description="SD system control register This register defines the system controls to set software resets clock frequency management and data timeout. MMCHS_SYSCTL[31:24] = Software resets MMCHS_SYSCTL[23:16] = Timeout control MMCHS_SYSCTL[15:0] = Clock control">
        <bitfield id="DTO" description="Data timeout counter value and busy timeout. This value determines the interval by which DAT lines timeouts are detected. The host driver needs to set this bitfield based on - the maximum read access time (NAC) (Refer to the SD Specification Part1 Physical Layer) - the data read access time values (TAAC and NSAC) in the card specific data register (CSD) of the card - the timeout clock base frequency (MMCHS_CAPA[TCF]). If the card does not respond within the specified number of cycles a data timeout error occurs (MMCHS_STA[DTO]). The MMCHS_SYSCTL[DTO] register is also used to check busy duration to generate busy timeout for commands with busy response or for busy programming during a write command. Timeout on CRC status is generated if no CRC token is present after a block write. 0x0 TCF x 2^13 0x1 TCF x 2^14 0xE TCF x 2^27 0xF Reserved" begin="19" end="16" width="4" rwaccess="R/W">
        </bitfield>
        <bitfield id="CLKD" description="Clock frequency select These bits define the ratio between a reference clock frequency (system dependant) and the output clock frequency on the CLK pin of either the memory card (MMC SD or SDIO). 0x000 Clock Ref bypass 0x001 Clock Ref bypass 0x002 Clock Ref / 2 0x003 Clock Ref / 3 0x3FF Clock Ref / 1023" begin="15" end="6" width="10" rwaccess="R/W">
        </bitfield>
    </register>
    <register id="STAT" width="32" offset="0x230" description="Interrupt status register The interrupt status regroups all the status of the module internal events that can generate an interrupt. MMCHS_STAT[31:16] = Error Interrupt Status MMCHS_STAT[15:0] = Normal Interrupt Status">
    </register>
    <register id="IE" width="32" offset="0x234" description="Interrupt SD enable register This register allows to enable/disable the module to set status bits on an event-by-event basis. MMCHS_IE[31:16] = Error Interrupt Status Enable MMCHS_IE[15:0] = Normal Interrupt Status Enable">
    </register>
    <register id="ISE" width="32" offset="0x238" description="Interrupt signal enable register This register allows to enable/disable the module internal sources of status on an event-by-event basis. MMCHS_ISE[31:16] = Error Interrupt Signal Enable MMCHS_ISE[15:0] = Normal Interrupt Signal Enable">
    </register>
    <register id="AC12" width="32" offset="0x23C" description="Auto CMD12 Error Status Register The host driver may determine which of the errors cases related to Auto CMD12 has occurred by checking this MMCHS_AC12 register when an Auto CMD12 Error interrupt occurs. This register is valid only when Auto CMD12 is enabled (MMCHS_CMD[ACEN]) and Auto CMD12Error (MMCHS_STAT[ACE]) is set to 1. Note: These bits are automatically reset when starting a new adtc command with data.">
    </register>
    <register id="CAPA" width="32" offset="0x240" description="Capabilities register This register lists the capabilities of the MMC/SD/SDIO host controller.">
        <bitfield id="MBL" description="" begin="17" end="16" width="2" rwaccess="R/W">
        </bitfield>
        <bitfield id="BCF" description="" begin="13" end="8" width="6" rwaccess="R/W">
        </bitfield>
        <bitfield id="TCF" description="" begin="5" end="0" width="6" rwaccess="R/W">
        </bitfield>
    </register>
    <register id="CUR_CAPA" width="32" offset="0x248" description="Maximum current capabilities Register This register indicates the maximum current capability for each voltage. The value is meaningful if the voltage support is set in the capabilities register (MMCHS_CAPA). Initialization of this register (via a write access to this register) depends on the system capabilities. The host driver shall not modify this register after the initilaization. This register is only reinitialized by a hard reset (via RESETN signal)">
        <bitfield id="CUR_1V8" description="" begin="23" end="16" width="8" rwaccess="R/W">
        </bitfield>
        <bitfield id="CUR_3V0" description="" begin="15" end="8" width="8" rwaccess="R/W">
        </bitfield>
        <bitfield id="CUR_3V3" description="" begin="7" end="0" width="8" rwaccess="R/W">
        </bitfield>
    </register>
    <register id="FE" width="32" offset="0x250" description="Force Event Register for Error Interrupt status The force Event Register is not a physically implemented register. Rather it is an address at which the Error Interrupt Status register can be written. The effect of a write to this address will be reflected in the Error Interrupt Status Register if corresponding bit of the Error Interrupt Status Enable Register is set.">
    </register>
    <register id="ADMAES" width="32" offset="0x254" description="ADMA Error Status Register When ADMA Error Interrupt is occurred the ADMA Error States field in this register holds the ADMA state and the ADMA System Address Register holds the address around the error descriptor. For recovering the error the Host Driver requires the ADMA state to identify the error descriptor address as follows: ST_STOP: Previous location set in the ADMA System Address register is the error descriptor address ST_FDS: Current location set in the ADMA System Address register is the error descriptor address ST_CADR: This sate is never set because do not generate ADMA error in this state. ST_TFR: Previous location set in the ADMA System Address register is the error descriptor address In case of write operation the Host Driver should use ACMD22 to get the number of written block rather than using this information since unwritten data may exist in the Host Controller. The Host Controller generates the ADMA Error Interrupt when it detects invalid descriptor data (Valid=0) at the ST_FDS state. In this case ADMA Error State indicates that an error occurs at ST_FDS state. The Host Driver may find that the Valid bit is not set in the error descriptor.">
        <bitfield id="AES" description="ADMA Error State his field indicates the state of ADMA when error is occurred during ADMA data transfer. &amp;quot;This field never indicates &amp;quot;&amp;quot;10&amp;quot;&amp;quot; because ADMA never stops in this state.&amp;quot; 0x0 ST_STOP (Stop DMA)Contents of SYS_SDR register 0x1 ST_STOP (Stop DMA)Points the error descriptor 0x2 Never set this state(Not used) 0x3 ST_TFR (Transfer Data)Points the next of the error descriptor" begin="1" end="0" width="2" rwaccess="R/W">
        </bitfield>
    </register>
    <register id="ADMASAL" width="32" offset="0x258" description="ADMA System address Low bits">
    </register>
    <register id="REV" width="32" offset="0x2FC" description="Versions Register This register contains the hard coded RTL vendor revision number the version number of SD specification compliancy and a slot status bit. MMCHS_REV[31:16] = Host controller version MMCHS_REV[15:0] = Slot Interrupt Status ****************************************************************************">
        <bitfield id="VREV" description="Vendor Version Number: IP revision [7:4] Major revision [3:0] Minor revision Examples: 0x10 for 1.0 0x21 for 2.1" begin="31" end="24" width="8" rwaccess="R/W">
        </bitfield>
        <bitfield id="SREV" description="" begin="23" end="16" width="8" rwaccess="R/W">
        </bitfield>
    </register>
</module>
