<?xml version="1.0" encoding="UTF-8"?>
<module id="PSC" HW_revision="1" XML_version="1" description="Power and Sleep Controller (PSC) Version 0.95">
   <register id="PID" acronym="PID" offset="0" width="32" description="Peripheral Revision and Class Information">
      <bitfield id="SCHEME" width="2" begin="31" end="30" resetval="1" description="Used to distinguish between old scheme and current.  Spare bit to encode future schemes" range="-" rwaccess="R">
         
         
      </bitfield>
      <bitfield id="_RESV" width="2" begin="29" end="28" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="FUNC" width="12" begin="27" end="16" resetval="520" description="Indicating a software compatible module family.  If there is no level of software compatibility a new ID should be assigned." range="" rwaccess="R">
         
         
      </bitfield>
      <bitfield id="RTL" width="5" begin="15" end="11" resetval="0" description="RTL Version. (R as described in PDR 9.3.2) Must be easily ECO'able or controlled during fabrication. Ideally through a top level metal mask or efuse.  Start with 0 for PSC1.0, 1 for PSC2.0" range="" rwaccess="R">
         
         
      </bitfield>
      <bitfield id="MAJOR" width="3" begin="10" end="8" resetval="0" description="Major Revision." range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="CUSTOM" width="2" begin="7" end="6" resetval="0" description="Indicates a Special Version for a particular device.  Consequence of use may avoid use of standard CSL/Drivers. 0 if non-custom" range="" rwaccess="R">
         
         
      </bitfield>
      <bitfield id="MINOR" width="6" begin="5" end="0" resetval="0" description="Minor Revision Must be easily ECO'able or controlled during fabrication. Ideally through a top level metal mask or efuse. Start with 0." range="-" rwaccess="R">
         
         
         
      </bitfield>
   </register>
   <register id="GBLCTL" acronym="GBLCTL" offset="0x10" width="32" description="Global Control Register">
      <bitfield id="_RESV" width="30" begin="31" end="2" resetval="0" description="Reserved" range="-" rwaccess="R">
         
      </bitfield>
      <bitfield id="CCM" width="1" begin="1" end="1" resetval="0" description="PSC MMR controlled by Chip Config Module (CCM) only                               0: Software is allowed to control PSC                                                          1: PSC is controlled by CCM                                            " range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="FORCE" width="1" begin="0" end="0" resetval="0" description="Force bit. For PSC 2.0, this bit is considered only if all of the conditions are true:                                                                                                         -GBLCTL.CCM = 0                                                                                         -Software manual control method is used                                                    0: No force                                                                                                    1: Force" range="" rwaccess="RW">
         
      </bitfield>
   </register>
   <register id="GBLSTAT" acronym="GBLSTAT" offset="0x14" width="32" description="Global Status Register">
      <bitfield id="_RESV" width="31" begin="31" end="1" resetval="0" description="Reserved" range="-" rwaccess="R">
         
      </bitfield>
      <bitfield id="GBLTRANS" width="1" begin="0" end="0" resetval="0" description="PSC Global Transition Status                                                                         0: No Global Transition in progress                                                               1: Global Transition in progress. PSC hardware is in the process of putting all power domains to the desired next states, and all modules to the desired next states" range="" rwaccess="R">
         
      </bitfield>
   </register>
   <register id="INTEVAL" acronym="INTEVAL" offset="0x18" width="32" description="Interrupt Evaluation Register">
      <bitfield id="_RESV" width="12" begin="31" end="20" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="MPSET" width="1" begin="19" end="19" resetval="0" description="Memory Protection Interrupt Set                                                                    0: Write of 0 has no effect                                                                                         1: Write of 1 causes the PSC_MPINT to be pulsed." range="" rwaccess="W">
         
      </bitfield>
      <bitfield id="EPCSET" width="1" begin="18" end="18" resetval="0" description="External Power Control Interrupt Set (not documented to users)                 0: Write of 0 has no effect                                                                            1: Write of 1 causes the PSC_EPCINT to be pulsed" range="" rwaccess="W">
         
      </bitfield>
      <bitfield id="ERRSET" width="1" begin="17" end="17" resetval="0" description="Error Interrupt Set (not documented for users)                                            0: Write of 0 has no effect                                                                            1: Write of 1 causes the PSC_ERRINT to be pulsed  " range="" rwaccess="W">
         
      </bitfield>
      <bitfield id="ALLSET" width="1" begin="16" end="16" resetval="0" description="Combined Interrupt Set (not documented to users)                                      0: Write of 0 has no effect                                                                            1: Write of 1 causes the PSC_ALLINT to be pulsed" range="" rwaccess="W">
         
      </bitfield>
      <bitfield id="_RESV" width="12" begin="15" end="4" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="MPEV" width="1" begin="3" end="3" resetval="0" description="Re-evaluate Memory Protection Interrupt                                                      0: Write of 0 has no effect                                                                            1: Write of 1 re-evaluate memory protection interrupt PSC_MPINT" range="" rwaccess="W">
         
      </bitfield>
      <bitfield id="EPCEV" width="1" begin="2" end="2" resetval="0" description="External Power Control Interrupt Set                                                           0: Write of 0 has no effect                                                                            1: Write of 1 re-evaluate external power control interrupt PSC_EPCINT" range="" rwaccess="W">
         
      </bitfield>
      <bitfield id="ERREV" width="1" begin="1" end="1" resetval="0" description="Re-evaluate Error Interrupt                                                                            0: Write of 0 has no effect                                                                            1: Write of 1 re-evaluate error Interrupt PSC_ERRINT" range="" rwaccess="W">
         
      </bitfield>
      <bitfield id="ALLEV" width="1" begin="0" end="0" resetval="0" description="Re-evaluate combined PSC interrupt                                                             0: Write of 0 has no effect                                                                             1: Write of 1 re-evaluate the combined PSC interrupt PSC_ALLINT" range="" rwaccess="W">
         
      </bitfield>
   </register>
   <register id="MERRPR0" acronym="MERRPR0" offset="0x40" width="32" description="Module Error Pending 0 (mod 0 - 31) Register">
      <bitfield id="M[32]" width="1" begin="31" end="0" resetval="0" description="Records pending error conditions for modules 0-31. Each bit n respresents a module. For each bit n,                                                          0: Module n does not have error condition                                                    1: Module n has error condition                                                                                 " range="-" rwaccess="R">
         
      </bitfield>
   </register>
   <register id="MERRPR1" acronym="MERRPR1" offset="0x44" width="32" description="Module Error Pending 1 (mod 32 - 63) Register">
      <bitfield id="M[32]" width="1" begin="31" end="0" resetval="0" description="Records pending error conditions for modules 32-63. Each bit n respresents a module. For each bit n,                                                          0: Module n does not have error condition                                                    1: Module n has error condition                                                                                 " range="-" rwaccess="R">
         
      </bitfield>
   </register>
   <register id="MERRCR0" acronym="MERRCR0" offset="0x50" width="32" description="Module Error Clear 0 (mod 0-31) Register">
      <bitfield id="M[32]" width="1" begin="31" end="0" resetval="0" description="Clears error bit set in corresponding ERRPR register bit field. This pertains to modules 0-31. For each bit n,                                                      0: Write of 0 has no effect                                                                            1: Write of 1 to bit n causes ERRPR bit n to be cleared, and the corresponding module's MDSTAT fields to be cleared - STERR, WKRSLP, ACSLP, MSTID." range="-" rwaccess="W">
         
      </bitfield>
   </register>
   <register id="MERRCR1" acronym="MERRCR1" offset="0x54" width="32" description="Module Error Clear 1 (mod 32-63) Register">
      <bitfield id="M[32]" width="1" begin="31" end="0" resetval="0" description="Clears error bit set in corresponding ERRPR register bit field. This pertains to modules 32-63. For each bit n,                                                      0: Write of 0 has no effect                                                                            1: Write of 1 to bit n causes ERRPR bit n to be cleared, and the corresponding module's MDSTAT fields to be cleared - STERR, WKRSLP, ACSLP, MSTID." range="-" rwaccess="W">
         
      </bitfield>
   </register>
   <register id="PERRPR" acronym="PERRPR" offset="0x60" width="32" description="Power Error Pending Register">
      <bitfield id="P[32]" width="1" begin="31" end="0" resetval="0" description="Power Domain n Error Condition                                                                   0: Power domain n does not have error condition                                        1: Power domain n has error condition                                                          " range="" rwaccess="R">
         
      </bitfield>
   </register>
   <register id="PERRCR" acronym="PERRCR" offset="0x68" width="32" description="Power Error Clear Register">
      <bitfield id="P[32]" width="1" begin="31" end="0" resetval="0" description="0: Write of 0 has no effect                                                                          1: Write of 1 clears the corresponding PERRPR bit                                                          " range="" rwaccess="W">
         
      </bitfield>
   </register>
   <register id="EPCPR" acronym="EPCPR" offset="0x70" width="32" description="Power Error Pending Register">
      <bitfield id="EPC[32]" width="1" begin="31" end="0" resetval="0" description="External Power Control Intervention Request for Power Domain n                                                                    0: No need for external power control to turn on/off power for Power Doamin n                                                                                                     1: External Power Control intervention is needed for turning on/off power for Power domain n " range="" rwaccess="R">
         
      </bitfield>
   </register>
   <register id="EPCCR" acronym="EPCCR" offset="0x78" width="32" description="External Power Control Clear Register">
      <bitfield id="EPC[32]" width="1" begin="31" end="0" resetval="0" description="0: Write of 0 has no effect                                                                          1: Write of 1 clears the corresponding EPCPR bit                                                          " range="" rwaccess="W">
         
      </bitfield>
   </register>
   <register id="RAILSTAT" acronym="RAILSTAT" offset="0x100" width="32" description="Power Rail Status Register">
      <bitfield id="_RESV" width="3" begin="31" end="29" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="RAILNUM" width="5" begin="28" end="24" resetval="0" description="Indicates Current Rail Requestor being processed by GPSC. Defaults to 0 indicating Always ON domain that has no rail request/grant associated with it. The 5 bit field allows up to 32 requestors." range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="_RESV" width="16" begin="23" end="8" resetval="0" description="Reserved for RAILCNT expansion" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="RAILCNT" width="8" begin="7" end="0" resetval="0" description="Indicates the current rail counter value. This is a dynamic field and reading this will not reflect real-time value. " range="" rwaccess="R">
         
      </bitfield>
   </register>
   <register id="RAILCTL" acronym="RAILCTL" offset="0x104" width="32" description="Power Rail Counter Control Register">
      <bitfield id="_RESV" width="16" begin="31" end="16" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="RAILCTR1" width="8" begin="15" end="8" resetval="0" description="Rail Counter Value 1" range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="RAILCTR0" width="8" begin="7" end="0" resetval="0" description="Rail Counter Value 0" range="" rwaccess="RW">
         
      </bitfield>
   </register>
   <register id="RAILSEL" acronym="RAILSEL" offset="0x108" width="32" description="Power Rail Counter Select Register">
      <bitfield id="P[32]" width="1" begin="31" end="0" resetval="0" description="Rail Counter Select for Power Domain n                                                       0: Use RAILCTL.RailCtr0 count value to bring up power domain n               1: Use RAILCTL.RailCtr1 count value to bring up power domain n" range="" rwaccess="RW">
         
      </bitfield>
   </register>
   <register id="PTCMD" acronym="PTCMD" offset="0x120" width="32" description="Power Domain Transition Command Register">
      <bitfield id="GO[32]" width="1" begin="31" end="0" resetval="0" description="PSC 1.0 definition: Power Domain n Evaluation                                             0: Writes of 0 has no effect                                                                          1: Writes of 1 cause the State Transition Interrupt Generation Block to evaluate the new PTNEXT and MDCTL.NEXT states as the Application desired states.                                                                                              PSC 2.0 definition: Power Domain n GO Transition                                       0: Writes of 0 have no effect                                                                        1: Writes of 1 cause PSC hardware to evaluate PTNEXT and MDCTL.NEXT (for this domain)." range="" rwaccess="RW">
         
      </bitfield>
   </register>
   <register id="PTSTAT" acronym="PTSTAT" offset="0x128" width="32" description="Power Domain Transition Status Register">
      <bitfield id="GOSTAT[32]" width="1" begin="31" end="0" resetval="0" description="Power Domain n Transition Command Status, where n ranges from 31 down to 0                                                                                                               0: No transitions in progress in Power Domain n                                         1: Power Domain 0 Transition in progress - either the power domain is transitioning, or modules on this domain are transitioning.                            Note: Power domain 0 is reserved for the Always ON domain, this bit is always 0." range="" rwaccess="R">
         
      </bitfield>
   </register>
   <register id="PDSTAT0" acronym="PDSTAT0" offset="0x200" width="32" description="Power Domain Status 0 Register">
      <bitfield id="_RESV" width="22" begin="31" end="10" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="EMUIHB" width="1" begin="9" end="9" resetval="0" description="Emulation Alters Domain State - Inhibits Off or Forces ON                              0: No emulation altering user-desired power domain state                           1: Emulation alters user-desired power state     " range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="PWRBAD" width="1" begin="8" end="8" resetval="0" description="Power Bad error. The power domain is in ON or WASRD state, but pwr_good_pi input is de-asserted to indicate power bad.                           0: No error                                                                                                     1: Error detected" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="_RESV" width="7" begin="7" end="1" resetval="0" description="Reserved" range="" rwaccess="R ">
         
      </bitfield>
      <bitfield id="STATE" width="1" begin="0" end="0" resetval="0" description="Current Power Domain State                                                                         0: Off                                                                                                             1: On               " range="" rwaccess="R">
         
      </bitfield>
   </register>
   <register id="PDSTAT1" acronym="PDSTAT1" offset="0x204" width="32" description="Power Domain Status 1 Register">
      <bitfield id="_RESV" width="22" begin="31" end="10" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="EMUIHB" width="1" begin="9" end="9" resetval="0" description="Emulation Alters Domain State - Inhibits Off or Forces ON                              0: No emulation altering user-desired power domain state                           1: Emulation alters user-desired power state     " range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="PWRBAD" width="1" begin="8" end="8" resetval="0" description="Power Bad error. The power domain is in ON or WASRD state, but pwr_good_pi input is de-asserted to indicate power bad.                           0: No error                                                                                                     1: Error detected" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="_RESV" width="7" begin="7" end="1" resetval="0" description="Reserved" range="" rwaccess="R ">
         
      </bitfield>
      <bitfield id="STATE" width="1" begin="0" end="0" resetval="0" description="Current Power Domain State                                                                         0: Off                                                                                                             1: On               " range="" rwaccess="R">
         
      </bitfield>
   </register>
   <register id="PDSTAT2" acronym="PDSTAT2" offset="0x208" width="32" description="Power Domain Status 2 Register">
      <bitfield id="_RESV" width="22" begin="31" end="10" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="EMUIHB" width="1" begin="9" end="9" resetval="0" description="Emulation Alters Domain State - Inhibits Off or Forces ON                              0: No emulation altering user-desired power domain state                           1: Emulation alters user-desired power state     " range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="PWRBAD" width="1" begin="8" end="8" resetval="0" description="Power Bad error. The power domain is in ON or WASRD state, but pwr_good_pi input is de-asserted to indicate power bad.                           0: No error                                                                                                     1: Error detected" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="_RESV" width="7" begin="7" end="1" resetval="0" description="Reserved" range="" rwaccess="R ">
         
      </bitfield>
      <bitfield id="STATE" width="1" begin="0" end="0" resetval="0" description="Current Power Domain State                                                                         0: Off                                                                                                             1: On               " range="" rwaccess="R">
         
      </bitfield>
   </register>
   <register id="PDSTAT3" acronym="PDSTAT3" offset="0x20C" width="32" description="Power Domain Status 3 Register">
      <bitfield id="_RESV" width="22" begin="31" end="10" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="EMUIHB" width="1" begin="9" end="9" resetval="0" description="Emulation Alters Domain State - Inhibits Off or Forces ON                              0: No emulation altering user-desired power domain state                           1: Emulation alters user-desired power state     " range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="PWRBAD" width="1" begin="8" end="8" resetval="0" description="Power Bad error. The power domain is in ON or WASRD state, but pwr_good_pi input is de-asserted to indicate power bad.                           0: No error                                                                                                     1: Error detected" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="_RESV" width="7" begin="7" end="1" resetval="0" description="Reserved" range="" rwaccess="R ">
         
      </bitfield>
      <bitfield id="STATE" width="1" begin="0" end="0" resetval="0" description="Current Power Domain State                                                                         0: Off                                                                                                             1: On               " range="" rwaccess="R">
         
      </bitfield>
   </register>
   <register id="PDSTAT4" acronym="PDSTAT4" offset="0x210" width="32" description="Power Domain Status 4 Register">
      <bitfield id="_RESV" width="22" begin="31" end="10" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="EMUIHB" width="1" begin="9" end="9" resetval="0" description="Emulation Alters Domain State - Inhibits Off or Forces ON                              0: No emulation altering user-desired power domain state                           1: Emulation alters user-desired power state     " range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="PWRBAD" width="1" begin="8" end="8" resetval="0" description="Power Bad error. The power domain is in ON or WASRD state, but pwr_good_pi input is de-asserted to indicate power bad.                           0: No error                                                                                                     1: Error detected" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="_RESV" width="7" begin="7" end="1" resetval="0" description="Reserved" range="" rwaccess="R ">
         
      </bitfield>
      <bitfield id="STATE" width="1" begin="0" end="0" resetval="0" description="Current Power Domain State                                                                         0: Off                                                                                                             1: On               " range="" rwaccess="R">
         
      </bitfield>
   </register>
   <register id="PDSTAT5" acronym="PDSTAT5" offset="0x214" width="32" description="Power Domain Status 5 Register">
      <bitfield id="_RESV" width="22" begin="31" end="10" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="EMUIHB" width="1" begin="9" end="9" resetval="0" description="Emulation Alters Domain State - Inhibits Off or Forces ON                              0: No emulation altering user-desired power domain state                           1: Emulation alters user-desired power state     " range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="PWRBAD" width="1" begin="8" end="8" resetval="0" description="Power Bad error. The power domain is in ON or WASRD state, but pwr_good_pi input is de-asserted to indicate power bad.                           0: No error                                                                                                     1: Error detected" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="_RESV" width="7" begin="7" end="1" resetval="0" description="Reserved" range="" rwaccess="R ">
         
      </bitfield>
      <bitfield id="STATE" width="1" begin="0" end="0" resetval="0" description="Current Power Domain State                                                                         0: Off                                                                                                             1: On               " range="" rwaccess="R">
         
      </bitfield>
   </register>
   <register id="PDSTAT6" acronym="PDSTAT6" offset="0x218" width="32" description="Power Domain Status 6 Register">
      <bitfield id="_RESV" width="22" begin="31" end="10" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="EMUIHB" width="1" begin="9" end="9" resetval="0" description="Emulation Alters Domain State - Inhibits Off or Forces ON                              0: No emulation altering user-desired power domain state                           1: Emulation alters user-desired power state     " range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="PWRBAD" width="1" begin="8" end="8" resetval="0" description="Power Bad error. The power domain is in ON or WASRD state, but pwr_good_pi input is de-asserted to indicate power bad.                           0: No error                                                                                                     1: Error detected" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="_RESV" width="7" begin="7" end="1" resetval="0" description="Reserved" range="" rwaccess="R ">
         
      </bitfield>
      <bitfield id="STATE" width="1" begin="0" end="0" resetval="0" description="Current Power Domain State                                                                         0: Off                                                                                                             1: On               " range="" rwaccess="R">
         
      </bitfield>
   </register>
   <register id="PDSTAT7" acronym="PDSTAT7" offset="0x21C" width="32" description="Power Domain Status 7 Register">
      <bitfield id="_RESV" width="22" begin="31" end="10" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="EMUIHB" width="1" begin="9" end="9" resetval="0" description="Emulation Alters Domain State - Inhibits Off or Forces ON                              0: No emulation altering user-desired power domain state                           1: Emulation alters user-desired power state     " range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="PWRBAD" width="1" begin="8" end="8" resetval="0" description="Power Bad error. The power domain is in ON or WASRD state, but pwr_good_pi input is de-asserted to indicate power bad.                           0: No error                                                                                                     1: Error detected" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="_RESV" width="7" begin="7" end="1" resetval="0" description="Reserved" range="" rwaccess="R ">
         
      </bitfield>
      <bitfield id="STATE" width="1" begin="0" end="0" resetval="0" description="Current Power Domain State                                                                         0: Off                                                                                                             1: On               " range="" rwaccess="R">
         
      </bitfield>
   </register>
   <register id="PDSTAT8" acronym="PDSTAT8" offset="0x220" width="32" description="Power Domain Status 8 Register">
      <bitfield id="_RESV" width="22" begin="31" end="10" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="EMUIHB" width="1" begin="9" end="9" resetval="0" description="Emulation Alters Domain State - Inhibits Off or Forces ON                              0: No emulation altering user-desired power domain state                           1: Emulation alters user-desired power state     " range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="PWRBAD" width="1" begin="8" end="8" resetval="0" description="Power Bad error. The power domain is in ON or WASRD state, but pwr_good_pi input is de-asserted to indicate power bad.                           0: No error                                                                                                     1: Error detected" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="_RESV" width="7" begin="7" end="1" resetval="0" description="Reserved" range="" rwaccess="R ">
         
      </bitfield>
      <bitfield id="STATE" width="1" begin="0" end="0" resetval="0" description="Current Power Domain State                                                                         0: Off                                                                                                             1: On               " range="" rwaccess="R">
         
      </bitfield>
   </register>
   <register id="PDSTAT9" acronym="PDSTAT9" offset="0x224" width="32" description="Power Domain Status 9 Register">
      <bitfield id="_RESV" width="22" begin="31" end="10" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="EMUIHB" width="1" begin="9" end="9" resetval="0" description="Emulation Alters Domain State - Inhibits Off or Forces ON                              0: No emulation altering user-desired power domain state                           1: Emulation alters user-desired power state     " range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="PWRBAD" width="1" begin="8" end="8" resetval="0" description="Power Bad error. The power domain is in ON or WASRD state, but pwr_good_pi input is de-asserted to indicate power bad.                           0: No error                                                                                                     1: Error detected" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="_RESV" width="7" begin="7" end="1" resetval="0" description="Reserved" range="" rwaccess="R ">
         
      </bitfield>
      <bitfield id="STATE" width="1" begin="0" end="0" resetval="0" description="Current Power Domain State                                                                         0: Off                                                                                                             1: On               " range="" rwaccess="R">
         
      </bitfield>
   </register>
   <register id="PDSTAT10" acronym="PDSTAT10" offset="0x228" width="32" description="Power Domain Status 10 Register">
      <bitfield id="_RESV" width="22" begin="31" end="10" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="EMUIHB" width="1" begin="9" end="9" resetval="0" description="Emulation Alters Domain State - Inhibits Off or Forces ON                              0: No emulation altering user-desired power domain state                           1: Emulation alters user-desired power state     " range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="PWRBAD" width="1" begin="8" end="8" resetval="0" description="Power Bad error. The power domain is in ON or WASRD state, but pwr_good_pi input is de-asserted to indicate power bad.                           0: No error                                                                                                     1: Error detected" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="_RESV" width="7" begin="7" end="1" resetval="0" description="Reserved" range="" rwaccess="R ">
         
      </bitfield>
      <bitfield id="STATE" width="1" begin="0" end="0" resetval="0" description="Current Power Domain State                                                                         0: Off                                                                                                             1: On               " range="" rwaccess="R">
         
      </bitfield>
   </register>
   <register id="PDSTAT11" acronym="PDSTAT11" offset="0x22C" width="32" description="Power Domain Status 11 Register">
      <bitfield id="_RESV" width="22" begin="31" end="10" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="EMUIHB" width="1" begin="9" end="9" resetval="0" description="Emulation Alters Domain State - Inhibits Off or Forces ON                              0: No emulation altering user-desired power domain state                           1: Emulation alters user-desired power state     " range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="PWRBAD" width="1" begin="8" end="8" resetval="0" description="Power Bad error. The power domain is in ON or WASRD state, but pwr_good_pi input is de-asserted to indicate power bad.                           0: No error                                                                                                     1: Error detected" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="_RESV" width="7" begin="7" end="1" resetval="0" description="Reserved" range="" rwaccess="R ">
         
      </bitfield>
      <bitfield id="STATE" width="1" begin="0" end="0" resetval="0" description="Current Power Domain State                                                                         0: Off                                                                                                             1: On               " range="" rwaccess="R">
         
      </bitfield>
   </register>
   <register id="PDSTAT12" acronym="PDSTAT12" offset="0x230" width="32" description="Power Domain Status 12 Register">
      <bitfield id="_RESV" width="22" begin="31" end="10" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="EMUIHB" width="1" begin="9" end="9" resetval="0" description="Emulation Alters Domain State - Inhibits Off or Forces ON                              0: No emulation altering user-desired power domain state                           1: Emulation alters user-desired power state     " range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="PWRBAD" width="1" begin="8" end="8" resetval="0" description="Power Bad error. The power domain is in ON or WASRD state, but pwr_good_pi input is de-asserted to indicate power bad.                           0: No error                                                                                                     1: Error detected" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="_RESV" width="7" begin="7" end="1" resetval="0" description="Reserved" range="" rwaccess="R ">
         
      </bitfield>
      <bitfield id="STATE" width="1" begin="0" end="0" resetval="0" description="Current Power Domain State                                                                         0: Off                                                                                                             1: On               " range="" rwaccess="R">
         
      </bitfield>
   </register>
   <register id="PDSTAT13" acronym="PDSTAT13" offset="0x234" width="32" description="Power Domain Status 13 Register">
      <bitfield id="_RESV" width="22" begin="31" end="10" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="EMUIHB" width="1" begin="9" end="9" resetval="0" description="Emulation Alters Domain State - Inhibits Off or Forces ON                              0: No emulation altering user-desired power domain state                           1: Emulation alters user-desired power state     " range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="PWRBAD" width="1" begin="8" end="8" resetval="0" description="Power Bad error. The power domain is in ON or WASRD state, but pwr_good_pi input is de-asserted to indicate power bad.                           0: No error                                                                                                     1: Error detected" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="_RESV" width="7" begin="7" end="1" resetval="0" description="Reserved" range="" rwaccess="R ">
         
      </bitfield>
      <bitfield id="STATE" width="1" begin="0" end="0" resetval="0" description="Current Power Domain State                                                                         0: Off                                                                                                             1: On               " range="" rwaccess="R">
         
      </bitfield>
   </register>
   <register id="PDSTAT14" acronym="PDSTAT14" offset="0x238" width="32" description="Power Domain Status 14 Register">
      <bitfield id="_RESV" width="22" begin="31" end="10" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="EMUIHB" width="1" begin="9" end="9" resetval="0" description="Emulation Alters Domain State - Inhibits Off or Forces ON                              0: No emulation altering user-desired power domain state                           1: Emulation alters user-desired power state     " range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="PWRBAD" width="1" begin="8" end="8" resetval="0" description="Power Bad error. The power domain is in ON or WASRD state, but pwr_good_pi input is de-asserted to indicate power bad.                           0: No error                                                                                                     1: Error detected" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="_RESV" width="7" begin="7" end="1" resetval="0" description="Reserved" range="" rwaccess="R ">
         
      </bitfield>
      <bitfield id="STATE" width="1" begin="0" end="0" resetval="0" description="Current Power Domain State                                                                         0: Off                                                                                                             1: On               " range="" rwaccess="R">
         
      </bitfield>
   </register>
   <register id="PDSTAT15" acronym="PDSTAT15" offset="0x23C" width="32" description="Power Domain Status 15 Register">
      <bitfield id="_RESV" width="22" begin="31" end="10" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="EMUIHB" width="1" begin="9" end="9" resetval="0" description="Emulation Alters Domain State - Inhibits Off or Forces ON                              0: No emulation altering user-desired power domain state                           1: Emulation alters user-desired power state     " range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="PWRBAD" width="1" begin="8" end="8" resetval="0" description="Power Bad error. The power domain is in ON or WASRD state, but pwr_good_pi input is de-asserted to indicate power bad.                           0: No error                                                                                                     1: Error detected" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="_RESV" width="7" begin="7" end="1" resetval="0" description="Reserved" range="" rwaccess="R ">
         
      </bitfield>
      <bitfield id="STATE" width="1" begin="0" end="0" resetval="0" description="Current Power Domain State                                                                         0: Off                                                                                                             1: On               " range="" rwaccess="R">
         
      </bitfield>
   </register>
   <register id="PDSTAT16" acronym="PDSTAT16" offset="0x240" width="32" description="Power Domain Status 16 Register">
      <bitfield id="_RESV" width="22" begin="31" end="10" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="EMUIHB" width="1" begin="9" end="9" resetval="0" description="Emulation Alters Domain State - Inhibits Off or Forces ON                              0: No emulation altering user-desired power domain state                           1: Emulation alters user-desired power state     " range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="PWRBAD" width="1" begin="8" end="8" resetval="0" description="Power Bad error. The power domain is in ON or WASRD state, but pwr_good_pi input is de-asserted to indicate power bad.                           0: No error                                                                                                     1: Error detected" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="_RESV" width="7" begin="7" end="1" resetval="0" description="Reserved" range="" rwaccess="R ">
         
      </bitfield>
      <bitfield id="STATE" width="1" begin="0" end="0" resetval="0" description="Current Power Domain State                                                                         0: Off                                                                                                             1: On               " range="" rwaccess="R">
         
      </bitfield>
   </register>
   <register id="PDSTAT17" acronym="PDSTAT17" offset="0x244" width="32" description="Power Domain Status 17 Register">
      <bitfield id="_RESV" width="22" begin="31" end="10" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="EMUIHB" width="1" begin="9" end="9" resetval="0" description="Emulation Alters Domain State - Inhibits Off or Forces ON                              0: No emulation altering user-desired power domain state                           1: Emulation alters user-desired power state     " range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="PWRBAD" width="1" begin="8" end="8" resetval="0" description="Power Bad error. The power domain is in ON or WASRD state, but pwr_good_pi input is de-asserted to indicate power bad.                           0: No error                                                                                                     1: Error detected" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="_RESV" width="7" begin="7" end="1" resetval="0" description="Reserved" range="" rwaccess="R ">
         
      </bitfield>
      <bitfield id="STATE" width="1" begin="0" end="0" resetval="0" description="Current Power Domain State                                                                         0: Off                                                                                                             1: On               " range="" rwaccess="R">
         
      </bitfield>
   </register>
   <register id="PDSTAT18" acronym="PDSTAT18" offset="0x248" width="32" description="Power Domain Status 18 Register">
      <bitfield id="_RESV" width="22" begin="31" end="10" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="EMUIHB" width="1" begin="9" end="9" resetval="0" description="Emulation Alters Domain State - Inhibits Off or Forces ON                              0: No emulation altering user-desired power domain state                           1: Emulation alters user-desired power state     " range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="PWRBAD" width="1" begin="8" end="8" resetval="0" description="Power Bad error. The power domain is in ON or WASRD state, but pwr_good_pi input is de-asserted to indicate power bad.                           0: No error                                                                                                     1: Error detected" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="_RESV" width="7" begin="7" end="1" resetval="0" description="Reserved" range="" rwaccess="R ">
         
      </bitfield>
      <bitfield id="STATE" width="1" begin="0" end="0" resetval="0" description="Current Power Domain State                                                                         0: Off                                                                                                             1: On               " range="" rwaccess="R">
         
      </bitfield>
   </register>
   <register id="PDSTAT19" acronym="PDSTAT19" offset="0x24C" width="32" description="Power Domain Status 19 Register">
      <bitfield id="_RESV" width="22" begin="31" end="10" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="EMUIHB" width="1" begin="9" end="9" resetval="0" description="Emulation Alters Domain State - Inhibits Off or Forces ON                              0: No emulation altering user-desired power domain state                           1: Emulation alters user-desired power state     " range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="PWRBAD" width="1" begin="8" end="8" resetval="0" description="Power Bad error. The power domain is in ON or WASRD state, but pwr_good_pi input is de-asserted to indicate power bad.                           0: No error                                                                                                     1: Error detected" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="_RESV" width="7" begin="7" end="1" resetval="0" description="Reserved" range="" rwaccess="R ">
         
      </bitfield>
      <bitfield id="STATE" width="1" begin="0" end="0" resetval="0" description="Current Power Domain State                                                                         0: Off                                                                                                             1: On               " range="" rwaccess="R">
         
      </bitfield>
   </register>
   <register id="PDSTAT20" acronym="PDSTAT20" offset="0x250" width="32" description="Power Domain Status 20 Register">
      <bitfield id="_RESV" width="22" begin="31" end="10" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="EMUIHB" width="1" begin="9" end="9" resetval="0" description="Emulation Alters Domain State - Inhibits Off or Forces ON                              0: No emulation altering user-desired power domain state                           1: Emulation alters user-desired power state     " range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="PWRBAD" width="1" begin="8" end="8" resetval="0" description="Power Bad error. The power domain is in ON or WASRD state, but pwr_good_pi input is de-asserted to indicate power bad.                           0: No error                                                                                                     1: Error detected" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="_RESV" width="7" begin="7" end="1" resetval="0" description="Reserved" range="" rwaccess="R ">
         
      </bitfield>
      <bitfield id="STATE" width="1" begin="0" end="0" resetval="0" description="Current Power Domain State                                                                         0: Off                                                                                                             1: On               " range="" rwaccess="R">
         
      </bitfield>
   </register>
   <register id="PDSTAT21" acronym="PDSTAT21" offset="0x254" width="32" description="Power Domain Status 21 Register">
      <bitfield id="_RESV" width="22" begin="31" end="10" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="EMUIHB" width="1" begin="9" end="9" resetval="0" description="Emulation Alters Domain State - Inhibits Off or Forces ON                              0: No emulation altering user-desired power domain state                           1: Emulation alters user-desired power state     " range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="PWRBAD" width="1" begin="8" end="8" resetval="0" description="Power Bad error. The power domain is in ON or WASRD state, but pwr_good_pi input is de-asserted to indicate power bad.                           0: No error                                                                                                     1: Error detected" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="_RESV" width="7" begin="7" end="1" resetval="0" description="Reserved" range="" rwaccess="R ">
         
      </bitfield>
      <bitfield id="STATE" width="1" begin="0" end="0" resetval="0" description="Current Power Domain State                                                                         0: Off                                                                                                             1: On               " range="" rwaccess="R">
         
      </bitfield>
   </register>
   <register id="PDSTAT22" acronym="PDSTAT22" offset="0x258" width="32" description="Power Domain Status 22 Register">
      <bitfield id="_RESV" width="22" begin="31" end="10" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="EMUIHB" width="1" begin="9" end="9" resetval="0" description="Emulation Alters Domain State - Inhibits Off or Forces ON                              0: No emulation altering user-desired power domain state                           1: Emulation alters user-desired power state     " range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="PWRBAD" width="1" begin="8" end="8" resetval="0" description="Power Bad error. The power domain is in ON or WASRD state, but pwr_good_pi input is de-asserted to indicate power bad.                           0: No error                                                                                                     1: Error detected" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="_RESV" width="7" begin="7" end="1" resetval="0" description="Reserved" range="" rwaccess="R ">
         
      </bitfield>
      <bitfield id="STATE" width="1" begin="0" end="0" resetval="0" description="Current Power Domain State                                                                         0: Off                                                                                                             1: On               " range="" rwaccess="R">
         
      </bitfield>
   </register>
   <register id="PDSTAT23" acronym="PDSTAT23" offset="0x25C" width="32" description="Power Domain Status 23 Register">
      <bitfield id="_RESV" width="22" begin="31" end="10" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="EMUIHB" width="1" begin="9" end="9" resetval="0" description="Emulation Alters Domain State - Inhibits Off or Forces ON                              0: No emulation altering user-desired power domain state                           1: Emulation alters user-desired power state     " range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="PWRBAD" width="1" begin="8" end="8" resetval="0" description="Power Bad error. The power domain is in ON or WASRD state, but pwr_good_pi input is de-asserted to indicate power bad.                           0: No error                                                                                                     1: Error detected" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="_RESV" width="7" begin="7" end="1" resetval="0" description="Reserved" range="" rwaccess="R ">
         
      </bitfield>
      <bitfield id="STATE" width="1" begin="0" end="0" resetval="0" description="Current Power Domain State                                                                         0: Off                                                                                                             1: On               " range="" rwaccess="R">
         
      </bitfield>
   </register>
   <register id="PDSTAT24" acronym="PDSTAT24" offset="0x260" width="32" description="Power Domain Status 24 Register">
      <bitfield id="_RESV" width="22" begin="31" end="10" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="EMUIHB" width="1" begin="9" end="9" resetval="0" description="Emulation Alters Domain State - Inhibits Off or Forces ON                              0: No emulation altering user-desired power domain state                           1: Emulation alters user-desired power state     " range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="PWRBAD" width="1" begin="8" end="8" resetval="0" description="Power Bad error. The power domain is in ON or WASRD state, but pwr_good_pi input is de-asserted to indicate power bad.                           0: No error                                                                                                     1: Error detected" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="_RESV" width="7" begin="7" end="1" resetval="0" description="Reserved" range="" rwaccess="R ">
         
      </bitfield>
      <bitfield id="STATE" width="1" begin="0" end="0" resetval="0" description="Current Power Domain State                                                                         0: Off                                                                                                             1: On               " range="" rwaccess="R">
         
      </bitfield>
   </register>
   <register id="PDSTAT25" acronym="PDSTAT25" offset="0x264" width="32" description="Power Domain Status 25 Register">
      <bitfield id="_RESV" width="22" begin="31" end="10" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="EMUIHB" width="1" begin="9" end="9" resetval="0" description="Emulation Alters Domain State - Inhibits Off or Forces ON                              0: No emulation altering user-desired power domain state                           1: Emulation alters user-desired power state     " range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="PWRBAD" width="1" begin="8" end="8" resetval="0" description="Power Bad error. The power domain is in ON or WASRD state, but pwr_good_pi input is de-asserted to indicate power bad.                           0: No error                                                                                                     1: Error detected" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="_RESV" width="7" begin="7" end="1" resetval="0" description="Reserved" range="" rwaccess="R ">
         
      </bitfield>
      <bitfield id="STATE" width="1" begin="0" end="0" resetval="0" description="Current Power Domain State                                                                         0: Off                                                                                                             1: On               " range="" rwaccess="R">
         
      </bitfield>
   </register>
   <register id="PDSTAT26" acronym="PDSTAT26" offset="0x268" width="32" description="Power Domain Status 26 Register">
      <bitfield id="_RESV" width="22" begin="31" end="10" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="EMUIHB" width="1" begin="9" end="9" resetval="0" description="Emulation Alters Domain State - Inhibits Off or Forces ON                              0: No emulation altering user-desired power domain state                           1: Emulation alters user-desired power state     " range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="PWRBAD" width="1" begin="8" end="8" resetval="0" description="Power Bad error. The power domain is in ON or WASRD state, but pwr_good_pi input is de-asserted to indicate power bad.                           0: No error                                                                                                     1: Error detected" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="_RESV" width="7" begin="7" end="1" resetval="0" description="Reserved" range="" rwaccess="R ">
         
      </bitfield>
      <bitfield id="STATE" width="1" begin="0" end="0" resetval="0" description="Current Power Domain State                                                                         0: Off                                                                                                             1: On               " range="" rwaccess="R">
         
      </bitfield>
   </register>
   <register id="PDSTAT27" acronym="PDSTAT27" offset="0x26C" width="32" description="Power Domain Status 27 Register">
      <bitfield id="_RESV" width="22" begin="31" end="10" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="EMUIHB" width="1" begin="9" end="9" resetval="0" description="Emulation Alters Domain State - Inhibits Off or Forces ON                              0: No emulation altering user-desired power domain state                           1: Emulation alters user-desired power state     " range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="PWRBAD" width="1" begin="8" end="8" resetval="0" description="Power Bad error. The power domain is in ON or WASRD state, but pwr_good_pi input is de-asserted to indicate power bad.                           0: No error                                                                                                     1: Error detected" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="_RESV" width="7" begin="7" end="1" resetval="0" description="Reserved" range="" rwaccess="R ">
         
      </bitfield>
      <bitfield id="STATE" width="1" begin="0" end="0" resetval="0" description="Current Power Domain State                                                                         0: Off                                                                                                             1: On               " range="" rwaccess="R">
         
      </bitfield>
   </register>
   <register id="PDSTAT28" acronym="PDSTAT28" offset="0x270" width="32" description="Power Domain Status 28 Register">
      <bitfield id="_RESV" width="22" begin="31" end="10" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="EMUIHB" width="1" begin="9" end="9" resetval="0" description="Emulation Alters Domain State - Inhibits Off or Forces ON                              0: No emulation altering user-desired power domain state                           1: Emulation alters user-desired power state     " range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="PWRBAD" width="1" begin="8" end="8" resetval="0" description="Power Bad error. The power domain is in ON or WASRD state, but pwr_good_pi input is de-asserted to indicate power bad.                           0: No error                                                                                                     1: Error detected" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="_RESV" width="7" begin="7" end="1" resetval="0" description="Reserved" range="" rwaccess="R ">
         
      </bitfield>
      <bitfield id="STATE" width="1" begin="0" end="0" resetval="0" description="Current Power Domain State                                                                         0: Off                                                                                                             1: On               " range="" rwaccess="R">
         
      </bitfield>
   </register>
   <register id="PDSTAT29" acronym="PDSTAT29" offset="0x274" width="32" description="Power Domain Status 29 Register">
      <bitfield id="_RESV" width="22" begin="31" end="10" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="EMUIHB" width="1" begin="9" end="9" resetval="0" description="Emulation Alters Domain State - Inhibits Off or Forces ON                              0: No emulation altering user-desired power domain state                           1: Emulation alters user-desired power state     " range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="PWRBAD" width="1" begin="8" end="8" resetval="0" description="Power Bad error. The power domain is in ON or WASRD state, but pwr_good_pi input is de-asserted to indicate power bad.                           0: No error                                                                                                     1: Error detected" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="_RESV" width="7" begin="7" end="1" resetval="0" description="Reserved" range="" rwaccess="R ">
         
      </bitfield>
      <bitfield id="STATE" width="1" begin="0" end="0" resetval="0" description="Current Power Domain State                                                                         0: Off                                                                                                             1: On               " range="" rwaccess="R">
         
      </bitfield>
   </register>
   <register id="PDSTAT30" acronym="PDSTAT30" offset="0x278" width="32" description="Power Domain Status 30 Register">
      <bitfield id="_RESV" width="22" begin="31" end="10" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="EMUIHB" width="1" begin="9" end="9" resetval="0" description="Emulation Alters Domain State - Inhibits Off or Forces ON                              0: No emulation altering user-desired power domain state                           1: Emulation alters user-desired power state     " range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="PWRBAD" width="1" begin="8" end="8" resetval="0" description="Power Bad error. The power domain is in ON or WASRD state, but pwr_good_pi input is de-asserted to indicate power bad.                           0: No error                                                                                                     1: Error detected" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="_RESV" width="7" begin="7" end="1" resetval="0" description="Reserved" range="" rwaccess="R ">
         
      </bitfield>
      <bitfield id="STATE" width="1" begin="0" end="0" resetval="0" description="Current Power Domain State                                                                         0: Off                                                                                                             1: On               " range="" rwaccess="R">
         
      </bitfield>
   </register>
   <register id="PDSTAT31" acronym="PDSTAT31" offset="0x27C" width="32" description="Power Domain Status 31 Register">
      <bitfield id="_RESV" width="22" begin="31" end="10" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="EMUIHB" width="1" begin="9" end="9" resetval="0" description="Emulation Alters Domain State - Inhibits Off or Forces ON                              0: No emulation altering user-desired power domain state                           1: Emulation alters user-desired power state     " range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="PWRBAD" width="1" begin="8" end="8" resetval="0" description="Power Bad error. The power domain is in ON or WASRD state, but pwr_good_pi input is de-asserted to indicate power bad.                           0: No error                                                                                                     1: Error detected" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="_RESV" width="7" begin="7" end="1" resetval="0" description="Reserved" range="" rwaccess="R ">
         
      </bitfield>
      <bitfield id="STATE" width="1" begin="0" end="0" resetval="0" description="Current Power Domain State                                                                         0: Off                                                                                                             1: On               " range="" rwaccess="R">
         
      </bitfield>
   </register>
   <register id="PDCTL0" acronym="PDCTL0" offset="0x300" width="32" description="Power Domain Control 0 Register">
      <bitfield id="_RESV" width="22" begin="31" end="10" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="EMUIHBIE" width="1" begin="9" end="9" resetval="0" description="Emulation alters domain state (Inhibits domain Off or Forces Domain On) Interrupt Enable                                                                                             0: Not enabled                                                                                               1: Enabled " range="" rwaccess="R/W">
         
      </bitfield>
      <bitfield id="EPCGOOD" width="1" begin="8" end="8" resetval="0" description="External Power Control Power Good Indication.                                           0: External Power Control has turned off power to this domain                     1: External Power Control has turned on power to this domain and the power has reached a desired threshold." range="" rwaccess="R/W">
         
      </bitfield>
      <bitfield id="_RESV" width="7" begin="7" end="1" resetval="0" description="Reserved" range="" rwaccess="R ">
         
      </bitfield>
      <bitfield id="NEXT" width="1" begin="0" end="0" resetval="0" description="User-Desired Next Power Domain State                                                                         0: Off                                                                                                             1: On               " range="" rwaccess="R/W">
         
      </bitfield>
   </register>
   <register id="PDCTL1" acronym="PDCTL1" offset="0x304" width="32" description="Power Domain Control 1 Register">
      <bitfield id="_RESV" width="22" begin="31" end="10" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="EMUIHBIE" width="1" begin="9" end="9" resetval="0" description="Emulation alters domain state (Inhibits domain Off or Forces Domain On) Interrupt Enable                                                                                             0: Not enabled                                                                                               1: Enabled " range="" rwaccess="R/W">
         
      </bitfield>
      <bitfield id="EPCGOOD" width="1" begin="8" end="8" resetval="0" description="External Power Control Power Good Indication.                                           0: External Power Control has turned off power to this domain                     1: External Power Control has turned on power to this domain and the power has reached a desired threshold." range="" rwaccess="R/W">
         
      </bitfield>
      <bitfield id="_RESV" width="7" begin="7" end="1" resetval="0" description="Reserved" range="" rwaccess="R ">
         
      </bitfield>
      <bitfield id="NEXT" width="1" begin="0" end="0" resetval="0" description="User-Desired Next Power Domain State                                                                         0: Off                                                                                                             1: On               " range="" rwaccess="R/W">
         
      </bitfield>
   </register>
   <register id="PDCTL2" acronym="PDCTL2" offset="0x308" width="32" description="Power Domain Control 2 Register">
      <bitfield id="_RESV" width="22" begin="31" end="10" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="EMUIHBIE" width="1" begin="9" end="9" resetval="0" description="Emulation alters domain state (Inhibits domain Off or Forces Domain On) Interrupt Enable                                                                                             0: Not enabled                                                                                               1: Enabled " range="" rwaccess="R/W">
         
      </bitfield>
      <bitfield id="EPCGOOD" width="1" begin="8" end="8" resetval="0" description="External Power Control Power Good Indication.                                           0: External Power Control has turned off power to this domain                     1: External Power Control has turned on power to this domain and the power has reached a desired threshold." range="" rwaccess="R/W">
         
      </bitfield>
      <bitfield id="_RESV" width="7" begin="7" end="1" resetval="0" description="Reserved" range="" rwaccess="R ">
         
      </bitfield>
      <bitfield id="NEXT" width="1" begin="0" end="0" resetval="0" description="User-Desired Next Power Domain State                                                                         0: Off                                                                                                             1: On               " range="" rwaccess="R/W">
         
      </bitfield>
   </register>
   <register id="PDCTL3" acronym="PDCTL3" offset="0x30C" width="32" description="Power Domain Control 3 Register">
      <bitfield id="_RESV" width="22" begin="31" end="10" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="EMUIHBIE" width="1" begin="9" end="9" resetval="0" description="Emulation alters domain state (Inhibits domain Off or Forces Domain On) Interrupt Enable                                                                                             0: Not enabled                                                                                               1: Enabled " range="" rwaccess="R/W">
         
      </bitfield>
      <bitfield id="EPCGOOD" width="1" begin="8" end="8" resetval="0" description="External Power Control Power Good Indication.                                           0: External Power Control has turned off power to this domain                     1: External Power Control has turned on power to this domain and the power has reached a desired threshold." range="" rwaccess="R/W">
         
      </bitfield>
      <bitfield id="_RESV" width="7" begin="7" end="1" resetval="0" description="Reserved" range="" rwaccess="R ">
         
      </bitfield>
      <bitfield id="NEXT" width="1" begin="0" end="0" resetval="0" description="User-Desired Next Power Domain State                                                                         0: Off                                                                                                             1: On               " range="" rwaccess="R/W">
         
      </bitfield>
   </register>
   <register id="PDCTL4" acronym="PDCTL4" offset="0x310" width="32" description="Power Domain Control 4 Register">
      <bitfield id="_RESV" width="22" begin="31" end="10" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="EMUIHBIE" width="1" begin="9" end="9" resetval="0" description="Emulation alters domain state (Inhibits domain Off or Forces Domain On) Interrupt Enable                                                                                             0: Not enabled                                                                                               1: Enabled " range="" rwaccess="R/W">
         
      </bitfield>
      <bitfield id="EPCGOOD" width="1" begin="8" end="8" resetval="0" description="External Power Control Power Good Indication.                                           0: External Power Control has turned off power to this domain                     1: External Power Control has turned on power to this domain and the power has reached a desired threshold." range="" rwaccess="R/W">
         
      </bitfield>
      <bitfield id="_RESV" width="7" begin="7" end="1" resetval="0" description="Reserved" range="" rwaccess="R ">
         
      </bitfield>
      <bitfield id="NEXT" width="1" begin="0" end="0" resetval="0" description="User-Desired Next Power Domain State                                                                         0: Off                                                                                                             1: On               " range="" rwaccess="R/W">
         
      </bitfield>
   </register>
   <register id="PDCTL5" acronym="PDCTL5" offset="0x314" width="32" description="Power Domain Control 5 Register">
      <bitfield id="_RESV" width="22" begin="31" end="10" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="EMUIHBIE" width="1" begin="9" end="9" resetval="0" description="Emulation alters domain state (Inhibits domain Off or Forces Domain On) Interrupt Enable                                                                                             0: Not enabled                                                                                               1: Enabled " range="" rwaccess="R/W">
         
      </bitfield>
      <bitfield id="EPCGOOD" width="1" begin="8" end="8" resetval="0" description="External Power Control Power Good Indication.                                           0: External Power Control has turned off power to this domain                     1: External Power Control has turned on power to this domain and the power has reached a desired threshold." range="" rwaccess="R/W">
         
      </bitfield>
      <bitfield id="_RESV" width="7" begin="7" end="1" resetval="0" description="Reserved" range="" rwaccess="R ">
         
      </bitfield>
      <bitfield id="NEXT" width="1" begin="0" end="0" resetval="0" description="User-Desired Next Power Domain State                                                                         0: Off                                                                                                             1: On               " range="" rwaccess="R/W">
         
      </bitfield>
   </register>
   <register id="PDCTL6" acronym="PDCTL6" offset="0x318" width="32" description="Power Domain Control 6 Register">
      <bitfield id="_RESV" width="22" begin="31" end="10" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="EMUIHBIE" width="1" begin="9" end="9" resetval="0" description="Emulation alters domain state (Inhibits domain Off or Forces Domain On) Interrupt Enable                                                                                             0: Not enabled                                                                                               1: Enabled " range="" rwaccess="R/W">
         
      </bitfield>
      <bitfield id="EPCGOOD" width="1" begin="8" end="8" resetval="0" description="External Power Control Power Good Indication.                                           0: External Power Control has turned off power to this domain                     1: External Power Control has turned on power to this domain and the power has reached a desired threshold." range="" rwaccess="R/W">
         
      </bitfield>
      <bitfield id="_RESV" width="7" begin="7" end="1" resetval="0" description="Reserved" range="" rwaccess="R ">
         
      </bitfield>
      <bitfield id="NEXT" width="1" begin="0" end="0" resetval="0" description="User-Desired Next Power Domain State                                                                         0: Off                                                                                                             1: On               " range="" rwaccess="R/W">
         
      </bitfield>
   </register>
   <register id="PDCTL7" acronym="PDCTL7" offset="0x31C" width="32" description="Power Domain Control 7 Register">
      <bitfield id="_RESV" width="22" begin="31" end="10" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="EMUIHBIE" width="1" begin="9" end="9" resetval="0" description="Emulation alters domain state (Inhibits domain Off or Forces Domain On) Interrupt Enable                                                                                             0: Not enabled                                                                                               1: Enabled " range="" rwaccess="R/W">
         
      </bitfield>
      <bitfield id="EPCGOOD" width="1" begin="8" end="8" resetval="0" description="External Power Control Power Good Indication.                                           0: External Power Control has turned off power to this domain                     1: External Power Control has turned on power to this domain and the power has reached a desired threshold." range="" rwaccess="R/W">
         
      </bitfield>
      <bitfield id="_RESV" width="7" begin="7" end="1" resetval="0" description="Reserved" range="" rwaccess="R ">
         
      </bitfield>
      <bitfield id="NEXT" width="1" begin="0" end="0" resetval="0" description="User-Desired Next Power Domain State                                                                         0: Off                                                                                                             1: On               " range="" rwaccess="R/W">
         
      </bitfield>
   </register>
   <register id="PDCTL8" acronym="PDCTL8" offset="0x320" width="32" description="Power Domain Control 8 Register">
      <bitfield id="_RESV" width="22" begin="31" end="10" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="EMUIHBIE" width="1" begin="9" end="9" resetval="0" description="Emulation alters domain state (Inhibits domain Off or Forces Domain On) Interrupt Enable                                                                                             0: Not enabled                                                                                               1: Enabled " range="" rwaccess="R/W">
         
      </bitfield>
      <bitfield id="EPCGOOD" width="1" begin="8" end="8" resetval="0" description="External Power Control Power Good Indication.                                           0: External Power Control has turned off power to this domain                     1: External Power Control has turned on power to this domain and the power has reached a desired threshold." range="" rwaccess="R/W">
         
      </bitfield>
      <bitfield id="_RESV" width="7" begin="7" end="1" resetval="0" description="Reserved" range="" rwaccess="R ">
         
      </bitfield>
      <bitfield id="NEXT" width="1" begin="0" end="0" resetval="0" description="User-Desired Next Power Domain State                                                                         0: Off                                                                                                             1: On               " range="" rwaccess="R/W">
         
      </bitfield>
   </register>
   <register id="PDCTL9" acronym="PDCTL9" offset="0x324" width="32" description="Power Domain Control 9 Register">
      <bitfield id="_RESV" width="22" begin="31" end="10" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="EMUIHBIE" width="1" begin="9" end="9" resetval="0" description="Emulation alters domain state (Inhibits domain Off or Forces Domain On) Interrupt Enable                                                                                             0: Not enabled                                                                                               1: Enabled " range="" rwaccess="R/W">
         
      </bitfield>
      <bitfield id="EPCGOOD" width="1" begin="8" end="8" resetval="0" description="External Power Control Power Good Indication.                                           0: External Power Control has turned off power to this domain                     1: External Power Control has turned on power to this domain and the power has reached a desired threshold." range="" rwaccess="R/W">
         
      </bitfield>
      <bitfield id="_RESV" width="7" begin="7" end="1" resetval="0" description="Reserved" range="" rwaccess="R ">
         
      </bitfield>
      <bitfield id="NEXT" width="1" begin="0" end="0" resetval="0" description="User-Desired Next Power Domain State                                                                         0: Off                                                                                                             1: On               " range="" rwaccess="R/W">
         
      </bitfield>
   </register>
   <register id="PDCTL10" acronym="PDCTL10" offset="0x328" width="32" description="Power Domain Control 10 Register">
      <bitfield id="_RESV" width="22" begin="31" end="10" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="EMUIHBIE" width="1" begin="9" end="9" resetval="0" description="Emulation alters domain state (Inhibits domain Off or Forces Domain On) Interrupt Enable                                                                                             0: Not enabled                                                                                               1: Enabled " range="" rwaccess="R/W">
         
      </bitfield>
      <bitfield id="EPCGOOD" width="1" begin="8" end="8" resetval="0" description="External Power Control Power Good Indication.                                           0: External Power Control has turned off power to this domain                     1: External Power Control has turned on power to this domain and the power has reached a desired threshold." range="" rwaccess="R/W">
         
      </bitfield>
      <bitfield id="_RESV" width="7" begin="7" end="1" resetval="0" description="Reserved" range="" rwaccess="R ">
         
      </bitfield>
      <bitfield id="NEXT" width="1" begin="0" end="0" resetval="0" description="User-Desired Next Power Domain State                                                                         0: Off                                                                                                             1: On               " range="" rwaccess="R/W">
         
      </bitfield>
   </register>
   <register id="PDCTL11" acronym="PDCTL11" offset="0x32C" width="32" description="Power Domain Control 11 Register">
      <bitfield id="_RESV" width="22" begin="31" end="10" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="EMUIHBIE" width="1" begin="9" end="9" resetval="0" description="Emulation alters domain state (Inhibits domain Off or Forces Domain On) Interrupt Enable                                                                                             0: Not enabled                                                                                               1: Enabled " range="" rwaccess="R/W">
         
      </bitfield>
      <bitfield id="EPCGOOD" width="1" begin="8" end="8" resetval="0" description="External Power Control Power Good Indication.                                           0: External Power Control has turned off power to this domain                     1: External Power Control has turned on power to this domain and the power has reached a desired threshold." range="" rwaccess="R/W">
         
      </bitfield>
      <bitfield id="_RESV" width="7" begin="7" end="1" resetval="0" description="Reserved" range="" rwaccess="R ">
         
      </bitfield>
      <bitfield id="NEXT" width="1" begin="0" end="0" resetval="0" description="User-Desired Next Power Domain State                                                                         0: Off                                                                                                             1: On               " range="" rwaccess="R/W">
         
      </bitfield>
   </register>
   <register id="PDCTL12" acronym="PDCTL12" offset="0x330" width="32" description="Power Domain Control 12 Register">
      <bitfield id="_RESV" width="22" begin="31" end="10" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="EMUIHBIE" width="1" begin="9" end="9" resetval="0" description="Emulation alters domain state (Inhibits domain Off or Forces Domain On) Interrupt Enable                                                                                             0: Not enabled                                                                                               1: Enabled " range="" rwaccess="R/W">
         
      </bitfield>
      <bitfield id="EPCGOOD" width="1" begin="8" end="8" resetval="0" description="External Power Control Power Good Indication.                                           0: External Power Control has turned off power to this domain                     1: External Power Control has turned on power to this domain and the power has reached a desired threshold." range="" rwaccess="R/W">
         
      </bitfield>
      <bitfield id="_RESV" width="7" begin="7" end="1" resetval="0" description="Reserved" range="" rwaccess="R ">
         
      </bitfield>
      <bitfield id="NEXT" width="1" begin="0" end="0" resetval="0" description="User-Desired Next Power Domain State                                                                         0: Off                                                                                                             1: On               " range="" rwaccess="R/W">
         
      </bitfield>
   </register>
   <register id="PDCTL13" acronym="PDCTL13" offset="0x334" width="32" description="Power Domain Control 13 Register">
      <bitfield id="_RESV" width="22" begin="31" end="10" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="EMUIHBIE" width="1" begin="9" end="9" resetval="0" description="Emulation alters domain state (Inhibits domain Off or Forces Domain On) Interrupt Enable                                                                                             0: Not enabled                                                                                               1: Enabled " range="" rwaccess="R/W">
         
      </bitfield>
      <bitfield id="EPCGOOD" width="1" begin="8" end="8" resetval="0" description="External Power Control Power Good Indication.                                           0: External Power Control has turned off power to this domain                     1: External Power Control has turned on power to this domain and the power has reached a desired threshold." range="" rwaccess="R/W">
         
      </bitfield>
      <bitfield id="_RESV" width="7" begin="7" end="1" resetval="0" description="Reserved" range="" rwaccess="R ">
         
      </bitfield>
      <bitfield id="NEXT" width="1" begin="0" end="0" resetval="0" description="User-Desired Next Power Domain State                                                                         0: Off                                                                                                             1: On               " range="" rwaccess="R/W">
         
      </bitfield>
   </register>
   <register id="PDCTL14" acronym="PDCTL14" offset="0x338" width="32" description="Power Domain Control 14 Register">
      <bitfield id="_RESV" width="22" begin="31" end="10" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="EMUIHBIE" width="1" begin="9" end="9" resetval="0" description="Emulation alters domain state (Inhibits domain Off or Forces Domain On) Interrupt Enable                                                                                             0: Not enabled                                                                                               1: Enabled " range="" rwaccess="R/W">
         
      </bitfield>
      <bitfield id="EPCGOOD" width="1" begin="8" end="8" resetval="0" description="External Power Control Power Good Indication.                                           0: External Power Control has turned off power to this domain                     1: External Power Control has turned on power to this domain and the power has reached a desired threshold." range="" rwaccess="R/W">
         
      </bitfield>
      <bitfield id="_RESV" width="7" begin="7" end="1" resetval="0" description="Reserved" range="" rwaccess="R ">
         
      </bitfield>
      <bitfield id="NEXT" width="1" begin="0" end="0" resetval="0" description="User-Desired Next Power Domain State                                                                         0: Off                                                                                                             1: On               " range="" rwaccess="R/W">
         
      </bitfield>
   </register>
   <register id="PDCTL15" acronym="PDCTL15" offset="0x33C" width="32" description="Power Domain Control 15 Register">
      <bitfield id="_RESV" width="22" begin="31" end="10" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="EMUIHBIE" width="1" begin="9" end="9" resetval="0" description="Emulation alters domain state (Inhibits domain Off or Forces Domain On) Interrupt Enable                                                                                             0: Not enabled                                                                                               1: Enabled " range="" rwaccess="R/W">
         
      </bitfield>
      <bitfield id="EPCGOOD" width="1" begin="8" end="8" resetval="0" description="External Power Control Power Good Indication.                                           0: External Power Control has turned off power to this domain                     1: External Power Control has turned on power to this domain and the power has reached a desired threshold." range="" rwaccess="R/W">
         
      </bitfield>
      <bitfield id="_RESV" width="7" begin="7" end="1" resetval="0" description="Reserved" range="" rwaccess="R ">
         
      </bitfield>
      <bitfield id="NEXT" width="1" begin="0" end="0" resetval="0" description="User-Desired Next Power Domain State                                                                         0: Off                                                                                                             1: On               " range="" rwaccess="R/W">
         
      </bitfield>
   </register>
   <register id="PDCTL16" acronym="PDCTL16" offset="0x340" width="32" description="Power Domain Control 16 Register">
      <bitfield id="_RESV" width="22" begin="31" end="10" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="EMUIHBIE" width="1" begin="9" end="9" resetval="0" description="Emulation alters domain state (Inhibits domain Off or Forces Domain On) Interrupt Enable                                                                                             0: Not enabled                                                                                               1: Enabled " range="" rwaccess="R/W">
         
      </bitfield>
      <bitfield id="EPCGOOD" width="1" begin="8" end="8" resetval="0" description="External Power Control Power Good Indication.                                           0: External Power Control has turned off power to this domain                     1: External Power Control has turned on power to this domain and the power has reached a desired threshold." range="" rwaccess="R/W">
         
      </bitfield>
      <bitfield id="_RESV" width="7" begin="7" end="1" resetval="0" description="Reserved" range="" rwaccess="R ">
         
      </bitfield>
      <bitfield id="NEXT" width="1" begin="0" end="0" resetval="0" description="User-Desired Next Power Domain State                                                                         0: Off                                                                                                             1: On               " range="" rwaccess="R/W">
         
      </bitfield>
   </register>
   <register id="PDCTL17" acronym="PDCTL17" offset="0x344" width="32" description="Power Domain Control 17 Register">
      <bitfield id="_RESV" width="22" begin="31" end="10" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="EMUIHBIE" width="1" begin="9" end="9" resetval="0" description="Emulation alters domain state (Inhibits domain Off or Forces Domain On) Interrupt Enable                                                                                             0: Not enabled                                                                                               1: Enabled " range="" rwaccess="R/W">
         
      </bitfield>
      <bitfield id="EPCGOOD" width="1" begin="8" end="8" resetval="0" description="External Power Control Power Good Indication.                                           0: External Power Control has turned off power to this domain                     1: External Power Control has turned on power to this domain and the power has reached a desired threshold." range="" rwaccess="R/W">
         
      </bitfield>
      <bitfield id="_RESV" width="7" begin="7" end="1" resetval="0" description="Reserved" range="" rwaccess="R ">
         
      </bitfield>
      <bitfield id="NEXT" width="1" begin="0" end="0" resetval="0" description="User-Desired Next Power Domain State                                                                         0: Off                                                                                                             1: On               " range="" rwaccess="R/W">
         
      </bitfield>
   </register>
   <register id="PDCTL18" acronym="PDCTL18" offset="0x348" width="32" description="Power Domain Control 18 Register">
      <bitfield id="_RESV" width="22" begin="31" end="10" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="EMUIHBIE" width="1" begin="9" end="9" resetval="0" description="Emulation alters domain state (Inhibits domain Off or Forces Domain On) Interrupt Enable                                                                                             0: Not enabled                                                                                               1: Enabled " range="" rwaccess="R/W">
         
      </bitfield>
      <bitfield id="EPCGOOD" width="1" begin="8" end="8" resetval="0" description="External Power Control Power Good Indication.                                           0: External Power Control has turned off power to this domain                     1: External Power Control has turned on power to this domain and the power has reached a desired threshold." range="" rwaccess="R/W">
         
      </bitfield>
      <bitfield id="_RESV" width="7" begin="7" end="1" resetval="0" description="Reserved" range="" rwaccess="R ">
         
      </bitfield>
      <bitfield id="NEXT" width="1" begin="0" end="0" resetval="0" description="User-Desired Next Power Domain State                                                                         0: Off                                                                                                             1: On               " range="" rwaccess="R/W">
         
      </bitfield>
   </register>
   <register id="PDCTL19" acronym="PDCTL19" offset="0x34C" width="32" description="Power Domain Control 19 Register">
      <bitfield id="_RESV" width="22" begin="31" end="10" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="EMUIHBIE" width="1" begin="9" end="9" resetval="0" description="Emulation alters domain state (Inhibits domain Off or Forces Domain On) Interrupt Enable                                                                                             0: Not enabled                                                                                               1: Enabled " range="" rwaccess="R/W">
         
      </bitfield>
      <bitfield id="EPCGOOD" width="1" begin="8" end="8" resetval="0" description="External Power Control Power Good Indication.                                           0: External Power Control has turned off power to this domain                     1: External Power Control has turned on power to this domain and the power has reached a desired threshold." range="" rwaccess="R/W">
         
      </bitfield>
      <bitfield id="_RESV" width="7" begin="7" end="1" resetval="0" description="Reserved" range="" rwaccess="R ">
         
      </bitfield>
      <bitfield id="NEXT" width="1" begin="0" end="0" resetval="0" description="User-Desired Next Power Domain State                                                                         0: Off                                                                                                             1: On               " range="" rwaccess="R/W">
         
      </bitfield>
   </register>
   <register id="PDCTL20" acronym="PDCTL20" offset="0x350" width="32" description="Power Domain Control 20 Register">
      <bitfield id="_RESV" width="22" begin="31" end="10" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="EMUIHBIE" width="1" begin="9" end="9" resetval="0" description="Emulation alters domain state (Inhibits domain Off or Forces Domain On) Interrupt Enable                                                                                             0: Not enabled                                                                                               1: Enabled " range="" rwaccess="R/W">
         
      </bitfield>
      <bitfield id="EPCGOOD" width="1" begin="8" end="8" resetval="0" description="External Power Control Power Good Indication.                                           0: External Power Control has turned off power to this domain                     1: External Power Control has turned on power to this domain and the power has reached a desired threshold." range="" rwaccess="R/W">
         
      </bitfield>
      <bitfield id="_RESV" width="7" begin="7" end="1" resetval="0" description="Reserved" range="" rwaccess="R ">
         
      </bitfield>
      <bitfield id="NEXT" width="1" begin="0" end="0" resetval="0" description="User-Desired Next Power Domain State                                                                         0: Off                                                                                                             1: On               " range="" rwaccess="R/W">
         
      </bitfield>
   </register>
   <register id="PDCTL21" acronym="PDCTL21" offset="0x354" width="32" description="Power Domain Control 21 Register">
      <bitfield id="_RESV" width="22" begin="31" end="10" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="EMUIHBIE" width="1" begin="9" end="9" resetval="0" description="Emulation alters domain state (Inhibits domain Off or Forces Domain On) Interrupt Enable                                                                                             0: Not enabled                                                                                               1: Enabled " range="" rwaccess="R/W">
         
      </bitfield>
      <bitfield id="EPCGOOD" width="1" begin="8" end="8" resetval="0" description="External Power Control Power Good Indication.                                           0: External Power Control has turned off power to this domain                     1: External Power Control has turned on power to this domain and the power has reached a desired threshold." range="" rwaccess="R/W">
         
      </bitfield>
      <bitfield id="_RESV" width="7" begin="7" end="1" resetval="0" description="Reserved" range="" rwaccess="R ">
         
      </bitfield>
      <bitfield id="NEXT" width="1" begin="0" end="0" resetval="0" description="User-Desired Next Power Domain State                                                                         0: Off                                                                                                             1: On               " range="" rwaccess="R/W">
         
      </bitfield>
   </register>
   <register id="PDCTL22" acronym="PDCTL22" offset="0x358" width="32" description="Power Domain Control 22 Register">
      <bitfield id="_RESV" width="22" begin="31" end="10" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="EMUIHBIE" width="1" begin="9" end="9" resetval="0" description="Emulation alters domain state (Inhibits domain Off or Forces Domain On) Interrupt Enable                                                                                             0: Not enabled                                                                                               1: Enabled " range="" rwaccess="R/W">
         
      </bitfield>
      <bitfield id="EPCGOOD" width="1" begin="8" end="8" resetval="0" description="External Power Control Power Good Indication.                                           0: External Power Control has turned off power to this domain                     1: External Power Control has turned on power to this domain and the power has reached a desired threshold." range="" rwaccess="R/W">
         
      </bitfield>
      <bitfield id="_RESV" width="7" begin="7" end="1" resetval="0" description="Reserved" range="" rwaccess="R ">
         
      </bitfield>
      <bitfield id="NEXT" width="1" begin="0" end="0" resetval="0" description="User-Desired Next Power Domain State                                                                         0: Off                                                                                                             1: On               " range="" rwaccess="R/W">
         
      </bitfield>
   </register>
   <register id="PDCTL23" acronym="PDCTL23" offset="0x35C" width="32" description="Power Domain Control 23 Register">
      <bitfield id="_RESV" width="22" begin="31" end="10" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="EMUIHBIE" width="1" begin="9" end="9" resetval="0" description="Emulation alters domain state (Inhibits domain Off or Forces Domain On) Interrupt Enable                                                                                             0: Not enabled                                                                                               1: Enabled " range="" rwaccess="R/W">
         
      </bitfield>
      <bitfield id="EPCGOOD" width="1" begin="8" end="8" resetval="0" description="External Power Control Power Good Indication.                                           0: External Power Control has turned off power to this domain                     1: External Power Control has turned on power to this domain and the power has reached a desired threshold." range="" rwaccess="R/W">
         
      </bitfield>
      <bitfield id="_RESV" width="7" begin="7" end="1" resetval="0" description="Reserved" range="" rwaccess="R ">
         
      </bitfield>
      <bitfield id="NEXT" width="1" begin="0" end="0" resetval="0" description="User-Desired Next Power Domain State                                                                         0: Off                                                                                                             1: On               " range="" rwaccess="R/W">
         
      </bitfield>
   </register>
   <register id="PDCTL24" acronym="PDCTL24" offset="0x360" width="32" description="Power Domain Control 24 Register">
      <bitfield id="_RESV" width="22" begin="31" end="10" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="EMUIHBIE" width="1" begin="9" end="9" resetval="0" description="Emulation alters domain state (Inhibits domain Off or Forces Domain On) Interrupt Enable                                                                                             0: Not enabled                                                                                               1: Enabled " range="" rwaccess="R/W">
         
      </bitfield>
      <bitfield id="EPCGOOD" width="1" begin="8" end="8" resetval="0" description="External Power Control Power Good Indication.                                           0: External Power Control has turned off power to this domain                     1: External Power Control has turned on power to this domain and the power has reached a desired threshold." range="" rwaccess="R/W">
         
      </bitfield>
      <bitfield id="_RESV" width="7" begin="7" end="1" resetval="0" description="Reserved" range="" rwaccess="R ">
         
      </bitfield>
      <bitfield id="NEXT" width="1" begin="0" end="0" resetval="0" description="User-Desired Next Power Domain State                                                                         0: Off                                                                                                             1: On               " range="" rwaccess="R/W">
         
      </bitfield>
   </register>
   <register id="PDCTL25" acronym="PDCTL25" offset="0x364" width="32" description="Power Domain Control 25 Register">
      <bitfield id="_RESV" width="22" begin="31" end="10" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="EMUIHBIE" width="1" begin="9" end="9" resetval="0" description="Emulation alters domain state (Inhibits domain Off or Forces Domain On) Interrupt Enable                                                                                             0: Not enabled                                                                                               1: Enabled " range="" rwaccess="R/W">
         
      </bitfield>
      <bitfield id="EPCGOOD" width="1" begin="8" end="8" resetval="0" description="External Power Control Power Good Indication.                                           0: External Power Control has turned off power to this domain                     1: External Power Control has turned on power to this domain and the power has reached a desired threshold." range="" rwaccess="R/W">
         
      </bitfield>
      <bitfield id="_RESV" width="7" begin="7" end="1" resetval="0" description="Reserved" range="" rwaccess="R ">
         
      </bitfield>
      <bitfield id="NEXT" width="1" begin="0" end="0" resetval="0" description="User-Desired Next Power Domain State                                                                         0: Off                                                                                                             1: On               " range="" rwaccess="R/W">
         
      </bitfield>
   </register>
   <register id="PDCTL26" acronym="PDCTL26" offset="0x368" width="32" description="Power Domain Control 26 Register">
      <bitfield id="_RESV" width="22" begin="31" end="10" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="EMUIHBIE" width="1" begin="9" end="9" resetval="0" description="Emulation alters domain state (Inhibits domain Off or Forces Domain On) Interrupt Enable                                                                                             0: Not enabled                                                                                               1: Enabled " range="" rwaccess="R/W">
         
      </bitfield>
      <bitfield id="EPCGOOD" width="1" begin="8" end="8" resetval="0" description="External Power Control Power Good Indication.                                           0: External Power Control has turned off power to this domain                     1: External Power Control has turned on power to this domain and the power has reached a desired threshold." range="" rwaccess="R/W">
         
      </bitfield>
      <bitfield id="_RESV" width="7" begin="7" end="1" resetval="0" description="Reserved" range="" rwaccess="R ">
         
      </bitfield>
      <bitfield id="NEXT" width="1" begin="0" end="0" resetval="0" description="User-Desired Next Power Domain State                                                                         0: Off                                                                                                             1: On               " range="" rwaccess="R/W">
         
      </bitfield>
   </register>
   <register id="PDCTL27" acronym="PDCTL27" offset="0x36C" width="32" description="Power Domain Control 27 Register">
      <bitfield id="_RESV" width="22" begin="31" end="10" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="EMUIHBIE" width="1" begin="9" end="9" resetval="0" description="Emulation alters domain state (Inhibits domain Off or Forces Domain On) Interrupt Enable                                                                                             0: Not enabled                                                                                               1: Enabled " range="" rwaccess="R/W">
         
      </bitfield>
      <bitfield id="EPCGOOD" width="1" begin="8" end="8" resetval="0" description="External Power Control Power Good Indication.                                           0: External Power Control has turned off power to this domain                     1: External Power Control has turned on power to this domain and the power has reached a desired threshold." range="" rwaccess="R/W">
         
      </bitfield>
      <bitfield id="_RESV" width="7" begin="7" end="1" resetval="0" description="Reserved" range="" rwaccess="R ">
         
      </bitfield>
      <bitfield id="NEXT" width="1" begin="0" end="0" resetval="0" description="User-Desired Next Power Domain State                                                                         0: Off                                                                                                             1: On               " range="" rwaccess="R/W">
         
      </bitfield>
   </register>
   <register id="PDCTL28" acronym="PDCTL28" offset="0x370" width="32" description="Power Domain Control 28 Register">
      <bitfield id="_RESV" width="22" begin="31" end="10" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="EMUIHBIE" width="1" begin="9" end="9" resetval="0" description="Emulation alters domain state (Inhibits domain Off or Forces Domain On) Interrupt Enable                                                                                             0: Not enabled                                                                                               1: Enabled " range="" rwaccess="R/W">
         
      </bitfield>
      <bitfield id="EPCGOOD" width="1" begin="8" end="8" resetval="0" description="External Power Control Power Good Indication.                                           0: External Power Control has turned off power to this domain                     1: External Power Control has turned on power to this domain and the power has reached a desired threshold." range="" rwaccess="R/W">
         
      </bitfield>
      <bitfield id="_RESV" width="7" begin="7" end="1" resetval="0" description="Reserved" range="" rwaccess="R ">
         
      </bitfield>
      <bitfield id="NEXT" width="1" begin="0" end="0" resetval="0" description="User-Desired Next Power Domain State                                                                         0: Off                                                                                                             1: On               " range="" rwaccess="R/W">
         
      </bitfield>
   </register>
   <register id="PDCTL29" acronym="PDCTL29" offset="0x374" width="32" description="Power Domain Control 29 Register">
      <bitfield id="_RESV" width="22" begin="31" end="10" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="EMUIHBIE" width="1" begin="9" end="9" resetval="0" description="Emulation alters domain state (Inhibits domain Off or Forces Domain On) Interrupt Enable                                                                                             0: Not enabled                                                                                               1: Enabled " range="" rwaccess="R/W">
         
      </bitfield>
      <bitfield id="EPCGOOD" width="1" begin="8" end="8" resetval="0" description="External Power Control Power Good Indication.                                           0: External Power Control has turned off power to this domain                     1: External Power Control has turned on power to this domain and the power has reached a desired threshold." range="" rwaccess="R/W">
         
      </bitfield>
      <bitfield id="_RESV" width="7" begin="7" end="1" resetval="0" description="Reserved" range="" rwaccess="R ">
         
      </bitfield>
      <bitfield id="NEXT" width="1" begin="0" end="0" resetval="0" description="User-Desired Next Power Domain State                                                                         0: Off                                                                                                             1: On               " range="" rwaccess="R/W">
         
      </bitfield>
   </register>
   <register id="PDCTL30" acronym="PDCTL30" offset="0x378" width="32" description="Power Domain Control 30 Register">
      <bitfield id="_RESV" width="22" begin="31" end="10" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="EMUIHBIE" width="1" begin="9" end="9" resetval="0" description="Emulation alters domain state (Inhibits domain Off or Forces Domain On) Interrupt Enable                                                                                             0: Not enabled                                                                                               1: Enabled " range="" rwaccess="R/W">
         
      </bitfield>
      <bitfield id="EPCGOOD" width="1" begin="8" end="8" resetval="0" description="External Power Control Power Good Indication.                                           0: External Power Control has turned off power to this domain                     1: External Power Control has turned on power to this domain and the power has reached a desired threshold." range="" rwaccess="R/W">
         
      </bitfield>
      <bitfield id="_RESV" width="7" begin="7" end="1" resetval="0" description="Reserved" range="" rwaccess="R ">
         
      </bitfield>
      <bitfield id="NEXT" width="1" begin="0" end="0" resetval="0" description="User-Desired Next Power Domain State                                                                         0: Off                                                                                                             1: On               " range="" rwaccess="R/W">
         
      </bitfield>
   </register>
   <register id="PDCTL31" acronym="PDCTL31" offset="0x37C" width="32" description="Power Domain Control 31 Register">
      <bitfield id="_RESV" width="22" begin="31" end="10" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="EMUIHBIE" width="1" begin="9" end="9" resetval="0" description="Emulation alters domain state (Inhibits domain Off or Forces Domain On) Interrupt Enable                                                                                             0: Not enabled                                                                                               1: Enabled " range="" rwaccess="R/W">
         
      </bitfield>
      <bitfield id="EPCGOOD" width="1" begin="8" end="8" resetval="0" description="External Power Control Power Good Indication.                                           0: External Power Control has turned off power to this domain                     1: External Power Control has turned on power to this domain and the power has reached a desired threshold." range="" rwaccess="R/W">
         
      </bitfield>
      <bitfield id="_RESV" width="7" begin="7" end="1" resetval="0" description="Reserved" range="" rwaccess="R ">
         
      </bitfield>
      <bitfield id="NEXT" width="1" begin="0" end="0" resetval="0" description="User-Desired Next Power Domain State                                                                         0: Off                                                                                                             1: On               " range="" rwaccess="R/W">
         
      </bitfield>
   </register>
   <register id="MRSTOUT0" acronym="MRSTOUT0" offset="0x500" width="32" description="Module Reset Output (mod 0-31) Register">
      <bitfield id="MRSTz[32]" width="1" begin="31" end="0" resetval="0" description="For Module 31 down-to 0,   actual modrstz output to module                                                                          0: modrstz asserted                                                                                      1: modrstz not asserted" range="" rwaccess="R">
         
      </bitfield>
   </register>
   <register id="MRSTOUT1" acronym="MRSTOUT1" offset="0x504" width="32" description="Module Reset Output (mod 32-63) Register">
      <bitfield id="MRSTz[32]" width="1" begin="31" end="0" resetval="0" description="For Module 63 down-to 32,  actual modrstz output to module                                                                            0: modrstz asserted                                                                                      1: modrstz not asserted" range="" rwaccess="R">
         
      </bitfield>
   </register>
   <register id="MCKOUT0" acronym="MCKOUT0" offset="0x510" width="32" description="Module Clock Output Status (mod 0-31) Register">
      <bitfield id="MCK[32]" width="1" begin="31" end="0" resetval="0" description="For Module 31 down-to 1,   actual modclk output to module                                                                          0: modclk gated                                                                                           1: modclk on" range="" rwaccess="R">
         
      </bitfield>
   </register>
   <register id="MCKOUT1" acronym="MCKOUT1" offset="0x514" width="32" description="Module Clock Output Status (mod 32-63) Register">
      <bitfield id="MCK[32]" width="1" begin="31" end="0" resetval="0" description="For Module 63 down-to 32,  actual modclk output to module                                                                           0: modclk gated                                                                                           1: modclk on" range="" rwaccess="R">
         
      </bitfield>
   </register>
   <register id="MDCFG0" acronym="MDCFG0" offset="0x600" width="32" description="Module Configuration 0 Register">
      <bitfield id="_RESV" width="10" begin="31" end="22" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="_RESV" width="1" begin="21" end="21" resetval="0" description="Reserved for PWRDOM expansion to up to 64 domains " range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="PWRDOM" width="5" begin="20" end="16" resetval="0" description="Power Domain                                                                                               Indicates which power domain this module belongs to (0 to 31)" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="_RESV" width="6" begin="15" end="10" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="MSTGKT" width="1" begin="9" end="9" resetval="0" description="Master Gasket support. Reflects the RTL parameter MSTGKT                     0: Master Gasket not supported by LPSC                                                     1: Master Gasket supported by LPSC" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="PERMDIS" width="1" begin="8" end="8" resetval="0" description="Permanently Disable                                                                                      Not documented to users                                                                              0: Not permanently disable module                                                                1: Permamanently disable module" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="CKRST" width="1" begin="7" end="7" resetval="0" description="Modclk During MSM reset source assert. Shows the tieoff d_mdcfg[x]_clk_during_hard_rst_src.                                                          MSM reset source is either hard_rst_src_assert_pi_n or any_rst_src_assert_pi_n                                                                              0: LPSC does not give modclk when its MSM reset source is asserted. LPSC only gives modclk after the MSM reset source is de-asserted           1: LPSC gives modclk even when the MSM reset source is asserted" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="PLLCKGT" width="1" begin="6" end="6" resetval="0" description="PLL Clock gate. Shows the tieoff d_mdcfg[x]_pll_handshake                      0: LPSC gates modclk directly                                                                       1: LPSC does not gate modclk directly. LPSC instructs the PLLCTRL to gate modclk." range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="LSRSTBLK" width="1" begin="5" end="5" resetval="0" description="LRST Soft Reset Block. Shows the tieoff d_mdcfg[x]_lrst_soft_rst_block value.                                                                                                             0: Soft resets are not blocked to LRST.                                                        1: Soft resets are blocked to LRST." range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="SRSTBLK" width="1" begin="4" end="4" resetval="0" description="Soft Reset Block. Shows the tieoff d_mdcfg[x]_soft_rst_block value.        0: Soft resets are not blocked. Any grstz from PLLCTRL will be propagated to the module                                                                              1: Soft resets are blocked LPSC only passes hard resets to the module" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="_RESV" width="2" begin="3" end="2" resetval="0" description="Reserved for NUMCLK expansion" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="NUMCLK" width="2" begin="1" end="0" resetval="0" description="Number of modclks supported on LPSC                                                        0: 1 modclk                                                                                                    1: 2 modclks                                                                                                  2: 3 modclks                                                                                                  3: 4 modclks" range="" rwaccess="R">
         
      </bitfield>
   </register>
   <register id="MDCFG1" acronym="MDCFG1" offset="0x604" width="32" description="Module Configuration 1 Register">
      <bitfield id="_RESV" width="10" begin="31" end="22" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="_RESV" width="1" begin="21" end="21" resetval="0" description="Reserved for PWRDOM expansion to up to 64 domains " range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="PWRDOM" width="5" begin="20" end="16" resetval="0" description="Power Domain                                                                                               Indicates which power domain this module belongs to (0 to 31)" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="_RESV" width="6" begin="15" end="10" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="MSTGKT" width="1" begin="9" end="9" resetval="0" description="Master Gasket support. Reflects the RTL parameter MSTGKT                     0: Master Gasket not supported by LPSC                                                     1: Master Gasket supported by LPSC" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="PERMDIS" width="1" begin="8" end="8" resetval="0" description="Permanently Disable                                                                                      Not documented to users                                                                              0: Not permanently disable module                                                                1: Permamanently disable module" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="CKRST" width="1" begin="7" end="7" resetval="0" description="Modclk During MSM reset source assert. Shows the tieoff d_mdcfg[x]_clk_during_hard_rst_src.                                                          MSM reset source is either hard_rst_src_assert_pi_n or any_rst_src_assert_pi_n                                                                              0: LPSC does not give modclk when its MSM reset source is asserted. LPSC only gives modclk after the MSM reset source is de-asserted           1: LPSC gives modclk even when the MSM reset source is asserted" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="PLLCKGT" width="1" begin="6" end="6" resetval="0" description="PLL Clock gate. Shows the tieoff d_mdcfg[x]_pll_handshake                      0: LPSC gates modclk directly                                                                       1: LPSC does not gate modclk directly. LPSC instructs the PLLCTRL to gate modclk." range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="LSRSTBLK" width="1" begin="5" end="5" resetval="0" description="LRST Soft Reset Block. Shows the tieoff d_mdcfg[x]_lrst_soft_rst_block value.                                                                                                             0: Soft resets are not blocked to LRST.                                                        1: Soft resets are blocked to LRST." range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="SRSTBLK" width="1" begin="4" end="4" resetval="0" description="Soft Reset Block. Shows the tieoff d_mdcfg[x]_soft_rst_block value.        0: Soft resets are not blocked. Any grstz from PLLCTRL will be propagated to the module                                                                              1: Soft resets are blocked LPSC only passes hard resets to the module" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="_RESV" width="2" begin="3" end="2" resetval="0" description="Reserved for NUMCLK expansion" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="NUMCLK" width="2" begin="1" end="0" resetval="0" description="Number of modclks supported on LPSC                                                        0: 1 modclk                                                                                                    1: 2 modclks                                                                                                  2: 3 modclks                                                                                                  3: 4 modclks" range="" rwaccess="R">
         
      </bitfield>
   </register>
   <register id="MDCFG2" acronym="MDCFG2" offset="0x608" width="32" description="Module Configuration 2 Register">
      <bitfield id="_RESV" width="10" begin="31" end="22" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="_RESV" width="1" begin="21" end="21" resetval="0" description="Reserved for PWRDOM expansion to up to 64 domains " range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="PWRDOM" width="5" begin="20" end="16" resetval="0" description="Power Domain                                                                                               Indicates which power domain this module belongs to (0 to 31)" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="_RESV" width="6" begin="15" end="10" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="MSTGKT" width="1" begin="9" end="9" resetval="0" description="Master Gasket support. Reflects the RTL parameter MSTGKT                     0: Master Gasket not supported by LPSC                                                     1: Master Gasket supported by LPSC" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="PERMDIS" width="1" begin="8" end="8" resetval="0" description="Permanently Disable                                                                                      Not documented to users                                                                              0: Not permanently disable module                                                                1: Permamanently disable module" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="CKRST" width="1" begin="7" end="7" resetval="0" description="Modclk During MSM reset source assert. Shows the tieoff d_mdcfg[x]_clk_during_hard_rst_src.                                                          MSM reset source is either hard_rst_src_assert_pi_n or any_rst_src_assert_pi_n                                                                              0: LPSC does not give modclk when its MSM reset source is asserted. LPSC only gives modclk after the MSM reset source is de-asserted           1: LPSC gives modclk even when the MSM reset source is asserted" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="PLLCKGT" width="1" begin="6" end="6" resetval="0" description="PLL Clock gate. Shows the tieoff d_mdcfg[x]_pll_handshake                      0: LPSC gates modclk directly                                                                       1: LPSC does not gate modclk directly. LPSC instructs the PLLCTRL to gate modclk." range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="LSRSTBLK" width="1" begin="5" end="5" resetval="0" description="LRST Soft Reset Block. Shows the tieoff d_mdcfg[x]_lrst_soft_rst_block value.                                                                                                             0: Soft resets are not blocked to LRST.                                                        1: Soft resets are blocked to LRST." range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="SRSTBLK" width="1" begin="4" end="4" resetval="0" description="Soft Reset Block. Shows the tieoff d_mdcfg[x]_soft_rst_block value.        0: Soft resets are not blocked. Any grstz from PLLCTRL will be propagated to the module                                                                              1: Soft resets are blocked LPSC only passes hard resets to the module" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="_RESV" width="2" begin="3" end="2" resetval="0" description="Reserved for NUMCLK expansion" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="NUMCLK" width="2" begin="1" end="0" resetval="0" description="Number of modclks supported on LPSC                                                        0: 1 modclk                                                                                                    1: 2 modclks                                                                                                  2: 3 modclks                                                                                                  3: 4 modclks" range="" rwaccess="R">
         
      </bitfield>
   </register>
   <register id="MDCFG3" acronym="MDCFG3" offset="0x60C" width="32" description="Module Configuration 3 Register">
      <bitfield id="_RESV" width="10" begin="31" end="22" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="_RESV" width="1" begin="21" end="21" resetval="0" description="Reserved for PWRDOM expansion to up to 64 domains " range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="PWRDOM" width="5" begin="20" end="16" resetval="0" description="Power Domain                                                                                               Indicates which power domain this module belongs to (0 to 31)" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="_RESV" width="6" begin="15" end="10" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="MSTGKT" width="1" begin="9" end="9" resetval="0" description="Master Gasket support. Reflects the RTL parameter MSTGKT                     0: Master Gasket not supported by LPSC                                                     1: Master Gasket supported by LPSC" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="PERMDIS" width="1" begin="8" end="8" resetval="0" description="Permanently Disable                                                                                      Not documented to users                                                                              0: Not permanently disable module                                                                1: Permamanently disable module" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="CKRST" width="1" begin="7" end="7" resetval="0" description="Modclk During MSM reset source assert. Shows the tieoff d_mdcfg[x]_clk_during_hard_rst_src.                                                          MSM reset source is either hard_rst_src_assert_pi_n or any_rst_src_assert_pi_n                                                                              0: LPSC does not give modclk when its MSM reset source is asserted. LPSC only gives modclk after the MSM reset source is de-asserted           1: LPSC gives modclk even when the MSM reset source is asserted" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="PLLCKGT" width="1" begin="6" end="6" resetval="0" description="PLL Clock gate. Shows the tieoff d_mdcfg[x]_pll_handshake                      0: LPSC gates modclk directly                                                                       1: LPSC does not gate modclk directly. LPSC instructs the PLLCTRL to gate modclk." range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="LSRSTBLK" width="1" begin="5" end="5" resetval="0" description="LRST Soft Reset Block. Shows the tieoff d_mdcfg[x]_lrst_soft_rst_block value.                                                                                                             0: Soft resets are not blocked to LRST.                                                        1: Soft resets are blocked to LRST." range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="SRSTBLK" width="1" begin="4" end="4" resetval="0" description="Soft Reset Block. Shows the tieoff d_mdcfg[x]_soft_rst_block value.        0: Soft resets are not blocked. Any grstz from PLLCTRL will be propagated to the module                                                                              1: Soft resets are blocked LPSC only passes hard resets to the module" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="_RESV" width="2" begin="3" end="2" resetval="0" description="Reserved for NUMCLK expansion" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="NUMCLK" width="2" begin="1" end="0" resetval="0" description="Number of modclks supported on LPSC                                                        0: 1 modclk                                                                                                    1: 2 modclks                                                                                                  2: 3 modclks                                                                                                  3: 4 modclks" range="" rwaccess="R">
         
      </bitfield>
   </register>
   <register id="MDCFG4" acronym="MDCFG4" offset="0x610" width="32" description="Module Configuration 4 Register">
      <bitfield id="_RESV" width="10" begin="31" end="22" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="_RESV" width="1" begin="21" end="21" resetval="0" description="Reserved for PWRDOM expansion to up to 64 domains " range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="PWRDOM" width="5" begin="20" end="16" resetval="0" description="Power Domain                                                                                               Indicates which power domain this module belongs to (0 to 31)" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="_RESV" width="6" begin="15" end="10" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="MSTGKT" width="1" begin="9" end="9" resetval="0" description="Master Gasket support. Reflects the RTL parameter MSTGKT                     0: Master Gasket not supported by LPSC                                                     1: Master Gasket supported by LPSC" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="PERMDIS" width="1" begin="8" end="8" resetval="0" description="Permanently Disable                                                                                      Not documented to users                                                                              0: Not permanently disable module                                                                1: Permamanently disable module" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="CKRST" width="1" begin="7" end="7" resetval="0" description="Modclk During MSM reset source assert. Shows the tieoff d_mdcfg[x]_clk_during_hard_rst_src.                                                          MSM reset source is either hard_rst_src_assert_pi_n or any_rst_src_assert_pi_n                                                                              0: LPSC does not give modclk when its MSM reset source is asserted. LPSC only gives modclk after the MSM reset source is de-asserted           1: LPSC gives modclk even when the MSM reset source is asserted" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="PLLCKGT" width="1" begin="6" end="6" resetval="0" description="PLL Clock gate. Shows the tieoff d_mdcfg[x]_pll_handshake                      0: LPSC gates modclk directly                                                                       1: LPSC does not gate modclk directly. LPSC instructs the PLLCTRL to gate modclk." range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="LSRSTBLK" width="1" begin="5" end="5" resetval="0" description="LRST Soft Reset Block. Shows the tieoff d_mdcfg[x]_lrst_soft_rst_block value.                                                                                                             0: Soft resets are not blocked to LRST.                                                        1: Soft resets are blocked to LRST." range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="SRSTBLK" width="1" begin="4" end="4" resetval="0" description="Soft Reset Block. Shows the tieoff d_mdcfg[x]_soft_rst_block value.        0: Soft resets are not blocked. Any grstz from PLLCTRL will be propagated to the module                                                                              1: Soft resets are blocked LPSC only passes hard resets to the module" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="_RESV" width="2" begin="3" end="2" resetval="0" description="Reserved for NUMCLK expansion" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="NUMCLK" width="2" begin="1" end="0" resetval="0" description="Number of modclks supported on LPSC                                                        0: 1 modclk                                                                                                    1: 2 modclks                                                                                                  2: 3 modclks                                                                                                  3: 4 modclks" range="" rwaccess="R">
         
      </bitfield>
   </register>
   <register id="MDCFG5" acronym="MDCFG5" offset="0x614" width="32" description="Module Configuration 5 Register">
      <bitfield id="_RESV" width="10" begin="31" end="22" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="_RESV" width="1" begin="21" end="21" resetval="0" description="Reserved for PWRDOM expansion to up to 64 domains " range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="PWRDOM" width="5" begin="20" end="16" resetval="0" description="Power Domain                                                                                               Indicates which power domain this module belongs to (0 to 31)" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="_RESV" width="6" begin="15" end="10" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="MSTGKT" width="1" begin="9" end="9" resetval="0" description="Master Gasket support. Reflects the RTL parameter MSTGKT                     0: Master Gasket not supported by LPSC                                                     1: Master Gasket supported by LPSC" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="PERMDIS" width="1" begin="8" end="8" resetval="0" description="Permanently Disable                                                                                      Not documented to users                                                                              0: Not permanently disable module                                                                1: Permamanently disable module" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="CKRST" width="1" begin="7" end="7" resetval="0" description="Modclk During MSM reset source assert. Shows the tieoff d_mdcfg[x]_clk_during_hard_rst_src.                                                          MSM reset source is either hard_rst_src_assert_pi_n or any_rst_src_assert_pi_n                                                                              0: LPSC does not give modclk when its MSM reset source is asserted. LPSC only gives modclk after the MSM reset source is de-asserted           1: LPSC gives modclk even when the MSM reset source is asserted" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="PLLCKGT" width="1" begin="6" end="6" resetval="0" description="PLL Clock gate. Shows the tieoff d_mdcfg[x]_pll_handshake                      0: LPSC gates modclk directly                                                                       1: LPSC does not gate modclk directly. LPSC instructs the PLLCTRL to gate modclk." range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="LSRSTBLK" width="1" begin="5" end="5" resetval="0" description="LRST Soft Reset Block. Shows the tieoff d_mdcfg[x]_lrst_soft_rst_block value.                                                                                                             0: Soft resets are not blocked to LRST.                                                        1: Soft resets are blocked to LRST." range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="SRSTBLK" width="1" begin="4" end="4" resetval="0" description="Soft Reset Block. Shows the tieoff d_mdcfg[x]_soft_rst_block value.        0: Soft resets are not blocked. Any grstz from PLLCTRL will be propagated to the module                                                                              1: Soft resets are blocked LPSC only passes hard resets to the module" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="_RESV" width="2" begin="3" end="2" resetval="0" description="Reserved for NUMCLK expansion" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="NUMCLK" width="2" begin="1" end="0" resetval="0" description="Number of modclks supported on LPSC                                                        0: 1 modclk                                                                                                    1: 2 modclks                                                                                                  2: 3 modclks                                                                                                  3: 4 modclks" range="" rwaccess="R">
         
      </bitfield>
   </register>
   <register id="MDCFG6" acronym="MDCFG6" offset="0x618" width="32" description="Module Configuration 6 Register">
      <bitfield id="_RESV" width="10" begin="31" end="22" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="_RESV" width="1" begin="21" end="21" resetval="0" description="Reserved for PWRDOM expansion to up to 64 domains " range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="PWRDOM" width="5" begin="20" end="16" resetval="0" description="Power Domain                                                                                               Indicates which power domain this module belongs to (0 to 31)" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="_RESV" width="6" begin="15" end="10" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="MSTGKT" width="1" begin="9" end="9" resetval="0" description="Master Gasket support. Reflects the RTL parameter MSTGKT                     0: Master Gasket not supported by LPSC                                                     1: Master Gasket supported by LPSC" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="PERMDIS" width="1" begin="8" end="8" resetval="0" description="Permanently Disable                                                                                      Not documented to users                                                                              0: Not permanently disable module                                                                1: Permamanently disable module" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="CKRST" width="1" begin="7" end="7" resetval="0" description="Modclk During MSM reset source assert. Shows the tieoff d_mdcfg[x]_clk_during_hard_rst_src.                                                          MSM reset source is either hard_rst_src_assert_pi_n or any_rst_src_assert_pi_n                                                                              0: LPSC does not give modclk when its MSM reset source is asserted. LPSC only gives modclk after the MSM reset source is de-asserted           1: LPSC gives modclk even when the MSM reset source is asserted" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="PLLCKGT" width="1" begin="6" end="6" resetval="0" description="PLL Clock gate. Shows the tieoff d_mdcfg[x]_pll_handshake                      0: LPSC gates modclk directly                                                                       1: LPSC does not gate modclk directly. LPSC instructs the PLLCTRL to gate modclk." range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="LSRSTBLK" width="1" begin="5" end="5" resetval="0" description="LRST Soft Reset Block. Shows the tieoff d_mdcfg[x]_lrst_soft_rst_block value.                                                                                                             0: Soft resets are not blocked to LRST.                                                        1: Soft resets are blocked to LRST." range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="SRSTBLK" width="1" begin="4" end="4" resetval="0" description="Soft Reset Block. Shows the tieoff d_mdcfg[x]_soft_rst_block value.        0: Soft resets are not blocked. Any grstz from PLLCTRL will be propagated to the module                                                                              1: Soft resets are blocked LPSC only passes hard resets to the module" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="_RESV" width="2" begin="3" end="2" resetval="0" description="Reserved for NUMCLK expansion" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="NUMCLK" width="2" begin="1" end="0" resetval="0" description="Number of modclks supported on LPSC                                                        0: 1 modclk                                                                                                    1: 2 modclks                                                                                                  2: 3 modclks                                                                                                  3: 4 modclks" range="" rwaccess="R">
         
      </bitfield>
   </register>
   <register id="MDCFG7" acronym="MDCFG7" offset="0x61C" width="32" description="Module Configuration 7 Register">
      <bitfield id="_RESV" width="10" begin="31" end="22" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="_RESV" width="1" begin="21" end="21" resetval="0" description="Reserved for PWRDOM expansion to up to 64 domains " range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="PWRDOM" width="5" begin="20" end="16" resetval="0" description="Power Domain                                                                                               Indicates which power domain this module belongs to (0 to 31)" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="_RESV" width="6" begin="15" end="10" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="MSTGKT" width="1" begin="9" end="9" resetval="0" description="Master Gasket support. Reflects the RTL parameter MSTGKT                     0: Master Gasket not supported by LPSC                                                     1: Master Gasket supported by LPSC" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="PERMDIS" width="1" begin="8" end="8" resetval="0" description="Permanently Disable                                                                                      Not documented to users                                                                              0: Not permanently disable module                                                                1: Permamanently disable module" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="CKRST" width="1" begin="7" end="7" resetval="0" description="Modclk During MSM reset source assert. Shows the tieoff d_mdcfg[x]_clk_during_hard_rst_src.                                                          MSM reset source is either hard_rst_src_assert_pi_n or any_rst_src_assert_pi_n                                                                              0: LPSC does not give modclk when its MSM reset source is asserted. LPSC only gives modclk after the MSM reset source is de-asserted           1: LPSC gives modclk even when the MSM reset source is asserted" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="PLLCKGT" width="1" begin="6" end="6" resetval="0" description="PLL Clock gate. Shows the tieoff d_mdcfg[x]_pll_handshake                      0: LPSC gates modclk directly                                                                       1: LPSC does not gate modclk directly. LPSC instructs the PLLCTRL to gate modclk." range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="LSRSTBLK" width="1" begin="5" end="5" resetval="0" description="LRST Soft Reset Block. Shows the tieoff d_mdcfg[x]_lrst_soft_rst_block value.                                                                                                             0: Soft resets are not blocked to LRST.                                                        1: Soft resets are blocked to LRST." range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="SRSTBLK" width="1" begin="4" end="4" resetval="0" description="Soft Reset Block. Shows the tieoff d_mdcfg[x]_soft_rst_block value.        0: Soft resets are not blocked. Any grstz from PLLCTRL will be propagated to the module                                                                              1: Soft resets are blocked LPSC only passes hard resets to the module" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="_RESV" width="2" begin="3" end="2" resetval="0" description="Reserved for NUMCLK expansion" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="NUMCLK" width="2" begin="1" end="0" resetval="0" description="Number of modclks supported on LPSC                                                        0: 1 modclk                                                                                                    1: 2 modclks                                                                                                  2: 3 modclks                                                                                                  3: 4 modclks" range="" rwaccess="R">
         
      </bitfield>
   </register>
   <register id="MDCFG8" acronym="MDCFG8" offset="0x620" width="32" description="Module Configuration 8 Register">
      <bitfield id="_RESV" width="10" begin="31" end="22" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="_RESV" width="1" begin="21" end="21" resetval="0" description="Reserved for PWRDOM expansion to up to 64 domains " range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="PWRDOM" width="5" begin="20" end="16" resetval="0" description="Power Domain                                                                                               Indicates which power domain this module belongs to (0 to 31)" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="_RESV" width="6" begin="15" end="10" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="MSTGKT" width="1" begin="9" end="9" resetval="0" description="Master Gasket support. Reflects the RTL parameter MSTGKT                     0: Master Gasket not supported by LPSC                                                     1: Master Gasket supported by LPSC" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="PERMDIS" width="1" begin="8" end="8" resetval="0" description="Permanently Disable                                                                                      Not documented to users                                                                              0: Not permanently disable module                                                                1: Permamanently disable module" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="CKRST" width="1" begin="7" end="7" resetval="0" description="Modclk During MSM reset source assert. Shows the tieoff d_mdcfg[x]_clk_during_hard_rst_src.                                                          MSM reset source is either hard_rst_src_assert_pi_n or any_rst_src_assert_pi_n                                                                              0: LPSC does not give modclk when its MSM reset source is asserted. LPSC only gives modclk after the MSM reset source is de-asserted           1: LPSC gives modclk even when the MSM reset source is asserted" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="PLLCKGT" width="1" begin="6" end="6" resetval="0" description="PLL Clock gate. Shows the tieoff d_mdcfg[x]_pll_handshake                      0: LPSC gates modclk directly                                                                       1: LPSC does not gate modclk directly. LPSC instructs the PLLCTRL to gate modclk." range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="LSRSTBLK" width="1" begin="5" end="5" resetval="0" description="LRST Soft Reset Block. Shows the tieoff d_mdcfg[x]_lrst_soft_rst_block value.                                                                                                             0: Soft resets are not blocked to LRST.                                                        1: Soft resets are blocked to LRST." range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="SRSTBLK" width="1" begin="4" end="4" resetval="0" description="Soft Reset Block. Shows the tieoff d_mdcfg[x]_soft_rst_block value.        0: Soft resets are not blocked. Any grstz from PLLCTRL will be propagated to the module                                                                              1: Soft resets are blocked LPSC only passes hard resets to the module" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="_RESV" width="2" begin="3" end="2" resetval="0" description="Reserved for NUMCLK expansion" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="NUMCLK" width="2" begin="1" end="0" resetval="0" description="Number of modclks supported on LPSC                                                        0: 1 modclk                                                                                                    1: 2 modclks                                                                                                  2: 3 modclks                                                                                                  3: 4 modclks" range="" rwaccess="R">
         
      </bitfield>
   </register>
   <register id="MDCFG9" acronym="MDCFG9" offset="0x624" width="32" description="Module Configuration 9 Register">
      <bitfield id="_RESV" width="10" begin="31" end="22" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="_RESV" width="1" begin="21" end="21" resetval="0" description="Reserved for PWRDOM expansion to up to 64 domains " range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="PWRDOM" width="5" begin="20" end="16" resetval="0" description="Power Domain                                                                                               Indicates which power domain this module belongs to (0 to 31)" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="_RESV" width="6" begin="15" end="10" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="MSTGKT" width="1" begin="9" end="9" resetval="0" description="Master Gasket support. Reflects the RTL parameter MSTGKT                     0: Master Gasket not supported by LPSC                                                     1: Master Gasket supported by LPSC" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="PERMDIS" width="1" begin="8" end="8" resetval="0" description="Permanently Disable                                                                                      Not documented to users                                                                              0: Not permanently disable module                                                                1: Permamanently disable module" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="CKRST" width="1" begin="7" end="7" resetval="0" description="Modclk During MSM reset source assert. Shows the tieoff d_mdcfg[x]_clk_during_hard_rst_src.                                                          MSM reset source is either hard_rst_src_assert_pi_n or any_rst_src_assert_pi_n                                                                              0: LPSC does not give modclk when its MSM reset source is asserted. LPSC only gives modclk after the MSM reset source is de-asserted           1: LPSC gives modclk even when the MSM reset source is asserted" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="PLLCKGT" width="1" begin="6" end="6" resetval="0" description="PLL Clock gate. Shows the tieoff d_mdcfg[x]_pll_handshake                      0: LPSC gates modclk directly                                                                       1: LPSC does not gate modclk directly. LPSC instructs the PLLCTRL to gate modclk." range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="LSRSTBLK" width="1" begin="5" end="5" resetval="0" description="LRST Soft Reset Block. Shows the tieoff d_mdcfg[x]_lrst_soft_rst_block value.                                                                                                             0: Soft resets are not blocked to LRST.                                                        1: Soft resets are blocked to LRST." range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="SRSTBLK" width="1" begin="4" end="4" resetval="0" description="Soft Reset Block. Shows the tieoff d_mdcfg[x]_soft_rst_block value.        0: Soft resets are not blocked. Any grstz from PLLCTRL will be propagated to the module                                                                              1: Soft resets are blocked LPSC only passes hard resets to the module" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="_RESV" width="2" begin="3" end="2" resetval="0" description="Reserved for NUMCLK expansion" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="NUMCLK" width="2" begin="1" end="0" resetval="0" description="Number of modclks supported on LPSC                                                        0: 1 modclk                                                                                                    1: 2 modclks                                                                                                  2: 3 modclks                                                                                                  3: 4 modclks" range="" rwaccess="R">
         
      </bitfield>
   </register>
   <register id="MDCFG10" acronym="MDCFG10" offset="0x628" width="32" description="Module Configuration 10 Register">
      <bitfield id="_RESV" width="10" begin="31" end="22" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="_RESV" width="1" begin="21" end="21" resetval="0" description="Reserved for PWRDOM expansion to up to 64 domains " range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="PWRDOM" width="5" begin="20" end="16" resetval="0" description="Power Domain                                                                                               Indicates which power domain this module belongs to (0 to 31)" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="_RESV" width="6" begin="15" end="10" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="MSTGKT" width="1" begin="9" end="9" resetval="0" description="Master Gasket support. Reflects the RTL parameter MSTGKT                     0: Master Gasket not supported by LPSC                                                     1: Master Gasket supported by LPSC" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="PERMDIS" width="1" begin="8" end="8" resetval="0" description="Permanently Disable                                                                                      Not documented to users                                                                              0: Not permanently disable module                                                                1: Permamanently disable module" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="CKRST" width="1" begin="7" end="7" resetval="0" description="Modclk During MSM reset source assert. Shows the tieoff d_mdcfg[x]_clk_during_hard_rst_src.                                                          MSM reset source is either hard_rst_src_assert_pi_n or any_rst_src_assert_pi_n                                                                              0: LPSC does not give modclk when its MSM reset source is asserted. LPSC only gives modclk after the MSM reset source is de-asserted           1: LPSC gives modclk even when the MSM reset source is asserted" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="PLLCKGT" width="1" begin="6" end="6" resetval="0" description="PLL Clock gate. Shows the tieoff d_mdcfg[x]_pll_handshake                      0: LPSC gates modclk directly                                                                       1: LPSC does not gate modclk directly. LPSC instructs the PLLCTRL to gate modclk." range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="LSRSTBLK" width="1" begin="5" end="5" resetval="0" description="LRST Soft Reset Block. Shows the tieoff d_mdcfg[x]_lrst_soft_rst_block value.                                                                                                             0: Soft resets are not blocked to LRST.                                                        1: Soft resets are blocked to LRST." range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="SRSTBLK" width="1" begin="4" end="4" resetval="0" description="Soft Reset Block. Shows the tieoff d_mdcfg[x]_soft_rst_block value.        0: Soft resets are not blocked. Any grstz from PLLCTRL will be propagated to the module                                                                              1: Soft resets are blocked LPSC only passes hard resets to the module" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="_RESV" width="2" begin="3" end="2" resetval="0" description="Reserved for NUMCLK expansion" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="NUMCLK" width="2" begin="1" end="0" resetval="0" description="Number of modclks supported on LPSC                                                        0: 1 modclk                                                                                                    1: 2 modclks                                                                                                  2: 3 modclks                                                                                                  3: 4 modclks" range="" rwaccess="R">
         
      </bitfield>
   </register>
   <register id="MDCFG11" acronym="MDCFG11" offset="0x62C" width="32" description="Module Configuration 11 Register">
      <bitfield id="_RESV" width="10" begin="31" end="22" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="_RESV" width="1" begin="21" end="21" resetval="0" description="Reserved for PWRDOM expansion to up to 64 domains " range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="PWRDOM" width="5" begin="20" end="16" resetval="0" description="Power Domain                                                                                               Indicates which power domain this module belongs to (0 to 31)" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="_RESV" width="6" begin="15" end="10" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="MSTGKT" width="1" begin="9" end="9" resetval="0" description="Master Gasket support. Reflects the RTL parameter MSTGKT                     0: Master Gasket not supported by LPSC                                                     1: Master Gasket supported by LPSC" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="PERMDIS" width="1" begin="8" end="8" resetval="0" description="Permanently Disable                                                                                      Not documented to users                                                                              0: Not permanently disable module                                                                1: Permamanently disable module" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="CKRST" width="1" begin="7" end="7" resetval="0" description="Modclk During MSM reset source assert. Shows the tieoff d_mdcfg[x]_clk_during_hard_rst_src.                                                          MSM reset source is either hard_rst_src_assert_pi_n or any_rst_src_assert_pi_n                                                                              0: LPSC does not give modclk when its MSM reset source is asserted. LPSC only gives modclk after the MSM reset source is de-asserted           1: LPSC gives modclk even when the MSM reset source is asserted" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="PLLCKGT" width="1" begin="6" end="6" resetval="0" description="PLL Clock gate. Shows the tieoff d_mdcfg[x]_pll_handshake                      0: LPSC gates modclk directly                                                                       1: LPSC does not gate modclk directly. LPSC instructs the PLLCTRL to gate modclk." range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="LSRSTBLK" width="1" begin="5" end="5" resetval="0" description="LRST Soft Reset Block. Shows the tieoff d_mdcfg[x]_lrst_soft_rst_block value.                                                                                                             0: Soft resets are not blocked to LRST.                                                        1: Soft resets are blocked to LRST." range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="SRSTBLK" width="1" begin="4" end="4" resetval="0" description="Soft Reset Block. Shows the tieoff d_mdcfg[x]_soft_rst_block value.        0: Soft resets are not blocked. Any grstz from PLLCTRL will be propagated to the module                                                                              1: Soft resets are blocked LPSC only passes hard resets to the module" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="_RESV" width="2" begin="3" end="2" resetval="0" description="Reserved for NUMCLK expansion" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="NUMCLK" width="2" begin="1" end="0" resetval="0" description="Number of modclks supported on LPSC                                                        0: 1 modclk                                                                                                    1: 2 modclks                                                                                                  2: 3 modclks                                                                                                  3: 4 modclks" range="" rwaccess="R">
         
      </bitfield>
   </register>
   <register id="MDCFG12" acronym="MDCFG12" offset="0x630" width="32" description="Module Configuration 12 Register">
      <bitfield id="_RESV" width="10" begin="31" end="22" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="_RESV" width="1" begin="21" end="21" resetval="0" description="Reserved for PWRDOM expansion to up to 64 domains " range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="PWRDOM" width="5" begin="20" end="16" resetval="0" description="Power Domain                                                                                               Indicates which power domain this module belongs to (0 to 31)" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="_RESV" width="6" begin="15" end="10" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="MSTGKT" width="1" begin="9" end="9" resetval="0" description="Master Gasket support. Reflects the RTL parameter MSTGKT                     0: Master Gasket not supported by LPSC                                                     1: Master Gasket supported by LPSC" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="PERMDIS" width="1" begin="8" end="8" resetval="0" description="Permanently Disable                                                                                      Not documented to users                                                                              0: Not permanently disable module                                                                1: Permamanently disable module" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="CKRST" width="1" begin="7" end="7" resetval="0" description="Modclk During MSM reset source assert. Shows the tieoff d_mdcfg[x]_clk_during_hard_rst_src.                                                          MSM reset source is either hard_rst_src_assert_pi_n or any_rst_src_assert_pi_n                                                                              0: LPSC does not give modclk when its MSM reset source is asserted. LPSC only gives modclk after the MSM reset source is de-asserted           1: LPSC gives modclk even when the MSM reset source is asserted" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="PLLCKGT" width="1" begin="6" end="6" resetval="0" description="PLL Clock gate. Shows the tieoff d_mdcfg[x]_pll_handshake                      0: LPSC gates modclk directly                                                                       1: LPSC does not gate modclk directly. LPSC instructs the PLLCTRL to gate modclk." range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="LSRSTBLK" width="1" begin="5" end="5" resetval="0" description="LRST Soft Reset Block. Shows the tieoff d_mdcfg[x]_lrst_soft_rst_block value.                                                                                                             0: Soft resets are not blocked to LRST.                                                        1: Soft resets are blocked to LRST." range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="SRSTBLK" width="1" begin="4" end="4" resetval="0" description="Soft Reset Block. Shows the tieoff d_mdcfg[x]_soft_rst_block value.        0: Soft resets are not blocked. Any grstz from PLLCTRL will be propagated to the module                                                                              1: Soft resets are blocked LPSC only passes hard resets to the module" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="_RESV" width="2" begin="3" end="2" resetval="0" description="Reserved for NUMCLK expansion" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="NUMCLK" width="2" begin="1" end="0" resetval="0" description="Number of modclks supported on LPSC                                                        0: 1 modclk                                                                                                    1: 2 modclks                                                                                                  2: 3 modclks                                                                                                  3: 4 modclks" range="" rwaccess="R">
         
      </bitfield>
   </register>
   <register id="MDCFG13" acronym="MDCFG13" offset="0x634" width="32" description="Module Configuration 13 Register">
      <bitfield id="_RESV" width="10" begin="31" end="22" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="_RESV" width="1" begin="21" end="21" resetval="0" description="Reserved for PWRDOM expansion to up to 64 domains " range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="PWRDOM" width="5" begin="20" end="16" resetval="0" description="Power Domain                                                                                               Indicates which power domain this module belongs to (0 to 31)" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="_RESV" width="6" begin="15" end="10" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="MSTGKT" width="1" begin="9" end="9" resetval="0" description="Master Gasket support. Reflects the RTL parameter MSTGKT                     0: Master Gasket not supported by LPSC                                                     1: Master Gasket supported by LPSC" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="PERMDIS" width="1" begin="8" end="8" resetval="0" description="Permanently Disable                                                                                      Not documented to users                                                                              0: Not permanently disable module                                                                1: Permamanently disable module" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="CKRST" width="1" begin="7" end="7" resetval="0" description="Modclk During MSM reset source assert. Shows the tieoff d_mdcfg[x]_clk_during_hard_rst_src.                                                          MSM reset source is either hard_rst_src_assert_pi_n or any_rst_src_assert_pi_n                                                                              0: LPSC does not give modclk when its MSM reset source is asserted. LPSC only gives modclk after the MSM reset source is de-asserted           1: LPSC gives modclk even when the MSM reset source is asserted" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="PLLCKGT" width="1" begin="6" end="6" resetval="0" description="PLL Clock gate. Shows the tieoff d_mdcfg[x]_pll_handshake                      0: LPSC gates modclk directly                                                                       1: LPSC does not gate modclk directly. LPSC instructs the PLLCTRL to gate modclk." range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="LSRSTBLK" width="1" begin="5" end="5" resetval="0" description="LRST Soft Reset Block. Shows the tieoff d_mdcfg[x]_lrst_soft_rst_block value.                                                                                                             0: Soft resets are not blocked to LRST.                                                        1: Soft resets are blocked to LRST." range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="SRSTBLK" width="1" begin="4" end="4" resetval="0" description="Soft Reset Block. Shows the tieoff d_mdcfg[x]_soft_rst_block value.        0: Soft resets are not blocked. Any grstz from PLLCTRL will be propagated to the module                                                                              1: Soft resets are blocked LPSC only passes hard resets to the module" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="_RESV" width="2" begin="3" end="2" resetval="0" description="Reserved for NUMCLK expansion" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="NUMCLK" width="2" begin="1" end="0" resetval="0" description="Number of modclks supported on LPSC                                                        0: 1 modclk                                                                                                    1: 2 modclks                                                                                                  2: 3 modclks                                                                                                  3: 4 modclks" range="" rwaccess="R">
         
      </bitfield>
   </register>
   <register id="MDCFG14" acronym="MDCFG14" offset="0x638" width="32" description="Module Configuration 14 Register">
      <bitfield id="_RESV" width="10" begin="31" end="22" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="_RESV" width="1" begin="21" end="21" resetval="0" description="Reserved for PWRDOM expansion to up to 64 domains " range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="PWRDOM" width="5" begin="20" end="16" resetval="0" description="Power Domain                                                                                               Indicates which power domain this module belongs to (0 to 31)" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="_RESV" width="6" begin="15" end="10" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="MSTGKT" width="1" begin="9" end="9" resetval="0" description="Master Gasket support. Reflects the RTL parameter MSTGKT                     0: Master Gasket not supported by LPSC                                                     1: Master Gasket supported by LPSC" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="PERMDIS" width="1" begin="8" end="8" resetval="0" description="Permanently Disable                                                                                      Not documented to users                                                                              0: Not permanently disable module                                                                1: Permamanently disable module" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="CKRST" width="1" begin="7" end="7" resetval="0" description="Modclk During MSM reset source assert. Shows the tieoff d_mdcfg[x]_clk_during_hard_rst_src.                                                          MSM reset source is either hard_rst_src_assert_pi_n or any_rst_src_assert_pi_n                                                                              0: LPSC does not give modclk when its MSM reset source is asserted. LPSC only gives modclk after the MSM reset source is de-asserted           1: LPSC gives modclk even when the MSM reset source is asserted" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="PLLCKGT" width="1" begin="6" end="6" resetval="0" description="PLL Clock gate. Shows the tieoff d_mdcfg[x]_pll_handshake                      0: LPSC gates modclk directly                                                                       1: LPSC does not gate modclk directly. LPSC instructs the PLLCTRL to gate modclk." range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="LSRSTBLK" width="1" begin="5" end="5" resetval="0" description="LRST Soft Reset Block. Shows the tieoff d_mdcfg[x]_lrst_soft_rst_block value.                                                                                                             0: Soft resets are not blocked to LRST.                                                        1: Soft resets are blocked to LRST." range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="SRSTBLK" width="1" begin="4" end="4" resetval="0" description="Soft Reset Block. Shows the tieoff d_mdcfg[x]_soft_rst_block value.        0: Soft resets are not blocked. Any grstz from PLLCTRL will be propagated to the module                                                                              1: Soft resets are blocked LPSC only passes hard resets to the module" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="_RESV" width="2" begin="3" end="2" resetval="0" description="Reserved for NUMCLK expansion" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="NUMCLK" width="2" begin="1" end="0" resetval="0" description="Number of modclks supported on LPSC                                                        0: 1 modclk                                                                                                    1: 2 modclks                                                                                                  2: 3 modclks                                                                                                  3: 4 modclks" range="" rwaccess="R">
         
      </bitfield>
   </register>
   <register id="MDCFG15" acronym="MDCFG15" offset="0x63C" width="32" description="Module Configuration 15 Register">
      <bitfield id="_RESV" width="10" begin="31" end="22" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="_RESV" width="1" begin="21" end="21" resetval="0" description="Reserved for PWRDOM expansion to up to 64 domains " range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="PWRDOM" width="5" begin="20" end="16" resetval="0" description="Power Domain                                                                                               Indicates which power domain this module belongs to (0 to 31)" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="_RESV" width="6" begin="15" end="10" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="MSTGKT" width="1" begin="9" end="9" resetval="0" description="Master Gasket support. Reflects the RTL parameter MSTGKT                     0: Master Gasket not supported by LPSC                                                     1: Master Gasket supported by LPSC" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="PERMDIS" width="1" begin="8" end="8" resetval="0" description="Permanently Disable                                                                                      Not documented to users                                                                              0: Not permanently disable module                                                                1: Permamanently disable module" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="CKRST" width="1" begin="7" end="7" resetval="0" description="Modclk During MSM reset source assert. Shows the tieoff d_mdcfg[x]_clk_during_hard_rst_src.                                                          MSM reset source is either hard_rst_src_assert_pi_n or any_rst_src_assert_pi_n                                                                              0: LPSC does not give modclk when its MSM reset source is asserted. LPSC only gives modclk after the MSM reset source is de-asserted           1: LPSC gives modclk even when the MSM reset source is asserted" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="PLLCKGT" width="1" begin="6" end="6" resetval="0" description="PLL Clock gate. Shows the tieoff d_mdcfg[x]_pll_handshake                      0: LPSC gates modclk directly                                                                       1: LPSC does not gate modclk directly. LPSC instructs the PLLCTRL to gate modclk." range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="LSRSTBLK" width="1" begin="5" end="5" resetval="0" description="LRST Soft Reset Block. Shows the tieoff d_mdcfg[x]_lrst_soft_rst_block value.                                                                                                             0: Soft resets are not blocked to LRST.                                                        1: Soft resets are blocked to LRST." range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="SRSTBLK" width="1" begin="4" end="4" resetval="0" description="Soft Reset Block. Shows the tieoff d_mdcfg[x]_soft_rst_block value.        0: Soft resets are not blocked. Any grstz from PLLCTRL will be propagated to the module                                                                              1: Soft resets are blocked LPSC only passes hard resets to the module" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="_RESV" width="2" begin="3" end="2" resetval="0" description="Reserved for NUMCLK expansion" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="NUMCLK" width="2" begin="1" end="0" resetval="0" description="Number of modclks supported on LPSC                                                        0: 1 modclk                                                                                                    1: 2 modclks                                                                                                  2: 3 modclks                                                                                                  3: 4 modclks" range="" rwaccess="R">
         
      </bitfield>
   </register>
   <register id="MDCFG16" acronym="MDCFG16" offset="0x640" width="32" description="Module Configuration 16 Register">
      <bitfield id="_RESV" width="10" begin="31" end="22" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="_RESV" width="1" begin="21" end="21" resetval="0" description="Reserved for PWRDOM expansion to up to 64 domains " range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="PWRDOM" width="5" begin="20" end="16" resetval="0" description="Power Domain                                                                                               Indicates which power domain this module belongs to (0 to 31)" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="_RESV" width="6" begin="15" end="10" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="MSTGKT" width="1" begin="9" end="9" resetval="0" description="Master Gasket support. Reflects the RTL parameter MSTGKT                     0: Master Gasket not supported by LPSC                                                     1: Master Gasket supported by LPSC" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="PERMDIS" width="1" begin="8" end="8" resetval="0" description="Permanently Disable                                                                                      Not documented to users                                                                              0: Not permanently disable module                                                                1: Permamanently disable module" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="CKRST" width="1" begin="7" end="7" resetval="0" description="Modclk During MSM reset source assert. Shows the tieoff d_mdcfg[x]_clk_during_hard_rst_src.                                                          MSM reset source is either hard_rst_src_assert_pi_n or any_rst_src_assert_pi_n                                                                              0: LPSC does not give modclk when its MSM reset source is asserted. LPSC only gives modclk after the MSM reset source is de-asserted           1: LPSC gives modclk even when the MSM reset source is asserted" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="PLLCKGT" width="1" begin="6" end="6" resetval="0" description="PLL Clock gate. Shows the tieoff d_mdcfg[x]_pll_handshake                      0: LPSC gates modclk directly                                                                       1: LPSC does not gate modclk directly. LPSC instructs the PLLCTRL to gate modclk." range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="LSRSTBLK" width="1" begin="5" end="5" resetval="0" description="LRST Soft Reset Block. Shows the tieoff d_mdcfg[x]_lrst_soft_rst_block value.                                                                                                             0: Soft resets are not blocked to LRST.                                                        1: Soft resets are blocked to LRST." range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="SRSTBLK" width="1" begin="4" end="4" resetval="0" description="Soft Reset Block. Shows the tieoff d_mdcfg[x]_soft_rst_block value.        0: Soft resets are not blocked. Any grstz from PLLCTRL will be propagated to the module                                                                              1: Soft resets are blocked LPSC only passes hard resets to the module" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="_RESV" width="2" begin="3" end="2" resetval="0" description="Reserved for NUMCLK expansion" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="NUMCLK" width="2" begin="1" end="0" resetval="0" description="Number of modclks supported on LPSC                                                        0: 1 modclk                                                                                                    1: 2 modclks                                                                                                  2: 3 modclks                                                                                                  3: 4 modclks" range="" rwaccess="R">
         
      </bitfield>
   </register>
   <register id="MDCFG17" acronym="MDCFG17" offset="0x644" width="32" description="Module Configuration 17 Register">
      <bitfield id="_RESV" width="10" begin="31" end="22" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="_RESV" width="1" begin="21" end="21" resetval="0" description="Reserved for PWRDOM expansion to up to 64 domains " range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="PWRDOM" width="5" begin="20" end="16" resetval="0" description="Power Domain                                                                                               Indicates which power domain this module belongs to (0 to 31)" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="_RESV" width="6" begin="15" end="10" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="MSTGKT" width="1" begin="9" end="9" resetval="0" description="Master Gasket support. Reflects the RTL parameter MSTGKT                     0: Master Gasket not supported by LPSC                                                     1: Master Gasket supported by LPSC" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="PERMDIS" width="1" begin="8" end="8" resetval="0" description="Permanently Disable                                                                                      Not documented to users                                                                              0: Not permanently disable module                                                                1: Permamanently disable module" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="CKRST" width="1" begin="7" end="7" resetval="0" description="Modclk During MSM reset source assert. Shows the tieoff d_mdcfg[x]_clk_during_hard_rst_src.                                                          MSM reset source is either hard_rst_src_assert_pi_n or any_rst_src_assert_pi_n                                                                              0: LPSC does not give modclk when its MSM reset source is asserted. LPSC only gives modclk after the MSM reset source is de-asserted           1: LPSC gives modclk even when the MSM reset source is asserted" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="PLLCKGT" width="1" begin="6" end="6" resetval="0" description="PLL Clock gate. Shows the tieoff d_mdcfg[x]_pll_handshake                      0: LPSC gates modclk directly                                                                       1: LPSC does not gate modclk directly. LPSC instructs the PLLCTRL to gate modclk." range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="LSRSTBLK" width="1" begin="5" end="5" resetval="0" description="LRST Soft Reset Block. Shows the tieoff d_mdcfg[x]_lrst_soft_rst_block value.                                                                                                             0: Soft resets are not blocked to LRST.                                                        1: Soft resets are blocked to LRST." range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="SRSTBLK" width="1" begin="4" end="4" resetval="0" description="Soft Reset Block. Shows the tieoff d_mdcfg[x]_soft_rst_block value.        0: Soft resets are not blocked. Any grstz from PLLCTRL will be propagated to the module                                                                              1: Soft resets are blocked LPSC only passes hard resets to the module" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="_RESV" width="2" begin="3" end="2" resetval="0" description="Reserved for NUMCLK expansion" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="NUMCLK" width="2" begin="1" end="0" resetval="0" description="Number of modclks supported on LPSC                                                        0: 1 modclk                                                                                                    1: 2 modclks                                                                                                  2: 3 modclks                                                                                                  3: 4 modclks" range="" rwaccess="R">
         
      </bitfield>
   </register>
   <register id="MDCFG18" acronym="MDCFG18" offset="0x648" width="32" description="Module Configuration 18 Register">
      <bitfield id="_RESV" width="10" begin="31" end="22" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="_RESV" width="1" begin="21" end="21" resetval="0" description="Reserved for PWRDOM expansion to up to 64 domains " range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="PWRDOM" width="5" begin="20" end="16" resetval="0" description="Power Domain                                                                                               Indicates which power domain this module belongs to (0 to 31)" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="_RESV" width="6" begin="15" end="10" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="MSTGKT" width="1" begin="9" end="9" resetval="0" description="Master Gasket support. Reflects the RTL parameter MSTGKT                     0: Master Gasket not supported by LPSC                                                     1: Master Gasket supported by LPSC" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="PERMDIS" width="1" begin="8" end="8" resetval="0" description="Permanently Disable                                                                                      Not documented to users                                                                              0: Not permanently disable module                                                                1: Permamanently disable module" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="CKRST" width="1" begin="7" end="7" resetval="0" description="Modclk During MSM reset source assert. Shows the tieoff d_mdcfg[x]_clk_during_hard_rst_src.                                                          MSM reset source is either hard_rst_src_assert_pi_n or any_rst_src_assert_pi_n                                                                              0: LPSC does not give modclk when its MSM reset source is asserted. LPSC only gives modclk after the MSM reset source is de-asserted           1: LPSC gives modclk even when the MSM reset source is asserted" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="PLLCKGT" width="1" begin="6" end="6" resetval="0" description="PLL Clock gate. Shows the tieoff d_mdcfg[x]_pll_handshake                      0: LPSC gates modclk directly                                                                       1: LPSC does not gate modclk directly. LPSC instructs the PLLCTRL to gate modclk." range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="LSRSTBLK" width="1" begin="5" end="5" resetval="0" description="LRST Soft Reset Block. Shows the tieoff d_mdcfg[x]_lrst_soft_rst_block value.                                                                                                             0: Soft resets are not blocked to LRST.                                                        1: Soft resets are blocked to LRST." range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="SRSTBLK" width="1" begin="4" end="4" resetval="0" description="Soft Reset Block. Shows the tieoff d_mdcfg[x]_soft_rst_block value.        0: Soft resets are not blocked. Any grstz from PLLCTRL will be propagated to the module                                                                              1: Soft resets are blocked LPSC only passes hard resets to the module" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="_RESV" width="2" begin="3" end="2" resetval="0" description="Reserved for NUMCLK expansion" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="NUMCLK" width="2" begin="1" end="0" resetval="0" description="Number of modclks supported on LPSC                                                        0: 1 modclk                                                                                                    1: 2 modclks                                                                                                  2: 3 modclks                                                                                                  3: 4 modclks" range="" rwaccess="R">
         
      </bitfield>
   </register>
   <register id="MDCFG19" acronym="MDCFG19" offset="0x64C" width="32" description="Module Configuration 19 Register">
      <bitfield id="_RESV" width="10" begin="31" end="22" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="_RESV" width="1" begin="21" end="21" resetval="0" description="Reserved for PWRDOM expansion to up to 64 domains " range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="PWRDOM" width="5" begin="20" end="16" resetval="0" description="Power Domain                                                                                               Indicates which power domain this module belongs to (0 to 31)" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="_RESV" width="6" begin="15" end="10" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="MSTGKT" width="1" begin="9" end="9" resetval="0" description="Master Gasket support. Reflects the RTL parameter MSTGKT                     0: Master Gasket not supported by LPSC                                                     1: Master Gasket supported by LPSC" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="PERMDIS" width="1" begin="8" end="8" resetval="0" description="Permanently Disable                                                                                      Not documented to users                                                                              0: Not permanently disable module                                                                1: Permamanently disable module" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="CKRST" width="1" begin="7" end="7" resetval="0" description="Modclk During MSM reset source assert. Shows the tieoff d_mdcfg[x]_clk_during_hard_rst_src.                                                          MSM reset source is either hard_rst_src_assert_pi_n or any_rst_src_assert_pi_n                                                                              0: LPSC does not give modclk when its MSM reset source is asserted. LPSC only gives modclk after the MSM reset source is de-asserted           1: LPSC gives modclk even when the MSM reset source is asserted" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="PLLCKGT" width="1" begin="6" end="6" resetval="0" description="PLL Clock gate. Shows the tieoff d_mdcfg[x]_pll_handshake                      0: LPSC gates modclk directly                                                                       1: LPSC does not gate modclk directly. LPSC instructs the PLLCTRL to gate modclk." range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="LSRSTBLK" width="1" begin="5" end="5" resetval="0" description="LRST Soft Reset Block. Shows the tieoff d_mdcfg[x]_lrst_soft_rst_block value.                                                                                                             0: Soft resets are not blocked to LRST.                                                        1: Soft resets are blocked to LRST." range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="SRSTBLK" width="1" begin="4" end="4" resetval="0" description="Soft Reset Block. Shows the tieoff d_mdcfg[x]_soft_rst_block value.        0: Soft resets are not blocked. Any grstz from PLLCTRL will be propagated to the module                                                                              1: Soft resets are blocked LPSC only passes hard resets to the module" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="_RESV" width="2" begin="3" end="2" resetval="0" description="Reserved for NUMCLK expansion" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="NUMCLK" width="2" begin="1" end="0" resetval="0" description="Number of modclks supported on LPSC                                                        0: 1 modclk                                                                                                    1: 2 modclks                                                                                                  2: 3 modclks                                                                                                  3: 4 modclks" range="" rwaccess="R">
         
      </bitfield>
   </register>
   <register id="MDCFG20" acronym="MDCFG20" offset="0x650" width="32" description="Module Configuration 20 Register">
      <bitfield id="_RESV" width="10" begin="31" end="22" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="_RESV" width="1" begin="21" end="21" resetval="0" description="Reserved for PWRDOM expansion to up to 64 domains " range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="PWRDOM" width="5" begin="20" end="16" resetval="0" description="Power Domain                                                                                               Indicates which power domain this module belongs to (0 to 31)" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="_RESV" width="6" begin="15" end="10" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="MSTGKT" width="1" begin="9" end="9" resetval="0" description="Master Gasket support. Reflects the RTL parameter MSTGKT                     0: Master Gasket not supported by LPSC                                                     1: Master Gasket supported by LPSC" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="PERMDIS" width="1" begin="8" end="8" resetval="0" description="Permanently Disable                                                                                      Not documented to users                                                                              0: Not permanently disable module                                                                1: Permamanently disable module" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="CKRST" width="1" begin="7" end="7" resetval="0" description="Modclk During MSM reset source assert. Shows the tieoff d_mdcfg[x]_clk_during_hard_rst_src.                                                          MSM reset source is either hard_rst_src_assert_pi_n or any_rst_src_assert_pi_n                                                                              0: LPSC does not give modclk when its MSM reset source is asserted. LPSC only gives modclk after the MSM reset source is de-asserted           1: LPSC gives modclk even when the MSM reset source is asserted" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="PLLCKGT" width="1" begin="6" end="6" resetval="0" description="PLL Clock gate. Shows the tieoff d_mdcfg[x]_pll_handshake                      0: LPSC gates modclk directly                                                                       1: LPSC does not gate modclk directly. LPSC instructs the PLLCTRL to gate modclk." range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="LSRSTBLK" width="1" begin="5" end="5" resetval="0" description="LRST Soft Reset Block. Shows the tieoff d_mdcfg[x]_lrst_soft_rst_block value.                                                                                                             0: Soft resets are not blocked to LRST.                                                        1: Soft resets are blocked to LRST." range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="SRSTBLK" width="1" begin="4" end="4" resetval="0" description="Soft Reset Block. Shows the tieoff d_mdcfg[x]_soft_rst_block value.        0: Soft resets are not blocked. Any grstz from PLLCTRL will be propagated to the module                                                                              1: Soft resets are blocked LPSC only passes hard resets to the module" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="_RESV" width="2" begin="3" end="2" resetval="0" description="Reserved for NUMCLK expansion" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="NUMCLK" width="2" begin="1" end="0" resetval="0" description="Number of modclks supported on LPSC                                                        0: 1 modclk                                                                                                    1: 2 modclks                                                                                                  2: 3 modclks                                                                                                  3: 4 modclks" range="" rwaccess="R">
         
      </bitfield>
   </register>
   <register id="MDCFG21" acronym="MDCFG21" offset="0x654" width="32" description="Module Configuration 21 Register">
      <bitfield id="_RESV" width="10" begin="31" end="22" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="_RESV" width="1" begin="21" end="21" resetval="0" description="Reserved for PWRDOM expansion to up to 64 domains " range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="PWRDOM" width="5" begin="20" end="16" resetval="0" description="Power Domain                                                                                               Indicates which power domain this module belongs to (0 to 31)" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="_RESV" width="6" begin="15" end="10" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="MSTGKT" width="1" begin="9" end="9" resetval="0" description="Master Gasket support. Reflects the RTL parameter MSTGKT                     0: Master Gasket not supported by LPSC                                                     1: Master Gasket supported by LPSC" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="PERMDIS" width="1" begin="8" end="8" resetval="0" description="Permanently Disable                                                                                      Not documented to users                                                                              0: Not permanently disable module                                                                1: Permamanently disable module" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="CKRST" width="1" begin="7" end="7" resetval="0" description="Modclk During MSM reset source assert. Shows the tieoff d_mdcfg[x]_clk_during_hard_rst_src.                                                          MSM reset source is either hard_rst_src_assert_pi_n or any_rst_src_assert_pi_n                                                                              0: LPSC does not give modclk when its MSM reset source is asserted. LPSC only gives modclk after the MSM reset source is de-asserted           1: LPSC gives modclk even when the MSM reset source is asserted" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="PLLCKGT" width="1" begin="6" end="6" resetval="0" description="PLL Clock gate. Shows the tieoff d_mdcfg[x]_pll_handshake                      0: LPSC gates modclk directly                                                                       1: LPSC does not gate modclk directly. LPSC instructs the PLLCTRL to gate modclk." range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="LSRSTBLK" width="1" begin="5" end="5" resetval="0" description="LRST Soft Reset Block. Shows the tieoff d_mdcfg[x]_lrst_soft_rst_block value.                                                                                                             0: Soft resets are not blocked to LRST.                                                        1: Soft resets are blocked to LRST." range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="SRSTBLK" width="1" begin="4" end="4" resetval="0" description="Soft Reset Block. Shows the tieoff d_mdcfg[x]_soft_rst_block value.        0: Soft resets are not blocked. Any grstz from PLLCTRL will be propagated to the module                                                                              1: Soft resets are blocked LPSC only passes hard resets to the module" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="_RESV" width="2" begin="3" end="2" resetval="0" description="Reserved for NUMCLK expansion" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="NUMCLK" width="2" begin="1" end="0" resetval="0" description="Number of modclks supported on LPSC                                                        0: 1 modclk                                                                                                    1: 2 modclks                                                                                                  2: 3 modclks                                                                                                  3: 4 modclks" range="" rwaccess="R">
         
      </bitfield>
   </register>
   <register id="MDCFG22" acronym="MDCFG22" offset="0x658" width="32" description="Module Configuration 22 Register">
      <bitfield id="_RESV" width="10" begin="31" end="22" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="_RESV" width="1" begin="21" end="21" resetval="0" description="Reserved for PWRDOM expansion to up to 64 domains " range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="PWRDOM" width="5" begin="20" end="16" resetval="0" description="Power Domain                                                                                               Indicates which power domain this module belongs to (0 to 31)" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="_RESV" width="6" begin="15" end="10" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="MSTGKT" width="1" begin="9" end="9" resetval="0" description="Master Gasket support. Reflects the RTL parameter MSTGKT                     0: Master Gasket not supported by LPSC                                                     1: Master Gasket supported by LPSC" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="PERMDIS" width="1" begin="8" end="8" resetval="0" description="Permanently Disable                                                                                      Not documented to users                                                                              0: Not permanently disable module                                                                1: Permamanently disable module" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="CKRST" width="1" begin="7" end="7" resetval="0" description="Modclk During MSM reset source assert. Shows the tieoff d_mdcfg[x]_clk_during_hard_rst_src.                                                          MSM reset source is either hard_rst_src_assert_pi_n or any_rst_src_assert_pi_n                                                                              0: LPSC does not give modclk when its MSM reset source is asserted. LPSC only gives modclk after the MSM reset source is de-asserted           1: LPSC gives modclk even when the MSM reset source is asserted" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="PLLCKGT" width="1" begin="6" end="6" resetval="0" description="PLL Clock gate. Shows the tieoff d_mdcfg[x]_pll_handshake                      0: LPSC gates modclk directly                                                                       1: LPSC does not gate modclk directly. LPSC instructs the PLLCTRL to gate modclk." range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="LSRSTBLK" width="1" begin="5" end="5" resetval="0" description="LRST Soft Reset Block. Shows the tieoff d_mdcfg[x]_lrst_soft_rst_block value.                                                                                                             0: Soft resets are not blocked to LRST.                                                        1: Soft resets are blocked to LRST." range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="SRSTBLK" width="1" begin="4" end="4" resetval="0" description="Soft Reset Block. Shows the tieoff d_mdcfg[x]_soft_rst_block value.        0: Soft resets are not blocked. Any grstz from PLLCTRL will be propagated to the module                                                                              1: Soft resets are blocked LPSC only passes hard resets to the module" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="_RESV" width="2" begin="3" end="2" resetval="0" description="Reserved for NUMCLK expansion" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="NUMCLK" width="2" begin="1" end="0" resetval="0" description="Number of modclks supported on LPSC                                                        0: 1 modclk                                                                                                    1: 2 modclks                                                                                                  2: 3 modclks                                                                                                  3: 4 modclks" range="" rwaccess="R">
         
      </bitfield>
   </register>
   <register id="MDCFG23" acronym="MDCFG23" offset="0x65C" width="32" description="Module Configuration 23 Register">
      <bitfield id="_RESV" width="10" begin="31" end="22" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="_RESV" width="1" begin="21" end="21" resetval="0" description="Reserved for PWRDOM expansion to up to 64 domains " range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="PWRDOM" width="5" begin="20" end="16" resetval="0" description="Power Domain                                                                                               Indicates which power domain this module belongs to (0 to 31)" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="_RESV" width="6" begin="15" end="10" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="MSTGKT" width="1" begin="9" end="9" resetval="0" description="Master Gasket support. Reflects the RTL parameter MSTGKT                     0: Master Gasket not supported by LPSC                                                     1: Master Gasket supported by LPSC" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="PERMDIS" width="1" begin="8" end="8" resetval="0" description="Permanently Disable                                                                                      Not documented to users                                                                              0: Not permanently disable module                                                                1: Permamanently disable module" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="CKRST" width="1" begin="7" end="7" resetval="0" description="Modclk During MSM reset source assert. Shows the tieoff d_mdcfg[x]_clk_during_hard_rst_src.                                                          MSM reset source is either hard_rst_src_assert_pi_n or any_rst_src_assert_pi_n                                                                              0: LPSC does not give modclk when its MSM reset source is asserted. LPSC only gives modclk after the MSM reset source is de-asserted           1: LPSC gives modclk even when the MSM reset source is asserted" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="PLLCKGT" width="1" begin="6" end="6" resetval="0" description="PLL Clock gate. Shows the tieoff d_mdcfg[x]_pll_handshake                      0: LPSC gates modclk directly                                                                       1: LPSC does not gate modclk directly. LPSC instructs the PLLCTRL to gate modclk." range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="LSRSTBLK" width="1" begin="5" end="5" resetval="0" description="LRST Soft Reset Block. Shows the tieoff d_mdcfg[x]_lrst_soft_rst_block value.                                                                                                             0: Soft resets are not blocked to LRST.                                                        1: Soft resets are blocked to LRST." range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="SRSTBLK" width="1" begin="4" end="4" resetval="0" description="Soft Reset Block. Shows the tieoff d_mdcfg[x]_soft_rst_block value.        0: Soft resets are not blocked. Any grstz from PLLCTRL will be propagated to the module                                                                              1: Soft resets are blocked LPSC only passes hard resets to the module" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="_RESV" width="2" begin="3" end="2" resetval="0" description="Reserved for NUMCLK expansion" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="NUMCLK" width="2" begin="1" end="0" resetval="0" description="Number of modclks supported on LPSC                                                        0: 1 modclk                                                                                                    1: 2 modclks                                                                                                  2: 3 modclks                                                                                                  3: 4 modclks" range="" rwaccess="R">
         
      </bitfield>
   </register>
   <register id="MDCFG24" acronym="MDCFG24" offset="0x660" width="32" description="Module Configuration 24 Register">
      <bitfield id="_RESV" width="10" begin="31" end="22" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="_RESV" width="1" begin="21" end="21" resetval="0" description="Reserved for PWRDOM expansion to up to 64 domains " range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="PWRDOM" width="5" begin="20" end="16" resetval="0" description="Power Domain                                                                                               Indicates which power domain this module belongs to (0 to 31)" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="_RESV" width="6" begin="15" end="10" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="MSTGKT" width="1" begin="9" end="9" resetval="0" description="Master Gasket support. Reflects the RTL parameter MSTGKT                     0: Master Gasket not supported by LPSC                                                     1: Master Gasket supported by LPSC" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="PERMDIS" width="1" begin="8" end="8" resetval="0" description="Permanently Disable                                                                                      Not documented to users                                                                              0: Not permanently disable module                                                                1: Permamanently disable module" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="CKRST" width="1" begin="7" end="7" resetval="0" description="Modclk During MSM reset source assert. Shows the tieoff d_mdcfg[x]_clk_during_hard_rst_src.                                                          MSM reset source is either hard_rst_src_assert_pi_n or any_rst_src_assert_pi_n                                                                              0: LPSC does not give modclk when its MSM reset source is asserted. LPSC only gives modclk after the MSM reset source is de-asserted           1: LPSC gives modclk even when the MSM reset source is asserted" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="PLLCKGT" width="1" begin="6" end="6" resetval="0" description="PLL Clock gate. Shows the tieoff d_mdcfg[x]_pll_handshake                      0: LPSC gates modclk directly                                                                       1: LPSC does not gate modclk directly. LPSC instructs the PLLCTRL to gate modclk." range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="LSRSTBLK" width="1" begin="5" end="5" resetval="0" description="LRST Soft Reset Block. Shows the tieoff d_mdcfg[x]_lrst_soft_rst_block value.                                                                                                             0: Soft resets are not blocked to LRST.                                                        1: Soft resets are blocked to LRST." range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="SRSTBLK" width="1" begin="4" end="4" resetval="0" description="Soft Reset Block. Shows the tieoff d_mdcfg[x]_soft_rst_block value.        0: Soft resets are not blocked. Any grstz from PLLCTRL will be propagated to the module                                                                              1: Soft resets are blocked LPSC only passes hard resets to the module" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="_RESV" width="2" begin="3" end="2" resetval="0" description="Reserved for NUMCLK expansion" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="NUMCLK" width="2" begin="1" end="0" resetval="0" description="Number of modclks supported on LPSC                                                        0: 1 modclk                                                                                                    1: 2 modclks                                                                                                  2: 3 modclks                                                                                                  3: 4 modclks" range="" rwaccess="R">
         
      </bitfield>
   </register>
   <register id="MDCFG25" acronym="MDCFG25" offset="0x664" width="32" description="Module Configuration 25 Register">
      <bitfield id="_RESV" width="10" begin="31" end="22" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="_RESV" width="1" begin="21" end="21" resetval="0" description="Reserved for PWRDOM expansion to up to 64 domains " range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="PWRDOM" width="5" begin="20" end="16" resetval="0" description="Power Domain                                                                                               Indicates which power domain this module belongs to (0 to 31)" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="_RESV" width="6" begin="15" end="10" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="MSTGKT" width="1" begin="9" end="9" resetval="0" description="Master Gasket support. Reflects the RTL parameter MSTGKT                     0: Master Gasket not supported by LPSC                                                     1: Master Gasket supported by LPSC" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="PERMDIS" width="1" begin="8" end="8" resetval="0" description="Permanently Disable                                                                                      Not documented to users                                                                              0: Not permanently disable module                                                                1: Permamanently disable module" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="CKRST" width="1" begin="7" end="7" resetval="0" description="Modclk During MSM reset source assert. Shows the tieoff d_mdcfg[x]_clk_during_hard_rst_src.                                                          MSM reset source is either hard_rst_src_assert_pi_n or any_rst_src_assert_pi_n                                                                              0: LPSC does not give modclk when its MSM reset source is asserted. LPSC only gives modclk after the MSM reset source is de-asserted           1: LPSC gives modclk even when the MSM reset source is asserted" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="PLLCKGT" width="1" begin="6" end="6" resetval="0" description="PLL Clock gate. Shows the tieoff d_mdcfg[x]_pll_handshake                      0: LPSC gates modclk directly                                                                       1: LPSC does not gate modclk directly. LPSC instructs the PLLCTRL to gate modclk." range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="LSRSTBLK" width="1" begin="5" end="5" resetval="0" description="LRST Soft Reset Block. Shows the tieoff d_mdcfg[x]_lrst_soft_rst_block value.                                                                                                             0: Soft resets are not blocked to LRST.                                                        1: Soft resets are blocked to LRST." range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="SRSTBLK" width="1" begin="4" end="4" resetval="0" description="Soft Reset Block. Shows the tieoff d_mdcfg[x]_soft_rst_block value.        0: Soft resets are not blocked. Any grstz from PLLCTRL will be propagated to the module                                                                              1: Soft resets are blocked LPSC only passes hard resets to the module" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="_RESV" width="2" begin="3" end="2" resetval="0" description="Reserved for NUMCLK expansion" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="NUMCLK" width="2" begin="1" end="0" resetval="0" description="Number of modclks supported on LPSC                                                        0: 1 modclk                                                                                                    1: 2 modclks                                                                                                  2: 3 modclks                                                                                                  3: 4 modclks" range="" rwaccess="R">
         
      </bitfield>
   </register>
   <register id="MDCFG26" acronym="MDCFG26" offset="0x668" width="32" description="Module Configuration 26 Register">
      <bitfield id="_RESV" width="10" begin="31" end="22" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="_RESV" width="1" begin="21" end="21" resetval="0" description="Reserved for PWRDOM expansion to up to 64 domains " range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="PWRDOM" width="5" begin="20" end="16" resetval="0" description="Power Domain                                                                                               Indicates which power domain this module belongs to (0 to 31)" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="_RESV" width="6" begin="15" end="10" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="MSTGKT" width="1" begin="9" end="9" resetval="0" description="Master Gasket support. Reflects the RTL parameter MSTGKT                     0: Master Gasket not supported by LPSC                                                     1: Master Gasket supported by LPSC" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="PERMDIS" width="1" begin="8" end="8" resetval="0" description="Permanently Disable                                                                                      Not documented to users                                                                              0: Not permanently disable module                                                                1: Permamanently disable module" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="CKRST" width="1" begin="7" end="7" resetval="0" description="Modclk During MSM reset source assert. Shows the tieoff d_mdcfg[x]_clk_during_hard_rst_src.                                                          MSM reset source is either hard_rst_src_assert_pi_n or any_rst_src_assert_pi_n                                                                              0: LPSC does not give modclk when its MSM reset source is asserted. LPSC only gives modclk after the MSM reset source is de-asserted           1: LPSC gives modclk even when the MSM reset source is asserted" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="PLLCKGT" width="1" begin="6" end="6" resetval="0" description="PLL Clock gate. Shows the tieoff d_mdcfg[x]_pll_handshake                      0: LPSC gates modclk directly                                                                       1: LPSC does not gate modclk directly. LPSC instructs the PLLCTRL to gate modclk." range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="LSRSTBLK" width="1" begin="5" end="5" resetval="0" description="LRST Soft Reset Block. Shows the tieoff d_mdcfg[x]_lrst_soft_rst_block value.                                                                                                             0: Soft resets are not blocked to LRST.                                                        1: Soft resets are blocked to LRST." range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="SRSTBLK" width="1" begin="4" end="4" resetval="0" description="Soft Reset Block. Shows the tieoff d_mdcfg[x]_soft_rst_block value.        0: Soft resets are not blocked. Any grstz from PLLCTRL will be propagated to the module                                                                              1: Soft resets are blocked LPSC only passes hard resets to the module" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="_RESV" width="2" begin="3" end="2" resetval="0" description="Reserved for NUMCLK expansion" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="NUMCLK" width="2" begin="1" end="0" resetval="0" description="Number of modclks supported on LPSC                                                        0: 1 modclk                                                                                                    1: 2 modclks                                                                                                  2: 3 modclks                                                                                                  3: 4 modclks" range="" rwaccess="R">
         
      </bitfield>
   </register>
   <register id="MDCFG27" acronym="MDCFG27" offset="0x66C" width="32" description="Module Configuration 27 Register">
      <bitfield id="_RESV" width="10" begin="31" end="22" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="_RESV" width="1" begin="21" end="21" resetval="0" description="Reserved for PWRDOM expansion to up to 64 domains " range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="PWRDOM" width="5" begin="20" end="16" resetval="0" description="Power Domain                                                                                               Indicates which power domain this module belongs to (0 to 31)" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="_RESV" width="6" begin="15" end="10" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="MSTGKT" width="1" begin="9" end="9" resetval="0" description="Master Gasket support. Reflects the RTL parameter MSTGKT                     0: Master Gasket not supported by LPSC                                                     1: Master Gasket supported by LPSC" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="PERMDIS" width="1" begin="8" end="8" resetval="0" description="Permanently Disable                                                                                      Not documented to users                                                                              0: Not permanently disable module                                                                1: Permamanently disable module" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="CKRST" width="1" begin="7" end="7" resetval="0" description="Modclk During MSM reset source assert. Shows the tieoff d_mdcfg[x]_clk_during_hard_rst_src.                                                          MSM reset source is either hard_rst_src_assert_pi_n or any_rst_src_assert_pi_n                                                                              0: LPSC does not give modclk when its MSM reset source is asserted. LPSC only gives modclk after the MSM reset source is de-asserted           1: LPSC gives modclk even when the MSM reset source is asserted" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="PLLCKGT" width="1" begin="6" end="6" resetval="0" description="PLL Clock gate. Shows the tieoff d_mdcfg[x]_pll_handshake                      0: LPSC gates modclk directly                                                                       1: LPSC does not gate modclk directly. LPSC instructs the PLLCTRL to gate modclk." range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="LSRSTBLK" width="1" begin="5" end="5" resetval="0" description="LRST Soft Reset Block. Shows the tieoff d_mdcfg[x]_lrst_soft_rst_block value.                                                                                                             0: Soft resets are not blocked to LRST.                                                        1: Soft resets are blocked to LRST." range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="SRSTBLK" width="1" begin="4" end="4" resetval="0" description="Soft Reset Block. Shows the tieoff d_mdcfg[x]_soft_rst_block value.        0: Soft resets are not blocked. Any grstz from PLLCTRL will be propagated to the module                                                                              1: Soft resets are blocked LPSC only passes hard resets to the module" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="_RESV" width="2" begin="3" end="2" resetval="0" description="Reserved for NUMCLK expansion" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="NUMCLK" width="2" begin="1" end="0" resetval="0" description="Number of modclks supported on LPSC                                                        0: 1 modclk                                                                                                    1: 2 modclks                                                                                                  2: 3 modclks                                                                                                  3: 4 modclks" range="" rwaccess="R">
         
      </bitfield>
   </register>
   <register id="MDCFG28" acronym="MDCFG28" offset="0x670" width="32" description="Module Configuration 28 Register">
      <bitfield id="_RESV" width="10" begin="31" end="22" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="_RESV" width="1" begin="21" end="21" resetval="0" description="Reserved for PWRDOM expansion to up to 64 domains " range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="PWRDOM" width="5" begin="20" end="16" resetval="0" description="Power Domain                                                                                               Indicates which power domain this module belongs to (0 to 31)" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="_RESV" width="6" begin="15" end="10" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="MSTGKT" width="1" begin="9" end="9" resetval="0" description="Master Gasket support. Reflects the RTL parameter MSTGKT                     0: Master Gasket not supported by LPSC                                                     1: Master Gasket supported by LPSC" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="PERMDIS" width="1" begin="8" end="8" resetval="0" description="Permanently Disable                                                                                      Not documented to users                                                                              0: Not permanently disable module                                                                1: Permamanently disable module" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="CKRST" width="1" begin="7" end="7" resetval="0" description="Modclk During MSM reset source assert. Shows the tieoff d_mdcfg[x]_clk_during_hard_rst_src.                                                          MSM reset source is either hard_rst_src_assert_pi_n or any_rst_src_assert_pi_n                                                                              0: LPSC does not give modclk when its MSM reset source is asserted. LPSC only gives modclk after the MSM reset source is de-asserted           1: LPSC gives modclk even when the MSM reset source is asserted" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="PLLCKGT" width="1" begin="6" end="6" resetval="0" description="PLL Clock gate. Shows the tieoff d_mdcfg[x]_pll_handshake                      0: LPSC gates modclk directly                                                                       1: LPSC does not gate modclk directly. LPSC instructs the PLLCTRL to gate modclk." range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="LSRSTBLK" width="1" begin="5" end="5" resetval="0" description="LRST Soft Reset Block. Shows the tieoff d_mdcfg[x]_lrst_soft_rst_block value.                                                                                                             0: Soft resets are not blocked to LRST.                                                        1: Soft resets are blocked to LRST." range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="SRSTBLK" width="1" begin="4" end="4" resetval="0" description="Soft Reset Block. Shows the tieoff d_mdcfg[x]_soft_rst_block value.        0: Soft resets are not blocked. Any grstz from PLLCTRL will be propagated to the module                                                                              1: Soft resets are blocked LPSC only passes hard resets to the module" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="_RESV" width="2" begin="3" end="2" resetval="0" description="Reserved for NUMCLK expansion" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="NUMCLK" width="2" begin="1" end="0" resetval="0" description="Number of modclks supported on LPSC                                                        0: 1 modclk                                                                                                    1: 2 modclks                                                                                                  2: 3 modclks                                                                                                  3: 4 modclks" range="" rwaccess="R">
         
      </bitfield>
   </register>
   <register id="MDCFG29" acronym="MDCFG29" offset="0x674" width="32" description="Module Configuration 29 Register">
      <bitfield id="_RESV" width="10" begin="31" end="22" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="_RESV" width="1" begin="21" end="21" resetval="0" description="Reserved for PWRDOM expansion to up to 64 domains " range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="PWRDOM" width="5" begin="20" end="16" resetval="0" description="Power Domain                                                                                               Indicates which power domain this module belongs to (0 to 31)" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="_RESV" width="6" begin="15" end="10" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="MSTGKT" width="1" begin="9" end="9" resetval="0" description="Master Gasket support. Reflects the RTL parameter MSTGKT                     0: Master Gasket not supported by LPSC                                                     1: Master Gasket supported by LPSC" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="PERMDIS" width="1" begin="8" end="8" resetval="0" description="Permanently Disable                                                                                      Not documented to users                                                                              0: Not permanently disable module                                                                1: Permamanently disable module" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="CKRST" width="1" begin="7" end="7" resetval="0" description="Modclk During MSM reset source assert. Shows the tieoff d_mdcfg[x]_clk_during_hard_rst_src.                                                          MSM reset source is either hard_rst_src_assert_pi_n or any_rst_src_assert_pi_n                                                                              0: LPSC does not give modclk when its MSM reset source is asserted. LPSC only gives modclk after the MSM reset source is de-asserted           1: LPSC gives modclk even when the MSM reset source is asserted" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="PLLCKGT" width="1" begin="6" end="6" resetval="0" description="PLL Clock gate. Shows the tieoff d_mdcfg[x]_pll_handshake                      0: LPSC gates modclk directly                                                                       1: LPSC does not gate modclk directly. LPSC instructs the PLLCTRL to gate modclk." range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="LSRSTBLK" width="1" begin="5" end="5" resetval="0" description="LRST Soft Reset Block. Shows the tieoff d_mdcfg[x]_lrst_soft_rst_block value.                                                                                                             0: Soft resets are not blocked to LRST.                                                        1: Soft resets are blocked to LRST." range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="SRSTBLK" width="1" begin="4" end="4" resetval="0" description="Soft Reset Block. Shows the tieoff d_mdcfg[x]_soft_rst_block value.        0: Soft resets are not blocked. Any grstz from PLLCTRL will be propagated to the module                                                                              1: Soft resets are blocked LPSC only passes hard resets to the module" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="_RESV" width="2" begin="3" end="2" resetval="0" description="Reserved for NUMCLK expansion" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="NUMCLK" width="2" begin="1" end="0" resetval="0" description="Number of modclks supported on LPSC                                                        0: 1 modclk                                                                                                    1: 2 modclks                                                                                                  2: 3 modclks                                                                                                  3: 4 modclks" range="" rwaccess="R">
         
      </bitfield>
   </register>
   <register id="MDCFG30" acronym="MDCFG30" offset="0x678" width="32" description="Module Configuration 30 Register">
      <bitfield id="_RESV" width="10" begin="31" end="22" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="_RESV" width="1" begin="21" end="21" resetval="0" description="Reserved for PWRDOM expansion to up to 64 domains " range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="PWRDOM" width="5" begin="20" end="16" resetval="0" description="Power Domain                                                                                               Indicates which power domain this module belongs to (0 to 31)" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="_RESV" width="6" begin="15" end="10" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="MSTGKT" width="1" begin="9" end="9" resetval="0" description="Master Gasket support. Reflects the RTL parameter MSTGKT                     0: Master Gasket not supported by LPSC                                                     1: Master Gasket supported by LPSC" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="PERMDIS" width="1" begin="8" end="8" resetval="0" description="Permanently Disable                                                                                      Not documented to users                                                                              0: Not permanently disable module                                                                1: Permamanently disable module" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="CKRST" width="1" begin="7" end="7" resetval="0" description="Modclk During MSM reset source assert. Shows the tieoff d_mdcfg[x]_clk_during_hard_rst_src.                                                          MSM reset source is either hard_rst_src_assert_pi_n or any_rst_src_assert_pi_n                                                                              0: LPSC does not give modclk when its MSM reset source is asserted. LPSC only gives modclk after the MSM reset source is de-asserted           1: LPSC gives modclk even when the MSM reset source is asserted" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="PLLCKGT" width="1" begin="6" end="6" resetval="0" description="PLL Clock gate. Shows the tieoff d_mdcfg[x]_pll_handshake                      0: LPSC gates modclk directly                                                                       1: LPSC does not gate modclk directly. LPSC instructs the PLLCTRL to gate modclk." range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="LSRSTBLK" width="1" begin="5" end="5" resetval="0" description="LRST Soft Reset Block. Shows the tieoff d_mdcfg[x]_lrst_soft_rst_block value.                                                                                                             0: Soft resets are not blocked to LRST.                                                        1: Soft resets are blocked to LRST." range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="SRSTBLK" width="1" begin="4" end="4" resetval="0" description="Soft Reset Block. Shows the tieoff d_mdcfg[x]_soft_rst_block value.        0: Soft resets are not blocked. Any grstz from PLLCTRL will be propagated to the module                                                                              1: Soft resets are blocked LPSC only passes hard resets to the module" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="_RESV" width="2" begin="3" end="2" resetval="0" description="Reserved for NUMCLK expansion" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="NUMCLK" width="2" begin="1" end="0" resetval="0" description="Number of modclks supported on LPSC                                                        0: 1 modclk                                                                                                    1: 2 modclks                                                                                                  2: 3 modclks                                                                                                  3: 4 modclks" range="" rwaccess="R">
         
      </bitfield>
   </register>
   <register id="MDCFG31" acronym="MDCFG31" offset="0x67C" width="32" description="Module Configuration 31 Register">
      <bitfield id="_RESV" width="10" begin="31" end="22" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="_RESV" width="1" begin="21" end="21" resetval="0" description="Reserved for PWRDOM expansion to up to 64 domains " range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="PWRDOM" width="5" begin="20" end="16" resetval="0" description="Power Domain                                                                                               Indicates which power domain this module belongs to (0 to 31)" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="_RESV" width="6" begin="15" end="10" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="MSTGKT" width="1" begin="9" end="9" resetval="0" description="Master Gasket support. Reflects the RTL parameter MSTGKT                     0: Master Gasket not supported by LPSC                                                     1: Master Gasket supported by LPSC" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="PERMDIS" width="1" begin="8" end="8" resetval="0" description="Permanently Disable                                                                                      Not documented to users                                                                              0: Not permanently disable module                                                                1: Permamanently disable module" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="CKRST" width="1" begin="7" end="7" resetval="0" description="Modclk During MSM reset source assert. Shows the tieoff d_mdcfg[x]_clk_during_hard_rst_src.                                                          MSM reset source is either hard_rst_src_assert_pi_n or any_rst_src_assert_pi_n                                                                              0: LPSC does not give modclk when its MSM reset source is asserted. LPSC only gives modclk after the MSM reset source is de-asserted           1: LPSC gives modclk even when the MSM reset source is asserted" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="PLLCKGT" width="1" begin="6" end="6" resetval="0" description="PLL Clock gate. Shows the tieoff d_mdcfg[x]_pll_handshake                      0: LPSC gates modclk directly                                                                       1: LPSC does not gate modclk directly. LPSC instructs the PLLCTRL to gate modclk." range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="LSRSTBLK" width="1" begin="5" end="5" resetval="0" description="LRST Soft Reset Block. Shows the tieoff d_mdcfg[x]_lrst_soft_rst_block value.                                                                                                             0: Soft resets are not blocked to LRST.                                                        1: Soft resets are blocked to LRST." range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="SRSTBLK" width="1" begin="4" end="4" resetval="0" description="Soft Reset Block. Shows the tieoff d_mdcfg[x]_soft_rst_block value.        0: Soft resets are not blocked. Any grstz from PLLCTRL will be propagated to the module                                                                              1: Soft resets are blocked LPSC only passes hard resets to the module" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="_RESV" width="2" begin="3" end="2" resetval="0" description="Reserved for NUMCLK expansion" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="NUMCLK" width="2" begin="1" end="0" resetval="0" description="Number of modclks supported on LPSC                                                        0: 1 modclk                                                                                                    1: 2 modclks                                                                                                  2: 3 modclks                                                                                                  3: 4 modclks" range="" rwaccess="R">
         
      </bitfield>
   </register>
   <register id="MDCFG32" acronym="MDCFG32" offset="0x680" width="32" description="Module Configuration 32 Register">
      <bitfield id="_RESV" width="10" begin="31" end="22" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="_RESV" width="1" begin="21" end="21" resetval="0" description="Reserved for PWRDOM expansion to up to 64 domains " range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="PWRDOM" width="5" begin="20" end="16" resetval="0" description="Power Domain                                                                                               Indicates which power domain this module belongs to (0 to 31)" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="_RESV" width="6" begin="15" end="10" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="MSTGKT" width="1" begin="9" end="9" resetval="0" description="Master Gasket support. Reflects the RTL parameter MSTGKT                     0: Master Gasket not supported by LPSC                                                     1: Master Gasket supported by LPSC" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="PERMDIS" width="1" begin="8" end="8" resetval="0" description="Permanently Disable                                                                                      Not documented to users                                                                              0: Not permanently disable module                                                                1: Permamanently disable module" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="CKRST" width="1" begin="7" end="7" resetval="0" description="Modclk During MSM reset source assert. Shows the tieoff d_mdcfg[x]_clk_during_hard_rst_src.                                                          MSM reset source is either hard_rst_src_assert_pi_n or any_rst_src_assert_pi_n                                                                              0: LPSC does not give modclk when its MSM reset source is asserted. LPSC only gives modclk after the MSM reset source is de-asserted           1: LPSC gives modclk even when the MSM reset source is asserted" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="PLLCKGT" width="1" begin="6" end="6" resetval="0" description="PLL Clock gate. Shows the tieoff d_mdcfg[x]_pll_handshake                      0: LPSC gates modclk directly                                                                       1: LPSC does not gate modclk directly. LPSC instructs the PLLCTRL to gate modclk." range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="LSRSTBLK" width="1" begin="5" end="5" resetval="0" description="LRST Soft Reset Block. Shows the tieoff d_mdcfg[x]_lrst_soft_rst_block value.                                                                                                             0: Soft resets are not blocked to LRST.                                                        1: Soft resets are blocked to LRST." range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="SRSTBLK" width="1" begin="4" end="4" resetval="0" description="Soft Reset Block. Shows the tieoff d_mdcfg[x]_soft_rst_block value.        0: Soft resets are not blocked. Any grstz from PLLCTRL will be propagated to the module                                                                              1: Soft resets are blocked LPSC only passes hard resets to the module" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="_RESV" width="2" begin="3" end="2" resetval="0" description="Reserved for NUMCLK expansion" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="NUMCLK" width="2" begin="1" end="0" resetval="0" description="Number of modclks supported on LPSC                                                        0: 1 modclk                                                                                                    1: 2 modclks                                                                                                  2: 3 modclks                                                                                                  3: 4 modclks" range="" rwaccess="R">
         
      </bitfield>
   </register>
   <register id="MDCFG33" acronym="MDCFG33" offset="0x684" width="32" description="Module Configuration 33 Register">
      <bitfield id="_RESV" width="10" begin="31" end="22" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="_RESV" width="1" begin="21" end="21" resetval="0" description="Reserved for PWRDOM expansion to up to 64 domains " range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="PWRDOM" width="5" begin="20" end="16" resetval="0" description="Power Domain                                                                                               Indicates which power domain this module belongs to (0 to 31)" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="_RESV" width="6" begin="15" end="10" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="MSTGKT" width="1" begin="9" end="9" resetval="0" description="Master Gasket support. Reflects the RTL parameter MSTGKT                     0: Master Gasket not supported by LPSC                                                     1: Master Gasket supported by LPSC" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="PERMDIS" width="1" begin="8" end="8" resetval="0" description="Permanently Disable                                                                                      Not documented to users                                                                              0: Not permanently disable module                                                                1: Permamanently disable module" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="CKRST" width="1" begin="7" end="7" resetval="0" description="Modclk During MSM reset source assert. Shows the tieoff d_mdcfg[x]_clk_during_hard_rst_src.                                                          MSM reset source is either hard_rst_src_assert_pi_n or any_rst_src_assert_pi_n                                                                              0: LPSC does not give modclk when its MSM reset source is asserted. LPSC only gives modclk after the MSM reset source is de-asserted           1: LPSC gives modclk even when the MSM reset source is asserted" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="PLLCKGT" width="1" begin="6" end="6" resetval="0" description="PLL Clock gate. Shows the tieoff d_mdcfg[x]_pll_handshake                      0: LPSC gates modclk directly                                                                       1: LPSC does not gate modclk directly. LPSC instructs the PLLCTRL to gate modclk." range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="LSRSTBLK" width="1" begin="5" end="5" resetval="0" description="LRST Soft Reset Block. Shows the tieoff d_mdcfg[x]_lrst_soft_rst_block value.                                                                                                             0: Soft resets are not blocked to LRST.                                                        1: Soft resets are blocked to LRST." range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="SRSTBLK" width="1" begin="4" end="4" resetval="0" description="Soft Reset Block. Shows the tieoff d_mdcfg[x]_soft_rst_block value.        0: Soft resets are not blocked. Any grstz from PLLCTRL will be propagated to the module                                                                              1: Soft resets are blocked LPSC only passes hard resets to the module" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="_RESV" width="2" begin="3" end="2" resetval="0" description="Reserved for NUMCLK expansion" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="NUMCLK" width="2" begin="1" end="0" resetval="0" description="Number of modclks supported on LPSC                                                        0: 1 modclk                                                                                                    1: 2 modclks                                                                                                  2: 3 modclks                                                                                                  3: 4 modclks" range="" rwaccess="R">
         
      </bitfield>
   </register>
   <register id="MDCFG34" acronym="MDCFG34" offset="0x688" width="32" description="Module Configuration 34 Register">
      <bitfield id="_RESV" width="10" begin="31" end="22" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="_RESV" width="1" begin="21" end="21" resetval="0" description="Reserved for PWRDOM expansion to up to 64 domains " range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="PWRDOM" width="5" begin="20" end="16" resetval="0" description="Power Domain                                                                                               Indicates which power domain this module belongs to (0 to 31)" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="_RESV" width="6" begin="15" end="10" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="MSTGKT" width="1" begin="9" end="9" resetval="0" description="Master Gasket support. Reflects the RTL parameter MSTGKT                     0: Master Gasket not supported by LPSC                                                     1: Master Gasket supported by LPSC" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="PERMDIS" width="1" begin="8" end="8" resetval="0" description="Permanently Disable                                                                                      Not documented to users                                                                              0: Not permanently disable module                                                                1: Permamanently disable module" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="CKRST" width="1" begin="7" end="7" resetval="0" description="Modclk During MSM reset source assert. Shows the tieoff d_mdcfg[x]_clk_during_hard_rst_src.                                                          MSM reset source is either hard_rst_src_assert_pi_n or any_rst_src_assert_pi_n                                                                              0: LPSC does not give modclk when its MSM reset source is asserted. LPSC only gives modclk after the MSM reset source is de-asserted           1: LPSC gives modclk even when the MSM reset source is asserted" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="PLLCKGT" width="1" begin="6" end="6" resetval="0" description="PLL Clock gate. Shows the tieoff d_mdcfg[x]_pll_handshake                      0: LPSC gates modclk directly                                                                       1: LPSC does not gate modclk directly. LPSC instructs the PLLCTRL to gate modclk." range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="LSRSTBLK" width="1" begin="5" end="5" resetval="0" description="LRST Soft Reset Block. Shows the tieoff d_mdcfg[x]_lrst_soft_rst_block value.                                                                                                             0: Soft resets are not blocked to LRST.                                                        1: Soft resets are blocked to LRST." range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="SRSTBLK" width="1" begin="4" end="4" resetval="0" description="Soft Reset Block. Shows the tieoff d_mdcfg[x]_soft_rst_block value.        0: Soft resets are not blocked. Any grstz from PLLCTRL will be propagated to the module                                                                              1: Soft resets are blocked LPSC only passes hard resets to the module" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="_RESV" width="2" begin="3" end="2" resetval="0" description="Reserved for NUMCLK expansion" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="NUMCLK" width="2" begin="1" end="0" resetval="0" description="Number of modclks supported on LPSC                                                        0: 1 modclk                                                                                                    1: 2 modclks                                                                                                  2: 3 modclks                                                                                                  3: 4 modclks" range="" rwaccess="R">
         
      </bitfield>
   </register>
   <register id="MDCFG35" acronym="MDCFG35" offset="0x68C" width="32" description="Module Configuration 35 Register">
      <bitfield id="_RESV" width="10" begin="31" end="22" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="_RESV" width="1" begin="21" end="21" resetval="0" description="Reserved for PWRDOM expansion to up to 64 domains " range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="PWRDOM" width="5" begin="20" end="16" resetval="0" description="Power Domain                                                                                               Indicates which power domain this module belongs to (0 to 31)" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="_RESV" width="6" begin="15" end="10" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="MSTGKT" width="1" begin="9" end="9" resetval="0" description="Master Gasket support. Reflects the RTL parameter MSTGKT                     0: Master Gasket not supported by LPSC                                                     1: Master Gasket supported by LPSC" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="PERMDIS" width="1" begin="8" end="8" resetval="0" description="Permanently Disable                                                                                      Not documented to users                                                                              0: Not permanently disable module                                                                1: Permamanently disable module" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="CKRST" width="1" begin="7" end="7" resetval="0" description="Modclk During MSM reset source assert. Shows the tieoff d_mdcfg[x]_clk_during_hard_rst_src.                                                          MSM reset source is either hard_rst_src_assert_pi_n or any_rst_src_assert_pi_n                                                                              0: LPSC does not give modclk when its MSM reset source is asserted. LPSC only gives modclk after the MSM reset source is de-asserted           1: LPSC gives modclk even when the MSM reset source is asserted" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="PLLCKGT" width="1" begin="6" end="6" resetval="0" description="PLL Clock gate. Shows the tieoff d_mdcfg[x]_pll_handshake                      0: LPSC gates modclk directly                                                                       1: LPSC does not gate modclk directly. LPSC instructs the PLLCTRL to gate modclk." range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="LSRSTBLK" width="1" begin="5" end="5" resetval="0" description="LRST Soft Reset Block. Shows the tieoff d_mdcfg[x]_lrst_soft_rst_block value.                                                                                                             0: Soft resets are not blocked to LRST.                                                        1: Soft resets are blocked to LRST." range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="SRSTBLK" width="1" begin="4" end="4" resetval="0" description="Soft Reset Block. Shows the tieoff d_mdcfg[x]_soft_rst_block value.        0: Soft resets are not blocked. Any grstz from PLLCTRL will be propagated to the module                                                                              1: Soft resets are blocked LPSC only passes hard resets to the module" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="_RESV" width="2" begin="3" end="2" resetval="0" description="Reserved for NUMCLK expansion" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="NUMCLK" width="2" begin="1" end="0" resetval="0" description="Number of modclks supported on LPSC                                                        0: 1 modclk                                                                                                    1: 2 modclks                                                                                                  2: 3 modclks                                                                                                  3: 4 modclks" range="" rwaccess="R">
         
      </bitfield>
   </register>
   <register id="MDCFG36" acronym="MDCFG36" offset="0x690" width="32" description="Module Configuration 36 Register">
      <bitfield id="_RESV" width="10" begin="31" end="22" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="_RESV" width="1" begin="21" end="21" resetval="0" description="Reserved for PWRDOM expansion to up to 64 domains " range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="PWRDOM" width="5" begin="20" end="16" resetval="0" description="Power Domain                                                                                               Indicates which power domain this module belongs to (0 to 31)" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="_RESV" width="6" begin="15" end="10" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="MSTGKT" width="1" begin="9" end="9" resetval="0" description="Master Gasket support. Reflects the RTL parameter MSTGKT                     0: Master Gasket not supported by LPSC                                                     1: Master Gasket supported by LPSC" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="PERMDIS" width="1" begin="8" end="8" resetval="0" description="Permanently Disable                                                                                      Not documented to users                                                                              0: Not permanently disable module                                                                1: Permamanently disable module" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="CKRST" width="1" begin="7" end="7" resetval="0" description="Modclk During MSM reset source assert. Shows the tieoff d_mdcfg[x]_clk_during_hard_rst_src.                                                          MSM reset source is either hard_rst_src_assert_pi_n or any_rst_src_assert_pi_n                                                                              0: LPSC does not give modclk when its MSM reset source is asserted. LPSC only gives modclk after the MSM reset source is de-asserted           1: LPSC gives modclk even when the MSM reset source is asserted" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="PLLCKGT" width="1" begin="6" end="6" resetval="0" description="PLL Clock gate. Shows the tieoff d_mdcfg[x]_pll_handshake                      0: LPSC gates modclk directly                                                                       1: LPSC does not gate modclk directly. LPSC instructs the PLLCTRL to gate modclk." range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="LSRSTBLK" width="1" begin="5" end="5" resetval="0" description="LRST Soft Reset Block. Shows the tieoff d_mdcfg[x]_lrst_soft_rst_block value.                                                                                                             0: Soft resets are not blocked to LRST.                                                        1: Soft resets are blocked to LRST." range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="SRSTBLK" width="1" begin="4" end="4" resetval="0" description="Soft Reset Block. Shows the tieoff d_mdcfg[x]_soft_rst_block value.        0: Soft resets are not blocked. Any grstz from PLLCTRL will be propagated to the module                                                                              1: Soft resets are blocked LPSC only passes hard resets to the module" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="_RESV" width="2" begin="3" end="2" resetval="0" description="Reserved for NUMCLK expansion" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="NUMCLK" width="2" begin="1" end="0" resetval="0" description="Number of modclks supported on LPSC                                                        0: 1 modclk                                                                                                    1: 2 modclks                                                                                                  2: 3 modclks                                                                                                  3: 4 modclks" range="" rwaccess="R">
         
      </bitfield>
   </register>
   <register id="MDCFG37" acronym="MDCFG37" offset="0x694" width="32" description="Module Configuration 37 Register">
      <bitfield id="_RESV" width="10" begin="31" end="22" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="_RESV" width="1" begin="21" end="21" resetval="0" description="Reserved for PWRDOM expansion to up to 64 domains " range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="PWRDOM" width="5" begin="20" end="16" resetval="0" description="Power Domain                                                                                               Indicates which power domain this module belongs to (0 to 31)" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="_RESV" width="6" begin="15" end="10" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="MSTGKT" width="1" begin="9" end="9" resetval="0" description="Master Gasket support. Reflects the RTL parameter MSTGKT                     0: Master Gasket not supported by LPSC                                                     1: Master Gasket supported by LPSC" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="PERMDIS" width="1" begin="8" end="8" resetval="0" description="Permanently Disable                                                                                      Not documented to users                                                                              0: Not permanently disable module                                                                1: Permamanently disable module" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="CKRST" width="1" begin="7" end="7" resetval="0" description="Modclk During MSM reset source assert. Shows the tieoff d_mdcfg[x]_clk_during_hard_rst_src.                                                          MSM reset source is either hard_rst_src_assert_pi_n or any_rst_src_assert_pi_n                                                                              0: LPSC does not give modclk when its MSM reset source is asserted. LPSC only gives modclk after the MSM reset source is de-asserted           1: LPSC gives modclk even when the MSM reset source is asserted" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="PLLCKGT" width="1" begin="6" end="6" resetval="0" description="PLL Clock gate. Shows the tieoff d_mdcfg[x]_pll_handshake                      0: LPSC gates modclk directly                                                                       1: LPSC does not gate modclk directly. LPSC instructs the PLLCTRL to gate modclk." range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="LSRSTBLK" width="1" begin="5" end="5" resetval="0" description="LRST Soft Reset Block. Shows the tieoff d_mdcfg[x]_lrst_soft_rst_block value.                                                                                                             0: Soft resets are not blocked to LRST.                                                        1: Soft resets are blocked to LRST." range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="SRSTBLK" width="1" begin="4" end="4" resetval="0" description="Soft Reset Block. Shows the tieoff d_mdcfg[x]_soft_rst_block value.        0: Soft resets are not blocked. Any grstz from PLLCTRL will be propagated to the module                                                                              1: Soft resets are blocked LPSC only passes hard resets to the module" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="_RESV" width="2" begin="3" end="2" resetval="0" description="Reserved for NUMCLK expansion" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="NUMCLK" width="2" begin="1" end="0" resetval="0" description="Number of modclks supported on LPSC                                                        0: 1 modclk                                                                                                    1: 2 modclks                                                                                                  2: 3 modclks                                                                                                  3: 4 modclks" range="" rwaccess="R">
         
      </bitfield>
   </register>
   <register id="MDCFG38" acronym="MDCFG38" offset="0x698" width="32" description="Module Configuration 38 Register">
      <bitfield id="_RESV" width="10" begin="31" end="22" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="_RESV" width="1" begin="21" end="21" resetval="0" description="Reserved for PWRDOM expansion to up to 64 domains " range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="PWRDOM" width="5" begin="20" end="16" resetval="0" description="Power Domain                                                                                               Indicates which power domain this module belongs to (0 to 31)" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="_RESV" width="6" begin="15" end="10" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="MSTGKT" width="1" begin="9" end="9" resetval="0" description="Master Gasket support. Reflects the RTL parameter MSTGKT                     0: Master Gasket not supported by LPSC                                                     1: Master Gasket supported by LPSC" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="PERMDIS" width="1" begin="8" end="8" resetval="0" description="Permanently Disable                                                                                      Not documented to users                                                                              0: Not permanently disable module                                                                1: Permamanently disable module" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="CKRST" width="1" begin="7" end="7" resetval="0" description="Modclk During MSM reset source assert. Shows the tieoff d_mdcfg[x]_clk_during_hard_rst_src.                                                          MSM reset source is either hard_rst_src_assert_pi_n or any_rst_src_assert_pi_n                                                                              0: LPSC does not give modclk when its MSM reset source is asserted. LPSC only gives modclk after the MSM reset source is de-asserted           1: LPSC gives modclk even when the MSM reset source is asserted" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="PLLCKGT" width="1" begin="6" end="6" resetval="0" description="PLL Clock gate. Shows the tieoff d_mdcfg[x]_pll_handshake                      0: LPSC gates modclk directly                                                                       1: LPSC does not gate modclk directly. LPSC instructs the PLLCTRL to gate modclk." range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="LSRSTBLK" width="1" begin="5" end="5" resetval="0" description="LRST Soft Reset Block. Shows the tieoff d_mdcfg[x]_lrst_soft_rst_block value.                                                                                                             0: Soft resets are not blocked to LRST.                                                        1: Soft resets are blocked to LRST." range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="SRSTBLK" width="1" begin="4" end="4" resetval="0" description="Soft Reset Block. Shows the tieoff d_mdcfg[x]_soft_rst_block value.        0: Soft resets are not blocked. Any grstz from PLLCTRL will be propagated to the module                                                                              1: Soft resets are blocked LPSC only passes hard resets to the module" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="_RESV" width="2" begin="3" end="2" resetval="0" description="Reserved for NUMCLK expansion" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="NUMCLK" width="2" begin="1" end="0" resetval="0" description="Number of modclks supported on LPSC                                                        0: 1 modclk                                                                                                    1: 2 modclks                                                                                                  2: 3 modclks                                                                                                  3: 4 modclks" range="" rwaccess="R">
         
      </bitfield>
   </register>
   <register id="MDCFG39" acronym="MDCFG39" offset="0x69C" width="32" description="Module Configuration 39 Register">
      <bitfield id="_RESV" width="10" begin="31" end="22" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="_RESV" width="1" begin="21" end="21" resetval="0" description="Reserved for PWRDOM expansion to up to 64 domains " range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="PWRDOM" width="5" begin="20" end="16" resetval="0" description="Power Domain                                                                                               Indicates which power domain this module belongs to (0 to 31)" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="_RESV" width="6" begin="15" end="10" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="MSTGKT" width="1" begin="9" end="9" resetval="0" description="Master Gasket support. Reflects the RTL parameter MSTGKT                     0: Master Gasket not supported by LPSC                                                     1: Master Gasket supported by LPSC" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="PERMDIS" width="1" begin="8" end="8" resetval="0" description="Permanently Disable                                                                                      Not documented to users                                                                              0: Not permanently disable module                                                                1: Permamanently disable module" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="CKRST" width="1" begin="7" end="7" resetval="0" description="Modclk During MSM reset source assert. Shows the tieoff d_mdcfg[x]_clk_during_hard_rst_src.                                                          MSM reset source is either hard_rst_src_assert_pi_n or any_rst_src_assert_pi_n                                                                              0: LPSC does not give modclk when its MSM reset source is asserted. LPSC only gives modclk after the MSM reset source is de-asserted           1: LPSC gives modclk even when the MSM reset source is asserted" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="PLLCKGT" width="1" begin="6" end="6" resetval="0" description="PLL Clock gate. Shows the tieoff d_mdcfg[x]_pll_handshake                      0: LPSC gates modclk directly                                                                       1: LPSC does not gate modclk directly. LPSC instructs the PLLCTRL to gate modclk." range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="LSRSTBLK" width="1" begin="5" end="5" resetval="0" description="LRST Soft Reset Block. Shows the tieoff d_mdcfg[x]_lrst_soft_rst_block value.                                                                                                             0: Soft resets are not blocked to LRST.                                                        1: Soft resets are blocked to LRST." range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="SRSTBLK" width="1" begin="4" end="4" resetval="0" description="Soft Reset Block. Shows the tieoff d_mdcfg[x]_soft_rst_block value.        0: Soft resets are not blocked. Any grstz from PLLCTRL will be propagated to the module                                                                              1: Soft resets are blocked LPSC only passes hard resets to the module" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="_RESV" width="2" begin="3" end="2" resetval="0" description="Reserved for NUMCLK expansion" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="NUMCLK" width="2" begin="1" end="0" resetval="0" description="Number of modclks supported on LPSC                                                        0: 1 modclk                                                                                                    1: 2 modclks                                                                                                  2: 3 modclks                                                                                                  3: 4 modclks" range="" rwaccess="R">
         
      </bitfield>
   </register>
   <register id="MDCFG40" acronym="MDCFG40" offset="0x6A0" width="32" description="Module Configuration 40 Register">
      <bitfield id="_RESV" width="10" begin="31" end="22" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="_RESV" width="1" begin="21" end="21" resetval="0" description="Reserved for PWRDOM expansion to up to 64 domains " range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="PWRDOM" width="5" begin="20" end="16" resetval="0" description="Power Domain                                                                                               Indicates which power domain this module belongs to (0 to 31)" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="_RESV" width="6" begin="15" end="10" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="MSTGKT" width="1" begin="9" end="9" resetval="0" description="Master Gasket support. Reflects the RTL parameter MSTGKT                     0: Master Gasket not supported by LPSC                                                     1: Master Gasket supported by LPSC" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="PERMDIS" width="1" begin="8" end="8" resetval="0" description="Permanently Disable                                                                                      Not documented to users                                                                              0: Not permanently disable module                                                                1: Permamanently disable module" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="CKRST" width="1" begin="7" end="7" resetval="0" description="Modclk During MSM reset source assert. Shows the tieoff d_mdcfg[x]_clk_during_hard_rst_src.                                                          MSM reset source is either hard_rst_src_assert_pi_n or any_rst_src_assert_pi_n                                                                              0: LPSC does not give modclk when its MSM reset source is asserted. LPSC only gives modclk after the MSM reset source is de-asserted           1: LPSC gives modclk even when the MSM reset source is asserted" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="PLLCKGT" width="1" begin="6" end="6" resetval="0" description="PLL Clock gate. Shows the tieoff d_mdcfg[x]_pll_handshake                      0: LPSC gates modclk directly                                                                       1: LPSC does not gate modclk directly. LPSC instructs the PLLCTRL to gate modclk." range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="LSRSTBLK" width="1" begin="5" end="5" resetval="0" description="LRST Soft Reset Block. Shows the tieoff d_mdcfg[x]_lrst_soft_rst_block value.                                                                                                             0: Soft resets are not blocked to LRST.                                                        1: Soft resets are blocked to LRST." range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="SRSTBLK" width="1" begin="4" end="4" resetval="0" description="Soft Reset Block. Shows the tieoff d_mdcfg[x]_soft_rst_block value.        0: Soft resets are not blocked. Any grstz from PLLCTRL will be propagated to the module                                                                              1: Soft resets are blocked LPSC only passes hard resets to the module" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="_RESV" width="2" begin="3" end="2" resetval="0" description="Reserved for NUMCLK expansion" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="NUMCLK" width="2" begin="1" end="0" resetval="0" description="Number of modclks supported on LPSC                                                        0: 1 modclk                                                                                                    1: 2 modclks                                                                                                  2: 3 modclks                                                                                                  3: 4 modclks" range="" rwaccess="R">
         
      </bitfield>
   </register>
   <register id="MDSTAT0" acronym="MDSTAT0" offset="0x800" width="32" description="Module Status 0 Register">
      <bitfield id="_RESV" width="10" begin="31" end="22" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="MSTID" width="6" begin="21" end="16" resetval="0" description="Master ID. If ACSLP occurs, this field records the master ID of the master that caused the access. This bit is cleared when the corresponding ERRCR bit is written with a 1. " range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="_RESV" width="2" begin="15" end="14" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="ACSLP" width="2" begin="13" end="12" resetval="0" description="Non-emulation access to Module in Sleep occurred.                                    00:  Condition did not occur                                                                           01:  Access to module in sleep occurred. PSC transitioned the module from Sleep state to Temp Wake state then back to Sleep state                                                     10:  Access to module in sleep occured. PSC transitioned the module from Sleep state to Enable state                                                                   11: Reserved           " range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="WKRSLP" width="1" begin="11" end="11" resetval="0" description="Wakeup Request to Module in Sleep Detected.  Wakeup_pi is detected for this module when it is in sleep. If MDCTL.WKRSLPIE = 1, the setting of this field can cause ERRPR for this module to be set.                                          0: Condition did not occur                                                                              1: wakeup_pi = 1 when module is in sleep.                                     " range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="EMUIHB" width="1" begin="10" end="10" resetval="0" description="Emulation Alters Module State - Inhibits Module Inactive or Force Module Active                                                                                                            0: No emulation altering user-desired module state                                      1: Emulation alters user-desired module state" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="EMURST" width="1" begin="9" end="9" resetval="0" description="Emulation Alters Reset (lrst or mrst) to Module                                             0: No emulation altering user-desired reset                                                  1: Emulation alters user-desired module state " range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="LRSTz" width="1" begin="8" end="8" resetval="0" description="Module local reset actual status                                                                    0: local reset asserted                                                                                  1: local reset de-asserted" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="_RESV" width="3" begin="7" end="5" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="STATE" width="5" begin="4" end="0" resetval="0" description="These bits indiacte the current module state                                                010: SyncReset                                                                                      000: SwRstDisable                                                                                      001: Disable                                                                                            011: Enable                                                                                                    111: Disable Clock-On Transition                                                                                                                                                                                                                                          100, 101, 110:   Reserved" range="" rwaccess="R">
         
      </bitfield>
   </register>
   <register id="MDSTAT1" acronym="MDSTAT1" offset="0x804" width="32" description="Module Status 1 Register">
      <bitfield id="_RESV" width="10" begin="31" end="22" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="MSTID" width="6" begin="21" end="16" resetval="0" description="Master ID. If ACSLP occurs, this field records the master ID of the master that caused the access. This bit is cleared when the corresponding ERRCR bit is written with a 1. " range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="_RESV" width="2" begin="15" end="14" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="ACSLP" width="2" begin="13" end="12" resetval="0" description="Non-emulation access to Module in Sleep occurred.                                    00:  Condition did not occur                                                                           01:  Access to module in sleep occurred. PSC transitioned the module from Sleep state to Temp Wake state then back to Sleep state                                                     10:  Access to module in sleep occured. PSC transitioned the module from Sleep state to Enable state                                                                   11: Reserved           " range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="WKRSLP" width="1" begin="11" end="11" resetval="0" description="Wakeup Request to Module in Sleep Detected.  Wakeup_pi is detected for this module when it is in sleep. If MDCTL.WKRSLPIE = 1, the setting of this field can cause ERRPR for this module to be set.                                          0: Condition did not occur                                                                              1: wakeup_pi = 1 when module is in sleep.                                     " range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="EMUIHB" width="1" begin="10" end="10" resetval="0" description="Emulation Alters Module State - Inhibits Module Inactive or Force Module Active                                                                                                            0: No emulation altering user-desired module state                                      1: Emulation alters user-desired module state" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="EMURST" width="1" begin="9" end="9" resetval="0" description="Emulation Alters Reset (lrst or mrst) to Module                                             0: No emulation altering user-desired reset                                                  1: Emulation alters user-desired module state " range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="LRSTz" width="1" begin="8" end="8" resetval="0" description="Module local reset actual status                                                                    0: local reset asserted                                                                                  1: local reset de-asserted" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="_RESV" width="3" begin="7" end="5" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="STATE" width="5" begin="4" end="0" resetval="0" description="These bits indiacte the current module state                                                010: SyncReset                                                                                      000: SwRstDisable                                                                                      001: Disable                                                                                            011: Enable                                                                                                    111: Disable Clock-On Transition                                                                                                                                                                                                                                          100, 101, 110:   Reserved" range="" rwaccess="R">
         
      </bitfield>
   </register>
   <register id="MDSTAT2" acronym="MDSTAT2" offset="0x808" width="32" description="Module Status 2 Register">
      <bitfield id="_RESV" width="10" begin="31" end="22" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="MSTID" width="6" begin="21" end="16" resetval="0" description="Master ID. If ACSLP occurs, this field records the master ID of the master that caused the access. This bit is cleared when the corresponding ERRCR bit is written with a 1. " range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="_RESV" width="2" begin="15" end="14" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="ACSLP" width="2" begin="13" end="12" resetval="0" description="Non-emulation access to Module in Sleep occurred.                                    00:  Condition did not occur                                                                           01:  Access to module in sleep occurred. PSC transitioned the module from Sleep state to Temp Wake state then back to Sleep state                                                     10:  Access to module in sleep occured. PSC transitioned the module from Sleep state to Enable state                                                                   11: Reserved           " range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="WKRSLP" width="1" begin="11" end="11" resetval="0" description="Wakeup Request to Module in Sleep Detected.  Wakeup_pi is detected for this module when it is in sleep. If MDCTL.WKRSLPIE = 1, the setting of this field can cause ERRPR for this module to be set.                                          0: Condition did not occur                                                                              1: wakeup_pi = 1 when module is in sleep.                                     " range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="EMUIHB" width="1" begin="10" end="10" resetval="0" description="Emulation Alters Module State - Inhibits Module Inactive or Force Module Active                                                                                                            0: No emulation altering user-desired module state                                      1: Emulation alters user-desired module state" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="EMURST" width="1" begin="9" end="9" resetval="0" description="Emulation Alters Reset (lrst or mrst) to Module                                             0: No emulation altering user-desired reset                                                  1: Emulation alters user-desired module state " range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="LRSTz" width="1" begin="8" end="8" resetval="0" description="Module local reset actual status                                                                    0: local reset asserted                                                                                  1: local reset de-asserted" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="_RESV" width="3" begin="7" end="5" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="STATE" width="5" begin="4" end="0" resetval="0" description="These bits indiacte the current module state                                                010: SyncReset                                                                                      000: SwRstDisable                                                                                      001: Disable                                                                                            011: Enable                                                                                                    111: Disable Clock-On Transition                                                                                                                                                                                                                                          100, 101, 110:   Reserved" range="" rwaccess="R">
         
      </bitfield>
   </register>
   <register id="MDSTAT3" acronym="MDSTAT3" offset="0x80C" width="32" description="Module Status 3 Register">
      <bitfield id="_RESV" width="10" begin="31" end="22" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="MSTID" width="6" begin="21" end="16" resetval="0" description="Master ID. If ACSLP occurs, this field records the master ID of the master that caused the access. This bit is cleared when the corresponding ERRCR bit is written with a 1. " range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="_RESV" width="2" begin="15" end="14" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="ACSLP" width="2" begin="13" end="12" resetval="0" description="Non-emulation access to Module in Sleep occurred.                                    00:  Condition did not occur                                                                           01:  Access to module in sleep occurred. PSC transitioned the module from Sleep state to Temp Wake state then back to Sleep state                                                     10:  Access to module in sleep occured. PSC transitioned the module from Sleep state to Enable state                                                                   11: Reserved           " range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="WKRSLP" width="1" begin="11" end="11" resetval="0" description="Wakeup Request to Module in Sleep Detected.  Wakeup_pi is detected for this module when it is in sleep. If MDCTL.WKRSLPIE = 1, the setting of this field can cause ERRPR for this module to be set.                                          0: Condition did not occur                                                                              1: wakeup_pi = 1 when module is in sleep.                                     " range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="EMUIHB" width="1" begin="10" end="10" resetval="0" description="Emulation Alters Module State - Inhibits Module Inactive or Force Module Active                                                                                                            0: No emulation altering user-desired module state                                      1: Emulation alters user-desired module state" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="EMURST" width="1" begin="9" end="9" resetval="0" description="Emulation Alters Reset (lrst or mrst) to Module                                             0: No emulation altering user-desired reset                                                  1: Emulation alters user-desired module state " range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="LRSTz" width="1" begin="8" end="8" resetval="0" description="Module local reset actual status                                                                    0: local reset asserted                                                                                  1: local reset de-asserted" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="_RESV" width="3" begin="7" end="5" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="STATE" width="5" begin="4" end="0" resetval="0" description="These bits indiacte the current module state                                                010: SyncReset                                                                                      000: SwRstDisable                                                                                      001: Disable                                                                                            011: Enable                                                                                                    111: Disable Clock-On Transition                                                                                                                                                                                                                                          100, 101, 110:   Reserved" range="" rwaccess="R">
         
      </bitfield>
   </register>
   <register id="MDSTAT4" acronym="MDSTAT4" offset="0x810" width="32" description="Module Status 4 Register">
      <bitfield id="_RESV" width="10" begin="31" end="22" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="MSTID" width="6" begin="21" end="16" resetval="0" description="Master ID. If ACSLP occurs, this field records the master ID of the master that caused the access. This bit is cleared when the corresponding ERRCR bit is written with a 1. " range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="_RESV" width="2" begin="15" end="14" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="ACSLP" width="2" begin="13" end="12" resetval="0" description="Non-emulation access to Module in Sleep occurred.                                    00:  Condition did not occur                                                                           01:  Access to module in sleep occurred. PSC transitioned the module from Sleep state to Temp Wake state then back to Sleep state                                                     10:  Access to module in sleep occured. PSC transitioned the module from Sleep state to Enable state                                                                   11: Reserved           " range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="WKRSLP" width="1" begin="11" end="11" resetval="0" description="Wakeup Request to Module in Sleep Detected.  Wakeup_pi is detected for this module when it is in sleep. If MDCTL.WKRSLPIE = 1, the setting of this field can cause ERRPR for this module to be set.                                          0: Condition did not occur                                                                              1: wakeup_pi = 1 when module is in sleep.                                     " range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="EMUIHB" width="1" begin="10" end="10" resetval="0" description="Emulation Alters Module State - Inhibits Module Inactive or Force Module Active                                                                                                            0: No emulation altering user-desired module state                                      1: Emulation alters user-desired module state" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="EMURST" width="1" begin="9" end="9" resetval="0" description="Emulation Alters Reset (lrst or mrst) to Module                                             0: No emulation altering user-desired reset                                                  1: Emulation alters user-desired module state " range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="LRSTz" width="1" begin="8" end="8" resetval="0" description="Module local reset actual status                                                                    0: local reset asserted                                                                                  1: local reset de-asserted" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="_RESV" width="3" begin="7" end="5" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="STATE" width="5" begin="4" end="0" resetval="0" description="These bits indiacte the current module state                                                010: SyncReset                                                                                      000: SwRstDisable                                                                                      001: Disable                                                                                            011: Enable                                                                                                    111: Disable Clock-On Transition                                                                                                                                                                                                                                          100, 101, 110:   Reserved" range="" rwaccess="R">
         
      </bitfield>
   </register>
   <register id="MDSTAT5" acronym="MDSTAT5" offset="0x814" width="32" description="Module Status 5 Register">
      <bitfield id="_RESV" width="10" begin="31" end="22" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="MSTID" width="6" begin="21" end="16" resetval="0" description="Master ID. If ACSLP occurs, this field records the master ID of the master that caused the access. This bit is cleared when the corresponding ERRCR bit is written with a 1. " range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="_RESV" width="2" begin="15" end="14" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="ACSLP" width="2" begin="13" end="12" resetval="0" description="Non-emulation access to Module in Sleep occurred.                                    00:  Condition did not occur                                                                           01:  Access to module in sleep occurred. PSC transitioned the module from Sleep state to Temp Wake state then back to Sleep state                                                     10:  Access to module in sleep occured. PSC transitioned the module from Sleep state to Enable state                                                                   11: Reserved           " range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="WKRSLP" width="1" begin="11" end="11" resetval="0" description="Wakeup Request to Module in Sleep Detected.  Wakeup_pi is detected for this module when it is in sleep. If MDCTL.WKRSLPIE = 1, the setting of this field can cause ERRPR for this module to be set.                                          0: Condition did not occur                                                                              1: wakeup_pi = 1 when module is in sleep.                                     " range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="EMUIHB" width="1" begin="10" end="10" resetval="0" description="Emulation Alters Module State - Inhibits Module Inactive or Force Module Active                                                                                                            0: No emulation altering user-desired module state                                      1: Emulation alters user-desired module state" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="EMURST" width="1" begin="9" end="9" resetval="0" description="Emulation Alters Reset (lrst or mrst) to Module                                             0: No emulation altering user-desired reset                                                  1: Emulation alters user-desired module state " range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="LRSTz" width="1" begin="8" end="8" resetval="0" description="Module local reset actual status                                                                    0: local reset asserted                                                                                  1: local reset de-asserted" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="_RESV" width="3" begin="7" end="5" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="STATE" width="5" begin="4" end="0" resetval="0" description="These bits indiacte the current module state                                                010: SyncReset                                                                                      000: SwRstDisable                                                                                      001: Disable                                                                                            011: Enable                                                                                                    111: Disable Clock-On Transition                                                                                                                                                                                                                                          100, 101, 110:   Reserved" range="" rwaccess="R">
         
      </bitfield>
   </register>
   <register id="MDSTAT6" acronym="MDSTAT6" offset="0x818" width="32" description="Module Status 6 Register">
      <bitfield id="_RESV" width="10" begin="31" end="22" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="MSTID" width="6" begin="21" end="16" resetval="0" description="Master ID. If ACSLP occurs, this field records the master ID of the master that caused the access. This bit is cleared when the corresponding ERRCR bit is written with a 1. " range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="_RESV" width="2" begin="15" end="14" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="ACSLP" width="2" begin="13" end="12" resetval="0" description="Non-emulation access to Module in Sleep occurred.                                    00:  Condition did not occur                                                                           01:  Access to module in sleep occurred. PSC transitioned the module from Sleep state to Temp Wake state then back to Sleep state                                                     10:  Access to module in sleep occured. PSC transitioned the module from Sleep state to Enable state                                                                   11: Reserved           " range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="WKRSLP" width="1" begin="11" end="11" resetval="0" description="Wakeup Request to Module in Sleep Detected.  Wakeup_pi is detected for this module when it is in sleep. If MDCTL.WKRSLPIE = 1, the setting of this field can cause ERRPR for this module to be set.                                          0: Condition did not occur                                                                              1: wakeup_pi = 1 when module is in sleep.                                     " range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="EMUIHB" width="1" begin="10" end="10" resetval="0" description="Emulation Alters Module State - Inhibits Module Inactive or Force Module Active                                                                                                            0: No emulation altering user-desired module state                                      1: Emulation alters user-desired module state" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="EMURST" width="1" begin="9" end="9" resetval="0" description="Emulation Alters Reset (lrst or mrst) to Module                                             0: No emulation altering user-desired reset                                                  1: Emulation alters user-desired module state " range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="LRSTz" width="1" begin="8" end="8" resetval="0" description="Module local reset actual status                                                                    0: local reset asserted                                                                                  1: local reset de-asserted" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="_RESV" width="3" begin="7" end="5" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="STATE" width="5" begin="4" end="0" resetval="0" description="These bits indiacte the current module state                                                010: SyncReset                                                                                      000: SwRstDisable                                                                                      001: Disable                                                                                            011: Enable                                                                                                    111: Disable Clock-On Transition                                                                                                                                                                                                                                          100, 101, 110:   Reserved" range="" rwaccess="R">
         
      </bitfield>
   </register>
   <register id="MDSTAT7" acronym="MDSTAT7" offset="0x81C" width="32" description="Module Status 7 Register">
      <bitfield id="_RESV" width="10" begin="31" end="22" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="MSTID" width="6" begin="21" end="16" resetval="0" description="Master ID. If ACSLP occurs, this field records the master ID of the master that caused the access. This bit is cleared when the corresponding ERRCR bit is written with a 1. " range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="_RESV" width="2" begin="15" end="14" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="ACSLP" width="2" begin="13" end="12" resetval="0" description="Non-emulation access to Module in Sleep occurred.                                    00:  Condition did not occur                                                                           01:  Access to module in sleep occurred. PSC transitioned the module from Sleep state to Temp Wake state then back to Sleep state                                                     10:  Access to module in sleep occured. PSC transitioned the module from Sleep state to Enable state                                                                   11: Reserved           " range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="WKRSLP" width="1" begin="11" end="11" resetval="0" description="Wakeup Request to Module in Sleep Detected.  Wakeup_pi is detected for this module when it is in sleep. If MDCTL.WKRSLPIE = 1, the setting of this field can cause ERRPR for this module to be set.                                          0: Condition did not occur                                                                              1: wakeup_pi = 1 when module is in sleep.                                     " range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="EMUIHB" width="1" begin="10" end="10" resetval="0" description="Emulation Alters Module State - Inhibits Module Inactive or Force Module Active                                                                                                            0: No emulation altering user-desired module state                                      1: Emulation alters user-desired module state" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="EMURST" width="1" begin="9" end="9" resetval="0" description="Emulation Alters Reset (lrst or mrst) to Module                                             0: No emulation altering user-desired reset                                                  1: Emulation alters user-desired module state " range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="LRSTz" width="1" begin="8" end="8" resetval="0" description="Module local reset actual status                                                                    0: local reset asserted                                                                                  1: local reset de-asserted" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="_RESV" width="3" begin="7" end="5" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="STATE" width="5" begin="4" end="0" resetval="0" description="These bits indiacte the current module state                                                010: SyncReset                                                                                      000: SwRstDisable                                                                                      001: Disable                                                                                            011: Enable                                                                                                    111: Disable Clock-On Transition                                                                                                                                                                                                                                          100, 101, 110:   Reserved" range="" rwaccess="R">
         
      </bitfield>
   </register>
   <register id="MDSTAT8" acronym="MDSTAT8" offset="0x820" width="32" description="Module Status 8 Register">
      <bitfield id="_RESV" width="10" begin="31" end="22" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="MSTID" width="6" begin="21" end="16" resetval="0" description="Master ID. If ACSLP occurs, this field records the master ID of the master that caused the access. This bit is cleared when the corresponding ERRCR bit is written with a 1. " range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="_RESV" width="2" begin="15" end="14" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="ACSLP" width="2" begin="13" end="12" resetval="0" description="Non-emulation access to Module in Sleep occurred.                                    00:  Condition did not occur                                                                           01:  Access to module in sleep occurred. PSC transitioned the module from Sleep state to Temp Wake state then back to Sleep state                                                     10:  Access to module in sleep occured. PSC transitioned the module from Sleep state to Enable state                                                                   11: Reserved           " range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="WKRSLP" width="1" begin="11" end="11" resetval="0" description="Wakeup Request to Module in Sleep Detected.  Wakeup_pi is detected for this module when it is in sleep. If MDCTL.WKRSLPIE = 1, the setting of this field can cause ERRPR for this module to be set.                                          0: Condition did not occur                                                                              1: wakeup_pi = 1 when module is in sleep.                                     " range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="EMUIHB" width="1" begin="10" end="10" resetval="0" description="Emulation Alters Module State - Inhibits Module Inactive or Force Module Active                                                                                                            0: No emulation altering user-desired module state                                      1: Emulation alters user-desired module state" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="EMURST" width="1" begin="9" end="9" resetval="0" description="Emulation Alters Reset (lrst or mrst) to Module                                             0: No emulation altering user-desired reset                                                  1: Emulation alters user-desired module state " range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="LRSTz" width="1" begin="8" end="8" resetval="0" description="Module local reset actual status                                                                    0: local reset asserted                                                                                  1: local reset de-asserted" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="_RESV" width="3" begin="7" end="5" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="STATE" width="5" begin="4" end="0" resetval="0" description="These bits indiacte the current module state                                                010: SyncReset                                                                                      000: SwRstDisable                                                                                      001: Disable                                                                                            011: Enable                                                                                                    111: Disable Clock-On Transition                                                                                                                                                                                                                                          100, 101, 110:   Reserved" range="" rwaccess="R">
         
      </bitfield>
   </register>
   <register id="MDSTAT9" acronym="MDSTAT9" offset="0x824" width="32" description="Module Status 9 Register">
      <bitfield id="_RESV" width="10" begin="31" end="22" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="MSTID" width="6" begin="21" end="16" resetval="0" description="Master ID. If ACSLP occurs, this field records the master ID of the master that caused the access. This bit is cleared when the corresponding ERRCR bit is written with a 1. " range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="_RESV" width="2" begin="15" end="14" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="ACSLP" width="2" begin="13" end="12" resetval="0" description="Non-emulation access to Module in Sleep occurred.                                    00:  Condition did not occur                                                                           01:  Access to module in sleep occurred. PSC transitioned the module from Sleep state to Temp Wake state then back to Sleep state                                                     10:  Access to module in sleep occured. PSC transitioned the module from Sleep state to Enable state                                                                   11: Reserved           " range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="WKRSLP" width="1" begin="11" end="11" resetval="0" description="Wakeup Request to Module in Sleep Detected.  Wakeup_pi is detected for this module when it is in sleep. If MDCTL.WKRSLPIE = 1, the setting of this field can cause ERRPR for this module to be set.                                          0: Condition did not occur                                                                              1: wakeup_pi = 1 when module is in sleep.                                     " range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="EMUIHB" width="1" begin="10" end="10" resetval="0" description="Emulation Alters Module State - Inhibits Module Inactive or Force Module Active                                                                                                            0: No emulation altering user-desired module state                                      1: Emulation alters user-desired module state" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="EMURST" width="1" begin="9" end="9" resetval="0" description="Emulation Alters Reset (lrst or mrst) to Module                                             0: No emulation altering user-desired reset                                                  1: Emulation alters user-desired module state " range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="LRSTz" width="1" begin="8" end="8" resetval="0" description="Module local reset actual status                                                                    0: local reset asserted                                                                                  1: local reset de-asserted" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="_RESV" width="3" begin="7" end="5" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="STATE" width="5" begin="4" end="0" resetval="0" description="These bits indiacte the current module state                                                010: SyncReset                                                                                      000: SwRstDisable                                                                                      001: Disable                                                                                            011: Enable                                                                                                    111: Disable Clock-On Transition                                                                                                                                                                                                                                          100, 101, 110:   Reserved" range="" rwaccess="R">
         
      </bitfield>
   </register>
   <register id="MDSTAT10" acronym="MDSTAT10" offset="0x828" width="32" description="Module Status 10 Register">
      <bitfield id="_RESV" width="10" begin="31" end="22" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="MSTID" width="6" begin="21" end="16" resetval="0" description="Master ID. If ACSLP occurs, this field records the master ID of the master that caused the access. This bit is cleared when the corresponding ERRCR bit is written with a 1. " range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="_RESV" width="2" begin="15" end="14" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="ACSLP" width="2" begin="13" end="12" resetval="0" description="Non-emulation access to Module in Sleep occurred.                                    00:  Condition did not occur                                                                           01:  Access to module in sleep occurred. PSC transitioned the module from Sleep state to Temp Wake state then back to Sleep state                                                     10:  Access to module in sleep occured. PSC transitioned the module from Sleep state to Enable state                                                                   11: Reserved           " range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="WKRSLP" width="1" begin="11" end="11" resetval="0" description="Wakeup Request to Module in Sleep Detected.  Wakeup_pi is detected for this module when it is in sleep. If MDCTL.WKRSLPIE = 1, the setting of this field can cause ERRPR for this module to be set.                                          0: Condition did not occur                                                                              1: wakeup_pi = 1 when module is in sleep.                                     " range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="EMUIHB" width="1" begin="10" end="10" resetval="0" description="Emulation Alters Module State - Inhibits Module Inactive or Force Module Active                                                                                                            0: No emulation altering user-desired module state                                      1: Emulation alters user-desired module state" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="EMURST" width="1" begin="9" end="9" resetval="0" description="Emulation Alters Reset (lrst or mrst) to Module                                             0: No emulation altering user-desired reset                                                  1: Emulation alters user-desired module state " range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="LRSTz" width="1" begin="8" end="8" resetval="0" description="Module local reset actual status                                                                    0: local reset asserted                                                                                  1: local reset de-asserted" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="_RESV" width="3" begin="7" end="5" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="STATE" width="5" begin="4" end="0" resetval="0" description="These bits indiacte the current module state                                                010: SyncReset                                                                                      000: SwRstDisable                                                                                      001: Disable                                                                                            011: Enable                                                                                                    111: Disable Clock-On Transition                                                                                                                                                                                                                                          100, 101, 110:   Reserved" range="" rwaccess="R">
         
      </bitfield>
   </register>
   <register id="MDSTAT11" acronym="MDSTAT11" offset="0x82C" width="32" description="Module Status 11 Register">
      <bitfield id="_RESV" width="10" begin="31" end="22" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="MSTID" width="6" begin="21" end="16" resetval="0" description="Master ID. If ACSLP occurs, this field records the master ID of the master that caused the access. This bit is cleared when the corresponding ERRCR bit is written with a 1. " range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="_RESV" width="2" begin="15" end="14" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="ACSLP" width="2" begin="13" end="12" resetval="0" description="Non-emulation access to Module in Sleep occurred.                                    00:  Condition did not occur                                                                           01:  Access to module in sleep occurred. PSC transitioned the module from Sleep state to Temp Wake state then back to Sleep state                                                     10:  Access to module in sleep occured. PSC transitioned the module from Sleep state to Enable state                                                                   11: Reserved           " range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="WKRSLP" width="1" begin="11" end="11" resetval="0" description="Wakeup Request to Module in Sleep Detected.  Wakeup_pi is detected for this module when it is in sleep. If MDCTL.WKRSLPIE = 1, the setting of this field can cause ERRPR for this module to be set.                                          0: Condition did not occur                                                                              1: wakeup_pi = 1 when module is in sleep.                                     " range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="EMUIHB" width="1" begin="10" end="10" resetval="0" description="Emulation Alters Module State - Inhibits Module Inactive or Force Module Active                                                                                                            0: No emulation altering user-desired module state                                      1: Emulation alters user-desired module state" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="EMURST" width="1" begin="9" end="9" resetval="0" description="Emulation Alters Reset (lrst or mrst) to Module                                             0: No emulation altering user-desired reset                                                  1: Emulation alters user-desired module state " range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="LRSTz" width="1" begin="8" end="8" resetval="0" description="Module local reset actual status                                                                    0: local reset asserted                                                                                  1: local reset de-asserted" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="_RESV" width="3" begin="7" end="5" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="STATE" width="5" begin="4" end="0" resetval="0" description="These bits indiacte the current module state                                                010: SyncReset                                                                                      000: SwRstDisable                                                                                      001: Disable                                                                                            011: Enable                                                                                                    111: Disable Clock-On Transition                                                                                                                                                                                                                                          100, 101, 110:   Reserved" range="" rwaccess="R">
         
      </bitfield>
   </register>
   <register id="MDSTAT12" acronym="MDSTAT12" offset="0x830" width="32" description="Module Status 12 Register">
      <bitfield id="_RESV" width="10" begin="31" end="22" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="MSTID" width="6" begin="21" end="16" resetval="0" description="Master ID. If ACSLP occurs, this field records the master ID of the master that caused the access. This bit is cleared when the corresponding ERRCR bit is written with a 1. " range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="_RESV" width="2" begin="15" end="14" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="ACSLP" width="2" begin="13" end="12" resetval="0" description="Non-emulation access to Module in Sleep occurred.                                    00:  Condition did not occur                                                                           01:  Access to module in sleep occurred. PSC transitioned the module from Sleep state to Temp Wake state then back to Sleep state                                                     10:  Access to module in sleep occured. PSC transitioned the module from Sleep state to Enable state                                                                   11: Reserved           " range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="WKRSLP" width="1" begin="11" end="11" resetval="0" description="Wakeup Request to Module in Sleep Detected.  Wakeup_pi is detected for this module when it is in sleep. If MDCTL.WKRSLPIE = 1, the setting of this field can cause ERRPR for this module to be set.                                          0: Condition did not occur                                                                              1: wakeup_pi = 1 when module is in sleep.                                     " range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="EMUIHB" width="1" begin="10" end="10" resetval="0" description="Emulation Alters Module State - Inhibits Module Inactive or Force Module Active                                                                                                            0: No emulation altering user-desired module state                                      1: Emulation alters user-desired module state" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="EMURST" width="1" begin="9" end="9" resetval="0" description="Emulation Alters Reset (lrst or mrst) to Module                                             0: No emulation altering user-desired reset                                                  1: Emulation alters user-desired module state " range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="LRSTz" width="1" begin="8" end="8" resetval="0" description="Module local reset actual status                                                                    0: local reset asserted                                                                                  1: local reset de-asserted" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="_RESV" width="3" begin="7" end="5" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="STATE" width="5" begin="4" end="0" resetval="0" description="These bits indiacte the current module state                                                010: SyncReset                                                                                      000: SwRstDisable                                                                                      001: Disable                                                                                            011: Enable                                                                                                    111: Disable Clock-On Transition                                                                                                                                                                                                                                          100, 101, 110:   Reserved" range="" rwaccess="R">
         
      </bitfield>
   </register>
   <register id="MDSTAT13" acronym="MDSTAT13" offset="0x834" width="32" description="Module Status 13 Register">
      <bitfield id="_RESV" width="10" begin="31" end="22" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="MSTID" width="6" begin="21" end="16" resetval="0" description="Master ID. If ACSLP occurs, this field records the master ID of the master that caused the access. This bit is cleared when the corresponding ERRCR bit is written with a 1. " range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="_RESV" width="2" begin="15" end="14" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="ACSLP" width="2" begin="13" end="12" resetval="0" description="Non-emulation access to Module in Sleep occurred.                                    00:  Condition did not occur                                                                           01:  Access to module in sleep occurred. PSC transitioned the module from Sleep state to Temp Wake state then back to Sleep state                                                     10:  Access to module in sleep occured. PSC transitioned the module from Sleep state to Enable state                                                                   11: Reserved           " range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="WKRSLP" width="1" begin="11" end="11" resetval="0" description="Wakeup Request to Module in Sleep Detected.  Wakeup_pi is detected for this module when it is in sleep. If MDCTL.WKRSLPIE = 1, the setting of this field can cause ERRPR for this module to be set.                                          0: Condition did not occur                                                                              1: wakeup_pi = 1 when module is in sleep.                                     " range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="EMUIHB" width="1" begin="10" end="10" resetval="0" description="Emulation Alters Module State - Inhibits Module Inactive or Force Module Active                                                                                                            0: No emulation altering user-desired module state                                      1: Emulation alters user-desired module state" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="EMURST" width="1" begin="9" end="9" resetval="0" description="Emulation Alters Reset (lrst or mrst) to Module                                             0: No emulation altering user-desired reset                                                  1: Emulation alters user-desired module state " range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="LRSTz" width="1" begin="8" end="8" resetval="0" description="Module local reset actual status                                                                    0: local reset asserted                                                                                  1: local reset de-asserted" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="_RESV" width="3" begin="7" end="5" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="STATE" width="5" begin="4" end="0" resetval="0" description="These bits indiacte the current module state                                                010: SyncReset                                                                                      000: SwRstDisable                                                                                      001: Disable                                                                                            011: Enable                                                                                                    111: Disable Clock-On Transition                                                                                                                                                                                                                                          100, 101, 110:   Reserved" range="" rwaccess="R">
         
      </bitfield>
   </register>
   <register id="MDSTAT14" acronym="MDSTAT14" offset="0x838" width="32" description="Module Status 14 Register">
      <bitfield id="_RESV" width="10" begin="31" end="22" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="MSTID" width="6" begin="21" end="16" resetval="0" description="Master ID. If ACSLP occurs, this field records the master ID of the master that caused the access. This bit is cleared when the corresponding ERRCR bit is written with a 1. " range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="_RESV" width="2" begin="15" end="14" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="ACSLP" width="2" begin="13" end="12" resetval="0" description="Non-emulation access to Module in Sleep occurred.                                    00:  Condition did not occur                                                                           01:  Access to module in sleep occurred. PSC transitioned the module from Sleep state to Temp Wake state then back to Sleep state                                                     10:  Access to module in sleep occured. PSC transitioned the module from Sleep state to Enable state                                                                   11: Reserved           " range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="WKRSLP" width="1" begin="11" end="11" resetval="0" description="Wakeup Request to Module in Sleep Detected.  Wakeup_pi is detected for this module when it is in sleep. If MDCTL.WKRSLPIE = 1, the setting of this field can cause ERRPR for this module to be set.                                          0: Condition did not occur                                                                              1: wakeup_pi = 1 when module is in sleep.                                     " range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="EMUIHB" width="1" begin="10" end="10" resetval="0" description="Emulation Alters Module State - Inhibits Module Inactive or Force Module Active                                                                                                            0: No emulation altering user-desired module state                                      1: Emulation alters user-desired module state" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="EMURST" width="1" begin="9" end="9" resetval="0" description="Emulation Alters Reset (lrst or mrst) to Module                                             0: No emulation altering user-desired reset                                                  1: Emulation alters user-desired module state " range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="LRSTz" width="1" begin="8" end="8" resetval="0" description="Module local reset actual status                                                                    0: local reset asserted                                                                                  1: local reset de-asserted" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="_RESV" width="3" begin="7" end="5" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="STATE" width="5" begin="4" end="0" resetval="0" description="These bits indiacte the current module state                                                010: SyncReset                                                                                      000: SwRstDisable                                                                                      001: Disable                                                                                            011: Enable                                                                                                    111: Disable Clock-On Transition                                                                                                                                                                                                                                          100, 101, 110:   Reserved" range="" rwaccess="R">
         
      </bitfield>
   </register>
   <register id="MDSTAT15" acronym="MDSTAT15" offset="0x83C" width="32" description="Module Status 15 Register">
      <bitfield id="_RESV" width="10" begin="31" end="22" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="MSTID" width="6" begin="21" end="16" resetval="0" description="Master ID. If ACSLP occurs, this field records the master ID of the master that caused the access. This bit is cleared when the corresponding ERRCR bit is written with a 1. " range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="_RESV" width="2" begin="15" end="14" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="ACSLP" width="2" begin="13" end="12" resetval="0" description="Non-emulation access to Module in Sleep occurred.                                    00:  Condition did not occur                                                                           01:  Access to module in sleep occurred. PSC transitioned the module from Sleep state to Temp Wake state then back to Sleep state                                                     10:  Access to module in sleep occured. PSC transitioned the module from Sleep state to Enable state                                                                   11: Reserved           " range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="WKRSLP" width="1" begin="11" end="11" resetval="0" description="Wakeup Request to Module in Sleep Detected.  Wakeup_pi is detected for this module when it is in sleep. If MDCTL.WKRSLPIE = 1, the setting of this field can cause ERRPR for this module to be set.                                          0: Condition did not occur                                                                              1: wakeup_pi = 1 when module is in sleep.                                     " range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="EMUIHB" width="1" begin="10" end="10" resetval="0" description="Emulation Alters Module State - Inhibits Module Inactive or Force Module Active                                                                                                            0: No emulation altering user-desired module state                                      1: Emulation alters user-desired module state" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="EMURST" width="1" begin="9" end="9" resetval="0" description="Emulation Alters Reset (lrst or mrst) to Module                                             0: No emulation altering user-desired reset                                                  1: Emulation alters user-desired module state " range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="LRSTz" width="1" begin="8" end="8" resetval="0" description="Module local reset actual status                                                                    0: local reset asserted                                                                                  1: local reset de-asserted" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="_RESV" width="3" begin="7" end="5" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="STATE" width="5" begin="4" end="0" resetval="0" description="These bits indiacte the current module state                                                010: SyncReset                                                                                      000: SwRstDisable                                                                                      001: Disable                                                                                            011: Enable                                                                                                    111: Disable Clock-On Transition                                                                                                                                                                                                                                          100, 101, 110:   Reserved" range="" rwaccess="R">
         
      </bitfield>
   </register>
   <register id="MDSTAT16" acronym="MDSTAT16" offset="0x840" width="32" description="Module Status 16 Register">
      <bitfield id="_RESV" width="10" begin="31" end="22" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="MSTID" width="6" begin="21" end="16" resetval="0" description="Master ID. If ACSLP occurs, this field records the master ID of the master that caused the access. This bit is cleared when the corresponding ERRCR bit is written with a 1. " range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="_RESV" width="2" begin="15" end="14" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="ACSLP" width="2" begin="13" end="12" resetval="0" description="Non-emulation access to Module in Sleep occurred.                                    00:  Condition did not occur                                                                           01:  Access to module in sleep occurred. PSC transitioned the module from Sleep state to Temp Wake state then back to Sleep state                                                     10:  Access to module in sleep occured. PSC transitioned the module from Sleep state to Enable state                                                                   11: Reserved           " range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="WKRSLP" width="1" begin="11" end="11" resetval="0" description="Wakeup Request to Module in Sleep Detected.  Wakeup_pi is detected for this module when it is in sleep. If MDCTL.WKRSLPIE = 1, the setting of this field can cause ERRPR for this module to be set.                                          0: Condition did not occur                                                                              1: wakeup_pi = 1 when module is in sleep.                                     " range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="EMUIHB" width="1" begin="10" end="10" resetval="0" description="Emulation Alters Module State - Inhibits Module Inactive or Force Module Active                                                                                                            0: No emulation altering user-desired module state                                      1: Emulation alters user-desired module state" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="EMURST" width="1" begin="9" end="9" resetval="0" description="Emulation Alters Reset (lrst or mrst) to Module                                             0: No emulation altering user-desired reset                                                  1: Emulation alters user-desired module state " range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="LRSTz" width="1" begin="8" end="8" resetval="0" description="Module local reset actual status                                                                    0: local reset asserted                                                                                  1: local reset de-asserted" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="_RESV" width="3" begin="7" end="5" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="STATE" width="5" begin="4" end="0" resetval="0" description="These bits indiacte the current module state                                                010: SyncReset                                                                                      000: SwRstDisable                                                                                      001: Disable                                                                                            011: Enable                                                                                                    111: Disable Clock-On Transition                                                                                                                                                                                                                                          100, 101, 110:   Reserved" range="" rwaccess="R">
         
      </bitfield>
   </register>
   <register id="MDSTAT17" acronym="MDSTAT17" offset="0x844" width="32" description="Module Status 17 Register">
      <bitfield id="_RESV" width="10" begin="31" end="22" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="MSTID" width="6" begin="21" end="16" resetval="0" description="Master ID. If ACSLP occurs, this field records the master ID of the master that caused the access. This bit is cleared when the corresponding ERRCR bit is written with a 1. " range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="_RESV" width="2" begin="15" end="14" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="ACSLP" width="2" begin="13" end="12" resetval="0" description="Non-emulation access to Module in Sleep occurred.                                    00:  Condition did not occur                                                                           01:  Access to module in sleep occurred. PSC transitioned the module from Sleep state to Temp Wake state then back to Sleep state                                                     10:  Access to module in sleep occured. PSC transitioned the module from Sleep state to Enable state                                                                   11: Reserved           " range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="WKRSLP" width="1" begin="11" end="11" resetval="0" description="Wakeup Request to Module in Sleep Detected.  Wakeup_pi is detected for this module when it is in sleep. If MDCTL.WKRSLPIE = 1, the setting of this field can cause ERRPR for this module to be set.                                          0: Condition did not occur                                                                              1: wakeup_pi = 1 when module is in sleep.                                     " range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="EMUIHB" width="1" begin="10" end="10" resetval="0" description="Emulation Alters Module State - Inhibits Module Inactive or Force Module Active                                                                                                            0: No emulation altering user-desired module state                                      1: Emulation alters user-desired module state" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="EMURST" width="1" begin="9" end="9" resetval="0" description="Emulation Alters Reset (lrst or mrst) to Module                                             0: No emulation altering user-desired reset                                                  1: Emulation alters user-desired module state " range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="LRSTz" width="1" begin="8" end="8" resetval="0" description="Module local reset actual status                                                                    0: local reset asserted                                                                                  1: local reset de-asserted" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="_RESV" width="3" begin="7" end="5" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="STATE" width="5" begin="4" end="0" resetval="0" description="These bits indiacte the current module state                                                010: SyncReset                                                                                      000: SwRstDisable                                                                                      001: Disable                                                                                            011: Enable                                                                                                    111: Disable Clock-On Transition                                                                                                                                                                                                                                          100, 101, 110:   Reserved" range="" rwaccess="R">
         
      </bitfield>
   </register>
   <register id="MDSTAT18" acronym="MDSTAT18" offset="0x848" width="32" description="Module Status 18 Register">
      <bitfield id="_RESV" width="10" begin="31" end="22" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="MSTID" width="6" begin="21" end="16" resetval="0" description="Master ID. If ACSLP occurs, this field records the master ID of the master that caused the access. This bit is cleared when the corresponding ERRCR bit is written with a 1. " range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="_RESV" width="2" begin="15" end="14" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="ACSLP" width="2" begin="13" end="12" resetval="0" description="Non-emulation access to Module in Sleep occurred.                                    00:  Condition did not occur                                                                           01:  Access to module in sleep occurred. PSC transitioned the module from Sleep state to Temp Wake state then back to Sleep state                                                     10:  Access to module in sleep occured. PSC transitioned the module from Sleep state to Enable state                                                                   11: Reserved           " range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="WKRSLP" width="1" begin="11" end="11" resetval="0" description="Wakeup Request to Module in Sleep Detected.  Wakeup_pi is detected for this module when it is in sleep. If MDCTL.WKRSLPIE = 1, the setting of this field can cause ERRPR for this module to be set.                                          0: Condition did not occur                                                                              1: wakeup_pi = 1 when module is in sleep.                                     " range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="EMUIHB" width="1" begin="10" end="10" resetval="0" description="Emulation Alters Module State - Inhibits Module Inactive or Force Module Active                                                                                                            0: No emulation altering user-desired module state                                      1: Emulation alters user-desired module state" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="EMURST" width="1" begin="9" end="9" resetval="0" description="Emulation Alters Reset (lrst or mrst) to Module                                             0: No emulation altering user-desired reset                                                  1: Emulation alters user-desired module state " range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="LRSTz" width="1" begin="8" end="8" resetval="0" description="Module local reset actual status                                                                    0: local reset asserted                                                                                  1: local reset de-asserted" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="_RESV" width="3" begin="7" end="5" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="STATE" width="5" begin="4" end="0" resetval="0" description="These bits indiacte the current module state                                                010: SyncReset                                                                                      000: SwRstDisable                                                                                      001: Disable                                                                                            011: Enable                                                                                                    111: Disable Clock-On Transition                                                                                                                                                                                                                                          100, 101, 110:   Reserved" range="" rwaccess="R">
         
      </bitfield>
   </register>
   <register id="MDSTAT19" acronym="MDSTAT19" offset="0x84C" width="32" description="Module Status 19 Register">
      <bitfield id="_RESV" width="10" begin="31" end="22" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="MSTID" width="6" begin="21" end="16" resetval="0" description="Master ID. If ACSLP occurs, this field records the master ID of the master that caused the access. This bit is cleared when the corresponding ERRCR bit is written with a 1. " range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="_RESV" width="2" begin="15" end="14" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="ACSLP" width="2" begin="13" end="12" resetval="0" description="Non-emulation access to Module in Sleep occurred.                                    00:  Condition did not occur                                                                           01:  Access to module in sleep occurred. PSC transitioned the module from Sleep state to Temp Wake state then back to Sleep state                                                     10:  Access to module in sleep occured. PSC transitioned the module from Sleep state to Enable state                                                                   11: Reserved           " range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="WKRSLP" width="1" begin="11" end="11" resetval="0" description="Wakeup Request to Module in Sleep Detected.  Wakeup_pi is detected for this module when it is in sleep. If MDCTL.WKRSLPIE = 1, the setting of this field can cause ERRPR for this module to be set.                                          0: Condition did not occur                                                                              1: wakeup_pi = 1 when module is in sleep.                                     " range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="EMUIHB" width="1" begin="10" end="10" resetval="0" description="Emulation Alters Module State - Inhibits Module Inactive or Force Module Active                                                                                                            0: No emulation altering user-desired module state                                      1: Emulation alters user-desired module state" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="EMURST" width="1" begin="9" end="9" resetval="0" description="Emulation Alters Reset (lrst or mrst) to Module                                             0: No emulation altering user-desired reset                                                  1: Emulation alters user-desired module state " range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="LRSTz" width="1" begin="8" end="8" resetval="0" description="Module local reset actual status                                                                    0: local reset asserted                                                                                  1: local reset de-asserted" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="_RESV" width="3" begin="7" end="5" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="STATE" width="5" begin="4" end="0" resetval="0" description="These bits indiacte the current module state                                                010: SyncReset                                                                                      000: SwRstDisable                                                                                      001: Disable                                                                                            011: Enable                                                                                                    111: Disable Clock-On Transition                                                                                                                                                                                                                                          100, 101, 110:   Reserved" range="" rwaccess="R">
         
      </bitfield>
   </register>
   <register id="MDSTAT20" acronym="MDSTAT20" offset="0x850" width="32" description="Module Status 20 Register">
      <bitfield id="_RESV" width="10" begin="31" end="22" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="MSTID" width="6" begin="21" end="16" resetval="0" description="Master ID. If ACSLP occurs, this field records the master ID of the master that caused the access. This bit is cleared when the corresponding ERRCR bit is written with a 1. " range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="_RESV" width="2" begin="15" end="14" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="ACSLP" width="2" begin="13" end="12" resetval="0" description="Non-emulation access to Module in Sleep occurred.                                    00:  Condition did not occur                                                                           01:  Access to module in sleep occurred. PSC transitioned the module from Sleep state to Temp Wake state then back to Sleep state                                                     10:  Access to module in sleep occured. PSC transitioned the module from Sleep state to Enable state                                                                   11: Reserved           " range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="WKRSLP" width="1" begin="11" end="11" resetval="0" description="Wakeup Request to Module in Sleep Detected.  Wakeup_pi is detected for this module when it is in sleep. If MDCTL.WKRSLPIE = 1, the setting of this field can cause ERRPR for this module to be set.                                          0: Condition did not occur                                                                              1: wakeup_pi = 1 when module is in sleep.                                     " range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="EMUIHB" width="1" begin="10" end="10" resetval="0" description="Emulation Alters Module State - Inhibits Module Inactive or Force Module Active                                                                                                            0: No emulation altering user-desired module state                                      1: Emulation alters user-desired module state" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="EMURST" width="1" begin="9" end="9" resetval="0" description="Emulation Alters Reset (lrst or mrst) to Module                                             0: No emulation altering user-desired reset                                                  1: Emulation alters user-desired module state " range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="LRSTz" width="1" begin="8" end="8" resetval="0" description="Module local reset actual status                                                                    0: local reset asserted                                                                                  1: local reset de-asserted" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="_RESV" width="3" begin="7" end="5" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="STATE" width="5" begin="4" end="0" resetval="0" description="These bits indiacte the current module state                                                010: SyncReset                                                                                      000: SwRstDisable                                                                                      001: Disable                                                                                            011: Enable                                                                                                    111: Disable Clock-On Transition                                                                                                                                                                                                                                          100, 101, 110:   Reserved" range="" rwaccess="R">
         
      </bitfield>
   </register>
   <register id="MDSTAT21" acronym="MDSTAT21" offset="0x854" width="32" description="Module Status 21 Register">
      <bitfield id="_RESV" width="10" begin="31" end="22" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="MSTID" width="6" begin="21" end="16" resetval="0" description="Master ID. If ACSLP occurs, this field records the master ID of the master that caused the access. This bit is cleared when the corresponding ERRCR bit is written with a 1. " range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="_RESV" width="2" begin="15" end="14" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="ACSLP" width="2" begin="13" end="12" resetval="0" description="Non-emulation access to Module in Sleep occurred.                                    00:  Condition did not occur                                                                           01:  Access to module in sleep occurred. PSC transitioned the module from Sleep state to Temp Wake state then back to Sleep state                                                     10:  Access to module in sleep occured. PSC transitioned the module from Sleep state to Enable state                                                                   11: Reserved           " range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="WKRSLP" width="1" begin="11" end="11" resetval="0" description="Wakeup Request to Module in Sleep Detected.  Wakeup_pi is detected for this module when it is in sleep. If MDCTL.WKRSLPIE = 1, the setting of this field can cause ERRPR for this module to be set.                                          0: Condition did not occur                                                                              1: wakeup_pi = 1 when module is in sleep.                                     " range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="EMUIHB" width="1" begin="10" end="10" resetval="0" description="Emulation Alters Module State - Inhibits Module Inactive or Force Module Active                                                                                                            0: No emulation altering user-desired module state                                      1: Emulation alters user-desired module state" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="EMURST" width="1" begin="9" end="9" resetval="0" description="Emulation Alters Reset (lrst or mrst) to Module                                             0: No emulation altering user-desired reset                                                  1: Emulation alters user-desired module state " range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="LRSTz" width="1" begin="8" end="8" resetval="0" description="Module local reset actual status                                                                    0: local reset asserted                                                                                  1: local reset de-asserted" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="_RESV" width="3" begin="7" end="5" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="STATE" width="5" begin="4" end="0" resetval="0" description="These bits indiacte the current module state                                                010: SyncReset                                                                                      000: SwRstDisable                                                                                      001: Disable                                                                                            011: Enable                                                                                                    111: Disable Clock-On Transition                                                                                                                                                                                                                                          100, 101, 110:   Reserved" range="" rwaccess="R">
         
      </bitfield>
   </register>
   <register id="MDSTAT22" acronym="MDSTAT22" offset="0x858" width="32" description="Module Status 22 Register">
      <bitfield id="_RESV" width="10" begin="31" end="22" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="MSTID" width="6" begin="21" end="16" resetval="0" description="Master ID. If ACSLP occurs, this field records the master ID of the master that caused the access. This bit is cleared when the corresponding ERRCR bit is written with a 1. " range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="_RESV" width="2" begin="15" end="14" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="ACSLP" width="2" begin="13" end="12" resetval="0" description="Non-emulation access to Module in Sleep occurred.                                    00:  Condition did not occur                                                                           01:  Access to module in sleep occurred. PSC transitioned the module from Sleep state to Temp Wake state then back to Sleep state                                                     10:  Access to module in sleep occured. PSC transitioned the module from Sleep state to Enable state                                                                   11: Reserved           " range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="WKRSLP" width="1" begin="11" end="11" resetval="0" description="Wakeup Request to Module in Sleep Detected.  Wakeup_pi is detected for this module when it is in sleep. If MDCTL.WKRSLPIE = 1, the setting of this field can cause ERRPR for this module to be set.                                          0: Condition did not occur                                                                              1: wakeup_pi = 1 when module is in sleep.                                     " range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="EMUIHB" width="1" begin="10" end="10" resetval="0" description="Emulation Alters Module State - Inhibits Module Inactive or Force Module Active                                                                                                            0: No emulation altering user-desired module state                                      1: Emulation alters user-desired module state" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="EMURST" width="1" begin="9" end="9" resetval="0" description="Emulation Alters Reset (lrst or mrst) to Module                                             0: No emulation altering user-desired reset                                                  1: Emulation alters user-desired module state " range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="LRSTz" width="1" begin="8" end="8" resetval="0" description="Module local reset actual status                                                                    0: local reset asserted                                                                                  1: local reset de-asserted" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="_RESV" width="3" begin="7" end="5" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="STATE" width="5" begin="4" end="0" resetval="0" description="These bits indiacte the current module state                                                010: SyncReset                                                                                      000: SwRstDisable                                                                                      001: Disable                                                                                            011: Enable                                                                                                    111: Disable Clock-On Transition                                                                                                                                                                                                                                          100, 101, 110:   Reserved" range="" rwaccess="R">
         
      </bitfield>
   </register>
   <register id="MDSTAT23" acronym="MDSTAT23" offset="0x85C" width="32" description="Module Status 23 Register">
      <bitfield id="_RESV" width="10" begin="31" end="22" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="MSTID" width="6" begin="21" end="16" resetval="0" description="Master ID. If ACSLP occurs, this field records the master ID of the master that caused the access. This bit is cleared when the corresponding ERRCR bit is written with a 1. " range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="_RESV" width="2" begin="15" end="14" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="ACSLP" width="2" begin="13" end="12" resetval="0" description="Non-emulation access to Module in Sleep occurred.                                    00:  Condition did not occur                                                                           01:  Access to module in sleep occurred. PSC transitioned the module from Sleep state to Temp Wake state then back to Sleep state                                                     10:  Access to module in sleep occured. PSC transitioned the module from Sleep state to Enable state                                                                   11: Reserved           " range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="WKRSLP" width="1" begin="11" end="11" resetval="0" description="Wakeup Request to Module in Sleep Detected.  Wakeup_pi is detected for this module when it is in sleep. If MDCTL.WKRSLPIE = 1, the setting of this field can cause ERRPR for this module to be set.                                          0: Condition did not occur                                                                              1: wakeup_pi = 1 when module is in sleep.                                     " range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="EMUIHB" width="1" begin="10" end="10" resetval="0" description="Emulation Alters Module State - Inhibits Module Inactive or Force Module Active                                                                                                            0: No emulation altering user-desired module state                                      1: Emulation alters user-desired module state" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="EMURST" width="1" begin="9" end="9" resetval="0" description="Emulation Alters Reset (lrst or mrst) to Module                                             0: No emulation altering user-desired reset                                                  1: Emulation alters user-desired module state " range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="LRSTz" width="1" begin="8" end="8" resetval="0" description="Module local reset actual status                                                                    0: local reset asserted                                                                                  1: local reset de-asserted" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="_RESV" width="3" begin="7" end="5" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="STATE" width="5" begin="4" end="0" resetval="0" description="These bits indiacte the current module state                                                010: SyncReset                                                                                      000: SwRstDisable                                                                                      001: Disable                                                                                            011: Enable                                                                                                    111: Disable Clock-On Transition                                                                                                                                                                                                                                          100, 101, 110:   Reserved" range="" rwaccess="R">
         
      </bitfield>
   </register>
   <register id="MDSTAT24" acronym="MDSTAT24" offset="0x860" width="32" description="Module Status 24 Register">
      <bitfield id="_RESV" width="10" begin="31" end="22" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="MSTID" width="6" begin="21" end="16" resetval="0" description="Master ID. If ACSLP occurs, this field records the master ID of the master that caused the access. This bit is cleared when the corresponding ERRCR bit is written with a 1. " range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="_RESV" width="2" begin="15" end="14" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="ACSLP" width="2" begin="13" end="12" resetval="0" description="Non-emulation access to Module in Sleep occurred.                                    00:  Condition did not occur                                                                           01:  Access to module in sleep occurred. PSC transitioned the module from Sleep state to Temp Wake state then back to Sleep state                                                     10:  Access to module in sleep occured. PSC transitioned the module from Sleep state to Enable state                                                                   11: Reserved           " range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="WKRSLP" width="1" begin="11" end="11" resetval="0" description="Wakeup Request to Module in Sleep Detected.  Wakeup_pi is detected for this module when it is in sleep. If MDCTL.WKRSLPIE = 1, the setting of this field can cause ERRPR for this module to be set.                                          0: Condition did not occur                                                                              1: wakeup_pi = 1 when module is in sleep.                                     " range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="EMUIHB" width="1" begin="10" end="10" resetval="0" description="Emulation Alters Module State - Inhibits Module Inactive or Force Module Active                                                                                                            0: No emulation altering user-desired module state                                      1: Emulation alters user-desired module state" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="EMURST" width="1" begin="9" end="9" resetval="0" description="Emulation Alters Reset (lrst or mrst) to Module                                             0: No emulation altering user-desired reset                                                  1: Emulation alters user-desired module state " range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="LRSTz" width="1" begin="8" end="8" resetval="0" description="Module local reset actual status                                                                    0: local reset asserted                                                                                  1: local reset de-asserted" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="_RESV" width="3" begin="7" end="5" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="STATE" width="5" begin="4" end="0" resetval="0" description="These bits indiacte the current module state                                                010: SyncReset                                                                                      000: SwRstDisable                                                                                      001: Disable                                                                                            011: Enable                                                                                                    111: Disable Clock-On Transition                                                                                                                                                                                                                                          100, 101, 110:   Reserved" range="" rwaccess="R">
         
      </bitfield>
   </register>
   <register id="MDSTAT25" acronym="MDSTAT25" offset="0x864" width="32" description="Module Status 25 Register">
      <bitfield id="_RESV" width="10" begin="31" end="22" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="MSTID" width="6" begin="21" end="16" resetval="0" description="Master ID. If ACSLP occurs, this field records the master ID of the master that caused the access. This bit is cleared when the corresponding ERRCR bit is written with a 1. " range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="_RESV" width="2" begin="15" end="14" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="ACSLP" width="2" begin="13" end="12" resetval="0" description="Non-emulation access to Module in Sleep occurred.                                    00:  Condition did not occur                                                                           01:  Access to module in sleep occurred. PSC transitioned the module from Sleep state to Temp Wake state then back to Sleep state                                                     10:  Access to module in sleep occured. PSC transitioned the module from Sleep state to Enable state                                                                   11: Reserved           " range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="WKRSLP" width="1" begin="11" end="11" resetval="0" description="Wakeup Request to Module in Sleep Detected.  Wakeup_pi is detected for this module when it is in sleep. If MDCTL.WKRSLPIE = 1, the setting of this field can cause ERRPR for this module to be set.                                          0: Condition did not occur                                                                              1: wakeup_pi = 1 when module is in sleep.                                     " range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="EMUIHB" width="1" begin="10" end="10" resetval="0" description="Emulation Alters Module State - Inhibits Module Inactive or Force Module Active                                                                                                            0: No emulation altering user-desired module state                                      1: Emulation alters user-desired module state" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="EMURST" width="1" begin="9" end="9" resetval="0" description="Emulation Alters Reset (lrst or mrst) to Module                                             0: No emulation altering user-desired reset                                                  1: Emulation alters user-desired module state " range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="LRSTz" width="1" begin="8" end="8" resetval="0" description="Module local reset actual status                                                                    0: local reset asserted                                                                                  1: local reset de-asserted" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="_RESV" width="3" begin="7" end="5" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="STATE" width="5" begin="4" end="0" resetval="0" description="These bits indiacte the current module state                                                010: SyncReset                                                                                      000: SwRstDisable                                                                                      001: Disable                                                                                            011: Enable                                                                                                    111: Disable Clock-On Transition                                                                                                                                                                                                                                          100, 101, 110:   Reserved" range="" rwaccess="R">
         
      </bitfield>
   </register>
   <register id="MDSTAT26" acronym="MDSTAT26" offset="0x868" width="32" description="Module Status 26 Register">
      <bitfield id="_RESV" width="10" begin="31" end="22" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="MSTID" width="6" begin="21" end="16" resetval="0" description="Master ID. If ACSLP occurs, this field records the master ID of the master that caused the access. This bit is cleared when the corresponding ERRCR bit is written with a 1. " range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="_RESV" width="2" begin="15" end="14" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="ACSLP" width="2" begin="13" end="12" resetval="0" description="Non-emulation access to Module in Sleep occurred.                                    00:  Condition did not occur                                                                           01:  Access to module in sleep occurred. PSC transitioned the module from Sleep state to Temp Wake state then back to Sleep state                                                     10:  Access to module in sleep occured. PSC transitioned the module from Sleep state to Enable state                                                                   11: Reserved           " range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="WKRSLP" width="1" begin="11" end="11" resetval="0" description="Wakeup Request to Module in Sleep Detected.  Wakeup_pi is detected for this module when it is in sleep. If MDCTL.WKRSLPIE = 1, the setting of this field can cause ERRPR for this module to be set.                                          0: Condition did not occur                                                                              1: wakeup_pi = 1 when module is in sleep.                                     " range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="EMUIHB" width="1" begin="10" end="10" resetval="0" description="Emulation Alters Module State - Inhibits Module Inactive or Force Module Active                                                                                                            0: No emulation altering user-desired module state                                      1: Emulation alters user-desired module state" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="EMURST" width="1" begin="9" end="9" resetval="0" description="Emulation Alters Reset (lrst or mrst) to Module                                             0: No emulation altering user-desired reset                                                  1: Emulation alters user-desired module state " range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="LRSTz" width="1" begin="8" end="8" resetval="0" description="Module local reset actual status                                                                    0: local reset asserted                                                                                  1: local reset de-asserted" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="_RESV" width="3" begin="7" end="5" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="STATE" width="5" begin="4" end="0" resetval="0" description="These bits indiacte the current module state                                                010: SyncReset                                                                                      000: SwRstDisable                                                                                      001: Disable                                                                                            011: Enable                                                                                                    111: Disable Clock-On Transition                                                                                                                                                                                                                                          100, 101, 110:   Reserved" range="" rwaccess="R">
         
      </bitfield>
   </register>
   <register id="MDSTAT27" acronym="MDSTAT27" offset="0x86C" width="32" description="Module Status 27 Register">
      <bitfield id="_RESV" width="10" begin="31" end="22" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="MSTID" width="6" begin="21" end="16" resetval="0" description="Master ID. If ACSLP occurs, this field records the master ID of the master that caused the access. This bit is cleared when the corresponding ERRCR bit is written with a 1. " range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="_RESV" width="2" begin="15" end="14" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="ACSLP" width="2" begin="13" end="12" resetval="0" description="Non-emulation access to Module in Sleep occurred.                                    00:  Condition did not occur                                                                           01:  Access to module in sleep occurred. PSC transitioned the module from Sleep state to Temp Wake state then back to Sleep state                                                     10:  Access to module in sleep occured. PSC transitioned the module from Sleep state to Enable state                                                                   11: Reserved           " range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="WKRSLP" width="1" begin="11" end="11" resetval="0" description="Wakeup Request to Module in Sleep Detected.  Wakeup_pi is detected for this module when it is in sleep. If MDCTL.WKRSLPIE = 1, the setting of this field can cause ERRPR for this module to be set.                                          0: Condition did not occur                                                                              1: wakeup_pi = 1 when module is in sleep.                                     " range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="EMUIHB" width="1" begin="10" end="10" resetval="0" description="Emulation Alters Module State - Inhibits Module Inactive or Force Module Active                                                                                                            0: No emulation altering user-desired module state                                      1: Emulation alters user-desired module state" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="EMURST" width="1" begin="9" end="9" resetval="0" description="Emulation Alters Reset (lrst or mrst) to Module                                             0: No emulation altering user-desired reset                                                  1: Emulation alters user-desired module state " range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="LRSTz" width="1" begin="8" end="8" resetval="0" description="Module local reset actual status                                                                    0: local reset asserted                                                                                  1: local reset de-asserted" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="_RESV" width="3" begin="7" end="5" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="STATE" width="5" begin="4" end="0" resetval="0" description="These bits indiacte the current module state                                                010: SyncReset                                                                                      000: SwRstDisable                                                                                      001: Disable                                                                                            011: Enable                                                                                                    111: Disable Clock-On Transition                                                                                                                                                                                                                                          100, 101, 110:   Reserved" range="" rwaccess="R">
         
      </bitfield>
   </register>
   <register id="MDSTAT28" acronym="MDSTAT28" offset="0x870" width="32" description="Module Status 28 Register">
      <bitfield id="_RESV" width="10" begin="31" end="22" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="MSTID" width="6" begin="21" end="16" resetval="0" description="Master ID. If ACSLP occurs, this field records the master ID of the master that caused the access. This bit is cleared when the corresponding ERRCR bit is written with a 1. " range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="_RESV" width="2" begin="15" end="14" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="ACSLP" width="2" begin="13" end="12" resetval="0" description="Non-emulation access to Module in Sleep occurred.                                    00:  Condition did not occur                                                                           01:  Access to module in sleep occurred. PSC transitioned the module from Sleep state to Temp Wake state then back to Sleep state                                                     10:  Access to module in sleep occured. PSC transitioned the module from Sleep state to Enable state                                                                   11: Reserved           " range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="WKRSLP" width="1" begin="11" end="11" resetval="0" description="Wakeup Request to Module in Sleep Detected.  Wakeup_pi is detected for this module when it is in sleep. If MDCTL.WKRSLPIE = 1, the setting of this field can cause ERRPR for this module to be set.                                          0: Condition did not occur                                                                              1: wakeup_pi = 1 when module is in sleep.                                     " range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="EMUIHB" width="1" begin="10" end="10" resetval="0" description="Emulation Alters Module State - Inhibits Module Inactive or Force Module Active                                                                                                            0: No emulation altering user-desired module state                                      1: Emulation alters user-desired module state" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="EMURST" width="1" begin="9" end="9" resetval="0" description="Emulation Alters Reset (lrst or mrst) to Module                                             0: No emulation altering user-desired reset                                                  1: Emulation alters user-desired module state " range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="LRSTz" width="1" begin="8" end="8" resetval="0" description="Module local reset actual status                                                                    0: local reset asserted                                                                                  1: local reset de-asserted" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="_RESV" width="3" begin="7" end="5" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="STATE" width="5" begin="4" end="0" resetval="0" description="These bits indiacte the current module state                                                010: SyncReset                                                                                      000: SwRstDisable                                                                                      001: Disable                                                                                            011: Enable                                                                                                    111: Disable Clock-On Transition                                                                                                                                                                                                                                          100, 101, 110:   Reserved" range="" rwaccess="R">
         
      </bitfield>
   </register>
   <register id="MDSTAT29" acronym="MDSTAT29" offset="0x874" width="32" description="Module Status 29 Register">
      <bitfield id="_RESV" width="10" begin="31" end="22" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="MSTID" width="6" begin="21" end="16" resetval="0" description="Master ID. If ACSLP occurs, this field records the master ID of the master that caused the access. This bit is cleared when the corresponding ERRCR bit is written with a 1. " range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="_RESV" width="2" begin="15" end="14" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="ACSLP" width="2" begin="13" end="12" resetval="0" description="Non-emulation access to Module in Sleep occurred.                                    00:  Condition did not occur                                                                           01:  Access to module in sleep occurred. PSC transitioned the module from Sleep state to Temp Wake state then back to Sleep state                                                     10:  Access to module in sleep occured. PSC transitioned the module from Sleep state to Enable state                                                                   11: Reserved           " range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="WKRSLP" width="1" begin="11" end="11" resetval="0" description="Wakeup Request to Module in Sleep Detected.  Wakeup_pi is detected for this module when it is in sleep. If MDCTL.WKRSLPIE = 1, the setting of this field can cause ERRPR for this module to be set.                                          0: Condition did not occur                                                                              1: wakeup_pi = 1 when module is in sleep.                                     " range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="EMUIHB" width="1" begin="10" end="10" resetval="0" description="Emulation Alters Module State - Inhibits Module Inactive or Force Module Active                                                                                                            0: No emulation altering user-desired module state                                      1: Emulation alters user-desired module state" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="EMURST" width="1" begin="9" end="9" resetval="0" description="Emulation Alters Reset (lrst or mrst) to Module                                             0: No emulation altering user-desired reset                                                  1: Emulation alters user-desired module state " range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="LRSTz" width="1" begin="8" end="8" resetval="0" description="Module local reset actual status                                                                    0: local reset asserted                                                                                  1: local reset de-asserted" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="_RESV" width="3" begin="7" end="5" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="STATE" width="5" begin="4" end="0" resetval="0" description="These bits indiacte the current module state                                                010: SyncReset                                                                                      000: SwRstDisable                                                                                      001: Disable                                                                                            011: Enable                                                                                                    111: Disable Clock-On Transition                                                                                                                                                                                                                                          100, 101, 110:   Reserved" range="" rwaccess="R">
         
      </bitfield>
   </register>
   <register id="MDSTAT30" acronym="MDSTAT30" offset="0x878" width="32" description="Module Status 30 Register">
      <bitfield id="_RESV" width="10" begin="31" end="22" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="MSTID" width="6" begin="21" end="16" resetval="0" description="Master ID. If ACSLP occurs, this field records the master ID of the master that caused the access. This bit is cleared when the corresponding ERRCR bit is written with a 1. " range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="_RESV" width="2" begin="15" end="14" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="ACSLP" width="2" begin="13" end="12" resetval="0" description="Non-emulation access to Module in Sleep occurred.                                    00:  Condition did not occur                                                                           01:  Access to module in sleep occurred. PSC transitioned the module from Sleep state to Temp Wake state then back to Sleep state                                                     10:  Access to module in sleep occured. PSC transitioned the module from Sleep state to Enable state                                                                   11: Reserved           " range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="WKRSLP" width="1" begin="11" end="11" resetval="0" description="Wakeup Request to Module in Sleep Detected.  Wakeup_pi is detected for this module when it is in sleep. If MDCTL.WKRSLPIE = 1, the setting of this field can cause ERRPR for this module to be set.                                          0: Condition did not occur                                                                              1: wakeup_pi = 1 when module is in sleep.                                     " range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="EMUIHB" width="1" begin="10" end="10" resetval="0" description="Emulation Alters Module State - Inhibits Module Inactive or Force Module Active                                                                                                            0: No emulation altering user-desired module state                                      1: Emulation alters user-desired module state" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="EMURST" width="1" begin="9" end="9" resetval="0" description="Emulation Alters Reset (lrst or mrst) to Module                                             0: No emulation altering user-desired reset                                                  1: Emulation alters user-desired module state " range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="LRSTz" width="1" begin="8" end="8" resetval="0" description="Module local reset actual status                                                                    0: local reset asserted                                                                                  1: local reset de-asserted" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="_RESV" width="3" begin="7" end="5" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="STATE" width="5" begin="4" end="0" resetval="0" description="These bits indiacte the current module state                                                010: SyncReset                                                                                      000: SwRstDisable                                                                                      001: Disable                                                                                            011: Enable                                                                                                    111: Disable Clock-On Transition                                                                                                                                                                                                                                          100, 101, 110:   Reserved" range="" rwaccess="R">
         
      </bitfield>
   </register>
   <register id="MDSTAT31" acronym="MDSTAT31" offset="0x87C" width="32" description="Module Status 31 Register">
      <bitfield id="_RESV" width="10" begin="31" end="22" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="MSTID" width="6" begin="21" end="16" resetval="0" description="Master ID. If ACSLP occurs, this field records the master ID of the master that caused the access. This bit is cleared when the corresponding ERRCR bit is written with a 1. " range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="_RESV" width="2" begin="15" end="14" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="ACSLP" width="2" begin="13" end="12" resetval="0" description="Non-emulation access to Module in Sleep occurred.                                    00:  Condition did not occur                                                                           01:  Access to module in sleep occurred. PSC transitioned the module from Sleep state to Temp Wake state then back to Sleep state                                                     10:  Access to module in sleep occured. PSC transitioned the module from Sleep state to Enable state                                                                   11: Reserved           " range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="WKRSLP" width="1" begin="11" end="11" resetval="0" description="Wakeup Request to Module in Sleep Detected.  Wakeup_pi is detected for this module when it is in sleep. If MDCTL.WKRSLPIE = 1, the setting of this field can cause ERRPR for this module to be set.                                          0: Condition did not occur                                                                              1: wakeup_pi = 1 when module is in sleep.                                     " range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="EMUIHB" width="1" begin="10" end="10" resetval="0" description="Emulation Alters Module State - Inhibits Module Inactive or Force Module Active                                                                                                            0: No emulation altering user-desired module state                                      1: Emulation alters user-desired module state" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="EMURST" width="1" begin="9" end="9" resetval="0" description="Emulation Alters Reset (lrst or mrst) to Module                                             0: No emulation altering user-desired reset                                                  1: Emulation alters user-desired module state " range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="LRSTz" width="1" begin="8" end="8" resetval="0" description="Module local reset actual status                                                                    0: local reset asserted                                                                                  1: local reset de-asserted" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="_RESV" width="3" begin="7" end="5" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="STATE" width="5" begin="4" end="0" resetval="0" description="These bits indiacte the current module state                                                010: SyncReset                                                                                      000: SwRstDisable                                                                                      001: Disable                                                                                            011: Enable                                                                                                    111: Disable Clock-On Transition                                                                                                                                                                                                                                          100, 101, 110:   Reserved" range="" rwaccess="R">
         
      </bitfield>
   </register>
   <register id="MDSTAT32" acronym="MDSTAT32" offset="0x880" width="32" description="Module Status 32 Register">
      <bitfield id="_RESV" width="10" begin="31" end="22" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="MSTID" width="6" begin="21" end="16" resetval="0" description="Master ID. If ACSLP occurs, this field records the master ID of the master that caused the access. This bit is cleared when the corresponding ERRCR bit is written with a 1. " range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="_RESV" width="2" begin="15" end="14" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="ACSLP" width="2" begin="13" end="12" resetval="0" description="Non-emulation access to Module in Sleep occurred.                                    00:  Condition did not occur                                                                           01:  Access to module in sleep occurred. PSC transitioned the module from Sleep state to Temp Wake state then back to Sleep state                                                     10:  Access to module in sleep occured. PSC transitioned the module from Sleep state to Enable state                                                                   11: Reserved           " range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="WKRSLP" width="1" begin="11" end="11" resetval="0" description="Wakeup Request to Module in Sleep Detected.  Wakeup_pi is detected for this module when it is in sleep. If MDCTL.WKRSLPIE = 1, the setting of this field can cause ERRPR for this module to be set.                                          0: Condition did not occur                                                                              1: wakeup_pi = 1 when module is in sleep.                                     " range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="EMUIHB" width="1" begin="10" end="10" resetval="0" description="Emulation Alters Module State - Inhibits Module Inactive or Force Module Active                                                                                                            0: No emulation altering user-desired module state                                      1: Emulation alters user-desired module state" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="EMURST" width="1" begin="9" end="9" resetval="0" description="Emulation Alters Reset (lrst or mrst) to Module                                             0: No emulation altering user-desired reset                                                  1: Emulation alters user-desired module state " range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="LRSTz" width="1" begin="8" end="8" resetval="0" description="Module local reset actual status                                                                    0: local reset asserted                                                                                  1: local reset de-asserted" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="_RESV" width="3" begin="7" end="5" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="STATE" width="5" begin="4" end="0" resetval="0" description="These bits indiacte the current module state                                                010: SyncReset                                                                                      000: SwRstDisable                                                                                      001: Disable                                                                                            011: Enable                                                                                                    111: Disable Clock-On Transition                                                                                                                                                                                                                                          100, 101, 110:   Reserved" range="" rwaccess="R">
         
      </bitfield>
   </register>
   <register id="MDSTAT33" acronym="MDSTAT33" offset="0x884" width="32" description="Module Status 33 Register">
      <bitfield id="_RESV" width="10" begin="31" end="22" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="MSTID" width="6" begin="21" end="16" resetval="0" description="Master ID. If ACSLP occurs, this field records the master ID of the master that caused the access. This bit is cleared when the corresponding ERRCR bit is written with a 1. " range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="_RESV" width="2" begin="15" end="14" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="ACSLP" width="2" begin="13" end="12" resetval="0" description="Non-emulation access to Module in Sleep occurred.                                    00:  Condition did not occur                                                                           01:  Access to module in sleep occurred. PSC transitioned the module from Sleep state to Temp Wake state then back to Sleep state                                                     10:  Access to module in sleep occured. PSC transitioned the module from Sleep state to Enable state                                                                   11: Reserved           " range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="WKRSLP" width="1" begin="11" end="11" resetval="0" description="Wakeup Request to Module in Sleep Detected.  Wakeup_pi is detected for this module when it is in sleep. If MDCTL.WKRSLPIE = 1, the setting of this field can cause ERRPR for this module to be set.                                          0: Condition did not occur                                                                              1: wakeup_pi = 1 when module is in sleep.                                     " range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="EMUIHB" width="1" begin="10" end="10" resetval="0" description="Emulation Alters Module State - Inhibits Module Inactive or Force Module Active                                                                                                            0: No emulation altering user-desired module state                                      1: Emulation alters user-desired module state" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="EMURST" width="1" begin="9" end="9" resetval="0" description="Emulation Alters Reset (lrst or mrst) to Module                                             0: No emulation altering user-desired reset                                                  1: Emulation alters user-desired module state " range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="LRSTz" width="1" begin="8" end="8" resetval="0" description="Module local reset actual status                                                                    0: local reset asserted                                                                                  1: local reset de-asserted" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="_RESV" width="3" begin="7" end="5" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="STATE" width="5" begin="4" end="0" resetval="0" description="These bits indiacte the current module state                                                010: SyncReset                                                                                      000: SwRstDisable                                                                                      001: Disable                                                                                            011: Enable                                                                                                    111: Disable Clock-On Transition                                                                                                                                                                                                                                          100, 101, 110:   Reserved" range="" rwaccess="R">
         
      </bitfield>
   </register>
   <register id="MDSTAT34" acronym="MDSTAT34" offset="0x888" width="32" description="Module Status 34 Register">
      <bitfield id="_RESV" width="10" begin="31" end="22" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="MSTID" width="6" begin="21" end="16" resetval="0" description="Master ID. If ACSLP occurs, this field records the master ID of the master that caused the access. This bit is cleared when the corresponding ERRCR bit is written with a 1. " range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="_RESV" width="2" begin="15" end="14" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="ACSLP" width="2" begin="13" end="12" resetval="0" description="Non-emulation access to Module in Sleep occurred.                                    00:  Condition did not occur                                                                           01:  Access to module in sleep occurred. PSC transitioned the module from Sleep state to Temp Wake state then back to Sleep state                                                     10:  Access to module in sleep occured. PSC transitioned the module from Sleep state to Enable state                                                                   11: Reserved           " range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="WKRSLP" width="1" begin="11" end="11" resetval="0" description="Wakeup Request to Module in Sleep Detected.  Wakeup_pi is detected for this module when it is in sleep. If MDCTL.WKRSLPIE = 1, the setting of this field can cause ERRPR for this module to be set.                                          0: Condition did not occur                                                                              1: wakeup_pi = 1 when module is in sleep.                                     " range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="EMUIHB" width="1" begin="10" end="10" resetval="0" description="Emulation Alters Module State - Inhibits Module Inactive or Force Module Active                                                                                                            0: No emulation altering user-desired module state                                      1: Emulation alters user-desired module state" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="EMURST" width="1" begin="9" end="9" resetval="0" description="Emulation Alters Reset (lrst or mrst) to Module                                             0: No emulation altering user-desired reset                                                  1: Emulation alters user-desired module state " range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="LRSTz" width="1" begin="8" end="8" resetval="0" description="Module local reset actual status                                                                    0: local reset asserted                                                                                  1: local reset de-asserted" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="_RESV" width="3" begin="7" end="5" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="STATE" width="5" begin="4" end="0" resetval="0" description="These bits indiacte the current module state                                                010: SyncReset                                                                                      000: SwRstDisable                                                                                      001: Disable                                                                                            011: Enable                                                                                                    111: Disable Clock-On Transition                                                                                                                                                                                                                                          100, 101, 110:   Reserved" range="" rwaccess="R">
         
      </bitfield>
   </register>
   <register id="MDSTAT35" acronym="MDSTAT35" offset="0x88C" width="32" description="Module Status 35 Register">
      <bitfield id="_RESV" width="10" begin="31" end="22" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="MSTID" width="6" begin="21" end="16" resetval="0" description="Master ID. If ACSLP occurs, this field records the master ID of the master that caused the access. This bit is cleared when the corresponding ERRCR bit is written with a 1. " range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="_RESV" width="2" begin="15" end="14" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="ACSLP" width="2" begin="13" end="12" resetval="0" description="Non-emulation access to Module in Sleep occurred.                                    00:  Condition did not occur                                                                           01:  Access to module in sleep occurred. PSC transitioned the module from Sleep state to Temp Wake state then back to Sleep state                                                     10:  Access to module in sleep occured. PSC transitioned the module from Sleep state to Enable state                                                                   11: Reserved           " range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="WKRSLP" width="1" begin="11" end="11" resetval="0" description="Wakeup Request to Module in Sleep Detected.  Wakeup_pi is detected for this module when it is in sleep. If MDCTL.WKRSLPIE = 1, the setting of this field can cause ERRPR for this module to be set.                                          0: Condition did not occur                                                                              1: wakeup_pi = 1 when module is in sleep.                                     " range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="EMUIHB" width="1" begin="10" end="10" resetval="0" description="Emulation Alters Module State - Inhibits Module Inactive or Force Module Active                                                                                                            0: No emulation altering user-desired module state                                      1: Emulation alters user-desired module state" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="EMURST" width="1" begin="9" end="9" resetval="0" description="Emulation Alters Reset (lrst or mrst) to Module                                             0: No emulation altering user-desired reset                                                  1: Emulation alters user-desired module state " range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="LRSTz" width="1" begin="8" end="8" resetval="0" description="Module local reset actual status                                                                    0: local reset asserted                                                                                  1: local reset de-asserted" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="_RESV" width="3" begin="7" end="5" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="STATE" width="5" begin="4" end="0" resetval="0" description="These bits indiacte the current module state                                                010: SyncReset                                                                                      000: SwRstDisable                                                                                      001: Disable                                                                                            011: Enable                                                                                                    111: Disable Clock-On Transition                                                                                                                                                                                                                                          100, 101, 110:   Reserved" range="" rwaccess="R">
         
      </bitfield>
   </register>
   <register id="MDSTAT36" acronym="MDSTAT36" offset="0x890" width="32" description="Module Status 36 Register">
      <bitfield id="_RESV" width="10" begin="31" end="22" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="MSTID" width="6" begin="21" end="16" resetval="0" description="Master ID. If ACSLP occurs, this field records the master ID of the master that caused the access. This bit is cleared when the corresponding ERRCR bit is written with a 1. " range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="_RESV" width="2" begin="15" end="14" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="ACSLP" width="2" begin="13" end="12" resetval="0" description="Non-emulation access to Module in Sleep occurred.                                    00:  Condition did not occur                                                                           01:  Access to module in sleep occurred. PSC transitioned the module from Sleep state to Temp Wake state then back to Sleep state                                                     10:  Access to module in sleep occured. PSC transitioned the module from Sleep state to Enable state                                                                   11: Reserved           " range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="WKRSLP" width="1" begin="11" end="11" resetval="0" description="Wakeup Request to Module in Sleep Detected.  Wakeup_pi is detected for this module when it is in sleep. If MDCTL.WKRSLPIE = 1, the setting of this field can cause ERRPR for this module to be set.                                          0: Condition did not occur                                                                              1: wakeup_pi = 1 when module is in sleep.                                     " range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="EMUIHB" width="1" begin="10" end="10" resetval="0" description="Emulation Alters Module State - Inhibits Module Inactive or Force Module Active                                                                                                            0: No emulation altering user-desired module state                                      1: Emulation alters user-desired module state" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="EMURST" width="1" begin="9" end="9" resetval="0" description="Emulation Alters Reset (lrst or mrst) to Module                                             0: No emulation altering user-desired reset                                                  1: Emulation alters user-desired module state " range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="LRSTz" width="1" begin="8" end="8" resetval="0" description="Module local reset actual status                                                                    0: local reset asserted                                                                                  1: local reset de-asserted" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="_RESV" width="3" begin="7" end="5" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="STATE" width="5" begin="4" end="0" resetval="0" description="These bits indiacte the current module state                                                010: SyncReset                                                                                      000: SwRstDisable                                                                                      001: Disable                                                                                            011: Enable                                                                                                    111: Disable Clock-On Transition                                                                                                                                                                                                                                          100, 101, 110:   Reserved" range="" rwaccess="R">
         
      </bitfield>
   </register>
   <register id="MDSTAT37" acronym="MDSTAT37" offset="0x894" width="32" description="Module Status 37 Register">
      <bitfield id="_RESV" width="10" begin="31" end="22" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="MSTID" width="6" begin="21" end="16" resetval="0" description="Master ID. If ACSLP occurs, this field records the master ID of the master that caused the access. This bit is cleared when the corresponding ERRCR bit is written with a 1. " range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="_RESV" width="2" begin="15" end="14" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="ACSLP" width="2" begin="13" end="12" resetval="0" description="Non-emulation access to Module in Sleep occurred.                                    00:  Condition did not occur                                                                           01:  Access to module in sleep occurred. PSC transitioned the module from Sleep state to Temp Wake state then back to Sleep state                                                     10:  Access to module in sleep occured. PSC transitioned the module from Sleep state to Enable state                                                                   11: Reserved           " range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="WKRSLP" width="1" begin="11" end="11" resetval="0" description="Wakeup Request to Module in Sleep Detected.  Wakeup_pi is detected for this module when it is in sleep. If MDCTL.WKRSLPIE = 1, the setting of this field can cause ERRPR for this module to be set.                                          0: Condition did not occur                                                                              1: wakeup_pi = 1 when module is in sleep.                                     " range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="EMUIHB" width="1" begin="10" end="10" resetval="0" description="Emulation Alters Module State - Inhibits Module Inactive or Force Module Active                                                                                                            0: No emulation altering user-desired module state                                      1: Emulation alters user-desired module state" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="EMURST" width="1" begin="9" end="9" resetval="0" description="Emulation Alters Reset (lrst or mrst) to Module                                             0: No emulation altering user-desired reset                                                  1: Emulation alters user-desired module state " range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="LRSTz" width="1" begin="8" end="8" resetval="0" description="Module local reset actual status                                                                    0: local reset asserted                                                                                  1: local reset de-asserted" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="_RESV" width="3" begin="7" end="5" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="STATE" width="5" begin="4" end="0" resetval="0" description="These bits indiacte the current module state                                                010: SyncReset                                                                                      000: SwRstDisable                                                                                      001: Disable                                                                                            011: Enable                                                                                                    111: Disable Clock-On Transition                                                                                                                                                                                                                                          100, 101, 110:   Reserved" range="" rwaccess="R">
         
      </bitfield>
   </register>
   <register id="MDSTAT38" acronym="MDSTAT38" offset="0x898" width="32" description="Module Status 38 Register">
      <bitfield id="_RESV" width="10" begin="31" end="22" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="MSTID" width="6" begin="21" end="16" resetval="0" description="Master ID. If ACSLP occurs, this field records the master ID of the master that caused the access. This bit is cleared when the corresponding ERRCR bit is written with a 1. " range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="_RESV" width="2" begin="15" end="14" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="ACSLP" width="2" begin="13" end="12" resetval="0" description="Non-emulation access to Module in Sleep occurred.                                    00:  Condition did not occur                                                                           01:  Access to module in sleep occurred. PSC transitioned the module from Sleep state to Temp Wake state then back to Sleep state                                                     10:  Access to module in sleep occured. PSC transitioned the module from Sleep state to Enable state                                                                   11: Reserved           " range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="WKRSLP" width="1" begin="11" end="11" resetval="0" description="Wakeup Request to Module in Sleep Detected.  Wakeup_pi is detected for this module when it is in sleep. If MDCTL.WKRSLPIE = 1, the setting of this field can cause ERRPR for this module to be set.                                          0: Condition did not occur                                                                              1: wakeup_pi = 1 when module is in sleep.                                     " range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="EMUIHB" width="1" begin="10" end="10" resetval="0" description="Emulation Alters Module State - Inhibits Module Inactive or Force Module Active                                                                                                            0: No emulation altering user-desired module state                                      1: Emulation alters user-desired module state" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="EMURST" width="1" begin="9" end="9" resetval="0" description="Emulation Alters Reset (lrst or mrst) to Module                                             0: No emulation altering user-desired reset                                                  1: Emulation alters user-desired module state " range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="LRSTz" width="1" begin="8" end="8" resetval="0" description="Module local reset actual status                                                                    0: local reset asserted                                                                                  1: local reset de-asserted" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="_RESV" width="3" begin="7" end="5" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="STATE" width="5" begin="4" end="0" resetval="0" description="These bits indiacte the current module state                                                010: SyncReset                                                                                      000: SwRstDisable                                                                                      001: Disable                                                                                            011: Enable                                                                                                    111: Disable Clock-On Transition                                                                                                                                                                                                                                          100, 101, 110:   Reserved" range="" rwaccess="R">
         
      </bitfield>
   </register>
   <register id="MDSTAT39" acronym="MDSTAT39" offset="0x89C" width="32" description="Module Status 39 Register">
      <bitfield id="_RESV" width="10" begin="31" end="22" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="MSTID" width="6" begin="21" end="16" resetval="0" description="Master ID. If ACSLP occurs, this field records the master ID of the master that caused the access. This bit is cleared when the corresponding ERRCR bit is written with a 1. " range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="_RESV" width="2" begin="15" end="14" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="ACSLP" width="2" begin="13" end="12" resetval="0" description="Non-emulation access to Module in Sleep occurred.                                    00:  Condition did not occur                                                                           01:  Access to module in sleep occurred. PSC transitioned the module from Sleep state to Temp Wake state then back to Sleep state                                                     10:  Access to module in sleep occured. PSC transitioned the module from Sleep state to Enable state                                                                   11: Reserved           " range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="WKRSLP" width="1" begin="11" end="11" resetval="0" description="Wakeup Request to Module in Sleep Detected.  Wakeup_pi is detected for this module when it is in sleep. If MDCTL.WKRSLPIE = 1, the setting of this field can cause ERRPR for this module to be set.                                          0: Condition did not occur                                                                              1: wakeup_pi = 1 when module is in sleep.                                     " range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="EMUIHB" width="1" begin="10" end="10" resetval="0" description="Emulation Alters Module State - Inhibits Module Inactive or Force Module Active                                                                                                            0: No emulation altering user-desired module state                                      1: Emulation alters user-desired module state" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="EMURST" width="1" begin="9" end="9" resetval="0" description="Emulation Alters Reset (lrst or mrst) to Module                                             0: No emulation altering user-desired reset                                                  1: Emulation alters user-desired module state " range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="LRSTz" width="1" begin="8" end="8" resetval="0" description="Module local reset actual status                                                                    0: local reset asserted                                                                                  1: local reset de-asserted" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="_RESV" width="3" begin="7" end="5" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="STATE" width="5" begin="4" end="0" resetval="0" description="These bits indiacte the current module state                                                010: SyncReset                                                                                      000: SwRstDisable                                                                                      001: Disable                                                                                            011: Enable                                                                                                    111: Disable Clock-On Transition                                                                                                                                                                                                                                          100, 101, 110:   Reserved" range="" rwaccess="R">
         
      </bitfield>
   </register>
   <register id="MDSTAT40" acronym="MDSTAT40" offset="0x8A0" width="32" description="Module Status 40 Register">
      <bitfield id="_RESV" width="10" begin="31" end="22" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="MSTID" width="6" begin="21" end="16" resetval="0" description="Master ID. If ACSLP occurs, this field records the master ID of the master that caused the access. This bit is cleared when the corresponding ERRCR bit is written with a 1. " range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="_RESV" width="2" begin="15" end="14" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="ACSLP" width="2" begin="13" end="12" resetval="0" description="Non-emulation access to Module in Sleep occurred.                                    00:  Condition did not occur                                                                           01:  Access to module in sleep occurred. PSC transitioned the module from Sleep state to Temp Wake state then back to Sleep state                                                     10:  Access to module in sleep occured. PSC transitioned the module from Sleep state to Enable state                                                                   11: Reserved           " range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="WKRSLP" width="1" begin="11" end="11" resetval="0" description="Wakeup Request to Module in Sleep Detected.  Wakeup_pi is detected for this module when it is in sleep. If MDCTL.WKRSLPIE = 1, the setting of this field can cause ERRPR for this module to be set.                                          0: Condition did not occur                                                                              1: wakeup_pi = 1 when module is in sleep.                                     " range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="EMUIHB" width="1" begin="10" end="10" resetval="0" description="Emulation Alters Module State - Inhibits Module Inactive or Force Module Active                                                                                                            0: No emulation altering user-desired module state                                      1: Emulation alters user-desired module state" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="EMURST" width="1" begin="9" end="9" resetval="0" description="Emulation Alters Reset (lrst or mrst) to Module                                             0: No emulation altering user-desired reset                                                  1: Emulation alters user-desired module state " range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="LRSTz" width="1" begin="8" end="8" resetval="0" description="Module local reset actual status                                                                    0: local reset asserted                                                                                  1: local reset de-asserted" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="_RESV" width="3" begin="7" end="5" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="STATE" width="5" begin="4" end="0" resetval="0" description="These bits indiacte the current module state                                                010: SyncReset                                                                                      000: SwRstDisable                                                                                      001: Disable                                                                                            011: Enable                                                                                                    111: Disable Clock-On Transition                                                                                                                                                                                                                                          100, 101, 110:   Reserved" range="" rwaccess="R">
         
      </bitfield>
   </register>
   <register id="MDCTL0" acronym="MDCTL0" offset="0xA00" width="32" description="Module Control 0 Register">
      <bitfield id="_RESV" width="17" begin="31" end="15" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="WKRSLPIE" width="1" begin="14" end="14" resetval="0" description="Wakeup Request to module in sleep Error Enable.                                        0: Wakeup request to module in sleep is not considered an error condition                                                                                                        1: Wakeup request to module in sleep is considered an error" range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="WKRSLP" width="1" begin="13" end="13" resetval="0" description="Wakeup Request to module in Sleep will cause this action.                         0: PSC transitions module from Sleep state to TWK state, once access completes (vbus_req = 0) put module back in Sleep state                           1: PSC transitions module to ENABLE state" range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="ACSLPIE" width="1" begin="12" end="12" resetval="0" description="Non-emulation Access to module in sleep Error enable                                0: Non-emulation access to module in sleep is not considered an error condition                                                                                                        1: Non-emulation access to module in sleep is considered an error" range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="ACSLP" width="1" begin="11" end="11" resetval="0" description="Non-emulation Access to module in Sleep will cause this action                              0: PSC transitions module from Sleep state to TWk state, once access completes put module back in Sleep state                                                    1: PSC transitions module to ENABLE state                                                                                            " range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="EMUIHBIE" width="1" begin="10" end="10" resetval="0" description="Emulation alters module state - Inhibits Module Inactive or Force Module Active                                                                                                            0: Not enabled                                                                                               1: Interrupt enabled" range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="EMURSTIE" width="1" begin="9" end="9" resetval="0" description="Emulation Alter Reset Interrupt Enable                                                          0: Not enabled                                                                                                1: Interrupt Enabled" range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="LRSTz" width="1" begin="8" end="8" resetval="0" description="Module local reset control (only applicable to some modules -- e.g GEM, BCG EMIF)                                                                                                     0: Assert local reset                                                                                      1: De-assert local reset" range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="_RESV" width="5" begin="7" end="3" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="NEXT" width="3" begin="2" end="0" resetval="0" description="Module Next State                                                                                          000: SwRstDisable                                                                                        001: Disable                                                                                                   010: SyncReset                                                                                             011: Enable                                                                                                    100: Reserved/Invalid                                                                                    101: Sleep                                                                                                     110: Reserved/Invalid                                                                                    111: Reserved/Invalid" range="" rwaccess="RW">
         
      </bitfield>
   </register>
   <register id="MDCTL1" acronym="MDCTL1" offset="0xA04" width="32" description="Module Control 1 Register">
      <bitfield id="_RESV" width="17" begin="31" end="15" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="WKRSLPIE" width="1" begin="14" end="14" resetval="0" description="Wakeup Request to module in sleep Error Enable.                                        0: Wakeup request to module in sleep is not considered an error condition                                                                                                        1: Wakeup request to module in sleep is considered an error" range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="WKRSLP" width="1" begin="13" end="13" resetval="0" description="Wakeup Request to module in Sleep will cause this action.                         0: PSC transitions module from Sleep state to TWK state, once access completes (vbus_req = 0) put module back in Sleep state                           1: PSC transitions module to ENABLE state" range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="ACSLPIE" width="1" begin="12" end="12" resetval="0" description="Non-emulation Access to module in sleep Error enable                                0: Non-emulation access to module in sleep is not considered an error condition                                                                                                        1: Non-emulation access to module in sleep is considered an error" range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="ACSLP" width="1" begin="11" end="11" resetval="0" description="Non-emulation Access to module in Sleep will cause this action                              0: PSC transitions module from Sleep state to TWk state, once access completes put module back in Sleep state                                                    1: PSC transitions module to ENABLE state                                                                                            " range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="EMUIHBIE" width="1" begin="10" end="10" resetval="0" description="Emulation alters module state - Inhibits Module Inactive or Force Module Active                                                                                                            0: Not enabled                                                                                               1: Interrupt enabled" range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="EMURSTIE" width="1" begin="9" end="9" resetval="0" description="Emulation Alter Reset Interrupt Enable                                                          0: Not enabled                                                                                                1: Interrupt Enabled" range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="LRSTz" width="1" begin="8" end="8" resetval="0" description="Module local reset control (only applicable to some modules -- e.g GEM, BCG EMIF)                                                                                                     0: Assert local reset                                                                                      1: De-assert local reset" range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="_RESV" width="5" begin="7" end="3" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="NEXT" width="3" begin="2" end="0" resetval="0" description="Module Next State                                                                                          000: SwRstDisable                                                                                        001: Disable                                                                                                   010: SyncReset                                                                                             011: Enable                                                                                                    100: Reserved/Invalid                                                                                    101: Sleep                                                                                                     110: Reserved/Invalid                                                                                    111: Reserved/Invalid" range="" rwaccess="RW">
         
      </bitfield>
   </register>
   <register id="MDCTL2" acronym="MDCTL2" offset="0xA08" width="32" description="Module Control 2 Register">
      <bitfield id="_RESV" width="17" begin="31" end="15" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="WKRSLPIE" width="1" begin="14" end="14" resetval="0" description="Wakeup Request to module in sleep Error Enable.                                        0: Wakeup request to module in sleep is not considered an error condition                                                                                                        1: Wakeup request to module in sleep is considered an error" range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="WKRSLP" width="1" begin="13" end="13" resetval="0" description="Wakeup Request to module in Sleep will cause this action.                         0: PSC transitions module from Sleep state to TWK state, once access completes (vbus_req = 0) put module back in Sleep state                           1: PSC transitions module to ENABLE state" range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="ACSLPIE" width="1" begin="12" end="12" resetval="0" description="Non-emulation Access to module in sleep Error enable                                0: Non-emulation access to module in sleep is not considered an error condition                                                                                                        1: Non-emulation access to module in sleep is considered an error" range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="ACSLP" width="1" begin="11" end="11" resetval="0" description="Non-emulation Access to module in Sleep will cause this action                              0: PSC transitions module from Sleep state to TWk state, once access completes put module back in Sleep state                                                    1: PSC transitions module to ENABLE state                                                                                            " range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="EMUIHBIE" width="1" begin="10" end="10" resetval="0" description="Emulation alters module state - Inhibits Module Inactive or Force Module Active                                                                                                            0: Not enabled                                                                                               1: Interrupt enabled" range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="EMURSTIE" width="1" begin="9" end="9" resetval="0" description="Emulation Alter Reset Interrupt Enable                                                          0: Not enabled                                                                                                1: Interrupt Enabled" range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="LRSTz" width="1" begin="8" end="8" resetval="0" description="Module local reset control (only applicable to some modules -- e.g GEM, BCG EMIF)                                                                                                     0: Assert local reset                                                                                      1: De-assert local reset" range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="_RESV" width="5" begin="7" end="3" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="NEXT" width="3" begin="2" end="0" resetval="0" description="Module Next State                                                                                          000: SwRstDisable                                                                                        001: Disable                                                                                                   010: SyncReset                                                                                             011: Enable                                                                                                    100: Reserved/Invalid                                                                                    101: Sleep                                                                                                     110: Reserved/Invalid                                                                                    111: Reserved/Invalid" range="" rwaccess="RW">
         
      </bitfield>
   </register>
   <register id="MDCTL3" acronym="MDCTL3" offset="0xA0C" width="32" description="Module Control 3 Register">
      <bitfield id="_RESV" width="17" begin="31" end="15" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="WKRSLPIE" width="1" begin="14" end="14" resetval="0" description="Wakeup Request to module in sleep Error Enable.                                        0: Wakeup request to module in sleep is not considered an error condition                                                                                                        1: Wakeup request to module in sleep is considered an error" range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="WKRSLP" width="1" begin="13" end="13" resetval="0" description="Wakeup Request to module in Sleep will cause this action.                         0: PSC transitions module from Sleep state to TWK state, once access completes (vbus_req = 0) put module back in Sleep state                           1: PSC transitions module to ENABLE state" range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="ACSLPIE" width="1" begin="12" end="12" resetval="0" description="Non-emulation Access to module in sleep Error enable                                0: Non-emulation access to module in sleep is not considered an error condition                                                                                                        1: Non-emulation access to module in sleep is considered an error" range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="ACSLP" width="1" begin="11" end="11" resetval="0" description="Non-emulation Access to module in Sleep will cause this action                              0: PSC transitions module from Sleep state to TWk state, once access completes put module back in Sleep state                                                    1: PSC transitions module to ENABLE state                                                                                            " range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="EMUIHBIE" width="1" begin="10" end="10" resetval="0" description="Emulation alters module state - Inhibits Module Inactive or Force Module Active                                                                                                            0: Not enabled                                                                                               1: Interrupt enabled" range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="EMURSTIE" width="1" begin="9" end="9" resetval="0" description="Emulation Alter Reset Interrupt Enable                                                          0: Not enabled                                                                                                1: Interrupt Enabled" range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="LRSTz" width="1" begin="8" end="8" resetval="0" description="Module local reset control (only applicable to some modules -- e.g GEM, BCG EMIF)                                                                                                     0: Assert local reset                                                                                      1: De-assert local reset" range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="_RESV" width="5" begin="7" end="3" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="NEXT" width="3" begin="2" end="0" resetval="0" description="Module Next State                                                                                          000: SwRstDisable                                                                                        001: Disable                                                                                                   010: SyncReset                                                                                             011: Enable                                                                                                    100: Reserved/Invalid                                                                                    101: Sleep                                                                                                     110: Reserved/Invalid                                                                                    111: Reserved/Invalid" range="" rwaccess="RW">
         
      </bitfield>
   </register>
   <register id="MDCTL4" acronym="MDCTL4" offset="0xA10" width="32" description="Module Control 4 Register">
      <bitfield id="_RESV" width="17" begin="31" end="15" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="WKRSLPIE" width="1" begin="14" end="14" resetval="0" description="Wakeup Request to module in sleep Error Enable.                                        0: Wakeup request to module in sleep is not considered an error condition                                                                                                        1: Wakeup request to module in sleep is considered an error" range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="WKRSLP" width="1" begin="13" end="13" resetval="0" description="Wakeup Request to module in Sleep will cause this action.                         0: PSC transitions module from Sleep state to TWK state, once access completes (vbus_req = 0) put module back in Sleep state                           1: PSC transitions module to ENABLE state" range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="ACSLPIE" width="1" begin="12" end="12" resetval="0" description="Non-emulation Access to module in sleep Error enable                                0: Non-emulation access to module in sleep is not considered an error condition                                                                                                        1: Non-emulation access to module in sleep is considered an error" range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="ACSLP" width="1" begin="11" end="11" resetval="0" description="Non-emulation Access to module in Sleep will cause this action                              0: PSC transitions module from Sleep state to TWk state, once access completes put module back in Sleep state                                                    1: PSC transitions module to ENABLE state                                                                                            " range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="EMUIHBIE" width="1" begin="10" end="10" resetval="0" description="Emulation alters module state - Inhibits Module Inactive or Force Module Active                                                                                                            0: Not enabled                                                                                               1: Interrupt enabled" range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="EMURSTIE" width="1" begin="9" end="9" resetval="0" description="Emulation Alter Reset Interrupt Enable                                                          0: Not enabled                                                                                                1: Interrupt Enabled" range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="LRSTz" width="1" begin="8" end="8" resetval="0" description="Module local reset control (only applicable to some modules -- e.g GEM, BCG EMIF)                                                                                                     0: Assert local reset                                                                                      1: De-assert local reset" range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="_RESV" width="5" begin="7" end="3" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="NEXT" width="3" begin="2" end="0" resetval="0" description="Module Next State                                                                                          000: SwRstDisable                                                                                        001: Disable                                                                                                   010: SyncReset                                                                                             011: Enable                                                                                                    100: Reserved/Invalid                                                                                    101: Sleep                                                                                                     110: Reserved/Invalid                                                                                    111: Reserved/Invalid" range="" rwaccess="RW">
         
      </bitfield>
   </register>
   <register id="MDCTL5" acronym="MDCTL5" offset="0xA14" width="32" description="Module Control 5 Register">
      <bitfield id="_RESV" width="17" begin="31" end="15" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="WKRSLPIE" width="1" begin="14" end="14" resetval="0" description="Wakeup Request to module in sleep Error Enable.                                        0: Wakeup request to module in sleep is not considered an error condition                                                                                                        1: Wakeup request to module in sleep is considered an error" range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="WKRSLP" width="1" begin="13" end="13" resetval="0" description="Wakeup Request to module in Sleep will cause this action.                         0: PSC transitions module from Sleep state to TWK state, once access completes (vbus_req = 0) put module back in Sleep state                           1: PSC transitions module to ENABLE state" range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="ACSLPIE" width="1" begin="12" end="12" resetval="0" description="Non-emulation Access to module in sleep Error enable                                0: Non-emulation access to module in sleep is not considered an error condition                                                                                                        1: Non-emulation access to module in sleep is considered an error" range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="ACSLP" width="1" begin="11" end="11" resetval="0" description="Non-emulation Access to module in Sleep will cause this action                              0: PSC transitions module from Sleep state to TWk state, once access completes put module back in Sleep state                                                    1: PSC transitions module to ENABLE state                                                                                            " range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="EMUIHBIE" width="1" begin="10" end="10" resetval="0" description="Emulation alters module state - Inhibits Module Inactive or Force Module Active                                                                                                            0: Not enabled                                                                                               1: Interrupt enabled" range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="EMURSTIE" width="1" begin="9" end="9" resetval="0" description="Emulation Alter Reset Interrupt Enable                                                          0: Not enabled                                                                                                1: Interrupt Enabled" range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="LRSTz" width="1" begin="8" end="8" resetval="0" description="Module local reset control (only applicable to some modules -- e.g GEM, BCG EMIF)                                                                                                     0: Assert local reset                                                                                      1: De-assert local reset" range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="_RESV" width="5" begin="7" end="3" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="NEXT" width="3" begin="2" end="0" resetval="0" description="Module Next State                                                                                          000: SwRstDisable                                                                                        001: Disable                                                                                                   010: SyncReset                                                                                             011: Enable                                                                                                    100: Reserved/Invalid                                                                                    101: Sleep                                                                                                     110: Reserved/Invalid                                                                                    111: Reserved/Invalid" range="" rwaccess="RW">
         
      </bitfield>
   </register>
   <register id="MDCTL6" acronym="MDCTL6" offset="0xA18" width="32" description="Module Control 6 Register">
      <bitfield id="_RESV" width="17" begin="31" end="15" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="WKRSLPIE" width="1" begin="14" end="14" resetval="0" description="Wakeup Request to module in sleep Error Enable.                                        0: Wakeup request to module in sleep is not considered an error condition                                                                                                        1: Wakeup request to module in sleep is considered an error" range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="WKRSLP" width="1" begin="13" end="13" resetval="0" description="Wakeup Request to module in Sleep will cause this action.                         0: PSC transitions module from Sleep state to TWK state, once access completes (vbus_req = 0) put module back in Sleep state                           1: PSC transitions module to ENABLE state" range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="ACSLPIE" width="1" begin="12" end="12" resetval="0" description="Non-emulation Access to module in sleep Error enable                                0: Non-emulation access to module in sleep is not considered an error condition                                                                                                        1: Non-emulation access to module in sleep is considered an error" range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="ACSLP" width="1" begin="11" end="11" resetval="0" description="Non-emulation Access to module in Sleep will cause this action                              0: PSC transitions module from Sleep state to TWk state, once access completes put module back in Sleep state                                                    1: PSC transitions module to ENABLE state                                                                                            " range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="EMUIHBIE" width="1" begin="10" end="10" resetval="0" description="Emulation alters module state - Inhibits Module Inactive or Force Module Active                                                                                                            0: Not enabled                                                                                               1: Interrupt enabled" range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="EMURSTIE" width="1" begin="9" end="9" resetval="0" description="Emulation Alter Reset Interrupt Enable                                                          0: Not enabled                                                                                                1: Interrupt Enabled" range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="LRSTz" width="1" begin="8" end="8" resetval="0" description="Module local reset control (only applicable to some modules -- e.g GEM, BCG EMIF)                                                                                                     0: Assert local reset                                                                                      1: De-assert local reset" range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="_RESV" width="5" begin="7" end="3" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="NEXT" width="3" begin="2" end="0" resetval="0" description="Module Next State                                                                                          000: SwRstDisable                                                                                        001: Disable                                                                                                   010: SyncReset                                                                                             011: Enable                                                                                                    100: Reserved/Invalid                                                                                    101: Sleep                                                                                                     110: Reserved/Invalid                                                                                    111: Reserved/Invalid" range="" rwaccess="RW">
         
      </bitfield>
   </register>
   <register id="MDCTL7" acronym="MDCTL7" offset="0xA1C" width="32" description="Module Control 7 Register">
      <bitfield id="_RESV" width="17" begin="31" end="15" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="WKRSLPIE" width="1" begin="14" end="14" resetval="0" description="Wakeup Request to module in sleep Error Enable.                                        0: Wakeup request to module in sleep is not considered an error condition                                                                                                        1: Wakeup request to module in sleep is considered an error" range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="WKRSLP" width="1" begin="13" end="13" resetval="0" description="Wakeup Request to module in Sleep will cause this action.                         0: PSC transitions module from Sleep state to TWK state, once access completes (vbus_req = 0) put module back in Sleep state                           1: PSC transitions module to ENABLE state" range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="ACSLPIE" width="1" begin="12" end="12" resetval="0" description="Non-emulation Access to module in sleep Error enable                                0: Non-emulation access to module in sleep is not considered an error condition                                                                                                        1: Non-emulation access to module in sleep is considered an error" range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="ACSLP" width="1" begin="11" end="11" resetval="0" description="Non-emulation Access to module in Sleep will cause this action                              0: PSC transitions module from Sleep state to TWk state, once access completes put module back in Sleep state                                                    1: PSC transitions module to ENABLE state                                                                                            " range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="EMUIHBIE" width="1" begin="10" end="10" resetval="0" description="Emulation alters module state - Inhibits Module Inactive or Force Module Active                                                                                                            0: Not enabled                                                                                               1: Interrupt enabled" range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="EMURSTIE" width="1" begin="9" end="9" resetval="0" description="Emulation Alter Reset Interrupt Enable                                                          0: Not enabled                                                                                                1: Interrupt Enabled" range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="LRSTz" width="1" begin="8" end="8" resetval="0" description="Module local reset control (only applicable to some modules -- e.g GEM, BCG EMIF)                                                                                                     0: Assert local reset                                                                                      1: De-assert local reset" range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="_RESV" width="5" begin="7" end="3" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="NEXT" width="3" begin="2" end="0" resetval="0" description="Module Next State                                                                                          000: SwRstDisable                                                                                        001: Disable                                                                                                   010: SyncReset                                                                                             011: Enable                                                                                                    100: Reserved/Invalid                                                                                    101: Sleep                                                                                                     110: Reserved/Invalid                                                                                    111: Reserved/Invalid" range="" rwaccess="RW">
         
      </bitfield>
   </register>
   <register id="MDCTL8" acronym="MDCTL8" offset="0xA20" width="32" description="Module Control 8 Register">
      <bitfield id="_RESV" width="17" begin="31" end="15" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="WKRSLPIE" width="1" begin="14" end="14" resetval="0" description="Wakeup Request to module in sleep Error Enable.                                        0: Wakeup request to module in sleep is not considered an error condition                                                                                                        1: Wakeup request to module in sleep is considered an error" range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="WKRSLP" width="1" begin="13" end="13" resetval="0" description="Wakeup Request to module in Sleep will cause this action.                         0: PSC transitions module from Sleep state to TWK state, once access completes (vbus_req = 0) put module back in Sleep state                           1: PSC transitions module to ENABLE state" range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="ACSLPIE" width="1" begin="12" end="12" resetval="0" description="Non-emulation Access to module in sleep Error enable                                0: Non-emulation access to module in sleep is not considered an error condition                                                                                                        1: Non-emulation access to module in sleep is considered an error" range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="ACSLP" width="1" begin="11" end="11" resetval="0" description="Non-emulation Access to module in Sleep will cause this action                              0: PSC transitions module from Sleep state to TWk state, once access completes put module back in Sleep state                                                    1: PSC transitions module to ENABLE state                                                                                            " range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="EMUIHBIE" width="1" begin="10" end="10" resetval="0" description="Emulation alters module state - Inhibits Module Inactive or Force Module Active                                                                                                            0: Not enabled                                                                                               1: Interrupt enabled" range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="EMURSTIE" width="1" begin="9" end="9" resetval="0" description="Emulation Alter Reset Interrupt Enable                                                          0: Not enabled                                                                                                1: Interrupt Enabled" range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="LRSTz" width="1" begin="8" end="8" resetval="0" description="Module local reset control (only applicable to some modules -- e.g GEM, BCG EMIF)                                                                                                     0: Assert local reset                                                                                      1: De-assert local reset" range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="_RESV" width="5" begin="7" end="3" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="NEXT" width="3" begin="2" end="0" resetval="0" description="Module Next State                                                                                          000: SwRstDisable                                                                                        001: Disable                                                                                                   010: SyncReset                                                                                             011: Enable                                                                                                    100: Reserved/Invalid                                                                                    101: Sleep                                                                                                     110: Reserved/Invalid                                                                                    111: Reserved/Invalid" range="" rwaccess="RW">
         
      </bitfield>
   </register>
   <register id="MDCTL9" acronym="MDCTL9" offset="0xA24" width="32" description="Module Control 9 Register">
      <bitfield id="_RESV" width="17" begin="31" end="15" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="WKRSLPIE" width="1" begin="14" end="14" resetval="0" description="Wakeup Request to module in sleep Error Enable.                                        0: Wakeup request to module in sleep is not considered an error condition                                                                                                        1: Wakeup request to module in sleep is considered an error" range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="WKRSLP" width="1" begin="13" end="13" resetval="0" description="Wakeup Request to module in Sleep will cause this action.                         0: PSC transitions module from Sleep state to TWK state, once access completes (vbus_req = 0) put module back in Sleep state                           1: PSC transitions module to ENABLE state" range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="ACSLPIE" width="1" begin="12" end="12" resetval="0" description="Non-emulation Access to module in sleep Error enable                                0: Non-emulation access to module in sleep is not considered an error condition                                                                                                        1: Non-emulation access to module in sleep is considered an error" range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="ACSLP" width="1" begin="11" end="11" resetval="0" description="Non-emulation Access to module in Sleep will cause this action                              0: PSC transitions module from Sleep state to TWk state, once access completes put module back in Sleep state                                                    1: PSC transitions module to ENABLE state                                                                                            " range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="EMUIHBIE" width="1" begin="10" end="10" resetval="0" description="Emulation alters module state - Inhibits Module Inactive or Force Module Active                                                                                                            0: Not enabled                                                                                               1: Interrupt enabled" range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="EMURSTIE" width="1" begin="9" end="9" resetval="0" description="Emulation Alter Reset Interrupt Enable                                                          0: Not enabled                                                                                                1: Interrupt Enabled" range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="LRSTz" width="1" begin="8" end="8" resetval="0" description="Module local reset control (only applicable to some modules -- e.g GEM, BCG EMIF)                                                                                                     0: Assert local reset                                                                                      1: De-assert local reset" range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="_RESV" width="5" begin="7" end="3" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="NEXT" width="3" begin="2" end="0" resetval="0" description="Module Next State                                                                                          000: SwRstDisable                                                                                        001: Disable                                                                                                   010: SyncReset                                                                                             011: Enable                                                                                                    100: Reserved/Invalid                                                                                    101: Sleep                                                                                                     110: Reserved/Invalid                                                                                    111: Reserved/Invalid" range="" rwaccess="RW">
         
      </bitfield>
   </register>
   <register id="MDCTL10" acronym="MDCTL10" offset="0xA28" width="32" description="Module Control 10 Register">
      <bitfield id="_RESV" width="17" begin="31" end="15" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="WKRSLPIE" width="1" begin="14" end="14" resetval="0" description="Wakeup Request to module in sleep Error Enable.                                        0: Wakeup request to module in sleep is not considered an error condition                                                                                                        1: Wakeup request to module in sleep is considered an error" range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="WKRSLP" width="1" begin="13" end="13" resetval="0" description="Wakeup Request to module in Sleep will cause this action.                         0: PSC transitions module from Sleep state to TWK state, once access completes (vbus_req = 0) put module back in Sleep state                           1: PSC transitions module to ENABLE state" range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="ACSLPIE" width="1" begin="12" end="12" resetval="0" description="Non-emulation Access to module in sleep Error enable                                0: Non-emulation access to module in sleep is not considered an error condition                                                                                                        1: Non-emulation access to module in sleep is considered an error" range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="ACSLP" width="1" begin="11" end="11" resetval="0" description="Non-emulation Access to module in Sleep will cause this action                              0: PSC transitions module from Sleep state to TWk state, once access completes put module back in Sleep state                                                    1: PSC transitions module to ENABLE state                                                                                            " range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="EMUIHBIE" width="1" begin="10" end="10" resetval="0" description="Emulation alters module state - Inhibits Module Inactive or Force Module Active                                                                                                            0: Not enabled                                                                                               1: Interrupt enabled" range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="EMURSTIE" width="1" begin="9" end="9" resetval="0" description="Emulation Alter Reset Interrupt Enable                                                          0: Not enabled                                                                                                1: Interrupt Enabled" range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="LRSTz" width="1" begin="8" end="8" resetval="0" description="Module local reset control (only applicable to some modules -- e.g GEM, BCG EMIF)                                                                                                     0: Assert local reset                                                                                      1: De-assert local reset" range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="_RESV" width="5" begin="7" end="3" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="NEXT" width="3" begin="2" end="0" resetval="0" description="Module Next State                                                                                          000: SwRstDisable                                                                                        001: Disable                                                                                                   010: SyncReset                                                                                             011: Enable                                                                                                    100: Reserved/Invalid                                                                                    101: Sleep                                                                                                     110: Reserved/Invalid                                                                                    111: Reserved/Invalid" range="" rwaccess="RW">
         
      </bitfield>
   </register>
   <register id="MDCTL11" acronym="MDCTL11" offset="0xA2C" width="32" description="Module Control 11 Register">
      <bitfield id="_RESV" width="17" begin="31" end="15" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="WKRSLPIE" width="1" begin="14" end="14" resetval="0" description="Wakeup Request to module in sleep Error Enable.                                        0: Wakeup request to module in sleep is not considered an error condition                                                                                                        1: Wakeup request to module in sleep is considered an error" range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="WKRSLP" width="1" begin="13" end="13" resetval="0" description="Wakeup Request to module in Sleep will cause this action.                         0: PSC transitions module from Sleep state to TWK state, once access completes (vbus_req = 0) put module back in Sleep state                           1: PSC transitions module to ENABLE state" range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="ACSLPIE" width="1" begin="12" end="12" resetval="0" description="Non-emulation Access to module in sleep Error enable                                0: Non-emulation access to module in sleep is not considered an error condition                                                                                                        1: Non-emulation access to module in sleep is considered an error" range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="ACSLP" width="1" begin="11" end="11" resetval="0" description="Non-emulation Access to module in Sleep will cause this action                              0: PSC transitions module from Sleep state to TWk state, once access completes put module back in Sleep state                                                    1: PSC transitions module to ENABLE state                                                                                            " range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="EMUIHBIE" width="1" begin="10" end="10" resetval="0" description="Emulation alters module state - Inhibits Module Inactive or Force Module Active                                                                                                            0: Not enabled                                                                                               1: Interrupt enabled" range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="EMURSTIE" width="1" begin="9" end="9" resetval="0" description="Emulation Alter Reset Interrupt Enable                                                          0: Not enabled                                                                                                1: Interrupt Enabled" range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="LRSTz" width="1" begin="8" end="8" resetval="0" description="Module local reset control (only applicable to some modules -- e.g GEM, BCG EMIF)                                                                                                     0: Assert local reset                                                                                      1: De-assert local reset" range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="_RESV" width="5" begin="7" end="3" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="NEXT" width="3" begin="2" end="0" resetval="0" description="Module Next State                                                                                          000: SwRstDisable                                                                                        001: Disable                                                                                                   010: SyncReset                                                                                             011: Enable                                                                                                    100: Reserved/Invalid                                                                                    101: Sleep                                                                                                     110: Reserved/Invalid                                                                                    111: Reserved/Invalid" range="" rwaccess="RW">
         
      </bitfield>
   </register>
   <register id="MDCTL12" acronym="MDCTL12" offset="0xA30" width="32" description="Module Control 12 Register">
      <bitfield id="_RESV" width="17" begin="31" end="15" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="WKRSLPIE" width="1" begin="14" end="14" resetval="0" description="Wakeup Request to module in sleep Error Enable.                                        0: Wakeup request to module in sleep is not considered an error condition                                                                                                        1: Wakeup request to module in sleep is considered an error" range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="WKRSLP" width="1" begin="13" end="13" resetval="0" description="Wakeup Request to module in Sleep will cause this action.                         0: PSC transitions module from Sleep state to TWK state, once access completes (vbus_req = 0) put module back in Sleep state                           1: PSC transitions module to ENABLE state" range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="ACSLPIE" width="1" begin="12" end="12" resetval="0" description="Non-emulation Access to module in sleep Error enable                                0: Non-emulation access to module in sleep is not considered an error condition                                                                                                        1: Non-emulation access to module in sleep is considered an error" range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="ACSLP" width="1" begin="11" end="11" resetval="0" description="Non-emulation Access to module in Sleep will cause this action                              0: PSC transitions module from Sleep state to TWk state, once access completes put module back in Sleep state                                                    1: PSC transitions module to ENABLE state                                                                                            " range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="EMUIHBIE" width="1" begin="10" end="10" resetval="0" description="Emulation alters module state - Inhibits Module Inactive or Force Module Active                                                                                                            0: Not enabled                                                                                               1: Interrupt enabled" range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="EMURSTIE" width="1" begin="9" end="9" resetval="0" description="Emulation Alter Reset Interrupt Enable                                                          0: Not enabled                                                                                                1: Interrupt Enabled" range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="LRSTz" width="1" begin="8" end="8" resetval="0" description="Module local reset control (only applicable to some modules -- e.g GEM, BCG EMIF)                                                                                                     0: Assert local reset                                                                                      1: De-assert local reset" range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="_RESV" width="5" begin="7" end="3" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="NEXT" width="3" begin="2" end="0" resetval="0" description="Module Next State                                                                                          000: SwRstDisable                                                                                        001: Disable                                                                                                   010: SyncReset                                                                                             011: Enable                                                                                                    100: Reserved/Invalid                                                                                    101: Sleep                                                                                                     110: Reserved/Invalid                                                                                    111: Reserved/Invalid" range="" rwaccess="RW">
         
      </bitfield>
   </register>
   <register id="MDCTL13" acronym="MDCTL13" offset="0xA34" width="32" description="Module Control 13 Register">
      <bitfield id="_RESV" width="17" begin="31" end="15" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="WKRSLPIE" width="1" begin="14" end="14" resetval="0" description="Wakeup Request to module in sleep Error Enable.                                        0: Wakeup request to module in sleep is not considered an error condition                                                                                                        1: Wakeup request to module in sleep is considered an error" range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="WKRSLP" width="1" begin="13" end="13" resetval="0" description="Wakeup Request to module in Sleep will cause this action.                         0: PSC transitions module from Sleep state to TWK state, once access completes (vbus_req = 0) put module back in Sleep state                           1: PSC transitions module to ENABLE state" range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="ACSLPIE" width="1" begin="12" end="12" resetval="0" description="Non-emulation Access to module in sleep Error enable                                0: Non-emulation access to module in sleep is not considered an error condition                                                                                                        1: Non-emulation access to module in sleep is considered an error" range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="ACSLP" width="1" begin="11" end="11" resetval="0" description="Non-emulation Access to module in Sleep will cause this action                              0: PSC transitions module from Sleep state to TWk state, once access completes put module back in Sleep state                                                    1: PSC transitions module to ENABLE state                                                                                            " range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="EMUIHBIE" width="1" begin="10" end="10" resetval="0" description="Emulation alters module state - Inhibits Module Inactive or Force Module Active                                                                                                            0: Not enabled                                                                                               1: Interrupt enabled" range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="EMURSTIE" width="1" begin="9" end="9" resetval="0" description="Emulation Alter Reset Interrupt Enable                                                          0: Not enabled                                                                                                1: Interrupt Enabled" range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="LRSTz" width="1" begin="8" end="8" resetval="0" description="Module local reset control (only applicable to some modules -- e.g GEM, BCG EMIF)                                                                                                     0: Assert local reset                                                                                      1: De-assert local reset" range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="_RESV" width="5" begin="7" end="3" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="NEXT" width="3" begin="2" end="0" resetval="0" description="Module Next State                                                                                          000: SwRstDisable                                                                                        001: Disable                                                                                                   010: SyncReset                                                                                             011: Enable                                                                                                    100: Reserved/Invalid                                                                                    101: Sleep                                                                                                     110: Reserved/Invalid                                                                                    111: Reserved/Invalid" range="" rwaccess="RW">
         
      </bitfield>
   </register>
   <register id="MDCTL14" acronym="MDCTL14" offset="0xA38" width="32" description="Module Control 14 Register">
      <bitfield id="_RESV" width="17" begin="31" end="15" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="WKRSLPIE" width="1" begin="14" end="14" resetval="0" description="Wakeup Request to module in sleep Error Enable.                                        0: Wakeup request to module in sleep is not considered an error condition                                                                                                        1: Wakeup request to module in sleep is considered an error" range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="WKRSLP" width="1" begin="13" end="13" resetval="0" description="Wakeup Request to module in Sleep will cause this action.                         0: PSC transitions module from Sleep state to TWK state, once access completes (vbus_req = 0) put module back in Sleep state                           1: PSC transitions module to ENABLE state" range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="ACSLPIE" width="1" begin="12" end="12" resetval="0" description="Non-emulation Access to module in sleep Error enable                                0: Non-emulation access to module in sleep is not considered an error condition                                                                                                        1: Non-emulation access to module in sleep is considered an error" range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="ACSLP" width="1" begin="11" end="11" resetval="0" description="Non-emulation Access to module in Sleep will cause this action                              0: PSC transitions module from Sleep state to TWk state, once access completes put module back in Sleep state                                                    1: PSC transitions module to ENABLE state                                                                                            " range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="EMUIHBIE" width="1" begin="10" end="10" resetval="0" description="Emulation alters module state - Inhibits Module Inactive or Force Module Active                                                                                                            0: Not enabled                                                                                               1: Interrupt enabled" range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="EMURSTIE" width="1" begin="9" end="9" resetval="0" description="Emulation Alter Reset Interrupt Enable                                                          0: Not enabled                                                                                                1: Interrupt Enabled" range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="LRSTz" width="1" begin="8" end="8" resetval="0" description="Module local reset control (only applicable to some modules -- e.g GEM, BCG EMIF)                                                                                                     0: Assert local reset                                                                                      1: De-assert local reset" range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="_RESV" width="5" begin="7" end="3" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="NEXT" width="3" begin="2" end="0" resetval="0" description="Module Next State                                                                                          000: SwRstDisable                                                                                        001: Disable                                                                                                   010: SyncReset                                                                                             011: Enable                                                                                                    100: Reserved/Invalid                                                                                    101: Sleep                                                                                                     110: Reserved/Invalid                                                                                    111: Reserved/Invalid" range="" rwaccess="RW">
         
      </bitfield>
   </register>
   <register id="MDCTL15" acronym="MDCTL15" offset="0xA3C" width="32" description="Module Control 15 Register">
      <bitfield id="_RESV" width="17" begin="31" end="15" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="WKRSLPIE" width="1" begin="14" end="14" resetval="0" description="Wakeup Request to module in sleep Error Enable.                                        0: Wakeup request to module in sleep is not considered an error condition                                                                                                        1: Wakeup request to module in sleep is considered an error" range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="WKRSLP" width="1" begin="13" end="13" resetval="0" description="Wakeup Request to module in Sleep will cause this action.                         0: PSC transitions module from Sleep state to TWK state, once access completes (vbus_req = 0) put module back in Sleep state                           1: PSC transitions module to ENABLE state" range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="ACSLPIE" width="1" begin="12" end="12" resetval="0" description="Non-emulation Access to module in sleep Error enable                                0: Non-emulation access to module in sleep is not considered an error condition                                                                                                        1: Non-emulation access to module in sleep is considered an error" range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="ACSLP" width="1" begin="11" end="11" resetval="0" description="Non-emulation Access to module in Sleep will cause this action                              0: PSC transitions module from Sleep state to TWk state, once access completes put module back in Sleep state                                                    1: PSC transitions module to ENABLE state                                                                                            " range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="EMUIHBIE" width="1" begin="10" end="10" resetval="0" description="Emulation alters module state - Inhibits Module Inactive or Force Module Active                                                                                                            0: Not enabled                                                                                               1: Interrupt enabled" range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="EMURSTIE" width="1" begin="9" end="9" resetval="0" description="Emulation Alter Reset Interrupt Enable                                                          0: Not enabled                                                                                                1: Interrupt Enabled" range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="LRSTz" width="1" begin="8" end="8" resetval="0" description="Module local reset control (only applicable to some modules -- e.g GEM, BCG EMIF)                                                                                                     0: Assert local reset                                                                                      1: De-assert local reset" range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="_RESV" width="5" begin="7" end="3" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="NEXT" width="3" begin="2" end="0" resetval="0" description="Module Next State                                                                                          000: SwRstDisable                                                                                        001: Disable                                                                                                   010: SyncReset                                                                                             011: Enable                                                                                                    100: Reserved/Invalid                                                                                    101: Sleep                                                                                                     110: Reserved/Invalid                                                                                    111: Reserved/Invalid" range="" rwaccess="RW">
         
      </bitfield>
   </register>
   <register id="MDCTL16" acronym="MDCTL16" offset="0xA40" width="32" description="Module Control 16 Register">
      <bitfield id="_RESV" width="17" begin="31" end="15" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="WKRSLPIE" width="1" begin="14" end="14" resetval="0" description="Wakeup Request to module in sleep Error Enable.                                        0: Wakeup request to module in sleep is not considered an error condition                                                                                                        1: Wakeup request to module in sleep is considered an error" range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="WKRSLP" width="1" begin="13" end="13" resetval="0" description="Wakeup Request to module in Sleep will cause this action.                         0: PSC transitions module from Sleep state to TWK state, once access completes (vbus_req = 0) put module back in Sleep state                           1: PSC transitions module to ENABLE state" range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="ACSLPIE" width="1" begin="12" end="12" resetval="0" description="Non-emulation Access to module in sleep Error enable                                0: Non-emulation access to module in sleep is not considered an error condition                                                                                                        1: Non-emulation access to module in sleep is considered an error" range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="ACSLP" width="1" begin="11" end="11" resetval="0" description="Non-emulation Access to module in Sleep will cause this action                              0: PSC transitions module from Sleep state to TWk state, once access completes put module back in Sleep state                                                    1: PSC transitions module to ENABLE state                                                                                            " range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="EMUIHBIE" width="1" begin="10" end="10" resetval="0" description="Emulation alters module state - Inhibits Module Inactive or Force Module Active                                                                                                            0: Not enabled                                                                                               1: Interrupt enabled" range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="EMURSTIE" width="1" begin="9" end="9" resetval="0" description="Emulation Alter Reset Interrupt Enable                                                          0: Not enabled                                                                                                1: Interrupt Enabled" range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="LRSTz" width="1" begin="8" end="8" resetval="0" description="Module local reset control (only applicable to some modules -- e.g GEM, BCG EMIF)                                                                                                     0: Assert local reset                                                                                      1: De-assert local reset" range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="_RESV" width="5" begin="7" end="3" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="NEXT" width="3" begin="2" end="0" resetval="0" description="Module Next State                                                                                          000: SwRstDisable                                                                                        001: Disable                                                                                                   010: SyncReset                                                                                             011: Enable                                                                                                    100: Reserved/Invalid                                                                                    101: Sleep                                                                                                     110: Reserved/Invalid                                                                                    111: Reserved/Invalid" range="" rwaccess="RW">
         
      </bitfield>
   </register>
   <register id="MDCTL17" acronym="MDCTL17" offset="0xA44" width="32" description="Module Control 17 Register">
      <bitfield id="_RESV" width="17" begin="31" end="15" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="WKRSLPIE" width="1" begin="14" end="14" resetval="0" description="Wakeup Request to module in sleep Error Enable.                                        0: Wakeup request to module in sleep is not considered an error condition                                                                                                        1: Wakeup request to module in sleep is considered an error" range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="WKRSLP" width="1" begin="13" end="13" resetval="0" description="Wakeup Request to module in Sleep will cause this action.                         0: PSC transitions module from Sleep state to TWK state, once access completes (vbus_req = 0) put module back in Sleep state                           1: PSC transitions module to ENABLE state" range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="ACSLPIE" width="1" begin="12" end="12" resetval="0" description="Non-emulation Access to module in sleep Error enable                                0: Non-emulation access to module in sleep is not considered an error condition                                                                                                        1: Non-emulation access to module in sleep is considered an error" range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="ACSLP" width="1" begin="11" end="11" resetval="0" description="Non-emulation Access to module in Sleep will cause this action                              0: PSC transitions module from Sleep state to TWk state, once access completes put module back in Sleep state                                                    1: PSC transitions module to ENABLE state                                                                                            " range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="EMUIHBIE" width="1" begin="10" end="10" resetval="0" description="Emulation alters module state - Inhibits Module Inactive or Force Module Active                                                                                                            0: Not enabled                                                                                               1: Interrupt enabled" range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="EMURSTIE" width="1" begin="9" end="9" resetval="0" description="Emulation Alter Reset Interrupt Enable                                                          0: Not enabled                                                                                                1: Interrupt Enabled" range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="LRSTz" width="1" begin="8" end="8" resetval="0" description="Module local reset control (only applicable to some modules -- e.g GEM, BCG EMIF)                                                                                                     0: Assert local reset                                                                                      1: De-assert local reset" range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="_RESV" width="5" begin="7" end="3" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="NEXT" width="3" begin="2" end="0" resetval="0" description="Module Next State                                                                                          000: SwRstDisable                                                                                        001: Disable                                                                                                   010: SyncReset                                                                                             011: Enable                                                                                                    100: Reserved/Invalid                                                                                    101: Sleep                                                                                                     110: Reserved/Invalid                                                                                    111: Reserved/Invalid" range="" rwaccess="RW">
         
      </bitfield>
   </register>
   <register id="MDCTL18" acronym="MDCTL18" offset="0xA48" width="32" description="Module Control 18 Register">
      <bitfield id="_RESV" width="17" begin="31" end="15" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="WKRSLPIE" width="1" begin="14" end="14" resetval="0" description="Wakeup Request to module in sleep Error Enable.                                        0: Wakeup request to module in sleep is not considered an error condition                                                                                                        1: Wakeup request to module in sleep is considered an error" range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="WKRSLP" width="1" begin="13" end="13" resetval="0" description="Wakeup Request to module in Sleep will cause this action.                         0: PSC transitions module from Sleep state to TWK state, once access completes (vbus_req = 0) put module back in Sleep state                           1: PSC transitions module to ENABLE state" range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="ACSLPIE" width="1" begin="12" end="12" resetval="0" description="Non-emulation Access to module in sleep Error enable                                0: Non-emulation access to module in sleep is not considered an error condition                                                                                                        1: Non-emulation access to module in sleep is considered an error" range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="ACSLP" width="1" begin="11" end="11" resetval="0" description="Non-emulation Access to module in Sleep will cause this action                              0: PSC transitions module from Sleep state to TWk state, once access completes put module back in Sleep state                                                    1: PSC transitions module to ENABLE state                                                                                            " range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="EMUIHBIE" width="1" begin="10" end="10" resetval="0" description="Emulation alters module state - Inhibits Module Inactive or Force Module Active                                                                                                            0: Not enabled                                                                                               1: Interrupt enabled" range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="EMURSTIE" width="1" begin="9" end="9" resetval="0" description="Emulation Alter Reset Interrupt Enable                                                          0: Not enabled                                                                                                1: Interrupt Enabled" range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="LRSTz" width="1" begin="8" end="8" resetval="0" description="Module local reset control (only applicable to some modules -- e.g GEM, BCG EMIF)                                                                                                     0: Assert local reset                                                                                      1: De-assert local reset" range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="_RESV" width="5" begin="7" end="3" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="NEXT" width="3" begin="2" end="0" resetval="0" description="Module Next State                                                                                          000: SwRstDisable                                                                                        001: Disable                                                                                                   010: SyncReset                                                                                             011: Enable                                                                                                    100: Reserved/Invalid                                                                                    101: Sleep                                                                                                     110: Reserved/Invalid                                                                                    111: Reserved/Invalid" range="" rwaccess="RW">
         
      </bitfield>
   </register>
   <register id="MDCTL19" acronym="MDCTL19" offset="0xA4C" width="32" description="Module Control 19 Register">
      <bitfield id="_RESV" width="17" begin="31" end="15" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="WKRSLPIE" width="1" begin="14" end="14" resetval="0" description="Wakeup Request to module in sleep Error Enable.                                        0: Wakeup request to module in sleep is not considered an error condition                                                                                                        1: Wakeup request to module in sleep is considered an error" range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="WKRSLP" width="1" begin="13" end="13" resetval="0" description="Wakeup Request to module in Sleep will cause this action.                         0: PSC transitions module from Sleep state to TWK state, once access completes (vbus_req = 0) put module back in Sleep state                           1: PSC transitions module to ENABLE state" range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="ACSLPIE" width="1" begin="12" end="12" resetval="0" description="Non-emulation Access to module in sleep Error enable                                0: Non-emulation access to module in sleep is not considered an error condition                                                                                                        1: Non-emulation access to module in sleep is considered an error" range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="ACSLP" width="1" begin="11" end="11" resetval="0" description="Non-emulation Access to module in Sleep will cause this action                              0: PSC transitions module from Sleep state to TWk state, once access completes put module back in Sleep state                                                    1: PSC transitions module to ENABLE state                                                                                            " range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="EMUIHBIE" width="1" begin="10" end="10" resetval="0" description="Emulation alters module state - Inhibits Module Inactive or Force Module Active                                                                                                            0: Not enabled                                                                                               1: Interrupt enabled" range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="EMURSTIE" width="1" begin="9" end="9" resetval="0" description="Emulation Alter Reset Interrupt Enable                                                          0: Not enabled                                                                                                1: Interrupt Enabled" range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="LRSTz" width="1" begin="8" end="8" resetval="0" description="Module local reset control (only applicable to some modules -- e.g GEM, BCG EMIF)                                                                                                     0: Assert local reset                                                                                      1: De-assert local reset" range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="_RESV" width="5" begin="7" end="3" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="NEXT" width="3" begin="2" end="0" resetval="0" description="Module Next State                                                                                          000: SwRstDisable                                                                                        001: Disable                                                                                                   010: SyncReset                                                                                             011: Enable                                                                                                    100: Reserved/Invalid                                                                                    101: Sleep                                                                                                     110: Reserved/Invalid                                                                                    111: Reserved/Invalid" range="" rwaccess="RW">
         
      </bitfield>
   </register>
   <register id="MDCTL20" acronym="MDCTL20" offset="0xA50" width="32" description="Module Control 20 Register">
      <bitfield id="_RESV" width="17" begin="31" end="15" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="WKRSLPIE" width="1" begin="14" end="14" resetval="0" description="Wakeup Request to module in sleep Error Enable.                                        0: Wakeup request to module in sleep is not considered an error condition                                                                                                        1: Wakeup request to module in sleep is considered an error" range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="WKRSLP" width="1" begin="13" end="13" resetval="0" description="Wakeup Request to module in Sleep will cause this action.                         0: PSC transitions module from Sleep state to TWK state, once access completes (vbus_req = 0) put module back in Sleep state                           1: PSC transitions module to ENABLE state" range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="ACSLPIE" width="1" begin="12" end="12" resetval="0" description="Non-emulation Access to module in sleep Error enable                                0: Non-emulation access to module in sleep is not considered an error condition                                                                                                        1: Non-emulation access to module in sleep is considered an error" range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="ACSLP" width="1" begin="11" end="11" resetval="0" description="Non-emulation Access to module in Sleep will cause this action                              0: PSC transitions module from Sleep state to TWk state, once access completes put module back in Sleep state                                                    1: PSC transitions module to ENABLE state                                                                                            " range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="EMUIHBIE" width="1" begin="10" end="10" resetval="0" description="Emulation alters module state - Inhibits Module Inactive or Force Module Active                                                                                                            0: Not enabled                                                                                               1: Interrupt enabled" range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="EMURSTIE" width="1" begin="9" end="9" resetval="0" description="Emulation Alter Reset Interrupt Enable                                                          0: Not enabled                                                                                                1: Interrupt Enabled" range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="LRSTz" width="1" begin="8" end="8" resetval="0" description="Module local reset control (only applicable to some modules -- e.g GEM, BCG EMIF)                                                                                                     0: Assert local reset                                                                                      1: De-assert local reset" range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="_RESV" width="5" begin="7" end="3" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="NEXT" width="3" begin="2" end="0" resetval="0" description="Module Next State                                                                                          000: SwRstDisable                                                                                        001: Disable                                                                                                   010: SyncReset                                                                                             011: Enable                                                                                                    100: Reserved/Invalid                                                                                    101: Sleep                                                                                                     110: Reserved/Invalid                                                                                    111: Reserved/Invalid" range="" rwaccess="RW">
         
      </bitfield>
   </register>
   <register id="MDCTL21" acronym="MDCTL21" offset="0xA54" width="32" description="Module Control 21 Register">
      <bitfield id="_RESV" width="17" begin="31" end="15" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="WKRSLPIE" width="1" begin="14" end="14" resetval="0" description="Wakeup Request to module in sleep Error Enable.                                        0: Wakeup request to module in sleep is not considered an error condition                                                                                                        1: Wakeup request to module in sleep is considered an error" range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="WKRSLP" width="1" begin="13" end="13" resetval="0" description="Wakeup Request to module in Sleep will cause this action.                         0: PSC transitions module from Sleep state to TWK state, once access completes (vbus_req = 0) put module back in Sleep state                           1: PSC transitions module to ENABLE state" range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="ACSLPIE" width="1" begin="12" end="12" resetval="0" description="Non-emulation Access to module in sleep Error enable                                0: Non-emulation access to module in sleep is not considered an error condition                                                                                                        1: Non-emulation access to module in sleep is considered an error" range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="ACSLP" width="1" begin="11" end="11" resetval="0" description="Non-emulation Access to module in Sleep will cause this action                              0: PSC transitions module from Sleep state to TWk state, once access completes put module back in Sleep state                                                    1: PSC transitions module to ENABLE state                                                                                            " range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="EMUIHBIE" width="1" begin="10" end="10" resetval="0" description="Emulation alters module state - Inhibits Module Inactive or Force Module Active                                                                                                            0: Not enabled                                                                                               1: Interrupt enabled" range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="EMURSTIE" width="1" begin="9" end="9" resetval="0" description="Emulation Alter Reset Interrupt Enable                                                          0: Not enabled                                                                                                1: Interrupt Enabled" range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="LRSTz" width="1" begin="8" end="8" resetval="0" description="Module local reset control (only applicable to some modules -- e.g GEM, BCG EMIF)                                                                                                     0: Assert local reset                                                                                      1: De-assert local reset" range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="_RESV" width="5" begin="7" end="3" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="NEXT" width="3" begin="2" end="0" resetval="0" description="Module Next State                                                                                          000: SwRstDisable                                                                                        001: Disable                                                                                                   010: SyncReset                                                                                             011: Enable                                                                                                    100: Reserved/Invalid                                                                                    101: Sleep                                                                                                     110: Reserved/Invalid                                                                                    111: Reserved/Invalid" range="" rwaccess="RW">
         
      </bitfield>
   </register>
   <register id="MDCTL22" acronym="MDCTL22" offset="0xA58" width="32" description="Module Control 22 Register">
      <bitfield id="_RESV" width="17" begin="31" end="15" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="WKRSLPIE" width="1" begin="14" end="14" resetval="0" description="Wakeup Request to module in sleep Error Enable.                                        0: Wakeup request to module in sleep is not considered an error condition                                                                                                        1: Wakeup request to module in sleep is considered an error" range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="WKRSLP" width="1" begin="13" end="13" resetval="0" description="Wakeup Request to module in Sleep will cause this action.                         0: PSC transitions module from Sleep state to TWK state, once access completes (vbus_req = 0) put module back in Sleep state                           1: PSC transitions module to ENABLE state" range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="ACSLPIE" width="1" begin="12" end="12" resetval="0" description="Non-emulation Access to module in sleep Error enable                                0: Non-emulation access to module in sleep is not considered an error condition                                                                                                        1: Non-emulation access to module in sleep is considered an error" range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="ACSLP" width="1" begin="11" end="11" resetval="0" description="Non-emulation Access to module in Sleep will cause this action                              0: PSC transitions module from Sleep state to TWk state, once access completes put module back in Sleep state                                                    1: PSC transitions module to ENABLE state                                                                                            " range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="EMUIHBIE" width="1" begin="10" end="10" resetval="0" description="Emulation alters module state - Inhibits Module Inactive or Force Module Active                                                                                                            0: Not enabled                                                                                               1: Interrupt enabled" range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="EMURSTIE" width="1" begin="9" end="9" resetval="0" description="Emulation Alter Reset Interrupt Enable                                                          0: Not enabled                                                                                                1: Interrupt Enabled" range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="LRSTz" width="1" begin="8" end="8" resetval="0" description="Module local reset control (only applicable to some modules -- e.g GEM, BCG EMIF)                                                                                                     0: Assert local reset                                                                                      1: De-assert local reset" range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="_RESV" width="5" begin="7" end="3" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="NEXT" width="3" begin="2" end="0" resetval="0" description="Module Next State                                                                                          000: SwRstDisable                                                                                        001: Disable                                                                                                   010: SyncReset                                                                                             011: Enable                                                                                                    100: Reserved/Invalid                                                                                    101: Sleep                                                                                                     110: Reserved/Invalid                                                                                    111: Reserved/Invalid" range="" rwaccess="RW">
         
      </bitfield>
   </register>
   <register id="MDCTL23" acronym="MDCTL23" offset="0xA5C" width="32" description="Module Control 23 Register">
      <bitfield id="_RESV" width="17" begin="31" end="15" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="WKRSLPIE" width="1" begin="14" end="14" resetval="0" description="Wakeup Request to module in sleep Error Enable.                                        0: Wakeup request to module in sleep is not considered an error condition                                                                                                        1: Wakeup request to module in sleep is considered an error" range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="WKRSLP" width="1" begin="13" end="13" resetval="0" description="Wakeup Request to module in Sleep will cause this action.                         0: PSC transitions module from Sleep state to TWK state, once access completes (vbus_req = 0) put module back in Sleep state                           1: PSC transitions module to ENABLE state" range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="ACSLPIE" width="1" begin="12" end="12" resetval="0" description="Non-emulation Access to module in sleep Error enable                                0: Non-emulation access to module in sleep is not considered an error condition                                                                                                        1: Non-emulation access to module in sleep is considered an error" range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="ACSLP" width="1" begin="11" end="11" resetval="0" description="Non-emulation Access to module in Sleep will cause this action                              0: PSC transitions module from Sleep state to TWk state, once access completes put module back in Sleep state                                                    1: PSC transitions module to ENABLE state                                                                                            " range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="EMUIHBIE" width="1" begin="10" end="10" resetval="0" description="Emulation alters module state - Inhibits Module Inactive or Force Module Active                                                                                                            0: Not enabled                                                                                               1: Interrupt enabled" range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="EMURSTIE" width="1" begin="9" end="9" resetval="0" description="Emulation Alter Reset Interrupt Enable                                                          0: Not enabled                                                                                                1: Interrupt Enabled" range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="LRSTz" width="1" begin="8" end="8" resetval="0" description="Module local reset control (only applicable to some modules -- e.g GEM, BCG EMIF)                                                                                                     0: Assert local reset                                                                                      1: De-assert local reset" range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="_RESV" width="5" begin="7" end="3" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="NEXT" width="3" begin="2" end="0" resetval="0" description="Module Next State                                                                                          000: SwRstDisable                                                                                        001: Disable                                                                                                   010: SyncReset                                                                                             011: Enable                                                                                                    100: Reserved/Invalid                                                                                    101: Sleep                                                                                                     110: Reserved/Invalid                                                                                    111: Reserved/Invalid" range="" rwaccess="RW">
         
      </bitfield>
   </register>
   <register id="MDCTL24" acronym="MDCTL24" offset="0xA60" width="32" description="Module Control 24 Register">
      <bitfield id="_RESV" width="17" begin="31" end="15" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="WKRSLPIE" width="1" begin="14" end="14" resetval="0" description="Wakeup Request to module in sleep Error Enable.                                        0: Wakeup request to module in sleep is not considered an error condition                                                                                                        1: Wakeup request to module in sleep is considered an error" range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="WKRSLP" width="1" begin="13" end="13" resetval="0" description="Wakeup Request to module in Sleep will cause this action.                         0: PSC transitions module from Sleep state to TWK state, once access completes (vbus_req = 0) put module back in Sleep state                           1: PSC transitions module to ENABLE state" range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="ACSLPIE" width="1" begin="12" end="12" resetval="0" description="Non-emulation Access to module in sleep Error enable                                0: Non-emulation access to module in sleep is not considered an error condition                                                                                                        1: Non-emulation access to module in sleep is considered an error" range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="ACSLP" width="1" begin="11" end="11" resetval="0" description="Non-emulation Access to module in Sleep will cause this action                              0: PSC transitions module from Sleep state to TWk state, once access completes put module back in Sleep state                                                    1: PSC transitions module to ENABLE state                                                                                            " range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="EMUIHBIE" width="1" begin="10" end="10" resetval="0" description="Emulation alters module state - Inhibits Module Inactive or Force Module Active                                                                                                            0: Not enabled                                                                                               1: Interrupt enabled" range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="EMURSTIE" width="1" begin="9" end="9" resetval="0" description="Emulation Alter Reset Interrupt Enable                                                          0: Not enabled                                                                                                1: Interrupt Enabled" range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="LRSTz" width="1" begin="8" end="8" resetval="0" description="Module local reset control (only applicable to some modules -- e.g GEM, BCG EMIF)                                                                                                     0: Assert local reset                                                                                      1: De-assert local reset" range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="_RESV" width="5" begin="7" end="3" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="NEXT" width="3" begin="2" end="0" resetval="0" description="Module Next State                                                                                          000: SwRstDisable                                                                                        001: Disable                                                                                                   010: SyncReset                                                                                             011: Enable                                                                                                    100: Reserved/Invalid                                                                                    101: Sleep                                                                                                     110: Reserved/Invalid                                                                                    111: Reserved/Invalid" range="" rwaccess="RW">
         
      </bitfield>
   </register>
   <register id="MDCTL25" acronym="MDCTL25" offset="0xA64" width="32" description="Module Control 25 Register">
      <bitfield id="_RESV" width="17" begin="31" end="15" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="WKRSLPIE" width="1" begin="14" end="14" resetval="0" description="Wakeup Request to module in sleep Error Enable.                                        0: Wakeup request to module in sleep is not considered an error condition                                                                                                        1: Wakeup request to module in sleep is considered an error" range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="WKRSLP" width="1" begin="13" end="13" resetval="0" description="Wakeup Request to module in Sleep will cause this action.                         0: PSC transitions module from Sleep state to TWK state, once access completes (vbus_req = 0) put module back in Sleep state                           1: PSC transitions module to ENABLE state" range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="ACSLPIE" width="1" begin="12" end="12" resetval="0" description="Non-emulation Access to module in sleep Error enable                                0: Non-emulation access to module in sleep is not considered an error condition                                                                                                        1: Non-emulation access to module in sleep is considered an error" range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="ACSLP" width="1" begin="11" end="11" resetval="0" description="Non-emulation Access to module in Sleep will cause this action                              0: PSC transitions module from Sleep state to TWk state, once access completes put module back in Sleep state                                                    1: PSC transitions module to ENABLE state                                                                                            " range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="EMUIHBIE" width="1" begin="10" end="10" resetval="0" description="Emulation alters module state - Inhibits Module Inactive or Force Module Active                                                                                                            0: Not enabled                                                                                               1: Interrupt enabled" range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="EMURSTIE" width="1" begin="9" end="9" resetval="0" description="Emulation Alter Reset Interrupt Enable                                                          0: Not enabled                                                                                                1: Interrupt Enabled" range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="LRSTz" width="1" begin="8" end="8" resetval="0" description="Module local reset control (only applicable to some modules -- e.g GEM, BCG EMIF)                                                                                                     0: Assert local reset                                                                                      1: De-assert local reset" range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="_RESV" width="5" begin="7" end="3" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="NEXT" width="3" begin="2" end="0" resetval="0" description="Module Next State                                                                                          000: SwRstDisable                                                                                        001: Disable                                                                                                   010: SyncReset                                                                                             011: Enable                                                                                                    100: Reserved/Invalid                                                                                    101: Sleep                                                                                                     110: Reserved/Invalid                                                                                    111: Reserved/Invalid" range="" rwaccess="RW">
         
      </bitfield>
   </register>
   <register id="MDCTL26" acronym="MDCTL26" offset="0xA68" width="32" description="Module Control 26 Register">
      <bitfield id="_RESV" width="17" begin="31" end="15" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="WKRSLPIE" width="1" begin="14" end="14" resetval="0" description="Wakeup Request to module in sleep Error Enable.                                        0: Wakeup request to module in sleep is not considered an error condition                                                                                                        1: Wakeup request to module in sleep is considered an error" range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="WKRSLP" width="1" begin="13" end="13" resetval="0" description="Wakeup Request to module in Sleep will cause this action.                         0: PSC transitions module from Sleep state to TWK state, once access completes (vbus_req = 0) put module back in Sleep state                           1: PSC transitions module to ENABLE state" range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="ACSLPIE" width="1" begin="12" end="12" resetval="0" description="Non-emulation Access to module in sleep Error enable                                0: Non-emulation access to module in sleep is not considered an error condition                                                                                                        1: Non-emulation access to module in sleep is considered an error" range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="ACSLP" width="1" begin="11" end="11" resetval="0" description="Non-emulation Access to module in Sleep will cause this action                              0: PSC transitions module from Sleep state to TWk state, once access completes put module back in Sleep state                                                    1: PSC transitions module to ENABLE state                                                                                            " range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="EMUIHBIE" width="1" begin="10" end="10" resetval="0" description="Emulation alters module state - Inhibits Module Inactive or Force Module Active                                                                                                            0: Not enabled                                                                                               1: Interrupt enabled" range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="EMURSTIE" width="1" begin="9" end="9" resetval="0" description="Emulation Alter Reset Interrupt Enable                                                          0: Not enabled                                                                                                1: Interrupt Enabled" range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="LRSTz" width="1" begin="8" end="8" resetval="0" description="Module local reset control (only applicable to some modules -- e.g GEM, BCG EMIF)                                                                                                     0: Assert local reset                                                                                      1: De-assert local reset" range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="_RESV" width="5" begin="7" end="3" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="NEXT" width="3" begin="2" end="0" resetval="0" description="Module Next State                                                                                          000: SwRstDisable                                                                                        001: Disable                                                                                                   010: SyncReset                                                                                             011: Enable                                                                                                    100: Reserved/Invalid                                                                                    101: Sleep                                                                                                     110: Reserved/Invalid                                                                                    111: Reserved/Invalid" range="" rwaccess="RW">
         
      </bitfield>
   </register>
   <register id="MDCTL27" acronym="MDCTL27" offset="0xA6C" width="32" description="Module Control 27 Register">
      <bitfield id="_RESV" width="17" begin="31" end="15" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="WKRSLPIE" width="1" begin="14" end="14" resetval="0" description="Wakeup Request to module in sleep Error Enable.                                        0: Wakeup request to module in sleep is not considered an error condition                                                                                                        1: Wakeup request to module in sleep is considered an error" range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="WKRSLP" width="1" begin="13" end="13" resetval="0" description="Wakeup Request to module in Sleep will cause this action.                         0: PSC transitions module from Sleep state to TWK state, once access completes (vbus_req = 0) put module back in Sleep state                           1: PSC transitions module to ENABLE state" range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="ACSLPIE" width="1" begin="12" end="12" resetval="0" description="Non-emulation Access to module in sleep Error enable                                0: Non-emulation access to module in sleep is not considered an error condition                                                                                                        1: Non-emulation access to module in sleep is considered an error" range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="ACSLP" width="1" begin="11" end="11" resetval="0" description="Non-emulation Access to module in Sleep will cause this action                              0: PSC transitions module from Sleep state to TWk state, once access completes put module back in Sleep state                                                    1: PSC transitions module to ENABLE state                                                                                            " range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="EMUIHBIE" width="1" begin="10" end="10" resetval="0" description="Emulation alters module state - Inhibits Module Inactive or Force Module Active                                                                                                            0: Not enabled                                                                                               1: Interrupt enabled" range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="EMURSTIE" width="1" begin="9" end="9" resetval="0" description="Emulation Alter Reset Interrupt Enable                                                          0: Not enabled                                                                                                1: Interrupt Enabled" range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="LRSTz" width="1" begin="8" end="8" resetval="0" description="Module local reset control (only applicable to some modules -- e.g GEM, BCG EMIF)                                                                                                     0: Assert local reset                                                                                      1: De-assert local reset" range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="_RESV" width="5" begin="7" end="3" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="NEXT" width="3" begin="2" end="0" resetval="0" description="Module Next State                                                                                          000: SwRstDisable                                                                                        001: Disable                                                                                                   010: SyncReset                                                                                             011: Enable                                                                                                    100: Reserved/Invalid                                                                                    101: Sleep                                                                                                     110: Reserved/Invalid                                                                                    111: Reserved/Invalid" range="" rwaccess="RW">
         
      </bitfield>
   </register>
   <register id="MDCTL28" acronym="MDCTL28" offset="0xA70" width="32" description="Module Control 28 Register">
      <bitfield id="_RESV" width="17" begin="31" end="15" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="WKRSLPIE" width="1" begin="14" end="14" resetval="0" description="Wakeup Request to module in sleep Error Enable.                                        0: Wakeup request to module in sleep is not considered an error condition                                                                                                        1: Wakeup request to module in sleep is considered an error" range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="WKRSLP" width="1" begin="13" end="13" resetval="0" description="Wakeup Request to module in Sleep will cause this action.                         0: PSC transitions module from Sleep state to TWK state, once access completes (vbus_req = 0) put module back in Sleep state                           1: PSC transitions module to ENABLE state" range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="ACSLPIE" width="1" begin="12" end="12" resetval="0" description="Non-emulation Access to module in sleep Error enable                                0: Non-emulation access to module in sleep is not considered an error condition                                                                                                        1: Non-emulation access to module in sleep is considered an error" range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="ACSLP" width="1" begin="11" end="11" resetval="0" description="Non-emulation Access to module in Sleep will cause this action                              0: PSC transitions module from Sleep state to TWk state, once access completes put module back in Sleep state                                                    1: PSC transitions module to ENABLE state                                                                                            " range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="EMUIHBIE" width="1" begin="10" end="10" resetval="0" description="Emulation alters module state - Inhibits Module Inactive or Force Module Active                                                                                                            0: Not enabled                                                                                               1: Interrupt enabled" range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="EMURSTIE" width="1" begin="9" end="9" resetval="0" description="Emulation Alter Reset Interrupt Enable                                                          0: Not enabled                                                                                                1: Interrupt Enabled" range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="LRSTz" width="1" begin="8" end="8" resetval="0" description="Module local reset control (only applicable to some modules -- e.g GEM, BCG EMIF)                                                                                                     0: Assert local reset                                                                                      1: De-assert local reset" range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="_RESV" width="5" begin="7" end="3" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="NEXT" width="3" begin="2" end="0" resetval="0" description="Module Next State                                                                                          000: SwRstDisable                                                                                        001: Disable                                                                                                   010: SyncReset                                                                                             011: Enable                                                                                                    100: Reserved/Invalid                                                                                    101: Sleep                                                                                                     110: Reserved/Invalid                                                                                    111: Reserved/Invalid" range="" rwaccess="RW">
         
      </bitfield>
   </register>
   <register id="MDCTL29" acronym="MDCTL29" offset="0xA74" width="32" description="Module Control 29 Register">
      <bitfield id="_RESV" width="17" begin="31" end="15" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="WKRSLPIE" width="1" begin="14" end="14" resetval="0" description="Wakeup Request to module in sleep Error Enable.                                        0: Wakeup request to module in sleep is not considered an error condition                                                                                                        1: Wakeup request to module in sleep is considered an error" range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="WKRSLP" width="1" begin="13" end="13" resetval="0" description="Wakeup Request to module in Sleep will cause this action.                         0: PSC transitions module from Sleep state to TWK state, once access completes (vbus_req = 0) put module back in Sleep state                           1: PSC transitions module to ENABLE state" range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="ACSLPIE" width="1" begin="12" end="12" resetval="0" description="Non-emulation Access to module in sleep Error enable                                0: Non-emulation access to module in sleep is not considered an error condition                                                                                                        1: Non-emulation access to module in sleep is considered an error" range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="ACSLP" width="1" begin="11" end="11" resetval="0" description="Non-emulation Access to module in Sleep will cause this action                              0: PSC transitions module from Sleep state to TWk state, once access completes put module back in Sleep state                                                    1: PSC transitions module to ENABLE state                                                                                            " range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="EMUIHBIE" width="1" begin="10" end="10" resetval="0" description="Emulation alters module state - Inhibits Module Inactive or Force Module Active                                                                                                            0: Not enabled                                                                                               1: Interrupt enabled" range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="EMURSTIE" width="1" begin="9" end="9" resetval="0" description="Emulation Alter Reset Interrupt Enable                                                          0: Not enabled                                                                                                1: Interrupt Enabled" range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="LRSTz" width="1" begin="8" end="8" resetval="0" description="Module local reset control (only applicable to some modules -- e.g GEM, BCG EMIF)                                                                                                     0: Assert local reset                                                                                      1: De-assert local reset" range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="_RESV" width="5" begin="7" end="3" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="NEXT" width="3" begin="2" end="0" resetval="0" description="Module Next State                                                                                          000: SwRstDisable                                                                                        001: Disable                                                                                                   010: SyncReset                                                                                             011: Enable                                                                                                    100: Reserved/Invalid                                                                                    101: Sleep                                                                                                     110: Reserved/Invalid                                                                                    111: Reserved/Invalid" range="" rwaccess="RW">
         
      </bitfield>
   </register>
   <register id="MDCTL30" acronym="MDCTL30" offset="0xA78" width="32" description="Module Control 30 Register">
      <bitfield id="_RESV" width="17" begin="31" end="15" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="WKRSLPIE" width="1" begin="14" end="14" resetval="0" description="Wakeup Request to module in sleep Error Enable.                                        0: Wakeup request to module in sleep is not considered an error condition                                                                                                        1: Wakeup request to module in sleep is considered an error" range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="WKRSLP" width="1" begin="13" end="13" resetval="0" description="Wakeup Request to module in Sleep will cause this action.                         0: PSC transitions module from Sleep state to TWK state, once access completes (vbus_req = 0) put module back in Sleep state                           1: PSC transitions module to ENABLE state" range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="ACSLPIE" width="1" begin="12" end="12" resetval="0" description="Non-emulation Access to module in sleep Error enable                                0: Non-emulation access to module in sleep is not considered an error condition                                                                                                        1: Non-emulation access to module in sleep is considered an error" range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="ACSLP" width="1" begin="11" end="11" resetval="0" description="Non-emulation Access to module in Sleep will cause this action                              0: PSC transitions module from Sleep state to TWk state, once access completes put module back in Sleep state                                                    1: PSC transitions module to ENABLE state                                                                                            " range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="EMUIHBIE" width="1" begin="10" end="10" resetval="0" description="Emulation alters module state - Inhibits Module Inactive or Force Module Active                                                                                                            0: Not enabled                                                                                               1: Interrupt enabled" range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="EMURSTIE" width="1" begin="9" end="9" resetval="0" description="Emulation Alter Reset Interrupt Enable                                                          0: Not enabled                                                                                                1: Interrupt Enabled" range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="LRSTz" width="1" begin="8" end="8" resetval="0" description="Module local reset control (only applicable to some modules -- e.g GEM, BCG EMIF)                                                                                                     0: Assert local reset                                                                                      1: De-assert local reset" range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="_RESV" width="5" begin="7" end="3" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="NEXT" width="3" begin="2" end="0" resetval="0" description="Module Next State                                                                                          000: SwRstDisable                                                                                        001: Disable                                                                                                   010: SyncReset                                                                                             011: Enable                                                                                                    100: Reserved/Invalid                                                                                    101: Sleep                                                                                                     110: Reserved/Invalid                                                                                    111: Reserved/Invalid" range="" rwaccess="RW">
         
      </bitfield>
   </register>
   <register id="MDCTL31" acronym="MDCTL31" offset="0xA7C" width="32" description="Module Control 31 Register">
      <bitfield id="_RESV" width="17" begin="31" end="15" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="WKRSLPIE" width="1" begin="14" end="14" resetval="0" description="Wakeup Request to module in sleep Error Enable.                                        0: Wakeup request to module in sleep is not considered an error condition                                                                                                        1: Wakeup request to module in sleep is considered an error" range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="WKRSLP" width="1" begin="13" end="13" resetval="0" description="Wakeup Request to module in Sleep will cause this action.                         0: PSC transitions module from Sleep state to TWK state, once access completes (vbus_req = 0) put module back in Sleep state                           1: PSC transitions module to ENABLE state" range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="ACSLPIE" width="1" begin="12" end="12" resetval="0" description="Non-emulation Access to module in sleep Error enable                                0: Non-emulation access to module in sleep is not considered an error condition                                                                                                        1: Non-emulation access to module in sleep is considered an error" range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="ACSLP" width="1" begin="11" end="11" resetval="0" description="Non-emulation Access to module in Sleep will cause this action                              0: PSC transitions module from Sleep state to TWk state, once access completes put module back in Sleep state                                                    1: PSC transitions module to ENABLE state                                                                                            " range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="EMUIHBIE" width="1" begin="10" end="10" resetval="0" description="Emulation alters module state - Inhibits Module Inactive or Force Module Active                                                                                                            0: Not enabled                                                                                               1: Interrupt enabled" range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="EMURSTIE" width="1" begin="9" end="9" resetval="0" description="Emulation Alter Reset Interrupt Enable                                                          0: Not enabled                                                                                                1: Interrupt Enabled" range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="LRSTz" width="1" begin="8" end="8" resetval="0" description="Module local reset control (only applicable to some modules -- e.g GEM, BCG EMIF)                                                                                                     0: Assert local reset                                                                                      1: De-assert local reset" range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="_RESV" width="5" begin="7" end="3" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="NEXT" width="3" begin="2" end="0" resetval="0" description="Module Next State                                                                                          000: SwRstDisable                                                                                        001: Disable                                                                                                   010: SyncReset                                                                                             011: Enable                                                                                                    100: Reserved/Invalid                                                                                    101: Sleep                                                                                                     110: Reserved/Invalid                                                                                    111: Reserved/Invalid" range="" rwaccess="RW">
         
      </bitfield>
   </register>
   <register id="MDCTL32" acronym="MDCTL32" offset="0xA80" width="32" description="Module Control 32 Register">
      <bitfield id="_RESV" width="17" begin="31" end="15" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="WKRSLPIE" width="1" begin="14" end="14" resetval="0" description="Wakeup Request to module in sleep Error Enable.                                        0: Wakeup request to module in sleep is not considered an error condition                                                                                                        1: Wakeup request to module in sleep is considered an error" range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="WKRSLP" width="1" begin="13" end="13" resetval="0" description="Wakeup Request to module in Sleep will cause this action.                         0: PSC transitions module from Sleep state to TWK state, once access completes (vbus_req = 0) put module back in Sleep state                           1: PSC transitions module to ENABLE state" range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="ACSLPIE" width="1" begin="12" end="12" resetval="0" description="Non-emulation Access to module in sleep Error enable                                0: Non-emulation access to module in sleep is not considered an error condition                                                                                                        1: Non-emulation access to module in sleep is considered an error" range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="ACSLP" width="1" begin="11" end="11" resetval="0" description="Non-emulation Access to module in Sleep will cause this action                              0: PSC transitions module from Sleep state to TWk state, once access completes put module back in Sleep state                                                    1: PSC transitions module to ENABLE state                                                                                            " range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="EMUIHBIE" width="1" begin="10" end="10" resetval="0" description="Emulation alters module state - Inhibits Module Inactive or Force Module Active                                                                                                            0: Not enabled                                                                                               1: Interrupt enabled" range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="EMURSTIE" width="1" begin="9" end="9" resetval="0" description="Emulation Alter Reset Interrupt Enable                                                          0: Not enabled                                                                                                1: Interrupt Enabled" range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="LRSTz" width="1" begin="8" end="8" resetval="0" description="Module local reset control (only applicable to some modules -- e.g GEM, BCG EMIF)                                                                                                     0: Assert local reset                                                                                      1: De-assert local reset" range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="_RESV" width="5" begin="7" end="3" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="NEXT" width="3" begin="2" end="0" resetval="0" description="Module Next State                                                                                          000: SwRstDisable                                                                                        001: Disable                                                                                                   010: SyncReset                                                                                             011: Enable                                                                                                    100: Reserved/Invalid                                                                                    101: Sleep                                                                                                     110: Reserved/Invalid                                                                                    111: Reserved/Invalid" range="" rwaccess="RW">
         
      </bitfield>
   </register>
   <register id="MDCTL33" acronym="MDCTL33" offset="0xA84" width="32" description="Module Control 33 Register">
      <bitfield id="_RESV" width="17" begin="31" end="15" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="WKRSLPIE" width="1" begin="14" end="14" resetval="0" description="Wakeup Request to module in sleep Error Enable.                                        0: Wakeup request to module in sleep is not considered an error condition                                                                                                        1: Wakeup request to module in sleep is considered an error" range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="WKRSLP" width="1" begin="13" end="13" resetval="0" description="Wakeup Request to module in Sleep will cause this action.                         0: PSC transitions module from Sleep state to TWK state, once access completes (vbus_req = 0) put module back in Sleep state                           1: PSC transitions module to ENABLE state" range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="ACSLPIE" width="1" begin="12" end="12" resetval="0" description="Non-emulation Access to module in sleep Error enable                                0: Non-emulation access to module in sleep is not considered an error condition                                                                                                        1: Non-emulation access to module in sleep is considered an error" range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="ACSLP" width="1" begin="11" end="11" resetval="0" description="Non-emulation Access to module in Sleep will cause this action                              0: PSC transitions module from Sleep state to TWk state, once access completes put module back in Sleep state                                                    1: PSC transitions module to ENABLE state                                                                                            " range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="EMUIHBIE" width="1" begin="10" end="10" resetval="0" description="Emulation alters module state - Inhibits Module Inactive or Force Module Active                                                                                                            0: Not enabled                                                                                               1: Interrupt enabled" range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="EMURSTIE" width="1" begin="9" end="9" resetval="0" description="Emulation Alter Reset Interrupt Enable                                                          0: Not enabled                                                                                                1: Interrupt Enabled" range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="LRSTz" width="1" begin="8" end="8" resetval="0" description="Module local reset control (only applicable to some modules -- e.g GEM, BCG EMIF)                                                                                                     0: Assert local reset                                                                                      1: De-assert local reset" range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="_RESV" width="5" begin="7" end="3" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="NEXT" width="3" begin="2" end="0" resetval="0" description="Module Next State                                                                                          000: SwRstDisable                                                                                        001: Disable                                                                                                   010: SyncReset                                                                                             011: Enable                                                                                                    100: Reserved/Invalid                                                                                    101: Sleep                                                                                                     110: Reserved/Invalid                                                                                    111: Reserved/Invalid" range="" rwaccess="RW">
         
      </bitfield>
   </register>
   <register id="MDCTL34" acronym="MDCTL34" offset="0xA88" width="32" description="Module Control 34 Register">
      <bitfield id="_RESV" width="17" begin="31" end="15" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="WKRSLPIE" width="1" begin="14" end="14" resetval="0" description="Wakeup Request to module in sleep Error Enable.                                        0: Wakeup request to module in sleep is not considered an error condition                                                                                                        1: Wakeup request to module in sleep is considered an error" range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="WKRSLP" width="1" begin="13" end="13" resetval="0" description="Wakeup Request to module in Sleep will cause this action.                         0: PSC transitions module from Sleep state to TWK state, once access completes (vbus_req = 0) put module back in Sleep state                           1: PSC transitions module to ENABLE state" range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="ACSLPIE" width="1" begin="12" end="12" resetval="0" description="Non-emulation Access to module in sleep Error enable                                0: Non-emulation access to module in sleep is not considered an error condition                                                                                                        1: Non-emulation access to module in sleep is considered an error" range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="ACSLP" width="1" begin="11" end="11" resetval="0" description="Non-emulation Access to module in Sleep will cause this action                              0: PSC transitions module from Sleep state to TWk state, once access completes put module back in Sleep state                                                    1: PSC transitions module to ENABLE state                                                                                            " range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="EMUIHBIE" width="1" begin="10" end="10" resetval="0" description="Emulation alters module state - Inhibits Module Inactive or Force Module Active                                                                                                            0: Not enabled                                                                                               1: Interrupt enabled" range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="EMURSTIE" width="1" begin="9" end="9" resetval="0" description="Emulation Alter Reset Interrupt Enable                                                          0: Not enabled                                                                                                1: Interrupt Enabled" range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="LRSTz" width="1" begin="8" end="8" resetval="0" description="Module local reset control (only applicable to some modules -- e.g GEM, BCG EMIF)                                                                                                     0: Assert local reset                                                                                      1: De-assert local reset" range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="_RESV" width="5" begin="7" end="3" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="NEXT" width="3" begin="2" end="0" resetval="0" description="Module Next State                                                                                          000: SwRstDisable                                                                                        001: Disable                                                                                                   010: SyncReset                                                                                             011: Enable                                                                                                    100: Reserved/Invalid                                                                                    101: Sleep                                                                                                     110: Reserved/Invalid                                                                                    111: Reserved/Invalid" range="" rwaccess="RW">
         
      </bitfield>
   </register>
   <register id="MDCTL35" acronym="MDCTL35" offset="0xA8C" width="32" description="Module Control 35 Register">
      <bitfield id="_RESV" width="17" begin="31" end="15" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="WKRSLPIE" width="1" begin="14" end="14" resetval="0" description="Wakeup Request to module in sleep Error Enable.                                        0: Wakeup request to module in sleep is not considered an error condition                                                                                                        1: Wakeup request to module in sleep is considered an error" range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="WKRSLP" width="1" begin="13" end="13" resetval="0" description="Wakeup Request to module in Sleep will cause this action.                         0: PSC transitions module from Sleep state to TWK state, once access completes (vbus_req = 0) put module back in Sleep state                           1: PSC transitions module to ENABLE state" range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="ACSLPIE" width="1" begin="12" end="12" resetval="0" description="Non-emulation Access to module in sleep Error enable                                0: Non-emulation access to module in sleep is not considered an error condition                                                                                                        1: Non-emulation access to module in sleep is considered an error" range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="ACSLP" width="1" begin="11" end="11" resetval="0" description="Non-emulation Access to module in Sleep will cause this action                              0: PSC transitions module from Sleep state to TWk state, once access completes put module back in Sleep state                                                    1: PSC transitions module to ENABLE state                                                                                            " range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="EMUIHBIE" width="1" begin="10" end="10" resetval="0" description="Emulation alters module state - Inhibits Module Inactive or Force Module Active                                                                                                            0: Not enabled                                                                                               1: Interrupt enabled" range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="EMURSTIE" width="1" begin="9" end="9" resetval="0" description="Emulation Alter Reset Interrupt Enable                                                          0: Not enabled                                                                                                1: Interrupt Enabled" range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="LRSTz" width="1" begin="8" end="8" resetval="0" description="Module local reset control (only applicable to some modules -- e.g GEM, BCG EMIF)                                                                                                     0: Assert local reset                                                                                      1: De-assert local reset" range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="_RESV" width="5" begin="7" end="3" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="NEXT" width="3" begin="2" end="0" resetval="0" description="Module Next State                                                                                          000: SwRstDisable                                                                                        001: Disable                                                                                                   010: SyncReset                                                                                             011: Enable                                                                                                    100: Reserved/Invalid                                                                                    101: Sleep                                                                                                     110: Reserved/Invalid                                                                                    111: Reserved/Invalid" range="" rwaccess="RW">
         
      </bitfield>
   </register>
   <register id="MDCTL36" acronym="MDCTL36" offset="0xA90" width="32" description="Module Control 36 Register">
      <bitfield id="_RESV" width="17" begin="31" end="15" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="WKRSLPIE" width="1" begin="14" end="14" resetval="0" description="Wakeup Request to module in sleep Error Enable.                                        0: Wakeup request to module in sleep is not considered an error condition                                                                                                        1: Wakeup request to module in sleep is considered an error" range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="WKRSLP" width="1" begin="13" end="13" resetval="0" description="Wakeup Request to module in Sleep will cause this action.                         0: PSC transitions module from Sleep state to TWK state, once access completes (vbus_req = 0) put module back in Sleep state                           1: PSC transitions module to ENABLE state" range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="ACSLPIE" width="1" begin="12" end="12" resetval="0" description="Non-emulation Access to module in sleep Error enable                                0: Non-emulation access to module in sleep is not considered an error condition                                                                                                        1: Non-emulation access to module in sleep is considered an error" range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="ACSLP" width="1" begin="11" end="11" resetval="0" description="Non-emulation Access to module in Sleep will cause this action                              0: PSC transitions module from Sleep state to TWk state, once access completes put module back in Sleep state                                                    1: PSC transitions module to ENABLE state                                                                                            " range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="EMUIHBIE" width="1" begin="10" end="10" resetval="0" description="Emulation alters module state - Inhibits Module Inactive or Force Module Active                                                                                                            0: Not enabled                                                                                               1: Interrupt enabled" range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="EMURSTIE" width="1" begin="9" end="9" resetval="0" description="Emulation Alter Reset Interrupt Enable                                                          0: Not enabled                                                                                                1: Interrupt Enabled" range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="LRSTz" width="1" begin="8" end="8" resetval="0" description="Module local reset control (only applicable to some modules -- e.g GEM, BCG EMIF)                                                                                                     0: Assert local reset                                                                                      1: De-assert local reset" range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="_RESV" width="5" begin="7" end="3" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="NEXT" width="3" begin="2" end="0" resetval="0" description="Module Next State                                                                                          000: SwRstDisable                                                                                        001: Disable                                                                                                   010: SyncReset                                                                                             011: Enable                                                                                                    100: Reserved/Invalid                                                                                    101: Sleep                                                                                                     110: Reserved/Invalid                                                                                    111: Reserved/Invalid" range="" rwaccess="RW">
         
      </bitfield>
   </register>
   <register id="MDCTL37" acronym="MDCTL37" offset="0xA94" width="32" description="Module Control 37 Register">
      <bitfield id="_RESV" width="17" begin="31" end="15" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="WKRSLPIE" width="1" begin="14" end="14" resetval="0" description="Wakeup Request to module in sleep Error Enable.                                        0: Wakeup request to module in sleep is not considered an error condition                                                                                                        1: Wakeup request to module in sleep is considered an error" range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="WKRSLP" width="1" begin="13" end="13" resetval="0" description="Wakeup Request to module in Sleep will cause this action.                         0: PSC transitions module from Sleep state to TWK state, once access completes (vbus_req = 0) put module back in Sleep state                           1: PSC transitions module to ENABLE state" range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="ACSLPIE" width="1" begin="12" end="12" resetval="0" description="Non-emulation Access to module in sleep Error enable                                0: Non-emulation access to module in sleep is not considered an error condition                                                                                                        1: Non-emulation access to module in sleep is considered an error" range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="ACSLP" width="1" begin="11" end="11" resetval="0" description="Non-emulation Access to module in Sleep will cause this action                              0: PSC transitions module from Sleep state to TWk state, once access completes put module back in Sleep state                                                    1: PSC transitions module to ENABLE state                                                                                            " range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="EMUIHBIE" width="1" begin="10" end="10" resetval="0" description="Emulation alters module state - Inhibits Module Inactive or Force Module Active                                                                                                            0: Not enabled                                                                                               1: Interrupt enabled" range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="EMURSTIE" width="1" begin="9" end="9" resetval="0" description="Emulation Alter Reset Interrupt Enable                                                          0: Not enabled                                                                                                1: Interrupt Enabled" range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="LRSTz" width="1" begin="8" end="8" resetval="0" description="Module local reset control (only applicable to some modules -- e.g GEM, BCG EMIF)                                                                                                     0: Assert local reset                                                                                      1: De-assert local reset" range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="_RESV" width="5" begin="7" end="3" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="NEXT" width="3" begin="2" end="0" resetval="0" description="Module Next State                                                                                          000: SwRstDisable                                                                                        001: Disable                                                                                                   010: SyncReset                                                                                             011: Enable                                                                                                    100: Reserved/Invalid                                                                                    101: Sleep                                                                                                     110: Reserved/Invalid                                                                                    111: Reserved/Invalid" range="" rwaccess="RW">
         
      </bitfield>
   </register>
   <register id="MDCTL38" acronym="MDCTL38" offset="0xA98" width="32" description="Module Control 38 Register">
      <bitfield id="_RESV" width="17" begin="31" end="15" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="WKRSLPIE" width="1" begin="14" end="14" resetval="0" description="Wakeup Request to module in sleep Error Enable.                                        0: Wakeup request to module in sleep is not considered an error condition                                                                                                        1: Wakeup request to module in sleep is considered an error" range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="WKRSLP" width="1" begin="13" end="13" resetval="0" description="Wakeup Request to module in Sleep will cause this action.                         0: PSC transitions module from Sleep state to TWK state, once access completes (vbus_req = 0) put module back in Sleep state                           1: PSC transitions module to ENABLE state" range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="ACSLPIE" width="1" begin="12" end="12" resetval="0" description="Non-emulation Access to module in sleep Error enable                                0: Non-emulation access to module in sleep is not considered an error condition                                                                                                        1: Non-emulation access to module in sleep is considered an error" range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="ACSLP" width="1" begin="11" end="11" resetval="0" description="Non-emulation Access to module in Sleep will cause this action                              0: PSC transitions module from Sleep state to TWk state, once access completes put module back in Sleep state                                                    1: PSC transitions module to ENABLE state                                                                                            " range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="EMUIHBIE" width="1" begin="10" end="10" resetval="0" description="Emulation alters module state - Inhibits Module Inactive or Force Module Active                                                                                                            0: Not enabled                                                                                               1: Interrupt enabled" range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="EMURSTIE" width="1" begin="9" end="9" resetval="0" description="Emulation Alter Reset Interrupt Enable                                                          0: Not enabled                                                                                                1: Interrupt Enabled" range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="LRSTz" width="1" begin="8" end="8" resetval="0" description="Module local reset control (only applicable to some modules -- e.g GEM, BCG EMIF)                                                                                                     0: Assert local reset                                                                                      1: De-assert local reset" range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="_RESV" width="5" begin="7" end="3" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="NEXT" width="3" begin="2" end="0" resetval="0" description="Module Next State                                                                                          000: SwRstDisable                                                                                        001: Disable                                                                                                   010: SyncReset                                                                                             011: Enable                                                                                                    100: Reserved/Invalid                                                                                    101: Sleep                                                                                                     110: Reserved/Invalid                                                                                    111: Reserved/Invalid" range="" rwaccess="RW">
         
      </bitfield>
   </register>
   <register id="MDCTL39" acronym="MDCTL39" offset="0xA9C" width="32" description="Module Control 39 Register">
      <bitfield id="_RESV" width="17" begin="31" end="15" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="WKRSLPIE" width="1" begin="14" end="14" resetval="0" description="Wakeup Request to module in sleep Error Enable.                                        0: Wakeup request to module in sleep is not considered an error condition                                                                                                        1: Wakeup request to module in sleep is considered an error" range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="WKRSLP" width="1" begin="13" end="13" resetval="0" description="Wakeup Request to module in Sleep will cause this action.                         0: PSC transitions module from Sleep state to TWK state, once access completes (vbus_req = 0) put module back in Sleep state                           1: PSC transitions module to ENABLE state" range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="ACSLPIE" width="1" begin="12" end="12" resetval="0" description="Non-emulation Access to module in sleep Error enable                                0: Non-emulation access to module in sleep is not considered an error condition                                                                                                        1: Non-emulation access to module in sleep is considered an error" range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="ACSLP" width="1" begin="11" end="11" resetval="0" description="Non-emulation Access to module in Sleep will cause this action                              0: PSC transitions module from Sleep state to TWk state, once access completes put module back in Sleep state                                                    1: PSC transitions module to ENABLE state                                                                                            " range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="EMUIHBIE" width="1" begin="10" end="10" resetval="0" description="Emulation alters module state - Inhibits Module Inactive or Force Module Active                                                                                                            0: Not enabled                                                                                               1: Interrupt enabled" range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="EMURSTIE" width="1" begin="9" end="9" resetval="0" description="Emulation Alter Reset Interrupt Enable                                                          0: Not enabled                                                                                                1: Interrupt Enabled" range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="LRSTz" width="1" begin="8" end="8" resetval="0" description="Module local reset control (only applicable to some modules -- e.g GEM, BCG EMIF)                                                                                                     0: Assert local reset                                                                                      1: De-assert local reset" range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="_RESV" width="5" begin="7" end="3" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="NEXT" width="3" begin="2" end="0" resetval="0" description="Module Next State                                                                                          000: SwRstDisable                                                                                        001: Disable                                                                                                   010: SyncReset                                                                                             011: Enable                                                                                                    100: Reserved/Invalid                                                                                    101: Sleep                                                                                                     110: Reserved/Invalid                                                                                    111: Reserved/Invalid" range="" rwaccess="RW">
         
      </bitfield>
   </register>
   <register id="MDCTL40" acronym="MDCTL40" offset="0xAA0" width="32" description="Module Control 30 Register">
      <bitfield id="_RESV" width="17" begin="31" end="15" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="WKRSLPIE" width="1" begin="14" end="14" resetval="0" description="Wakeup Request to module in sleep Error Enable.                                        0: Wakeup request to module in sleep is not considered an error condition                                                                                                        1: Wakeup request to module in sleep is considered an error" range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="WKRSLP" width="1" begin="13" end="13" resetval="0" description="Wakeup Request to module in Sleep will cause this action.                         0: PSC transitions module from Sleep state to TWK state, once access completes (vbus_req = 0) put module back in Sleep state                           1: PSC transitions module to ENABLE state" range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="ACSLPIE" width="1" begin="12" end="12" resetval="0" description="Non-emulation Access to module in sleep Error enable                                0: Non-emulation access to module in sleep is not considered an error condition                                                                                                        1: Non-emulation access to module in sleep is considered an error" range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="ACSLP" width="1" begin="11" end="11" resetval="0" description="Non-emulation Access to module in Sleep will cause this action                              0: PSC transitions module from Sleep state to TWk state, once access completes put module back in Sleep state                                                    1: PSC transitions module to ENABLE state                                                                                            " range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="EMUIHBIE" width="1" begin="10" end="10" resetval="0" description="Emulation alters module state - Inhibits Module Inactive or Force Module Active                                                                                                            0: Not enabled                                                                                               1: Interrupt enabled" range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="EMURSTIE" width="1" begin="9" end="9" resetval="0" description="Emulation Alter Reset Interrupt Enable                                                          0: Not enabled                                                                                                1: Interrupt Enabled" range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="LRSTz" width="1" begin="8" end="8" resetval="0" description="Module local reset control (only applicable to some modules -- e.g GEM, BCG EMIF)                                                                                                     0: Assert local reset                                                                                      1: De-assert local reset" range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="_RESV" width="5" begin="7" end="3" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="NEXT" width="3" begin="2" end="0" resetval="0" description="Module Next State                                                                                          000: SwRstDisable                                                                                        001: Disable                                                                                                   010: SyncReset                                                                                             011: Enable                                                                                                    100: Reserved/Invalid                                                                                    101: Sleep                                                                                                     110: Reserved/Invalid                                                                                    111: Reserved/Invalid" range="" rwaccess="RW">
         
      </bitfield>
   </register>
   <register id="MPFAR" acronym="MPFAR" offset="0x1000" width="32" description="Memory Protection Fault Address Register">
      <bitfield id="FADDR" width="32" begin="31" end="0" resetval="0" description="Memory Protection Fault Address                                                                 Captures the faulting address when a memory protection vioaltion is detected. This register can only be cleared via MPFCR.MPFCLR" range="" rwaccess="R">
         
      </bitfield>
   </register>
   <register id="MPFSR" acronym="MPFSR" offset="0x1004" width="32" description="Memory Protection Fault Status Register">
      <bitfield id="_RESV" width="19" begin="31" end="13" resetval="0" description="Reserved" range="" rwaccess="W">
         
      </bitfield>
      <bitfield id="FID" width="4" begin="12" end="9" resetval="0" description="Faulted ID                                                                                                        FID contains valid info if any of the MP error bits (UXE, UWE, URE, SXE, SWE, SRE) are non-zero. The FID field contains the vbus PrivID for the specific request/requestor that resulted in a MP error.   " range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="_RESV" width="1" begin="8" end="8" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="SECE" width="1" begin="7" end="7" resetval="0" description="Secure Access Error                                                                                    Hard-wired to 0 to show no secure access error - because PSC does not check for security." range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="_RESV" width="1" begin="6" end="6" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="SRE" width="1" begin="5" end="5" resetval="0" description="Supervisor Read Error                                                                                  SRE = 0: No error detected                                                                            SRE = 1: Supervisor level task attempted to read from a MP page without SR permissions" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="SWE" width="1" begin="4" end="4" resetval="0" description="Supervisor Write Error                                                                                  SWE = 0: No error detected                                                                            SWE = 1: Supervisor level task attempted to write to a MP page without SW permissions" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="SXE" width="1" begin="3" end="3" resetval="0" description="Supervisor Execute Error. This bit is hard-wired to 0 to indicate no Supervisor Execute Error (because PSC does not check for VBUS data type vbus_dtype)                                                                             " range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="URE" width="1" begin="2" end="2" resetval="0" description="User Read Error                                                                                            URE = 0: No Error detected                                                                           URE = 1: User level task attempted to read from a MP page without UR permissions" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="UWE" width="1" begin="1" end="1" resetval="0" description="User Write Error                                                                                             UWE = 0: No error detected                                                                          UWE = 1: User level task attempted to write to a MP page without UW permissions" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="UXE" width="1" begin="0" end="0" resetval="0" description="User Execute Error. This bit is hard-wired to 0 to indicate no User Execute Error (because PSC does not check for VBUS data type vbus_dtype)" range="" rwaccess="R">
         
      </bitfield>
   </register>
   <register id="MPFCR" acronym="MPFCR" offset="0x1008" width="32" description="Memory Protection Fault Command Register">
      <bitfield id="_RESV" width="31" begin="31" end="1" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="MPFCLR" width="1" begin="0" end="0" resetval="0" description="Fault Clear                                                                                                     Write of 1 to this bit causes any error conditions stored in MPFAR and MPFSR registers to be cleared. Write of 0 has no effect" range="" rwaccess="W">
         
      </bitfield>
   </register>
   <register id="MPAA" acronym="MPAA" offset="0x100C" width="32" description="Memory Protection Page Attribute Register">
      <bitfield id="_RESV" width="16" begin="31" end="16" resetval="0" description="Reserved" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="AID5" width="1" begin="15" end="15" resetval="0" description="Allowed ID 5                                                                                                  AID5 = 0: VBUS requests with PrivID == 5 are not allowed to this MMR region regardless of permission settings (UW, UR, SW, SR)                       AID5 = 1: VBUS requests with PrivID == 5 are permitted if access type is allowed as defined by permission settings (UW, UR, SW, SR)" range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="AID4" width="1" begin="14" end="14" resetval="0" description="Allowed ID 4                                                                                                 AID4 = 0: VBUS requests with PrivID == 4 are not allowed to this MMR region regardless of permission settings (UW, UR, SW, SR)                       AID4 = 1: VBUS requests with PrivID == 4 are permitted if access type is allowed as defined by permission settings (UW, UR, SW, SR)" range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="AID3" width="1" begin="13" end="13" resetval="0" description="Allowed ID 3                                                                                                  AID3 = 0: VBUS requests with PrivID == 3 are not allowed to this MMR region regardless of permission settings (UW, UR, SW, SR)                       AID3 = 1: VBUS requests with PrivID == 3 are permitted if access type is allowed as defined by permission settings (UW, UR, SW, SR)" range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="AID2" width="1" begin="12" end="12" resetval="0" description="Allowed ID 2                                                                                                 AID2 = 0: VBUS requests with PrivID == 2 are not allowed to this MMR region regardless of permission settings (UW, UR, SW, SR)                       AID2 = 1: VBUS requests with PrivID == 2 are permitted if access type is allowed as defined by permission settings (UW, UR, SW, SR)" range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="AID1" width="1" begin="11" end="11" resetval="0" description="Allowed ID 1                                                                                                  AID1 = 0: VBUS requests with PrivID == 1 are not allowed to this MMR region regardless of permission settings (UW, UR, SW, SR)                       AID1 = 1: VBUS requests with PrivID == 1 are permitted if access type is allowed as defined by permission settings (UW, UR, SW, SR)" range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="AID0" width="1" begin="10" end="10" resetval="0" description="Allowed ID 0                                                                                                 AID0 = 0: VBUS requests with PrivID == 0 are not allowed to this MMR region regardless of permission settings (UW, UR, SW, SR)                       AID0 = 1: VBUS requests with PrivID == 0 are permitted if access type is allowed as defined by permission settings (UW, UR, SW, SR)" range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="EXT" width="1" begin="9" end="9" resetval="0" description="External Allowed ID                                                                                       EXT = 0: VBUS requests with PrivID &gt;= 6 are not allowed to this MMR region regardless of permission settings (UW, UR, SW, SR)                       EXT = 1: VBUS requests with PrivID &gt;= 6 are permitted if access type is allowed as defined by permission settings (UW, UR, SW, SR)" range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="LCL" width="1" begin="8" end="8" resetval="0" description="Local access permission (Not applicable)                                                    Local accesses are not applicable, therefore hard-code this value to 0" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="NS" width="1" begin="7" end="7" resetval="1" description="Secure Access Permission (not applicable)                                                 Hard-wired to 1 to show page is not secure. Secure and non-secure code can both access this MMR region." range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="EMU" width="1" begin="6" end="6" resetval="1" description="Emulation Security Permission (not applicable)                                             Hard-wired to 1 to indicate emulation read/write to this page is permitted." range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="SR" width="1" begin="5" end="5" resetval="0" description="Supervisor Read Permission                                                                         UR = 0: Supervisor reads are not allowed to this MMR region                     UR = 1: Supervisor reads allowed to this MMR region                                  " range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="SW" width="1" begin="4" end="4" resetval="0" description="Supervisor Write Permission                                                                         UW = 0: Supervisor writes are not allowed to this MMR region                     UW = 1: Supervisor writes allowed to this MMR region                                  " range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="SX" width="1" begin="3" end="3" resetval="0" description="Supervisor Execute Permission (not applicable)                                           This bit is hard-wired to 0 to indicate no Supervisor Execute Permission (because PSC does not check for VBUS data type vbus_dtype)" range="" rwaccess="R">
         
      </bitfield>
      <bitfield id="UR" width="1" begin="2" end="2" resetval="0" description="User Read Permission                                                                                   UR = 0: User reads not allowed to this MMR region                                      UR = 1: User reads allowed to this MMR region                                            " range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="UW" width="1" begin="1" end="1" resetval="0" description="User Write Permission                                                                                   UW = 0: User writesnot allowed to this MMR region                                      UW = 1: User writes allowed to this MMR region                                            " range="" rwaccess="RW">
         
      </bitfield>
      <bitfield id="UX" width="1" begin="0" end="0" resetval="0" description="User Execute Permission (not applicable)                                                     This bit is hard-wired to 0 to indicate no User Execute Permission (because PSC does not check for VBUS data type vbus_dtype)                                                    " range="" rwaccess="R">
         
      </bitfield>
   </register>
</module>
