<?xml version="1.0" encoding="utf-8"?>
<module id="I2C" HW_revision="" XML_version="1" description="I2C">
  <register id="ICOAR" acronym="ICOAR" offset="0x0000" width="32" description="The I2C own address register (ICOAR) is used to specify its own slave address, which distinguishes it from other slaves connected to the I2C-bus. If the 7-bit addressing mode is selected (XA = 0 in ICMDR),only bits 6-0 are used; bits 9-7 are ignored.">
    <bitfield id="Reserved" width="22" begin="31" end="10" resetval="0" description="These reserved bit locations are always read as zeros. A value written to this field has no effect." range="" rwaccess="N" />
    <bitfield id="OADDR" width="10" begin="9" end="0" resetval="0" description="Own slave address. Provides the slave address of the I2C. In 7-bit addressing mode (XA = 0 in ICMDR): bits 6-0 provide the 7-bit slave address of the I2C. Bits 9-7 are ignored. In 10-bit addressing mode (XA = 1 in ICMDR): bits 9-0 provide the 10-bit slave address of the I2C." range="" rwaccess="RW" />
  </register>
  <register id="ICIMR" acronym="ICIMR" offset="0x0004" width="32" description="The I2C interrupt mask register (ICIMR) is used to individually enable or disable I2C interrupt requests.">
    <bitfield id="Reserved" width="25" begin="31" end="7" resetval="0" description="These reserved bit locations are always read as zeros. A value written to this field has no effect." range="" rwaccess="N" />
    <bitfield id="AAS" width="1" begin="6" end="6" resetval="0" description="Address-As-Slave interrupt enable bit                                                                                           " range="" rwaccess="RW">
      <bitenum id="DISABLE" value="0" token="DISABLE" description="Interrupt request is disabled." />
      <bitenum id="ENABLE" value="1" token="ENABLE" description="Interrupt request is enabled.   " />
    </bitfield>
    <bitfield id="SCD" width="1" begin="5" end="5" resetval="0" description="Stop condition detected interrupt enable bit. " range="" rwaccess="RW">
      <bitenum id="DISABLE" value="0" token="DISABLE" description=" Interrupt request is disabled." />
      <bitenum id="ENABLE" value="1" token="ENABLE" description="Interrupt request is enabled." />
    </bitfield>
    <bitfield id="ICXRDY" width="1" begin="4" end="4" resetval="0" description="Transmit-data-ready interrupt enable bit. " range="" rwaccess="RW">
      <bitenum id="DISABLE" value="0" token="DISABLE" description=" Interrupt request is disabled." />
      <bitenum id="ENABLE" value="1" token="ENABLE" description=" Interrupt request is enabled" />
      <bitenum id="CLEAR" value="0" token="CLEAR" description="" />
    </bitfield>
    <bitfield id="ICRRDY" width="1" begin="3" end="3" resetval="0" description="Receive-data-ready interrupt enable bit. " range="" rwaccess="RW">
      <bitenum id="DISABLE" value="0" token="DISABLE" description="Interrupt request is disabled." />
      <bitenum id="ENABLE" value="1" token="ENABLE" description="Interrupt request is enabled." />
    </bitfield>
    <bitfield id="ARDY" width="1" begin="2" end="2" resetval="0" description="Register-access-ready interrupt enable bit. " range="" rwaccess="RW">
      <bitenum id="DISABLE" value="0" token="DISABLE" description=" Interrupt request is disabled." />
      <bitenum id="ENABLE" value="1" token="ENABLE" description=" Interrupt request is enabled." />
    </bitfield>
    <bitfield id="NACK" width="1" begin="1" end="1" resetval="0" description="No-acknowledgment interrupt enable bit. " range="" rwaccess="RW">
      <bitenum id="DISABLE" value="0" token="DISABLE" description=" Interrupt request is disabled." />
      <bitenum id="ENABLE" value="1" token="ENABLE" description=" Interrupt request is enabled." />
    </bitfield>
    <bitfield id="AL" width="1" begin="0" end="0" resetval="0" description="Arbitration-lost interrupt enable bit " range="" rwaccess="RW">
      <bitenum id="DISABLE" value="0" token="DISABLE" description=" Interrupt request is disabled." />
      <bitenum id="ENABLE" value="1" token="ENABLE" description=" Interrupt request is enabled." />
    </bitfield>
  </register>
  <register id="ICSTR" acronym="ICSTR" offset="0x0008" width="32" description="The I2C interrupt status register (ICSTR) is used to determine which interrupt has occurred and to read status information.">
    <bitfield id="Reserved" width="17" begin="31" end="15" resetval="0" description="These reserved bit locations are always read as zeros. A value written to this field has no effect." range="" rwaccess="N" />
    <bitfield id="SDIR" width="1" begin="14" end="14" resetval="0" description="Slave direction bit. In digital-loopback mode (DLB), the SDIR bit is cleared to 0. " range="" rwaccess="RW">
      <bitenum id="MASTER" value="0" token="MASTER" description=" I2C is acting as a master-transmitter/receiver or a slave-receiver. SDIR is cleared by one of the following events: A STOP or a START condition, or SDIR is manually cleared by writing a 1 to it." />
      <bitenum id="SLAVE" value="1" token="SLAVE" description="I2C is acting as a slave-transmitter." />
      <bitenum id="CLEAR" value="0" token="CLEAR" description="" />
    </bitfield>
    <bitfield id="NACKSNT" width="1" begin="13" end="13" resetval="0" description="No-acknowledgment sent bit. NACKSNT bit is used when the I2C is in the receiver mode. One instance in which NACKSNT is affected is when the NACK mode is used . " range="" rwaccess="RW">
      <bitenum id="NO_ACK" value="0" token="NO_ACK" description="NACK is not sent. NACKSNT is cleared by one of the following events: It is manually cleared by writing a 1 to it, or the I2C is reset (either when 0 is written to the IRS bit of ICMDR or when the processor is reset)." />
      <bitenum id="NACK" value="1" token="NACK" description="NACK is sent. A no-acknowledge bit was sent during the acknowledge cycle on the I2C-bus." />
      <bitenum id="CLEAR" value="0" token="CLEAR" description="" />
    </bitfield>
    <bitfield id="BB" width="1" begin="12" end="12" resetval="0" description="Bus busy bit. BB bit indicates whether the I2C-bus is busy or is free for another data transfer. In the master mode, BB is controlled by the software. " range="" rwaccess="RW">
      <bitenum id="FREE" value="0" token="FREE" description="Bus is free. BB is cleared by one of the following events: The I2C receives or transmits a STOP bit (bus free), BB is manually cleared by writing a 1 to it, or the I2C is reset (either when 0 is written to the IRS bit of ICMDR or when the processor is reset)." />
      <bitenum id="BUSY" value="1" token="BUSY" description=" Bus is busy. When the STT bit in ICMDR is set to 1, a restart condition is generated. BB is set by one of the following events: The I2C has received or transmitted a START bit on the bus, or SCL is in a low state and the IRS bit in ICMDR is 0" />
      <bitenum id="CLEAR" value="0" token="CLEAR" description="" />
    </bitfield>
    <bitfield id="RSFULL" width="1" begin="11" end="11" resetval="0" description="Receive shift register full bit. RSFULL indicates an overrun condition during reception. Overrun occurs when the receive shift register (ICRSR) is full with new data but the previous data has not been read from the data receive register (ICDRR). The new data will not be copied to ICDRR until the previous data is read. As new bits arrive from the SDA pin, they overwrite the bits in ICRSR. " range="" rwaccess="R">
      <bitenum id="No_OverRun" value="0" token="No_OverRun" description="No overrun is detected. RSFULL is cleared by one of the following events: ICDRR is read, or the I2C is reset (either when 0 is written to the IRS bit of ICMDR or when the processor is reset)." />
      <bitenum id="OverRun" value="1" token="OverRun" description="Overrun is detected." />
    </bitfield>
    <bitfield id="XSMT" width="1" begin="10" end="10" resetval="1" description="Transmit shift register empty bit. XSMT indicates that the transmitter has experienced underflow. Underflow occurs when the transmit shift register (ICXSR) is empty but the data transmit register (ICDXR) has not been loaded since the last ICDXR-to-ICXSR transfer. The next ICDXR-to-ICXSR transfer will not occur until new data is in ICDXR. If new data is not transferred in time, the previous data may be re-transmitted on the SDA pin. " range="" rwaccess="R">
      <bitenum id="UnderFlow" value="0" token="UnderFlow" description="Underflow is detected." />
      <bitenum id="No_Underflow" value="1" token="No_Underflow" description="No underflow is detected. XSMT is set by one of the following events: Data is written to ICDXR, or the I2C is reset (either when 0 is written to the IRS bit of ICMDR or when the processor is reset)." />
    </bitfield>
    <bitfield id="AAS" width="1" begin="9" end="9" resetval="0" description="Addressed-as-slave bit.  " range="" rwaccess="R">
      <bitenum id="CLEAR" value="0" token="CLEAR" description="The AAS bit has been cleared by a repeated START condition or by a STOP condition." />
      <bitenum id="SET" value="1" token="SET" description="AAS is set by one of the following events: I2C has recognized its own slave address or an address of all zeros (general call), or the first data word has been received in the free data format (FDF = 1 in ICMDR)." />
    </bitfield>
    <bitfield id="AD0" width="1" begin="8" end="8" resetval="0" description="Address 0 bit. " range="" rwaccess="R">
      <bitenum id="NO" value="0" token="NO" description="AD0 has been cleared by a START or STOP condition." />
      <bitenum id="YES" value="1" token="YES" description="An address of all zeros (general call) is detected." />
    </bitfield>
    <bitfield id="_RESV_9" width="2" begin="7" end="6" resetval="0" description="These reserved bit locations are always read as zeros. A value written to this field has no effect." range="" rwaccess="N" />
    <bitfield id="SCD" width="1" begin="5" end="5" resetval="0" description="Stop condition detected bit. SCD indicates when a STOP condition has been detected on the I2C bus. The STOP condition could be generated by the I2C or by another I2C device connected to the bus. " range="" rwaccess="RW">
      <bitenum id="NO" value="0" token="NO" description="No STOP condition has been detected. SCD is cleared by one of the following events: By reading the INTCODE bits in ICIVR as 110b, or SCD is manually cleared by writing a 1 to it." />
      <bitenum id="YES" value="1" token="YES" description="A STOP condition has been detected" />
      <bitenum id="CLEAR" value="0" token="CLEAR" description="" />
    </bitfield>
    <bitfield id="ICXRDY" width="1" begin="4" end="4" resetval="1" description="Transmit-data-ready interrupt flag bit. ICXRDY indicates that the data transmit register (ICDXR) is ready to accept new data because the previous data has been copied from ICDXR to the transmit shift register (ICXSR). The CPU can poll ICXRDY or use the XRDY interrupt request. " range="" rwaccess="RW">
      <bitenum id="FALSE" value="0" token="FALSE" description=" ICDXR is not ready. ICXRDY is cleared by one of the following events: Data is written to ICDXR, or ICXRDY is manually cleared by writing a 1 to it." />
      <bitenum id="TRUE" value="1" token="TRUE" description=" ICDXR is ready. Data has been copied from ICDXR to ICXSR. ICXRDY is forced to 1 when the I2C is reset." />
      <bitenum id="CLEAR" value="0" token="CLEAR" description="" />
    </bitfield>
    <bitfield id="ICRRDY" width="1" begin="3" end="3" resetval="0" description="Receive-data-ready interrupt flag bit. ICRRDY indicates that the data receive register (ICDRR) is ready to be read because data has been copied from the receive shift register (ICRSR) to ICDRR. The CPU can poll ICRRDY or use the RRDY interrupt request. " range="" rwaccess="RW">
      <bitenum id="FALSE" value="0" token="FALSE" description=" ICDRR is not ready. ICRRDY is cleared by one of the following events: ICDRR is read, ICRRDY is manually cleared by writing a 1 to it, or the I2C is reset (either when 0 is written to the IRS bit of ICMDR or when the processor is reset)." />
      <bitenum id="TRUE" value="1" token="TRUE" description=" ICDRR is ready. Data has been copied from ICRSR to ICDRR." />
      <bitenum id="CLEAR" value="0" token="CLEAR" description="" />
    </bitfield>
    <bitfield id="ARDY" width="1" begin="2" end="2" resetval="0" description="Register-access-ready interrupt flag bit (only applicable when the I2C is in the master mode). ARDY indicates that the I2C registers are ready to be accessed because the previously programmed address, data, and command values have been used. The CPU can poll ARDY or use the ARDY interrupt request. " range="" rwaccess="RW">
      <bitenum id="FALSE" value="0" token="FALSE" description="The registers are not ready to be accessed. ARDY is cleared by one of the following events:" />
      <bitenum id="TRUE" value="1" token="TRUE" description="The registers are ready to be accessed. This bit is set after the slave address appears on the I2C bus. In the nonrepeat mode (RM = 0 in ICMDR): If STP = 0 in ICMDR, ARDY is set when the internal data counter counts down to 0. If STP = 1, ARDY is not affected (instead, the I2C generates a STOP condition when the counter reaches 0). In the repeat mode (RM = 1): ARDY is set at the end of each data word transmitted from ICDXR." />
      <bitenum id="CLEAR" value="0" token="CLEAR" description="" />
    </bitfield>
    <bitfield id="NACK" width="1" begin="1" end="1" resetval="0" description="No-acknowledgment interrupt flag bit. NACK applies when the I2C is a transmitter (master or slave). NACK indicates whether the I2C has detected an acknowledge bit (ACK) or a no-acknowledge bit (NACK) from the receiver. The CPU can poll NACK or use the NACK interrupt request. " range="" rwaccess="RW">
      <bitenum id="FALSE" value="0" token="FALSE" description="ACK received/NACK is not received. NACK is cleared by one of the following events: An acknowledge bit (ACK) has been sent by the receiver, NACK is manually cleared by writing a 1 to it, the CPU reads the interrupt source register (ICISR) when the register contains the code for a NACK interrupt, or the I2C is reset (either when 0 is written to the IRS bit of ICMDR or when the processor is reset)." />
      <bitenum id="TRUE" value="1" token="TRUE" description="NACK bit is received. The hardware detects that a no-acknowledge (NACK) bit has been received. Note: While the I2C performs a general call transfer, NACK is 1, even if one or more slaves send acknowledgment." />
      <bitenum id="CLEAR" value="0" token="CLEAR" description="" />
    </bitfield>
    <bitfield id="AL" width="1" begin="0" end="0" resetval="0" description="Arbitration-lost interrupt flag bit (only applicable when the I2C is a master-transmitter). AL primarily indicates when the I2C has lost an arbitration contest with another master-transmitter. The CPU can poll AL or use the AL interrupt request. " range="" rwaccess="RW">
      <bitenum id="FALSE" value="0" token="FALSE" description="Arbitration is not lost. AL is cleared by one of the following events: AL is manually cleared by writing a 1 to it, the CPU reads the interrupt source register (ICISR) when the register contains the code for an AL interrupt, or the I2C is reset (either when 0 is written to the IRS bit of ICMDR or when the processor is reset)." />
      <bitenum id="TRUE" value="1" token="TRUE" description="Arbitration is lost. AL is set by one of the following events: The I2C senses that it has lost an arbitration with two or more competing transmitters that started a transmission almost simultaneously, the I2C attempts to start a transfer while the BB (bus busy) bit is set to 1, or when AL is set to 1, the MST and STP bits of ICMDR are cleared, and the I2C becomes a slave-receiver." />
      <bitenum id="CLEAR" value="0" token="CLEAR" description="" />
    </bitfield>
  </register>
  <register id="ICCLKL" acronym="ICCLKL" offset="0x000C" width="32" description="When the I2C is a master, the prescaled module clock is divided down for use as the I2C serial clock on the SCL pin. The shape of the I2C serial clock depends on two divide-down values, ICCL and ICCH.">
    <bitfield id="Reserved" width="16" begin="31" end="16" resetval="0" description="Reserved" range="" rwaccess="N" />
    <bitfield id="ICCL" width="16" begin="15" end="0" resetval="0" description="Clock low-time divide-down value of 1-65536. The period of the module clock is (ICCL + d) to produce the low-time duration of the I2C serial on the SCL pin." range="" rwaccess="RW" />
  </register>
  <register id="ICCLKH" acronym="ICCLKH" offset="0x0010" width="32" description="For each I2C serial clock cycle, ICCL determines the amount of time the signal is low. ICCLKL must be configured while the I2C is still in reset (IRS = 0 in ICMDR).">
    <bitfield id="Reserved" width="16" begin="31" end="16" resetval="0" description="These reserved bit locations are always read as zeros. A value written to this field has no effect." range="" rwaccess="N" />
    <bitfield id="ICCH" width="16" begin="15" end="0" resetval="0" description="Clock high-time divide-down value of 1-65536. The period of the module clock is multiplied by (ICCH + d) to produce the high-time duration of the I2C serial on the SCL pin." range="" rwaccess="RW" />
  </register>
  <register id="ICCNT" acronym="ICCNT" offset="0x0014" width="32" description="The I2C data count register (ICCNT) is used to indicate how many data words to transfer when the I2C is configured as a master-transmitter (MST = 1 and TRX = 1 in ICMDR) and the repeat mode is off (RM = 0 in ICMDR). In the repeat mode (RM = 1), ICCNT is not used.">
    <bitfield id="Reserved" width="16" begin="31" end="16" resetval="0" description="These reserved bit locations are always read as zeros. A value written to this field has no effect." range="" rwaccess="N" />
    <bitfield id="ICDC" width="16" begin="15" end="0" resetval="0" description="Data count value. When RM=0 in ICMDR, ICDC indicates the number of data words to transfer in the nonrepeat mode. When RM=1 in ICMDR, the value in ICCNT is a don't care. If STP=1 in ICMDR, a STOP condition is generated when the internal data counter counts down to 0. For value 0 the start value loaded to the internal data counter is 65536 .For value 1-1FFFh the start value loaded to internal data counter is 1-65535. " range="" rwaccess="RW" />
  </register>
  <register id="ICDRR" acronym="ICDRR" offset="0x0018" width="32" description="The I2C data receive register (ICDRR) is used to read the receive data. The ICDRR can receive a data value of up to 8 bits; data values with fewer than 8 bits are right-aligned in the D bits and the remaining D bits are undefined. The number of data bits is selected by the bit count bits (BC) of ICMDR. The I2C receive shift register (ICRSR) shifts in the received data from the SDA pin. Once data is complete, the I2C copies the contents of ICRSR into ICDRR. The CPU and the EDMA controller cannot access ICRSR.">
    <bitfield id="Reserved" width="24" begin="31" end="8" resetval="0" description="These reserved bit locations are always read as zeros. A value written to this field has no effect." range="" rwaccess="N" />
    <bitfield id="D" width="8" begin="7" end="0" resetval="0" description="Receive data." range="" rwaccess="R" />
  </register>
  <register id="ICSAR" acronym="ICSAR" offset="0x001C" width="32" description="The I2C slave address register (ICSAR) contains a 7-bit or 10-bit slave address. When the I2C is not using the free data format (FDF = 0 in ICMDR), it uses this address to initiate data transfers with a slave or slaves. When the address is nonzero, the address is for a particular slave. When the address is 0, the address is a general call to all slaves. If the 7-bit addressing mode is selected (XA = 0 in ICMDR), only bits 6-0 of ICSAR are used; bits 9-7 are ignored.">
    <bitfield id="Reserved" width="22" begin="31" end="10" resetval="0" description="These reserved bit locations are always read as zeros. A value written to this field has no effect." range="" rwaccess="N" />
    <bitfield id="SADDR" width="10" begin="9" end="0" resetval="1023" description="Slave address. Provides the slave address of the I2C. In 7-bit addressing mode (XA = 0 in ICMDR): bits 6-0 provide the 7-bit slave address that the I2C transmits when it is in the master-transmitter mode. Bits 9-7 are ignored. In 10-bit addressing mode (XA = 1 in ICMDR): Bits 9-0 provide the 10-bit slave address that the I2C transmits when it is in the master-transmitter mode." range="" rwaccess="RW" />
  </register>
  <register id="ICDXR" acronym="ICDXR" offset="0x0020" width="32" description="The CPU or EDMA writes transmit data to the I2C data transmit register (ICDXR). The ICDXR can accept a data value of up to 8 bits. When writing a data value with fewer than 8 bits, the written data must be right-aligned in the D bits. The number of data bits is selected by the bit count bits (BC) of ICMDR. Once data is written to ICDXR, the I2C copies the contents of ICDXR into the I2C transmit shift register (ICXSR). The ICXSR shifts out the transmit data from the SDA pin. The CPU and the EDMA controller cannot access ICXSR.">
    <bitfield id="Reserved" width="24" begin="31" end="8" resetval="0" description="These reserved bit locations are always read as zeros. A value written to this field has no effect." range="" rwaccess="N" />
    <bitfield id="D" width="8" begin="7" end="0" resetval="0" description="Transmit data." range="" rwaccess="RW" />
  </register>
  <register id="ICMDR" acronym="ICMDR" offset="0x0024" width="32" description="The I2C mode register (ICMDR) contains the control bits of the I2C.">
    <bitfield id="Reserved" width="16" begin="31" end="16" resetval="0" description="Reserved" range="" rwaccess="N" />
    <bitfield id="NACKMOD" width="1" begin="15" end="15" resetval="0" description="No-acknowledge (NACK) mode bit (only applicable when the I2C is a receiver). " range="" rwaccess="RW">
      <bitenum id="SLAVE_RX" value="0" token="SLAVE_RX" description="In slave-receiver mode: The I2C sends an acknowledge (ACK) bit to the transmitter during the each acknowledge cycle on the bus. The I2C only sends a no-acknowledge (NACK) bit if you set the NACKMOD bit. In master-receiver mode: The I2C sends an ACK bit during each acknowledge cycle until the internal data counter counts down to 0. When the counter reaches 0, the I2C sends a NACK bit to the transmitter. To have a NACK bit sent earlier, you must set the NACKMOD bit." />
      <bitenum id="MASTER_SLAVE_RX" value="1" token="MASTER_SLAVE_RX" description="In either slave-receiver or master-receiver mode: The I2C sends a NACK bit to the transmitter during the next acknowledge cycle on the bus. Once the NACK bit has been sent, NACKMOD is cleared. To send a NACK bit in the next acknowledge cycle, you must set NACKMOD before the rising edge of the last data bit." />
    </bitfield>
    <bitfield id="FREE" width="1" begin="14" end="14" resetval="0" description="This emulation mode bit is used to determine the state of the I2C when a breakpoint is encountered in the high-level language debugger. " range="" rwaccess="RW">
      <bitenum id="FALSE" value="0" token="FALSE" description="When I2C is master: If SCL is low when the breakpoint occurs, the I2C stops immediately and keeps driving SCL low, whether the I2C is the transmitter or the receiver. If SCL is high, the I2C waits until SCL becomes low and then stops. When I2C is slave: A breakpoint forces the I2C to stop when the current transmission/reception is complete." />
      <bitenum id="TRUE" value="1" token="TRUE" description="The I2C runs free; that is, it continues to operate when a breakpoint occurs." />
    </bitfield>
    <bitfield id="STT" width="1" begin="13" end="13" resetval="0" description="START condition bit (only applicable when the I2C is a master). The RM, STT, and STP bits determine when the I2C starts and stops data transmissions. Note that the STT and STP bits can be used to terminate the repeat mode. " range="" rwaccess="RW">
      <bitenum id="CLEAR" value="0" token="CLEAR" description="In master mode, STT is automatically cleared after the START condition has been generated. In slave mode, if STT is 0, the I2C does not monitor the bus for commands from a master. As a result, the I2C performs no data transfers." />
      <bitenum id="SET" value="1" token="SET" description="In master mode, setting STT to 1 causes the I2C to generate a START condition on the I2C-bus. In slave mode, if STT is 1, the I2C monitors the bus and transmits/receives data in response to commands from a master." />
    </bitfield>
    <bitfield id="_RESV_5" width="1" begin="12" end="12" resetval="0" description="These reserved bit locations are always read as zeros. A value written to this field has no effect." range="" rwaccess="N" />
    <bitfield id="STP" width="1" begin="11" end="11" resetval="0" description="STOP condition bit (only applicable when the I2C is a master). The RM, STT, and STP bits determine when the I2C starts and stops data transmissions . Note that the STT and STP bits can be used to terminate the repeat mode. " range="" rwaccess="RW">
      <bitenum id="CLEAR" value="0" token="CLEAR" description="STP is automatically cleared after the STOP condition has been generated." />
      <bitenum id="SET" value="1" token="SET" description="STP has been set to generate a STOP condition when the internal data counter of the I2C counts down to 0." />
    </bitfield>
    <bitfield id="MST" width="1" begin="10" end="10" resetval="0" description="Master mode bit. MST determines whether the I2C is in the slave mode or the master mode. MST is automatically changed from 1 to 0 when the I2C master generates a STOP condition.  " range="" rwaccess="RW">
      <bitenum id="SLAVE_MODE" value="0" token="SLAVE_MODE" description="Slave mode. The I2C is a slave and receives the serial clock from the master." />
      <bitenum id="MASTER_MODE" value="1" token="MASTER_MODE" description="Master mode. The I2C is a master and generates the serial clock on the SCL pin." />
    </bitfield>
    <bitfield id="TRX" width="1" begin="9" end="9" resetval="0" description="Transmitter. The operating modes are defined as follows. MST, TRX, Operating Modes (In order below)      0, x, slave receiver     0, x, slave transmitter     1, 0, master receiver     1, 1, master transmitter" range="" rwaccess="RW">
      <bitenum id="RX_MODE" value="0" token="RX_MODE" description=" The I 2 C is in the receiver mode and data on data line SDA is shifted into the data register ICDRR." />
      <bitenum id="TX_MODE" value="1" token="TX_MODE" description="The I 2 C is in the transmitter mode and the data in ICDXR is shifted out on data line SDA." />
    </bitfield>
    <bitfield id="XA" width="1" begin="8" end="8" resetval="0" description="Expanded address enable bit. " range="" rwaccess="RW">
      <bitenum id="7BIT" value="0" token="7BIT" description="7-bit Addressing Mode Enabled (normal address mode). The I2C transmits 7 -bit slave addresses (from bits 6-0 of ICSAR), and its own slave address has 7 bits (bits 6-0 of ICOAR)." />
      <bitenum id="10BIT" value="1" token="10BIT" description="10-bit addressing mode (expanded address mode). The I2C transmits 10-bit slave addresses (from bits 9-0 of ICSAR), and its own slave address has 10 bits (bits 9-0 of ICOAR)." />
    </bitfield>
    <bitfield id="RM" width="1" begin="7" end="7" resetval="0" description="Repeat Mode. This bit is set to 1 to put the I2C in repeat mode." range="" rwaccess="RW">
      <bitenum id="DISABLE" value="0" token="DISABLE" description="Nonrepeat mode. The value in the data count register (ICCNT) determines how many data words are received/transmitted by the I2C." />
      <bitenum id="ENABLE" value="1" token="ENABLE" description="Repeat mode. Data words are continuously received/transmitted by the I2C until the STP bit is manually set to 1, regardless of the value in ICCNT." />
    </bitfield>
    <bitfield id="DLB" width="1" begin="6" end="6" resetval="0" description="Digital loopback mode bit (only applicable when the I2C is a master-transmitter). This bit disables or enables the digital loopback mode of the I2C. Note that DLB mode in the free data format mode (DLB = 1 and FDF = 1) is not supported. " range="" rwaccess="RW">
      <bitenum id="DISABLE" value="0" token="DISABLE" description="Digital loopback mode is disabled." />
      <bitenum id="ENABLE" value="1" token="ENABLE" description="Digital loopback mode is enabled. In this mode, the MST bit must be set to 1 and data transmitted out of ICDXR is received in ICDRR after n clock cycles by an internal path, where: n = ((I2C input clock frequency/prescaled module clock frequency) x 8) The transmit clock is also the receive clock. The address transmitted on the SDA pin is the address in ICOAR." />
    </bitfield>
    <bitfield id="IRS" width="1" begin="5" end="5" resetval="0" description="I2C reset bit. Note that if IRS is reset during a transfer, it can cause the I2C bus to hang (SDA and SCL are in a high-impedance state). " range="" rwaccess="RW">
      <bitenum id="DISABLE" value="0" token="DISABLE" description="I2C is in reset/disabled.When this bit is cleared to 0, all status bits (in ICSTR) are set to their default values." />
      <bitenum id="ENABLE" value="1" token="ENABLE" description="I2C is in enabled" />
      <bitenum id="RESET" value="0" token="RESET" description="" />
    </bitfield>
    <bitfield id="STB" width="1" begin="4" end="4" resetval="0" description="START byte mode bit (only applicable when the I2C is a master). As described in version 2.1 of the Philips I2C-bus specification, the START byte can be used to help a slave that needs extra time to detect a START condition. When the I2C is a slave, the I2C ignores a START byte from a master, regardless of the value of the STB bit. " range="" rwaccess="RW">
      <bitenum id="DISABLE" value="0" token="DISABLE" description="The I2C is not in the START byte mode." />
      <bitenum id="ENABLE" value="1" token="ENABLE" description="The I2C is in the START byte mode. When you set the START condition bit (STT), the I2C begins the transfer with more than just a START condition. Specifically, it generates: 1. A START condition 2. A START byte (0000 0001b) 3. A dummy acknowledge clock pulse 4. A repeated START condition The I2C sends the slave address that is in ICSAR." />
    </bitfield>
    <bitfield id="FDF" width="1" begin="3" end="3" resetval="0" description="Free data format mode bit. Note that DLB mode in the free data format mode (DLB = 1 and FDF = 1) is not supported. " range="" rwaccess="RW">
      <bitenum id="DISABLE" value="0" token="DISABLE" description="Free data format mode is disabled.Transfers use the 7-/10-bit addressing format selected by the XA bit." />
      <bitenum id="ENABLE" value="1" token="ENABLE" description="Free data format mode is enabled." />
    </bitfield>
    <bitfield id="BC" width="3" begin="2" end="0" resetval="0" description="Bit count bits. BC defines the number of bits (1 to 8) in the next data word that is to be received or transmitted by the I2C. The number of bits selected with BC must match the data size of the other device. Note that when BC = 0, a data word has 8 bits.If the bit count is less than 8, receive data is right aligned in the D bits of ICDRR and the remaining D bits are undefined. Also, transmit data written to ICDXR must be right aligned.  " range="" rwaccess="RW">
      <bitenum id="8BIT" value="0" token="8BIT" description="8 bits per data word" />
      <bitenum id="1BIT" value="16" token="1BIT" description="1 bit per data word" />
      <bitenum id="2BIT" value="32" token="2BIT" description="2 bits per data word" />
      <bitenum id="3BIT" value="48" token="3BIT" description="3 bits per data word" />
      <bitenum id="4BIT" value="64" token="4BIT" description="4 bits per data word" />
      <bitenum id="5BIT" value="80" token="5BIT" description="5 bits per data word" />
      <bitenum id="6BIT" value="96" token="6BIT" description="6 bits per data word" />
      <bitenum id="7BIT" value="112" token="7BIT" description="7 bits per data word" />
    </bitfield>
  </register>
  <register id="ICIVR" acronym="ICIVR" offset="0x0028" width="32" description="The I2C interrupt vector register (ICIVR) is used by the CPU to determine which event generated the I2C interrupt. Reading ICIVR clears the interrupt flag; if other interrupts are pending, a new interrupt is generated. If there are more than one interrupt flag, reading ICIVR clears the highest priority interrupt flag. Note that you must read (clear) ICIVR before doing another start; otherwise, ICIVR could contain an incorrect (old interrupt flags) value.">
    <bitfield id="Reserved" width="29" begin="31" end="3" resetval="0" description="These reserved bit locations are always read as zeros. A value written to this field has no effect." range="" rwaccess="N" />
    <bitfield id="INTCODE" width="3" begin="2" end="0" resetval="0" description="Interrupt code. The binary-coded-interrupt vector indicates which interrupt has occurred. Reading the ICIVR clears the interrupt flag; if other interrupts are pending, a new interrupt is generated. If there are more than one interrupt flag, reading the ICIVR clears the highest priority interrupt flag. Note that users must read (clear) the IVR before doing another start otherwise the IVR could contain incorrect (old interrupt flags) value." range="" rwaccess="R">
      <bitenum id="NONE" value="11" token="NONE" description="No interrupt occurred" />
      <bitenum id="AL" value="27" token="AL" description="Arbitration Lost interrupt occurred (Highest Priority)" />
      <bitenum id="NACK" value="267" token="NACK" description="No Acknowledge interrupt occurred" />
      <bitenum id="ARDY" value="283" token="ARDY" description="Register Access Ready interrupt occurred" />
      <bitenum id="ICRRDY" value="4107" token="ICRRDY" description="Receive Data Ready interrupt occurred" />
      <bitenum id="ICXRDY" value="4123" token="ICXRDY" description="Transmit Data Ready interrupt occurred" />
      <bitenum id="SCD" value="4363" token="SCD" description="Stop Condition Detected interrupt occurred" />
      <bitenum id="AAS" value="4379" token="AAS" description="Address As Slave interrupt occurred (Lowest Priority)" />
    </bitfield>
  </register>
  <register id="ICEMDR" acronym="ICEMDR" offset="0x002C" width="32" description="The I2C extended mode register (ICEMDR) is used to indicate which condition generates a transmit data ready interrupt.">
    <bitfield id="Reserved" width="30" begin="31" end="2" resetval="0" description="These reserved bit locations are always read as zeros. A value written to this field has no effect." range="" rwaccess="N" />
    <bitfield id="IGNACK" width="1" begin="1" end="1" resetval="0" description="Ignore NACK mode. " range="" rwaccess="RW">
      <bitenum id="DISABLE" value="0" token="DISABLE" description="Master transmitter operates normally, that is, it discontinues the data transfer and sets the ARDY and NACK bits in ICSTR when receiving a NACK from the slave." />
      <bitenum id="ENABLE" value="1" token="ENABLE" description="Master transmitter ignores a NACK from the slave." />
    </bitfield>
    <bitfield id="BCM" width="1" begin="0" end="0" resetval="1" description="Backward compatibility mode bit. Determines which condition generates a transmit data ready interrupt. The BCM bit only has an effect when the I2C is operating as a slave-transmitter. " range="" rwaccess="RW" />
  </register>
  <register id="ICPSC" acronym="ICPSC" offset="0x0030" width="32" description="The I2C prescaler register (ICPSC) is used for dividing down the I2C input clock to obtain the desired prescaled module clock for the operation of the I2C. The IPSC bits must be initialized while the I2C is in reset (IRS = 0 in ICMDR). The prescaled frequency takes effect only when the IRS bit is changed to 1. Changing the IPSC value while IRS = 1 has no effect.">
    <bitfield id="Reserved" width="24" begin="31" end="8" resetval="0" description="These reserved bit locations are always read as zeros. A value written to this field has no effect." range="" rwaccess="N" />
    <bitfield id="IPSC" width="8" begin="7" end="0" resetval="0" description="I2C prescaler divide-down value. IPSC determines how much the I2C input clock is divided to create the I2C peripheral clock: I2C clock frequency = I2C input clock frequency/(IPSC+1) Note: IPSC must be initialized while the I2C is in reset (IRS=0 in ICMDR)." range="" rwaccess="RW" />
  </register>
  <register id="ICPID1" acronym="ICPID1" offset="0x0034" width="32" description="The I2C revision identification registers (ICREVID1) contain identification data for the peripheral.">
    <bitfield id="Reserved" width="16" begin="31" end="16" resetval="0" description="Reserved" range="" rwaccess="N" />
    <bitfield id="CLASS" width="8" begin="15" end="8" resetval="68" description="Identifies the class of peripheral." range="" rwaccess="R" />
    <bitfield id="REVISION" width="8" begin="7" end="0" resetval="21" description="Identifies the revision level of the I2C." range="" rwaccess="R" />
  </register>
  <register id="ICPID2" acronym="ICPID2" offset="0x0038" width="32" description="I2C Revision ID Register 2">
    <bitfield id="Reserved" width="24" begin="31" end="8" resetval="0" description="Reserved" range="" rwaccess="N" />
    <bitfield id="TYPE" width="8" begin="7" end="0" resetval="6" description="Identifies the type of peripheral. " range="" rwaccess="R" />
  </register>
  <register id="ICDMAC" acronym="ICDMAC" offset="0x003C" width="32" description="I2C DMA Control  Register ">
    <bitfield id="Reserved" width="30" begin="31" end="2" resetval="0" description="Reserved" range="" rwaccess="N" />
    <bitfield id="TXDMAEN" width="1" begin="1" end="1" resetval="1" description="Transmit DMA Enable. This bit controls the transmit DMA event pin to the system. When this bit is 1, the DMA event is enabled and the ICTEVT_POR pin is asserted when the DMA transfer is required. When this bit is 0, the ICTEVT_POR pin is never asserted." range="" rwaccess="R/W">
      <bitenum id="DISABLE" value="0" token="DISABLE" description="DMA transmit event is disabled" />
      <bitenum id="ENABLE" value="1" token="ENABLE" description="DMA transmit event is enabled" />
    </bitfield>
    <bitfield id="RXDMAEN" width="1" begin="0" end="0" resetval="1" description="Receive  DMA Enable .  This bit controls the receive  DMA event pin to the system. When this bit is 1, the DMA event is enabled and the ICREVT_POR pin is asserted when the DMA transfer is required. When this bit is 0, the ICREVT_POR pin is never asserted." range="" rwaccess="R/W">
      <bitenum id="DISABLE" value="0" token="DISABLE" description="DMA receive event is disabled" />
      <bitenum id="ENABLE" value="1" token="ENABLE" description="DMA receive event is enabled" />
    </bitfield>
  </register>
  <register id="ICPFUNC" acronym="ICPFUNC" offset="0x0048" width="32" description="The ICPFUNC register is used to configure the external I2C pins (SDA and SCL) as a I2C peripheral pin or a GPIO pin.">
    <bitfield id="Reserved" width="31" begin="31" end="1" resetval="0" description="Reserved" range="" rwaccess="N" />
    <bitfield id="PFUNC0" width="1" begin="0" end="0" resetval="0" description="Controls the function of the I2C SCL and SDA pins .                                                 " range="" rwaccess="R/W">
      <bitenum id="DISABLE" value="0" token="DISABLE" description="Pin Function as SCL and SDA" />
      <bitenum id="ENABLE" value="1" token="ENABLE" description="Pin function as GPIO" />
    </bitfield>
  </register>
  <register id="ICPDIR" acronym="ICPDIR" offset="0x004C" width="32" description="The ICPDIR register is used to independently configure each GPIO pin as either an input or an output.">
    <bitfield id="Reserved" width="30" begin="31" end="2" resetval="0" description="Reserved" range="" rwaccess="N" />
    <bitfield id="PDIR1" width="1" begin="1" end="1" resetval="0" description="Controls the direction of the I2C SDA  pin when configured as GPIO                                                                                                                            " range="" rwaccess="R/W">
      <bitenum id="DISABLE" value="0" token="DISABLE" description="SDA pin functions as input    " />
      <bitenum id="ENABLE" value="1" token="ENABLE" description="SDA pin functions as output                  " />
    </bitfield>
    <bitfield id="PDIR0" width="1" begin="0" end="0" resetval="0" description="Controls the direction of the I2C SCL  pin when configured as GPIO                                                                                                   " range="" rwaccess="R/W">
      <bitenum id="DISABLE" value="0" token="DISABLE" description="SCL pin functions as input    " />
      <bitenum id="ENABLE" value="1" token="ENABLE" description="SCL pin functions as output                  " />
    </bitfield>
  </register>
  <register id="ICPDIN" acronym="ICPDIN" offset="0x0050" width="32" description="The ICPDIN register holds the I/O pin state of each of the I2C pins (SDA and SCL)">
    <bitfield id="Reserved" width="30" begin="31" end="2" resetval="0" description="Reserved" range="" rwaccess="N" />
    <bitfield id="PDIN1" width="1" begin="1" end="1" resetval="0" description="Indicates the logic level present on the SDA pin .    Reads:                                                                                                                                             " range="" rwaccess="R">
      <bitenum id="LOW" value="0" token="LOW" description="                                logic low present at SDA pin, regardess of PFUNC setting.  " />
      <bitenum id="HIGH" value="1" token="HIGH" description=" logic high  present at SDA  pin, regardess of PFUNC setting.                     Writes:                                                                                                          Writes have no effect" />
    </bitfield>
    <bitfield id="PDIN0" width="1" begin="0" end="0" resetval="0" description="Indicates the logic level present on the SCL pin .                                                 " range="" rwaccess="R">
      <bitenum id="LOW" value="0" token="LOW" description=" logic low present at SCL pin, regardless of PFUNC setting.   " />
      <bitenum id="HIGH" value="1" token="HIGH" description=" logic high present at SCL pin, regardless of PFUNC setting.                         Writes:                                                                                                          Writes have no effect" />
    </bitfield>
  </register>
  <register id="ICPDOUT" acronym="ICPDOUT" offset="0x0054" width="32" description="The ICPDOUT register has one bit for each of the GPIO pins. ">
    <bitfield id="Reserved" width="30" begin="31" end="2" resetval="0" description="Reserved" range="" rwaccess="N" />
    <bitfield id="PDOUT1" width="1" begin="1" end="1" resetval="0" description="Controls the level driven on the SDA pin when configured as GPIO output                                          Reads:                                                                                                             Reads return register values, not GPIO pin levels.                                             Writes:                                                                                                        " range="" rwaccess="R/W">
      <bitenum id="LOW" value="0" token="LOW" description="SDA Pin driven low  " />
      <bitenum id="HIGH" value="1" token="HIGH" description="SDA pin driven high                                                                              " />
    </bitfield>
    <bitfield id="PDOUT0" width="1" begin="0" end="0" resetval="0" description="Controls the level driven on the SCL  pin when configured as GPIO output                                          Reads:                                                                                                             Reads return register values, not GPIO pin levels.                                             Writes:                                                                                                                                                                               " range="" rwaccess="R/W">
      <bitenum id="LOW" value="0" token="LOW" description="SCL  pin driven low   " />
      <bitenum id="HIGH" value="1" token="HIGH" description="SCL pin driven high    " />
    </bitfield>
  </register>
  <register id="ICPDSET" acronym="ICPDSET" offset="0x0058" width="32" description="The ICPDSET register is an alias of the ICPDOUT register.">
    <bitfield id="Reserved" width="30" begin="31" end="2" resetval="0" description="Reserved" range="" rwaccess="N" />
    <bitfield id="PDSET1" width="1" begin="1" end="1" resetval="0" description="Used to set PDOUT[1] bit which corresponds to the SDA GPIO pin                                         Reads:                                                                                                             Reads return indeterminate  values.                                                               Writes:                                                                                                                                                                                  " range="" rwaccess="R/W">
      <bitenum id="NO_EFFECT" value="0" token="NO_EFFECT" description="no effect     " />
      <bitenum id="HIGH" value="1" token="HIGH" description="PDOUT[1] bit is set to logic high  " />
    </bitfield>
    <bitfield id="PDSET0" width="1" begin="0" end="0" resetval="0" description="Used to set PDOUT[0] bit which corresponds to the SCL GPIO pin                                         Reads:                                                                                                             Reads return indeterminate  values.                                                               Writes:                                                                                                                                                                               " range="" rwaccess="R/W">
      <bitenum id="NO_EFFECT" value="0" token="NO_EFFECT" description=" no effect  " />
      <bitenum id="HIGH" value="1" token="HIGH" description="PDOUT[0] bit is set to logic high    " />
    </bitfield>
  </register>
  <register id="ICPDCLR" acronym="ICPDCLR" offset="0x005C" width="32" description="The ICPDCLR register is an alias of the ICPDOUT register. ">
    <bitfield id="Reserved" width="30" begin="31" end="2" resetval="0" description="Reserved" range="" rwaccess="N" />
    <bitfield id="PDCLR1" width="1" begin="1" end="1" resetval="0" description="Used to clear  PDOUT[1] bit which corresponds to the SDA GPIO pin                                         Reads:                                                                                                             Reads return indeterminate  values.                                                               Writes:                                                                                                                                                                                " range="" rwaccess="R/W">
      <bitenum id="NO_EFFECT" value="0" token="NO_EFFECT" description="no effect     " />
      <bitenum id="CLEAR" value="1" token="CLEAR" description="PDOUT[1] bit is cleared to logic low   " />
    </bitfield>
    <bitfield id="PDCLR0" width="1" begin="0" end="0" resetval="0" description="Used to clear PDOUT[0] bit which corresponds to the SCL GPIO pin                                         Reads:                                                                                                             Reads return indeterminate  values.                                                               Writes:                                                                                                                                                                                 " range="" rwaccess="R/W">
      <bitenum id="NO_EFFECT" value="0" token="NO_EFFECT" description=" no effect  " />
      <bitenum id="CLEAR" value="1" token="CLEAR" description="PDOUT[0] bit is cleared to logic low    " />
    </bitfield>
  </register>
</module>