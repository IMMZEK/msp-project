<?xml version="1.0" encoding="UTF-8"?>
<module id="SPI" HW_revision="" XML_version="1" description="Serial Peripheral Interface">
     <register id="SPIGCR0" acronym="SPIGCR0" offset="0x0000" width="32" description="SPI Global Control Register 0">
<bitfield id="_RESV_1" width="31" begin="31" end="1" resetval="0" description="Reserved" range="" rwaccess="N"></bitfield>
<bitfield id="RESET" width="1" begin="0" end="0" resetval="0" description="This bit needs to be set before any operation on SPI can be done 0: SPI is in reset state 1: SPI is out of reset state" range="" rwaccess="RW">
<bitenum id="IN_RESET" value="0" token="IN_RESET" description="" />
<bitenum id="OUT_OF_RESET" value="1" token="OUT_OF_RESET" description="" />
</bitfield>
</register>
     <register id="SPIGCR1" acronym="SPIGCR1" offset="0x0004" width="32" description="SPI Global Control Register 1">
<bitfield id="_RESV_1" width="7" begin="31" end="25" resetval="0" description="Reserved" range="" rwaccess="N"></bitfield>
<bitfield id="SPIEN" width="1" begin="24" end="24" resetval="0" description="SPI enable Holds the SPI in a reset state after a chip reset. The SPI is enabled only after a 1 is written to this bit. This bit must be setto 1 after all other SPI configuration bits have been written. This prevents an invalid operation of the SPI while the clock polarity is being changed. When this bit is 0, the SPI shift registers (SPIDAT0 and SPIDAT1) is held in reset mode and forced to 0x0000 The RXINTFLAG (SPIFLG.8) and RCVROVRN (SPIFLG.6) bits are also held in reset mode and forced to 0 when this bit is 0. SPICLK is disabled when this bit is 0 0: SPI is in reset 1: Activates SPI" range="" rwaccess="RW">
<bitenum id="DISABLED" value="0" token="DISABLED" description="" />
<bitenum id="ENABLED" value="1" token="ENABLED" description="" />
</bitfield>
<bitfield id="_RESV_3" width="7" begin="23" end="17" resetval="0" description="Reserved" range="" rwaccess="N"></bitfield>
<bitfield id="LOOPBACK" width="1" begin="16" end="16" resetval="0" description="Internal loop-back test mode The internal self-test option can be enabled by setting this bit. If the SPISIMO and SPISOMI pins are configured with SPI functionality, then the SPISIMOpin is internally connected to the SPISOMI pin. The transmit data is looped back as receive data and is stored in the receive field of the concerned buffer.Externally, during loop-back operation, the SPICLK pin outputs an inactive value and SPISOMI remains in high-impedance state. The SPI has to be initialized in master mode before the loop-back can be selected. If the SPI is initialized in slave mode or a data transfer is ongoing, errors may result" range="" rwaccess="RW">
<bitenum id="DISABLE" value="0" token="DISABLE" description="" />
<bitenum id="ENABLE" value="1" token="ENABLE" description="" />
</bitfield>
<bitfield id="_RESV_5" width="7" begin="15" end="9" resetval="0" description="Reserved" range="" rwaccess="N"></bitfield>
<bitfield id="POWERDOWN" width="1" begin="8" end="8" resetval="0" description="When active, the SPI state machines enter a powerdown state 0: SPI in active mode 1: SPI in powerdown mode" range="" rwaccess="RW">
<bitenum id="ACTIVE" value="0" token="ACTIVE" description="" />
<bitenum id="POWERDOWN" value="1" token="POWERDOWN" description="" />
</bitfield>
<bitfield id="_RESV_7" width="6" begin="7" end="2" resetval="0" description="Reserved" range="" rwaccess="N"></bitfield>
<bitfield id="CLKMOD" width="1" begin="1" end="1" resetval="0" description="Selects either an internal or external clock source. This bit also determines the I/O direction of the SPIENA and SPISCS[3:0] pins in functional mode 0: Clock is external 1: Clock is internal" range="" rwaccess="RW">
<bitenum id="EXTERNAL" value="0" token="EXTERNAL" description="" />
<bitenum id="INTERNAL" value="1" token="INTERNAL" description="" />
</bitfield>
<bitfield id="MASTER" width="1" begin="0" end="0" resetval="0" description="SPISIMO/SPISOMI pin direction determination Determines the direction of the SPISIMO and SPISOMI pins 0: SPISIMO pin an input, SPISOMI pin an output 1: SPISOMI pin an input, SPISIMO pin an output" range="" rwaccess="RW">
<bitenum id="SPISIMO_OUTPUT_SPISOMI_OUTPUT" value="0" token="SPISIMO_OUTPUT_SPISOMI_OUTPUT" description="" />
<bitenum id="SPISOMI_INPUT_SPISIMO_OUTPUT" value="1" token="SPISOMI_INPUT_SPISIMO_OUTPUT" description="" />
</bitfield>
</register>
     <register id="SPIINT0" acronym="SPIINT0" offset="0x0008" width="32" description="SPI Interrupt Register">
<bitfield id="_RESV_1" width="7" begin="31" end="25" resetval="0" description="Reserved" range="" rwaccess="N"></bitfield>
<bitfield id="ENABLEHIGHZ" width="1" begin="24" end="24" resetval="0" description="SPIENA pin high-z enable When active, the  pin (when it is configured as a WAIT functional output signal in a slave SPI) is forced to place it's output in high-z when not driving a low signal. If inactive, then the pin will output both a high and a low signal 0: SPIENA pin is a value 1: SPIENA pin is in high-z" range="" rwaccess="RW">
<bitenum id="SPIENA_VALUE" value="0" token="SPIENA_VALUE" description="" />
<bitenum id="SPIENA_HIZ" value="1" token="SPIENA_HIZ" description="" />
</bitfield>
<bitfield id="_RESV_3" width="7" begin="23" end="17" resetval="0" description="Reserved" range="" rwaccess="N"></bitfield>
<bitfield id="DMAREQEN" width="1" begin="16" end="16" resetval="0" description="DMA request enable Enables the DMA request signal to be generated for both receive and transmit channels 0: DMA is not used 1: DMA is used" range="" rwaccess="RW">
<bitenum id="DISABLED" value="0" token="DISABLED" description="" />
<bitenum id="ENABLED" value="1" token="ENABLED" description="" />
</bitfield>
<bitfield id="_RESV_5" width="7" begin="15" end="9" resetval="0" description="Reserved" range="" rwaccess="N"></bitfield>
<bitfield id="RXINTEN" width="1" begin="8" end="8" resetval="0" description="An interrupt is to be generated when the RXINTFLAG bit (SPICTRL3.0) is set by hardware. Otherwise, no interrupt will be generated 0: Interrupt will not be generated 1: Interrupt will be generated" range="" rwaccess="RW">
<bitenum id="DISABLED" value="0" token="DISABLED" description="" />
<bitenum id="ENABLED" value="1" token="ENABLED" description="" />
</bitfield>
<bitfield id="_RESV_7" width="1" begin="7" end="7" resetval="0" description="Reserved" range="" rwaccess="N"></bitfield>
<bitfield id="OVRNINTEN" width="1" begin="6" end="6" resetval="0" description="Overrun interrupt enable An interrupt is to be generated when the RCVR OVRN flag bit (SPIFLG.6) is set by hardware. Otherwise, no interrupt will be generated 0: Overrun interrupt will not be generated 1: Overrun interrupt will be generated" range="" rwaccess="RW">
<bitenum id="DISABLED" value="0" token="DISABLED" description="" />
<bitenum id="ENABLED" value="1" token="ENABLED" description="" />
</bitfield>
<bitfield id="_RESV_9" width="1" begin="5" end="5" resetval="0" description="Reserved" range="" rwaccess="N"></bitfield>
<bitfield id="BITERRENA" width="1" begin="4" end="4" resetval="0" description="Enables interrupt on bit error 0: No interrupt asserted upon bit error 1: Enables an interrupt on a bit error (BITERR = 1)" range="" rwaccess="RW">
<bitenum id="DISABLED" value="0" token="DISABLED" description="" />
<bitenum id="ENABLED" value="1" token="ENABLED" description="" />
</bitfield>
<bitfield id="DESYNCENA" width="1" begin="3" end="3" resetval="0" description="Enables interrupt on de-synchronized slave DESYNCENA is used in master mode only 0: No interrupt asserted upon de-synchronization error 1: Enables an interrupt on de-synchronization of the slave (DESYNC = 1)" range="" rwaccess="RW">
<bitenum id="DISABLED" value="0" token="DISABLED" description="" />
<bitenum id="ENABLED" value="1" token="ENABLED" description="" />
</bitfield>
<bitfield id="PARERRENA" width="1" begin="2" end="2" resetval="0" description="Enables interrupt on parity error 0: No interrupt asserted upon parity error 1: Enables an interrupt on a parity error (PARITYERR = 1)" range="" rwaccess="RW">
<bitenum id="DISABLED" value="0" token="DISABLED" description="" />
<bitenum id="ENABLED" value="1" token="ENABLED" description="" />
</bitfield>
<bitfield id="TIMEOUTENA" width="1" begin="1" end="1" resetval="0" description="Enables interrupt on ENA signal time-out 0: No interrupt asserted upon ENA signal time-out 1: Enables an interrupt on a time-out of the ENA signal (TIMEOUT = 1)" range="" rwaccess="RW">
<bitenum id="DISABLED" value="0" token="DISABLED" description="" />
<bitenum id="ENABLED" value="1" token="ENABLED" description="" />
</bitfield>
<bitfield id="_RESV_14" width="1" begin="0" end="0" resetval="0" description="Reserved" range="" rwaccess="N"></bitfield>
</register>
     <register id="SPILVL" acronym="SPILVL" offset="0x000C" width="32" description="SPI Level Register">
<bitfield id="_RESV_1" width="23" begin="31" end="9" resetval="0" description="Reserved" range="" rwaccess="N"></bitfield>
<bitfield id="RXINTLVL" width="1" begin="8" end="8" resetval="0" description="Receive interrupt level 0: Receive interrupt is mapped to interrupt line INT0 1: Receive interrupt is mapped to interrupt line INT1" range="" rwaccess="RW">
<bitenum id="RCV_INT0" value="0" token="RCV_INT0" description="" />
<bitenum id="RCV_INT1" value="1" token="RCV_INT1" description="" />
</bitfield>
<bitfield id="_RESV_3" width="1" begin="7" end="7" resetval="0" description="Reserved" range="" rwaccess="N"></bitfield>
<bitfield id="OVRNINTLVL" width="1" begin="6" end="6" resetval="0" description="Receive Overrun interrupt level 0: Receive Overrun interrupt is mapped to interrupt line INT0 1: Receive Overrun interrupt is mapped to interrupt line INT1" range="" rwaccess="RW">
<bitenum id="RCV_INT0" value="0" token="RCV_INT0" description="" />
<bitenum id="RCV_INT1" value="1" token="RCV_INT1" description="" />
</bitfield>
<bitfield id="_RESV_5" width="1" begin="5" end="5" resetval="0" description="Reserved" range="" rwaccess="N"></bitfield>
<bitfield id="BITERRLVL" width="1" begin="4" end="4" resetval="0" description="Bit error interrupt level 0: Bit error interrupt is mapped to interrupt line INT0 1: Bit error interrupt is mapped to interrupt line INT1" range="" rwaccess="RW">
<bitenum id="INT0" value="0" token="INT0" description="" />
<bitenum id="INT1" value="1" token="INT1" description="" />
</bitfield>
<bitfield id="DESYNCLVL" width="1" begin="3" end="3" resetval="0" description="De-synchronized slave interrupt level DESYNCLVL is used in master mode only 0: An interrupt due to de-synchronization of the slave (DESYNC = 1) is mapped to interrupt line INT0 1: An interrupt due to de-synchronization of the slave (DESYNC = 1) is mapped to interrupt line INT1" range="" rwaccess="RW">
<bitenum id="INT0" value="0" token="INT0" description="" />
<bitenum id="INT1" value="1" token="INT1" description="" />
</bitfield>
<bitfield id="PARERRLVL" width="1" begin="2" end="2" resetval="0" description="Parity error interrupt level 0: A parity error interrupt (PARITYERR = 1) is mapped to interrupt line INT0 1: A parity error interrupt (PARITYERR = 1) is mapped to interrupt line INT1" range="" rwaccess="RW">
<bitenum id="INT0" value="0" token="INT0" description="" />
<bitenum id="INT1" value="1" token="INT1" description="" />
</bitfield>
<bitfield id="TIMEOUTLVL" width="1" begin="1" end="1" resetval="0" description="ENA signal time-out interrupt level 0: An interrupt on a time-out of the ENA signal (TIMEOUT = 1) is mapped to interrupt line INT0 1: An interrupt on a time-out of the ENA signal (TIMEOUT = 1) is mapped to interrupt line INT1" range="" rwaccess="RW">
<bitenum id="INT0" value="0" token="INT0" description="" />
<bitenum id="INT1" value="1" token="INT1" description="" />
</bitfield>
<bitfield id="_RESV_10" width="1" begin="0" end="0" resetval="0" description="Reserved" range="" rwaccess="N"></bitfield>
</register>
     <register id="SPIFLG" acronym="SPIFLG" offset="0x0010" width="32" description="SPI Flag Register">
<bitfield id="_RESV_1" width="23" begin="31" end="9" resetval="0" description="Reserved" range="" rwaccess="N"></bitfield>
<bitfield id="RXINTFLAG" width="1" begin="8" end="8" resetval="0" description="Serves as the interrupt flag This flag is set when a word is received and copied into the buffer register (SPIBUF). If RXINTEN is enabled, an interrupt is also generated. During emulation mode, however, a read to the emulation register (SPIEMU) does not clear this flag bit. This bit is cleared in one of four ways a) Reading the SPIBUF register b)Writing a 1 to this bit c) Writing a 0 to SPIEN (SPIGCR1.24) d) System reset 0: Interrupt condition did not occur 1: Interrupt condition did occur" range="" rwaccess="RC">
<bitenum id="ENABLED" value="0" token="ENABLED" description="" />
<bitenum id="DISABLED" value="1" token="DISABLED" description="" />
</bitfield>
<bitfield id="_RESV_3" width="1" begin="7" end="7" resetval="0" description="Reserved" range="" rwaccess="N"></bitfield>
<bitfield id="RCVROVRN" width="1" begin="6" end="6" resetval="0" description="Receiver overrun flag This bit is a read/clear only flag. The SPI hardware sets this bit when an operation completes before the previous character has been read from the buffer. The bit indicates that the last received character has been overwritten and therefore lost. The SPI will generate an interrupt request if this bit is set and the OVRN INTEN bit (SPIINT0.6) is set high This bit is cleared in one of four ways: a) Reading the SPIBUF register b) Writing a 1 to this bit c) Writing a 0 to SPIEN (SPIGCR1.24) d) System reset 0: Overrun condition did not occur 1: Overrun condition has occurred" range="" rwaccess="RC">
<bitenum id="ENABLED" value="0" token="ENABLED" description="" />
<bitenum id="DISABLED" value="1" token="DISABLED" description="" />
</bitfield>
<bitfield id="_RESV_5" width="1" begin="5" end="5" resetval="0" description="Reserved" range="" rwaccess="N"></bitfield>
<bitfield id="BITERR" width="1" begin="4" end="4" resetval="0" description="Mismatch of internal transmit data and transmitted data This flag is read/clear only flag, i.e. reading the flag will automatically clear it 0: No bit error occurred 1: A bit error occurred. The SPI samples the signal of the transmit pin (master: SIMO, slave: SOMI) at the receive point (half clock cycle after transmit point). If the sampled value differs from the transmitted value a bit error is detected and the Flag BITERR is set. If BIT-ERRENA is set an interrupt is asserted. A possible reason for a bit error can be a to high bit rate / capacitive load or another master/slave trying to transmit at the same time" range="" rwaccess="RC">
<bitenum id="NO_ERROR" value="0" token="NO_ERROR" description="" />
<bitenum id="ERROR" value="1" token="ERROR" description="" />
</bitfield>
<bitfield id="DESYNC" width="1" begin="3" end="3" resetval="0" description="De-synchronization of slave device This flag is read/clear only flag, i.e. reading the flag will automatically clear it De-synchronization monitor is active in master mode only 0: No slave de-synchronization detected 1: A slave device is de-synchronized. The master monitors the ENABLE signal coming from the slave device and sets the DESYNC flag if ENA is deactivated before the last reception point or after the last bit is transmitted plus tT2EDELAY. If DESYNCENA is set an interrupt is asserted. De-synchronization can occur if a slave device misses a clock edge coming from the master or is detecting an additional clock edge due to perturbation" range="" rwaccess="RC">
<bitenum id="ENABLED" value="0" token="ENABLED" description="" />
<bitenum id="DISABLED" value="1" token="DISABLED" description="" />
</bitfield>
<bitfield id="PARITYERR" width="1" begin="2" end="2" resetval="0" description="Calculated parity differs from received parity bit This flag is read/clear only flag, i.e. reading the flag will automatically clear it 0: No parity error detected 1: A parity error occurred. If the parity generator is enabled (can be selected individually for each buffer) an even or odd parity bit is added at the end of a data word. During reception of the data word the parity generator calculates the reference parity and compares it to the received parity bit. In the event of a mismatch the PARITYERR flag is set and an interrupt is asserted if PARERRENA is set" range="" rwaccess="RC">
<bitenum id="NO_ERROR" value="0" token="NO_ERROR" description="" />
<bitenum id="ERROR" value="1" token="ERROR" description="" />
</bitfield>
<bitfield id="TIMEOUT" width="1" begin="1" end="1" resetval="0" description="Time-out due to non-activation of ENA signal This flag is read/clear only flag, i.e. reading the flag will automatically clear it 0: No ENA-signal time-out occurred 1: An ENA signal time-out occurred. The SPI generates a time-out because the slave hasn't responded in time by activating the ENA signal after the chip select signal has been activated. If a time-out condition is detected the corresponding chip select is deactivated immediately and the TIMEOUT flag is set. In addition the TIMOUT flag in the status field of the corresponding buffer is set. The transmit request of the concerned buffer is cleared, i.e. the SPIdoesn't restart a data transfer from this buffer" range="" rwaccess="RC">
<bitenum id="DISABLED" value="0" token="DISABLED" description="" />
<bitenum id="ENABLED" value="1" token="ENABLED" description="" />
</bitfield>
<bitfield id="_RESV_10" width="1" begin="0" end="0" resetval="0" description="Reserved" range="" rwaccess="N"></bitfield>
</register>
     <register id="SPIPC0" acronym="SPIPC0" offset="0x0014" width="32" description="SPI Pin Control Register 0">
<bitfield id="_RESV_1" width="20" begin="31" end="12" resetval="0" description="Reserved" range="" rwaccess="N"></bitfield>
<bitfield id="SOMIFUN" width="1" begin="11" end="11" resetval="0" description="Slave out, master in function Determines whether the SPISOMI pin is to be used as a general-purpose I/O pin or as a SPI functional pin. 0: SPISOMI pin is a GPIO 1: SPISOMI pin is a SPI functional pin" range="" rwaccess="RW">
<bitenum id="GPIO" value="0" token="GPIO" description="" />
<bitenum id="SPI" value="0" token="SPI" description="" />
</bitfield>
<bitfield id="SIMOFUN" width="1" begin="10" end="10" resetval="0" description="Slave in, master out function Determines whether the SPISIMO pin is to be used as a general-purpose I/O pin, or as a SPI functional pin. 0: SPISIMO pin is a GPIO 1: SPISIMO pin is a SPI functional pin" range="" rwaccess="RW">
<bitenum id="GPIO" value="0" token="GPIO" description="" />
<bitenum id="SPI" value="0" token="SPI" description="" />
</bitfield>
<bitfield id="CLKFUN" width="1" begin="9" end="9" resetval="0" description="SPI clock function Determines whether the SPICLK pin is to be used as a general-purpose I/O pin, or as a SPI functional pin. 0: SPICLK pin is a GPIO 1: SPICLK pin is a SPI functional pin" range="" rwaccess="RW">
<bitenum id="GPIO" value="0" token="GPIO" description="" />
<bitenum id="SPI" value="0" token="SPI" description="" />
</bitfield>
<bitfield id="ENAFUN" width="1" begin="8" end="8" resetval="0" description="SPIENA function Determines whether the SPIENA pin is to be used as a general-purpose I/O pin, or as a SPI functional pin 0: SPIENA pin is a GPIO 1: SPIENA pin is a SPI functional pin" range="" rwaccess="RW">
<bitenum id="GPIO" value="0" token="GPIO" description="" />
<bitenum id="SPI" value="0" token="SPI" description="" />
</bitfield>
<bitfield id="SCSFUN7" width="1" begin="7" end="7" resetval="0" description="SPISCS7 function Determines whether the SPISCS7 pin are to be used as a general-purpose I/O pin or as SPI functional pin. If the slave SPISCS7 pin are in functional mode and receive an inactive high signal, the slave SPI will place it's output in high-z and disable shifting 0: SPISCS7 pin is a GPIO 1: SPISCS7 pin is a SPI functional pin" range="" rwaccess="RW">
<bitenum id="GPIO" value="0" token="GPIO" description="" />
<bitenum id="SPI" value="0" token="SPI" description="" />
</bitfield>
<bitfield id="SCSFUN6" width="1" begin="6" end="6" resetval="0" description="SPISCS6 function Determines whether the SPISCS6 pin are to be used as a general-purpose I/O pin or as SPI functional pin. If the slave SPISCS6 pin are in functional mode and receive an inactive high signal, the slave SPI will place it's output in high-z and disable shifting 0: SPISCS6 pin is a GPIO 1: SPISCS6 pin is a SPI functional pin" range="" rwaccess="RW">
<bitenum id="GPIO" value="0" token="GPIO" description="" />
<bitenum id="SPI" value="0" token="SPI" description="" />
</bitfield>
<bitfield id="SCSFUN5" width="1" begin="5" end="5" resetval="0" description="SPISCS5 function Determines whether the SPISCS5 pin are to be used as a general-purpose I/O pin or as SPI functional pin. If the slave SPISCS5 pin are in functional mode and receive an inactive high signal, the slave SPI will place it's output in high-z and disable shifting 0: SPISCS5 pin is a GPIO 1: SPISCS5 pin is a SPI functional pin" range="" rwaccess="RW">
<bitenum id="GPIO" value="0" token="GPIO" description="" />
<bitenum id="SPI" value="0" token="SPI" description="" />
</bitfield>
<bitfield id="SCSFUN4" width="1" begin="4" end="4" resetval="0" description="SPISCS4 function Determines whether the SPISCS4 pin are to be used as a general-purpose I/O pin or as SPI functional pin. If the slave SPISCS4 pin are in functional mode and receive an inactive high signal, the slave SPI will place it's output in high-z and disable shifting 0: SPISCS4 pin is a GPIO 1: SPISCS4 pin is a SPI functional pin" range="" rwaccess="RW">
<bitenum id="GPIO" value="0" token="GPIO" description="" />
<bitenum id="SPI" value="0" token="SPI" description="" />
</bitfield>
<bitfield id="SCSFUN3" width="1" begin="3" end="3" resetval="0" description="SPISCS3 function Determines whether the SPISCS3 pin are to be used as a general-purpose I/O pin or as SPI functional pin. If the slave SPISCS3 pin are in functional mode and receive an inactive high signal, the slave SPI will place it's output in high-z and disable shifting 0: SPISCS3 pin is a GPIO 1: SPISCS3 pin is a SPI functional pin" range="" rwaccess="RW">
<bitenum id="GPIO" value="0" token="GPIO" description="" />
<bitenum id="SPI" value="0" token="SPI" description="" />
</bitfield>
<bitfield id="SCSFUN2" width="1" begin="2" end="2" resetval="0" description="SPISCS7 function Determines whether the SPISCS2 pin are to be used as a general-purpose I/O pin or as SPI functional pin. If the slave SPISCS2 pin are in functional mode and receive an inactive high signal, the slave SPI will place it's output in high-z and disable shifting 0: SPISCS2 pin is a GPIO 1: SPISCS2 pin is a SPI functional pin" range="" rwaccess="RW">
<bitenum id="GPIO" value="0" token="GPIO" description="" />
<bitenum id="SPI" value="0" token="SPI" description="" />
</bitfield>
<bitfield id="SCSFUN1" width="1" begin="1" end="1" resetval="0" description="SPISCS1 function Determines whether the SPISCS1 pin are to be used as a general-purpose I/O pin or as SPI functional pin. If the slave SPISCS1 pin are in functional mode and receive an inactive high signal, the slave SPI will place it's output in high-z and disable shifting 0: SPISCS1 pin is a GPIO 1: SPISCS1 pin is a SPI functional pin" range="" rwaccess="RW">
<bitenum id="GPIO" value="0" token="GPIO" description="" />
<bitenum id="SPI" value="0" token="SPI" description="" />
</bitfield>
<bitfield id="SCSFUN0" width="1" begin="0" end="0" resetval="0" description="SPISCS0 function Determines whether the SPISCS0 pin are to be used as a general-purpose I/O pin or as SPI functional pin. If the slave SPISCS0 pin are in functional mode and receive an inactive high signal, the slave SPI will place it's output in high-z and disable shifting 0: SPISCS0 pin is a GPIO 1: SPISCS0 pin is a SPI functional pin" range="" rwaccess="RW">
<bitenum id="GPIO" value="0" token="GPIO" description="" />
<bitenum id="SPI" value="0" token="SPI" description="" />
</bitfield>
</register>
     <register id="SPIPC2" acronym="SPIPC2" offset="0x001C" width="32" description="SPI Pin Control Register 2">
<bitfield id="_RESV_1" width="20" begin="31" end="12" resetval="0" description="Reserved" range="" rwaccess="N"></bitfield>
<bitfield id="SOMIDIN" width="1" begin="11" end="11" resetval="0" description="SPISOMI data in Reflects the value of the SPISOMI pin 0: Current value on SPISOMI pin is logic 0 1: Current value on SPISOMI pin is logic 1" range="" rwaccess="R">
<bitenum id="LOW" value="0" token="LOW" description="" />
<bitenum id="HIGH" value="1" token="HIGH" description="" />
</bitfield>
<bitfield id="SIMODIN" width="1" begin="10" end="10" resetval="0" description="SPISIMO data in Reflects the value of the SPISIMO pin 0: Current value on SPISIMO pin is logic 0 1: Current value on SPISIMO pin is logic 1" range="" rwaccess="R">
<bitenum id="LOW" value="0" token="LOW" description="" />
<bitenum id="HIGH" value="1" token="HIGH" description="" />
</bitfield>
<bitfield id="CLKDIN" width="1" begin="9" end="9" resetval="0" description="Clock data in Reflects the value of the SPICLK pin 0: Current value on SPICLK pin is logic 0 1: Current value on SPICLK pin is logic 1" range="" rwaccess="R">
<bitenum id="LOW" value="0" token="LOW" description="" />
<bitenum id="HIGH" value="1" token="HIGH" description="" />
</bitfield>
<bitfield id="ENADIN" width="1" begin="8" end="8" resetval="0" description="SPIENA data in Reflects the value of the SPIENA pin 0: Current value on SPIENA pin is logic 0 1: Current value on SPIENA pin is logic 1" range="" rwaccess="R">
<bitenum id="LOW" value="0" token="LOW" description="" />
<bitenum id="HIGH" value="1" token="HIGH" description="" />
</bitfield>
<bitfield id="SCSDIN7" width="1" begin="7" end="7" resetval="0" description="SPISCS7 data in Reflects the value of the SPISCS7 pins 0: Current value on SPISCS7 pin is logic 0 1: Current value on SPISCS7 pin is logic 1" range="" rwaccess="R">
<bitenum id="LOW" value="0" token="LOW" description="" />
<bitenum id="HIGH" value="1" token="HIGH" description="" />
</bitfield>
<bitfield id="SCSDIN6" width="1" begin="6" end="6" resetval="0" description="SPISCS6 data in Reflects the value of the SPISCS6 pins 0: Current value on SPISCS6 pin is logic 0 1: Current value on SPISCS6 pin is logic 1" range="" rwaccess="R">
<bitenum id="LOW" value="0" token="LOW" description="" />
<bitenum id="HIGH" value="1" token="HIGH" description="" />
</bitfield>
<bitfield id="SCSDIN5" width="1" begin="5" end="5" resetval="0" description="SPISCS5 data in Reflects the value of the SPISCS5 pins 0: Current value on SPISCS5 pin is logic 0 1: Current value on SPISCS5 pin is logic 1" range="" rwaccess="R">
<bitenum id="LOW" value="0" token="LOW" description="" />
<bitenum id="HIGH" value="1" token="HIGH" description="" />
</bitfield>
<bitfield id="SCSDIN4" width="1" begin="4" end="4" resetval="0" description="SPISCS4 data in Reflects the value of the SPISCS4 pins 0: Current value on SPISCS4 pin is logic 0 1: Current value on SPISCS4 pin is logic 1" range="" rwaccess="R">
<bitenum id="LOW" value="0" token="LOW" description="" />
<bitenum id="HIGH" value="1" token="HIGH" description="" />
</bitfield>
<bitfield id="SCSDIN3" width="1" begin="3" end="3" resetval="0" description="SPISCS3 data in Reflects the value of the SPISCS3 pins 0: Current value on SPISCS3 pin is logic 0 1: Current value on SPISCS3 pin is logic 1" range="" rwaccess="R">
<bitenum id="LOW" value="0" token="LOW" description="" />
<bitenum id="HIGH" value="1" token="HIGH" description="" />
</bitfield>
<bitfield id="SCSDIN2" width="1" begin="2" end="2" resetval="0" description="SPISCS2 data in Reflects the value of the SPISCS2 pins 0: Current value on SPISCS2 pin is logic 0 1: Current value on SPISCS2 pin is logic 1" range="" rwaccess="R">
<bitenum id="LOW" value="0" token="LOW" description="" />
<bitenum id="HIGH" value="1" token="HIGH" description="" />
</bitfield>
<bitfield id="SCSDIN1" width="1" begin="1" end="1" resetval="0" description="SPISCS1data in Reflects the value of the SPISCS1 pins. 0: Current value on SPISCS1 pin is logic 0 1: Current value on SPISCS2 pin is logic 1" range="" rwaccess="R">
<bitenum id="LOW" value="0" token="LOW" description="" />
<bitenum id="HIGH" value="1" token="HIGH" description="" />
</bitfield>
<bitfield id="SCSDIN0" width="1" begin="0" end="0" resetval="0" description="SPISCS0data in Reflects the value of the SPISCS0  pins 0: Current value on SPISCS0 pin is logic 0 1: Current value on SPISCS0 pin is logic 1" range="" rwaccess="R">
<bitenum id="LOW" value="0" token="LOW" description="" />
<bitenum id="HIGH" value="1" token="HIGH" description="" />
</bitfield>
</register>
     <register id="SPIDAT1" acronym="SPIDAT1" offset="0x003C" width="32" description="SPI Shift Register 1">
<bitfield id="_RESV_1" width="3" begin="31" end="29" resetval="0" description="Reserved" range="" rwaccess="N"></bitfield>
<bitfield id="CSHOLD" width="1" begin="28" end="28" resetval="0" description="Chip select hold mode CSHOLD is considered in master mode only. In slave mode this bit has no meaning. CSHOLD defines the behavior of the chip select line at the end of a data transfer 0: The chip select signal is deactivated at the end of a transfer after the T2CDELAY time has passed. If two consecutive transfers are dedicated to the same chip select this chip select signal will be shortly deactivated before it is activated again 1: The chip select signal is held active at the end of a transfer until a control field with new data and control information is loaded into SPIDAT1. If the new chip select information equals the previous one the active chip select signal is extended until the end of transfer with CSHOLD cleared or until the chip select information changes " range="" rwaccess="RW">
<bitenum id="DISABLED" value="0" token="DISABLED" description="" />
<bitenum id="ENABLED" value="1" token="ENABLED" description="" />
</bitfield>
<bitfield id="_RESV_3" width="1" begin="27" end="27" resetval="0" description="Reserved" range="" rwaccess="N"></bitfield>
<bitfield id="WDEL" width="1" begin="26" end="26" resetval="0" description="Enable the delay counter at the end of the current transaction 0: No delay is inserted 1: After the transaction WDELAY of the corresponding data format is loaded into the delay counter. No transaction is performed until the counter is reset" range="" rwaccess="RW">
<bitenum id="NODELAY" value="0" token="NODELAY" description="" />
<bitenum id="DEYAL" value="1" token="DEYAL" description="" />
</bitfield>
<bitfield id="DFSEL" width="2" begin="25" end="24" resetval="0" description="Data word format select  -------------------------------------------------------------------------------- DFSEL1    DFSEL0      Description ---------------------------------------------------------------------------------   0               0               Data word format 0 is selected   0               1               Data word format 1 is selected   1               0               Data word format 2 is selected   1               1               Data word format 3 is selected" range="" rwaccess="RW">
<bitenum id="FORMAT0" value="0" token="FORMAT0" description="" />
<bitenum id="FORMAT1" value="1" token="FORMAT1" description="" />
<bitenum id="FORMAT2" value="16" token="FORMAT2" description="" />
<bitenum id="FORMAT3" value="17" token="FORMAT3" description="" />
</bitfield>
<bitfield id="CSNR" width="8" begin="23" end="16" resetval="0" description="Chip select number CSNR defines the chip select that shall be activated during the data transfer" range="" rwaccess="RW"></bitfield>
<bitfield id="SPIDAT1" width="16" begin="15" end="0" resetval="0" description="SPI shift data 1 These bits make up the SPI shift register 1. Data is shifted out of the MSB (bit 15) and into the LSB (bit 0) SPIEN must be set to 1 before this register can be written to. Writing a 0 to the SPIEN register forces the lower 16 bits of the SPIDAT1 register to 0x00 Write to this register ONLY when using the automatic Slave Chip Select feature. A write to this register will drive the SPISCS signal low When data is read from this register, the value is indeterminate because of the shift operation. The value in the buffer register (SPIBUF) should be read after the shift operation is complete to determine what data was shifted into the SPIDAT1 register" range="" rwaccess="RW"></bitfield>
</register>
     <register id="SPIBUF" acronym="SPIBUF" offset="0x0040" width="32" description="SPI Buffer Register">
<bitfield id="RXEMPTY" width="1" begin="31" end="31" resetval="1" description="Receive data buffer empty This flag is a read-only flag. When host reads the SPIBUF field or the whole SPIBUF register this will automatically set the RXEMPTY flag. When a data transfer has been finished and the received data is copied into SPIBUF the RXEMPTY flag is cleared 0: Data is received and copied into SPIBUF field 1: No data received since last reading of SPIBUF register" range="" rwaccess="R">
<bitenum id="YES" value="0" token="YES" description="" />
<bitenum id="NO" value="1" token="NO" description="" />
</bitfield>
<bitfield id="RXOVR" width="1" begin="30" end="30" resetval="0" description="Receive data buffer overrun This flag is read/clear only flag, i.e. reading the flag will automatically clear it. When a data transfer has been finished and the received data is copied into the SPIBUF while RXEMPTY flag is already cleared RXOVR is set 0: No receive data overrun condition occurred since last time reading the status field 1: A receive data overrun condition occurred since last time reading the status field" range="" rwaccess="RC">
<bitenum id="NO" value="0" token="NO" description="" />
<bitenum id="YES" value="1" token="YES" description="" />
</bitfield>
<bitfield id="TXFULL" width="1" begin="29" end="29" resetval="0" description="Transmit data buffer full This flag is a read-only flag. Writing into SPIDAT0 or SPIDAT1 field will automatically set the TXFULL flag. After transfer of the transmit data the TXFULL flag is cleared 0: No new transmit data from host since previous transfer of transmit data 1: Host provided new transmit data to SPIDAT0 or SPIDAT1" range="" rwaccess="R">
<bitenum id="NO" value="0" token="NO" description="" />
<bitenum id="YES" value="1" token="YES" description="" />
</bitfield>
<bitfield id="BITERR" width="1" begin="28" end="28" resetval="0" description="Mismatch of internal transmit data and transmitted data This flag is read/clear only flag, i.e. reading the flag will automatically clear it. It represents a copy of the BITERR flag in SPIFLG 0: No bit error occurred 1: A bit error occurred. The SPI samples the signal of the transmit pin (master: SIMO, slave: SOMI) at the receive point (half clock cycle after transmit point). If the sampled value differs from the transmitted value a bit error is detected and the flag BITERR is set. A possible reason for a bit error can be noise, a to high bit rate / capacitive load or another master/slave trying to transmit at the same time" range="" rwaccess="RC">
<bitenum id="NO" value="0" token="NO" description="" />
<bitenum id="YES" value="1" token="YES" description="" />
</bitfield>
<bitfield id="DESYNC" width="1" begin="27" end="27" resetval="0" description="De-synchronization of slave device This flag is read/clear only flag, i.e. reading the flag will automatically clear it. De-synchronization monitor is active in master mode only. DESYNC represents a copy of the DESYNC flag in SPIFLG 0: No slave de-synchronization detected 1: A slave device is de-synchronized. The master monitors the ENA signal coming from the slave device and sets the DESYNC flag if ENA is deactivated before the last reception point or after the last bit is transmitted plus t T2EDELAY. If DESYNCENA is set an interrupt is asserted. De-synchronization can occur if a slave device misses a clock edge coming from the master or is detecting an additional clock edge due to perturbation" range="" rwaccess="RC">
<bitenum id="NO" value="0" token="NO" description="" />
<bitenum id="YES" value="1" token="YES" description="" />
</bitfield>
<bitfield id="PARITYERR" width="1" begin="26" end="26" resetval="0" description="Calculated parity differs from received parity bit This flag is read/clear only flag, i.e. reading the flag will automatically clear it. It represents a copy of the PARITYERR flag in SPIFLG 0: No parity error detected 1: A parity error occurred. If the parity generator is enabled (can be selected individually for each buffer) an even or odd parity bit is added at the end of a data word. During reception of the data word the parity generator calculates the reference parity and compares it to the received parity bit. In the event of a mismatch the PARITYERR flag is set" range="" rwaccess="RC">
<bitenum id="NO" value="0" token="NO" description="" />
<bitenum id="YES" value="1" token="YES" description="" />
</bitfield>
<bitfield id="TIMEOUT" width="1" begin="25" end="25" resetval="0" description="Time-out due to non-activation of ENA signal This flag is read/clear only flag, i.e. reading the flag will automatically clear it 0: No ENA-signal time-out occurred 1: An ENA signal time-out occurred. The SPI generates a time-out because the slave hasn't responded in time by activating the ENA signal after the chip select signal has been activated. If a time-out condition is detected the corresponding chip select is deactivated immediately and the TIMEOUT flag is set. In addition the TIMOUT flag in the status field of the corresponding buffer and in the SPISTAT register is set" range="" rwaccess="RC">
<bitenum id="NO" value="0" token="NO" description="" />
<bitenum id="YES" value="1" token="YES" description="" />
</bitfield>
<bitfield id="_RESV_8" width="1" begin="24" end="24" resetval="0" description="Reserved" range="" rwaccess="N"></bitfield>
<bitfield id="LCSNR" width="8" begin="23" end="16" resetval="0" description="LCSNR in the status field is a copy of CSNR in the corresponding control field  It defines the chip select that has been activated during the last data transfer from the corresponding buffer. LCSNR is copied from the Kernel of SPI after transmission during write back of received data" range="" rwaccess="R"></bitfield>
<bitfield id="SPIBUF" width="16" begin="15" end="0" resetval="0" description="SPI Buffer The data in this register is the data transferred from the shift-register (SPIDAT). Since the data is shifted into the SPI most significant bit first, for word lengths less than 16, the data is stored right-justified in the register" range="" rwaccess="R"></bitfield>
</register>
     <register id="SPIEMU" acronym="SPIEMU" offset="0x0044" width="32" description="SPI Emulation Register">
<bitfield id="_RESV_1" width="16" begin="31" end="16" resetval="0" description="Reserved" range="" rwaccess="N"></bitfield>
<bitfield id="SPIEMU" width="16" begin="15" end="0" resetval="0" description="SPI Emulation SPI emulation is a mirror of the SPIBUF register. The only difference between SPIEMU and SPIBUF is that a read from SPIEMU does not clear the RCVR OVRN (SPIFLG.6) or RXINTFLAG (SPIFLG.8) bits" range="" rwaccess="R"></bitfield>
</register>
     <register id="SPIDELAY" acronym="SPIDELAY" offset="0x0048" width="32" description="SPI Delay Register">
<bitfield id="_RESV_1" width="3" begin="31" end="29" resetval="0" description="Reserved" range="" rwaccess="N"></bitfield>
<bitfield id="C2TDELAY" width="5" begin="28" end="24" resetval="0" description="Chip select active to transmit start delay C2TDELAY is used in master mode only. If the slave device indicates the ready-to-transfer status via the ENA signal, C2TDELAY time is not delayed after the ENA signal is activated. It defines a setup time for the slave device that delays the data transmission from the chip select active edge by a multiple of VBUSPCLK cycles. C2TDELAY can be configured between 2 and 33 VBUSPCLK cycles" range="" rwaccess="RW"></bitfield>
<bitfield id="_RESV_3" width="3" begin="23" end="21" resetval="0" description="Reserved" range="" rwaccess="N"></bitfield>
<bitfield id="T2CDELAY" width="5" begin="20" end="16" resetval="0" description="Transmit end to chip select inactive delay T2CDELAY is used in master mode only. It defines a hold time for the slave device that delays the chip select deactivation by a multiple of VBUSPCLK cycles after the last bit is transferred. T2CDELAY can be configured between 1 and 32 VBUSPCLK cycles" range="" rwaccess="RW"></bitfield>
<bitfield id="T2EDELAY" width="8" begin="15" end="8" resetval="0" description="Transmit data finished to ENA pin inactive timeout T2EDELAY is used in master mode only. It defines a time-out value as a multiple of SPI clock before the ENAble signal has to become inactive and after the CS becomes inactive. The SPI clock depends on which data format is selected. If the slave device is missing one or more clock edges, it's becoming de-synchronized. Although the master has finished the data transfer the slave is still waiting for the missed clock pulses and the ENA signal isn't disabled. The T2EDELAY defines a time-out value that triggers the DESYNC flag, if the ENA signal isn't deactivated in time" range="" rwaccess="RW"></bitfield>
<bitfield id="C2EDELAY" width="8" begin="7" end="0" resetval="0" description="Chip select active to ENA signal active timeout C2EDELAY is utilized only in master mode and it applies only if the addressed slave generates an ENA signal as a hardware handshake response. C2EDELAY defines the maximum time between the SPI activates the chip select signal and the addressed slave has to respond by activating the ENA signal. C2EDELAY defines a time-out value as a multiple of SPI clocks. The SPI clock depends on whether data format 0 or data format 1 is selected. If the slave device is not responding with the ENA signal before the time-out value is reached, the TIMEOUT flag in SPISTAT register is set and a interrupt is asserted if enabled" range="" rwaccess="RW"></bitfield>
</register>
     <register id="SPIDEF" acronym="SPIDEF" offset="0x004C" width="32" description="SPI Chipselect Default Regsiter">
<bitfield id="_RESV_1" width="24" begin="31" end="8" resetval="0" description="Reserved" range="" rwaccess="N"></bitfield>
<bitfield id="CSDEF7" width="1" begin="7" end="7" resetval="1" description="Chip select default pattern Master mode behavior. The CSDEF7 register is output to the chip select pin when no transmission are currently performed. It allows the user to set a chip select pattern which deselect all the SPI slaves 0: If CSDEF7 is set to &quot;0&quot; the corresponding chip select is set to &quot;0&quot; when no transfer occurs 1: If CSDEF7 is set to &quot;1&quot; the corresponding chip select is set to &quot;1&quot; when no transfer occurs" range="" rwaccess="RW">
<bitenum id="CS_0" value="0" token="CS_0" description="" />
<bitenum id="CS_1" value="1" token="CS_1" description="" />
</bitfield>
<bitfield id="CSDEF6" width="1" begin="6" end="6" resetval="1" description="Chip select default pattern Master mode behavior. The CSDEF6 register is output to the chip select pin when no transmission are currently performed. It allows the user to set a chip select pattern which deselect all the SPI slaves 0: If CSDEF6 is set to &quot;0&quot; the corresponding chip select is set to &quot;0&quot; when no transfer occurs 1: If CSDEF6 is set to &quot;1&quot; the corresponding chip select is set to &quot;1&quot; when no transfer occurs" range="" rwaccess="RW">
<bitenum id="CS_0" value="0" token="CS_0" description="" />
<bitenum id="CS_1" value="1" token="CS_1" description="" />
</bitfield>
<bitfield id="CSDEF5" width="1" begin="5" end="5" resetval="1" description="Chip select default pattern Master mode behavior. The CSDEF5 register is output to the chip select pin when no transmission are currently performed. It allows the user to set a chip select pattern which deselect all the SPI slaves 0: If CSDEF5 is set to &quot;0&quot; the corresponding chip select is set to &quot;0&quot; when no transfer occurs 1: If CSDEF5 is set to &quot;1&quot; the corresponding chip select is set to &quot;1&quot; when no transfer occurs" range="" rwaccess="RW">
<bitenum id="CS_0" value="0" token="CS_0" description="" />
<bitenum id="CS_1" value="1" token="CS_1" description="" />
</bitfield>
<bitfield id="CSDEF4" width="1" begin="4" end="4" resetval="1" description="Chip select default pattern Master mode behavior. The CSDEF4 register is output to the chip select pin when no transmission are currently performed. It allows the user to set a chip select pattern which deselect all the SPI slaves 0: If CSDEF4 is set to &quot;0&quot; the corresponding chip select is set to &quot;0&quot; when no transfer occurs 1: If CSDEF4 is set to &quot;1&quot; the corresponding chip select is set to &quot;1&quot; when no transfer occurs" range="" rwaccess="RW">
<bitenum id="CS_0" value="0" token="CS_0" description="" />
<bitenum id="CS_1" value="1" token="CS_1" description="" />
</bitfield>
<bitfield id="CSDEF3" width="1" begin="3" end="3" resetval="1" description="Chip select default pattern Master mode behavior. The CSDEF3 register is output to the chip select pin when no transmission are currently performed. It allows the user to set a chip select pattern which deselect all the SPI slaves 0: If CSDEF3 is set to &quot;0&quot; the corresponding chip select is set to &quot;0&quot; when no transfer occurs 1: If CSDEF3 is set to &quot;1&quot; the corresponding chip select is set to &quot;1&quot; when no transfer occurs" range="" rwaccess="RW">
<bitenum id="CS_0" value="0" token="CS_0" description="" />
<bitenum id="CS_1" value="1" token="CS_1" description="" />
</bitfield>
<bitfield id="CSDEF2" width="1" begin="2" end="2" resetval="1" description="Chip select default pattern Master mode behavior. The CSDEF2 register is output to the chip select pin when no transmission are currently performed. It allows the user to set a chip select pattern which deselect all the SPI slaves 0: If CSDEF2 is set to &quot;0&quot; the corresponding chip select is set to &quot;0&quot; when no transfer occurs 1: If CSDEF2 is set to &quot;1&quot; the corresponding chip select is set to &quot;1&quot; when no transfer occurs" range="" rwaccess="RW">
<bitenum id="CS_0" value="0" token="CS_0" description="" />
<bitenum id="CS_1" value="1" token="CS_1" description="" />
</bitfield>
<bitfield id="CSDEF1" width="1" begin="1" end="1" resetval="1" description="Chip select default pattern Master mode behavior. The CSDEF1 register is output to the chip select pin when no transmission are currently performed. It allows the user to set a chip select pattern which deselect all the SPI slaves 0: If CSDEF1 is set to &quot;0&quot; the corresponding chip select is set to &quot;0&quot; when no transfer occurs 1: If CSDEF1 is set to &quot;1&quot; the corresponding chip select is set to &quot;1&quot; when no transfer occurs" range="" rwaccess="RW">
<bitenum id="CS_0" value="0" token="CS_0" description="" />
<bitenum id="CS_1" value="1" token="CS_1" description="" />
</bitfield>
<bitfield id="CSDEF0" width="1" begin="0" end="0" resetval="1" description="Chip select default pattern Master mode behavior. The CSDEF0 register is output to the chip select pin when no transmission are currently performed. It allows the user to set a chip select pattern which deselect all the SPI slaves 0: If CSDEF0 is set to &quot;0&quot; the corresponding chip select is set to &quot;0&quot; when no transfer occurs 1: If CSDEF0 is set to &quot;1&quot; the corresponding chip select is set to &quot;1&quot; when no transfer occurs" range="" rwaccess="RW">
<bitenum id="CS_0" value="0" token="CS_0" description="" />
<bitenum id="CS_1" value="1" token="CS_1" description="" />
</bitfield>
</register>
     <register id="SPIFMT0" acronym="SPIFMT0" offset="0x0050" width="32" description="SPI Format 0 Register">
<bitfield id="_RESV_1" width="2" begin="31" end="30" resetval="0" description="Reserved" range="" rwaccess="N"></bitfield>
<bitfield id="WDELAY0" width="6" begin="29" end="24" resetval="0" description="Delay in between transmissions for data format 0 Idle time that will be applied at the end of the current transmission if the bit WDEL is set in the current buffer The delay to be applied is equal to: WDELAY * PVBUSPCLK + 2 * PVBUSPCLK" range="" rwaccess="RW"></bitfield>
<bitfield id="PARPOL0" width="1" begin="23" end="23" resetval="0" description="Parity polarity: even or odd. PARPOL0 can be modified in privilege mode only 0: If PARPOL0 is set to &quot;0&quot; and PARITY0 is enabled, a even parity flag is added at the end of the transmit data stream 1: If PARPOL0 is set to &quot;1&quot; and PARITY0 is enabled, a odd parity flag is added at the end of the transmit data stream" range="" rwaccess="RW">
<bitenum id="EVEN" value="0" token="EVEN" description="" />
<bitenum id="ODD" value="1" token="ODD" description="" />
</bitfield>
<bitfield id="PARITY0" width="1" begin="22" end="22" resetval="0" description="Parity enable for data format 0 0: No parity generation/ verification is performed for this data format 1: A parity is added after transfer of the data bit. At the end of a transfer the parity generator compares the received parity bit with the locally calculated parity flag. If the parity bits do not match the RXERR flag is set in the corresponding control field. The parity type (even or odd) can be selected via the PARPOL bit" range="" rwaccess="RW">
<bitenum id="NOPARITY" value="0" token="NOPARITY" description="" />
<bitenum id="PARITY" value="1" token="PARITY" description="" />
</bitfield>
<bitfield id="WAITENA0" width="1" begin="21" end="21" resetval="0" description="Master waits for ENA signal from slave for data format 0. WAITENA is considered in master mode only. In slave mode this bit has no meaning. WAITENA enables a flexible SPI network where slaves with ENA signal and slaves without ENA signal can be mixed. WAITENA defines for each buffer whether the addressed slave generates the ENA signal or does not 0: The SPI does not wait for the ENA signal from the slaves and directly starts the transfer 1: Before the SPI starts the data transfer it waits for the ENA signal to become low. If the ENA signal is not pulled down by the addressed slave before the internal time-out counter (CE2DELAY) expires" range="" rwaccess="RW">
<bitenum id="NO_WAIT" value="0" token="NO_WAIT" description="" />
<bitenum id="WAIT" value="1" token="WAIT" description="" />
</bitfield>
<bitfield id="SHIFTDIR0" width="1" begin="20" end="20" resetval="0" description="Shift direction for data format 0 With bit SHIFTDIR0 the shift direction for data format 0  can be selected 0: Data format 0 shift direction: Most significant bit is shifted out first 1: Data format 0 shift direction: Least significant bit is shifted out first" range="" rwaccess="RW">
<bitenum id="MSB" value="0" token="MSB" description="" />
<bitenum id="LSB" value="1" token="LSB" description="" />
</bitfield>
<bitfield id="_RESV_7" width="2" begin="19" end="18" resetval="0" description="Reserved" range="" rwaccess="N"></bitfield>
<bitfield id="POLARITY0" width="1" begin="17" end="17" resetval="0" description="SPI data format 0 clock polarity POLARITY0 defines the clock polarity of data format 0. POLARITY0 can be modified in privilege mode only 0: If POLARITY0 is set to &quot;0&quot; the SPI clock signal is low-inactive, i.e. before and after data transfer the clock signal is low 1: If POLARITY0 is set to &quot;1&quot; the SPI clock signal is high-inactive, i.e. before and after data transfer the clock signal is high" range="" rwaccess="RW">
<bitenum id="LOW" value="0" token="LOW" description="" />
<bitenum id="HIGH" value="1" token="HIGH" description="" />
</bitfield>
<bitfield id="PHASE0" width="1" begin="16" end="16" resetval="0" description="SPI Data format 0 clock delay PHASE0 defines the clock delay of data format 0. PHASE0 can be modified in privilege mode only 0: If PHASE0 is set to &quot;0&quot; the SPI clock signal is not delayed versus the transmit / receive data stream. The first data bit is transmitted with the first clock edge and the first bit is received with the second (inverse) clock edge 1: If PHASE0 is set to &quot;1&quot; the SPI clock signal is delayed by a half SPI clock cycle versus the transmit / receive data stream. The first transmit bit has to output prior to the first clock edge. Master and slave receive the first bit with the first edge" range="" rwaccess="RW">
<bitenum id="NO_DELAY" value="0" token="NO_DELAY" description="" />
<bitenum id="DELAY" value="1" token="DELAY" description="" />
</bitfield>
<bitfield id="PRESCALE0" width="8" begin="15" end="8" resetval="0" description="SPI data format 0 prescaler PRESCALE0 can be modified in privilege mode only PRESCALE0 determines the bit transfer rate of data format 0 if the SPI is the network master. PRESCALE0 is directly derived from VBUSPCLK. If the SPI is configured as slave, PRESCALE0 DOES NOT NEED to be configured. When PRESCALE0 is set to zero (0), the SPI clock rate is VBUSPCLK/2" range="" rwaccess="RW"></bitfield>
<bitfield id="_RESV_11" width="3" begin="7" end="5" resetval="0" description="Reserved" range="" rwaccess="N"></bitfield>
<bitfield id="CHARLEN0" width="5" begin="4" end="0" resetval="0" description="SPI data format 0 data word length CHARLEN0 defines the word length of data format 0. Legal values are 0x02 (data word length = 2 bit) to 0x10 (data word length = 16). Illegal values, such as 0x00 or 0x1F are not detected and their effect is indeterminate" range="" rwaccess="RW"></bitfield>
</register>
     <register id="SPIFMT1" acronym="SPIFMT1" offset="0x0054" width="32" description="SPI Format 1 Register">
<bitfield id="_RESV_1" width="2" begin="31" end="30" resetval="0" description="Reserved" range="" rwaccess="N"></bitfield>
<bitfield id="WDELAY1" width="6" begin="29" end="24" resetval="0" description="Delay in between transmissions for data format 1 Idle time that will be applied at the end of the current transmission if the bit WDEL is set in the current buffer The delay to be applied is equal to: WDELAY * PVBUSPCLK + 2 * PVBUSPCLK" range="" rwaccess="RW"></bitfield>
<bitfield id="PARPOL1" width="1" begin="23" end="23" resetval="0" description="Parity polarity: even or odd. PARPOL1 can be modified in privilege mode only 0: If PARPOL1 is set to &quot;0&quot; and PARITY1 is enabled, a even parity flag is added at the end of the transmit data stream 1: If PARPOL1 is set to &quot;1&quot; and PARITY1 is enabled, a odd parity flag is added at the end of the transmit data stream" range="" rwaccess="RW">
<bitenum id="EVEN" value="0" token="EVEN" description="" />
<bitenum id="ODD" value="1" token="ODD" description="" />
</bitfield>
<bitfield id="PARITY1" width="1" begin="22" end="22" resetval="0" description="Parity enable for data format 1 0: No parity generation/ verification is performed for this data format 1: A parity is added after transfer of the data bit. At the end of a transfer the parity generator compares the received parity bit with the locally calculated parity flag. If the parity bits do not match the RXERR flag is set in the corresponding control field. The parity type (even or odd) can be selected via the PARPOL bit" range="" rwaccess="RW">
<bitenum id="NOPARITY" value="0" token="NOPARITY" description="" />
<bitenum id="PARITY" value="1" token="PARITY" description="" />
</bitfield>
<bitfield id="WAITENA1" width="1" begin="21" end="21" resetval="0" description="Master waits for ENA signal from slave for data format1 WAITENA is considered in master mode only. In slave mode this bit has no meaning. WAITENA enables a flexible SPI network where slaves with ENA signal and slaves without ENA signal can be mixed. WAITENA defines for each buffer whether the addressed slave generates the ENA signal or does not 0: The SPI does not wait for the ENA signal from the slaves and directly starts the transfer 1: Before the SPI starts the data transfer it waits for the ENA signal to become low. If the ENA signal is not pulled down by the addressed slave before the internal time-out counter (CE2DELAY) expires" range="" rwaccess="RW">
<bitenum id="NO_WAIT" value="0" token="NO_WAIT" description="" />
<bitenum id="WAIT" value="1" token="WAIT" description="" />
</bitfield>
<bitfield id="SHIFTDIR1" width="1" begin="20" end="20" resetval="0" description="Shift direction for data format 1 With bit SHIFTDIR1 the shift direction for data format 1  can be selected 0: Data format 1shift direction: Most significant bit is shifted out first 1: Data format 1shift direction: Least significant bit is shifted out first" range="" rwaccess="RW">
<bitenum id="MSB" value="0" token="MSB" description="" />
<bitenum id="LSB" value="1" token="LSB" description="" />
</bitfield>
<bitfield id="_RESV_7" width="2" begin="19" end="18" resetval="0" description="Reserved" range="" rwaccess="N"></bitfield>
<bitfield id="POLARITY1" width="1" begin="17" end="17" resetval="0" description="SPI data format 1 clock polarity POLARITY1 defines the clock polarity of data format 1. POLARITY1 can be modified in privilege mode only 0: If POLARITY1 is set to &quot;0&quot; the SPI clock signal is low-inactive, i.e. before and after data transfer the clock signal is low 1: If POLARITY1 is set to &quot;1&quot; the SPI clock signal is high-inactive, i.e. before and after data transfer the clock signal is high" range="" rwaccess="RW">
<bitenum id="LOW" value="0" token="LOW" description="" />
<bitenum id="HIGH" value="1" token="HIGH" description="" />
</bitfield>
<bitfield id="PHASE1" width="1" begin="16" end="16" resetval="0" description="SPI Data format 1 clock delay PHASE1 defines the clock delay of data format 1. PHASE1 can be modified in privilege mode only 0: If PHASE1 is set to &quot;0&quot; the SPI clock signal is not delayed versus the transmit / receive data stream. The first data bit is transmitted with the first clock edge and the first bit is received with the second (inverse) clock edge 1: If PHASE1 is set to &quot;1&quot; the SPI clock signal is delayed by a half SPI clock cycle versus the transmit / receive data stream. The first transmit bit has to output prior to the first clock edge. Master and slave receive the first bit with the first edge" range="" rwaccess="RW">
<bitenum id="NO_DELAY" value="0" token="NO_DELAY" description="" />
<bitenum id="DELAY" value="1" token="DELAY" description="" />
</bitfield>
<bitfield id="PRESCALE1" width="8" begin="15" end="8" resetval="0" description="SPI data format 1 prescaler PRESCALE1 can be modified in privilege mode only PRESCALE1 determines the bit transfer rate of data format 1 if the SPI is the network master. PRESCALE1 is directly derived from VBUSPCLK. If the SPI is configured as slave, PRESCALE1 DOES NOT NEED to be configured. When PRESCALE1 is set to zero (0), the SPI clock rate is VBUSPCLK/2" range="" rwaccess="RW"></bitfield>
<bitfield id="_RESV_11" width="3" begin="7" end="5" resetval="0" description="Reserved" range="" rwaccess="N"></bitfield>
<bitfield id="CHARLEN1" width="5" begin="4" end="0" resetval="0" description="SPI data format 1 data word length CHARLEN1 defines the word length of data format 1. Legal values are 0x02 (data word length = 2 bit) to 0x10 (data word length = 16). Illegal values, such as 0x00 or 0x1F are not detected and their effect is indeterminate" range="" rwaccess="RW"></bitfield>
</register>
     <register id="SPIFMT2" acronym="SPIFMT2" offset="0x0058" width="32" description="SPI Format 2 Register">
<bitfield id="_RESV_1" width="2" begin="31" end="30" resetval="0" description="Reserved" range="" rwaccess="N"></bitfield>
<bitfield id="WDELAY2" width="6" begin="29" end="24" resetval="0" description="Delay in between transmissions for data format 2 Idle time that will be applied at the end of the current transmission if the bit WDEL is set in the current buffer The delay to be applied is equal to: WDELAY * PVBUSPCLK + 2 * PVBUSPCLK" range="" rwaccess="RW"></bitfield>
<bitfield id="PARPOL2" width="1" begin="23" end="23" resetval="0" description="Parity polarity: even or odd. PARPOL2 can be modified in privilege mode only 0: If PARPOL2 is set to &quot;0&quot; and PARITY2 is enabled, a even parity flag is added at the end of the transmit data stream 1: If PARPOL2 is set to &quot;1&quot; and PARITY2 is enabled, a odd parity flag is added at the end of the transmit data stream" range="" rwaccess="RW">
<bitenum id="EVEN" value="0" token="EVEN" description="" />
<bitenum id="ODD" value="1" token="ODD" description="" />
</bitfield>
<bitfield id="PARITY2" width="1" begin="22" end="22" resetval="0" description="Parity enable for data format 2 0: No parity generation/ verification is performed for this data format 1: A parity is added after transfer of the data bit. At the end of a transfer the parity generator compares the received parity bit with the locally calculated parity flag. If the parity bits do not match the RXERR flag is set in the corresponding control field. The parity type (even or odd) can be selected via the PARPOL bit" range="" rwaccess="RW">
<bitenum id="NOPARITY" value="0" token="NOPARITY" description="" />
<bitenum id="PARITY" value="1" token="PARITY" description="" />
</bitfield>
<bitfield id="WAITENA2" width="1" begin="21" end="21" resetval="0" description="Master waits for ENA signal from slave for data format 2  WAITENA is considered in master mode only. In slave mode this bit has no meaning. WAITENA enables a flexible SPI network where slaves with ENA signal and slaves without ENA signal can be mixed. WAITENA defines for each buffer whether the addressed slave generates the ENA signal or does not 0: The SPI does not wait for the ENA signal from the slaves and directly starts the transfer 1: Before the SPI starts the data transfer it waits for the ENA signal to become low. If the ENA signal is not pulled down by the addressed slave before the internal time-out counter (CE2DELAY) expires" range="" rwaccess="RW">
<bitenum id="NO_WAIT" value="0" token="NO_WAIT" description="" />
<bitenum id="WAIT" value="1" token="WAIT" description="" />
</bitfield>
<bitfield id="SHIFTDIR2" width="1" begin="20" end="20" resetval="0" description="Shift direction for data format 2 With bit SHIFTDIR2 the shift direction for data format 2  can be selected 0: Data format 2 shift direction: Most significant bit is shifted out first 1: Data format 2 shift direction: Least significant bit is shifted out first" range="" rwaccess="RW">
<bitenum id="MSB" value="0" token="MSB" description="" />
<bitenum id="LSB" value="1" token="LSB" description="" />
</bitfield>
<bitfield id="_RESV_7" width="2" begin="19" end="18" resetval="0" description="Reserved" range="" rwaccess="N"></bitfield>
<bitfield id="POLARITY2" width="1" begin="17" end="17" resetval="0" description="SPI data format 2 clock polarity POLARITY2 defines the clock polarity of data format 2. POLARITY2 can be modified in privilege mode only 0: If POLARITY2 is set to &quot;0&quot; the SPI clock signal is low-inactive, i.e. before and after data transfer the clock signal is low 1: If POLARITY2 is set to &quot;1&quot; the SPI clock signal is high-inactive, i.e. before and after data transfer the clock signal is high" range="" rwaccess="RW">
<bitenum id="LOW" value="0" token="LOW" description="" />
<bitenum id="HIGH" value="1" token="HIGH" description="" />
</bitfield>
<bitfield id="PHASE2" width="1" begin="16" end="16" resetval="0" description="SPI Data format 2 clock delay PHASE2 defines the clock delay of data format 2. PHASE2 can be modified in privilege mode only 0: If PHASE2 is set to &quot;0&quot; the SPI clock signal is not delayed versus the transmit / receive data stream. The first data bit is transmitted with the first clock edge and the first bit is received with the second (inverse) clock edge 1: If PHASE2 is set to &quot;1&quot; the SPI clock signal is delayed by a half SPI clock cycle versus the transmit / receive data stream. The first transmit bit has to output prior to the first clock edge. Master and slave receive the first bit with the first edge" range="" rwaccess="RW">
<bitenum id="NO_DELAY" value="0" token="NO_DELAY" description="" />
<bitenum id="DELAY" value="1" token="DELAY" description="" />
</bitfield>
<bitfield id="PRESCALE2" width="8" begin="15" end="8" resetval="0" description="SPI data format 2 prescaler PRESCALE2 can be modified in privilege mode only PRESCALE2 determines the bit transfer rate of data format 2 if the SPI is the network master. PRESCALE2 is directly derived from VBUSPCLK. If the SPI is configured as slave, PRESCALE2 DOES NOT NEED to be configured. When PRESCALE2 is set to zero (0), the SPI clock rate is VBUSPCLK/2" range="" rwaccess="RW"></bitfield>
<bitfield id="_RESV_11" width="3" begin="7" end="5" resetval="0" description="Reserved" range="" rwaccess="N"></bitfield>
<bitfield id="CHARLEN2" width="5" begin="4" end="0" resetval="0" description="SPI data format 2 data word length CHARLEN2 defines the word length of data format 1. Legal values are 0x02 (data word length = 2 bit) to 0x10 (data word length = 16). Illegal values, such as 0x00 or 0x1F are not detected and their effect is indeterminate" range="" rwaccess="RW"></bitfield>
</register>
     <register id="SPIFMT3" acronym="SPIFMT3" offset="0x005C" width="32" description="SPI Format 3 Register">
<bitfield id="_RESV_1" width="2" begin="31" end="30" resetval="0" description="Reserved" range="" rwaccess="N"></bitfield>
<bitfield id="WDELAY3" width="6" begin="29" end="24" resetval="0" description="Delay in between transmissions for data format 3 Idle time that will be applied at the end of the current transmission if the bit WDEL is set in the current buffer The delay to be applied is equal to: WDELAY * PVBUSPCLK + 2 * PVBUSPCLK" range="" rwaccess="RW"></bitfield>
<bitfield id="PARPOL3" width="1" begin="23" end="23" resetval="0" description="Parity polarity: even or odd. PARPOL3 can be modified in privilege mode only 0: If PARPOL3 is set to &quot;0&quot; and PARITY3 is enabled, a even parity flag is added at the end of the transmit data stream 1: If PARPOL3 is set to &quot;1&quot; and PARITY3 is enabled, a odd parity flag is added at the end of the transmit data stream" range="" rwaccess="RW">
<bitenum id="EVEN" value="0" token="EVEN" description="" />
<bitenum id="ODD" value="1" token="ODD" description="" />
</bitfield>
<bitfield id="PARITY3" width="1" begin="22" end="22" resetval="0" description="Parity enable for data format 3 0: No parity generation/ verification is performed for this data format 1: A parity is added after transfer of the data bit. At the end of a transfer the parity generator compares the received parity bit with the locally calculated parity flag. If the parity bits do not match the RXERR flag is set in the corresponding control field. The parity type (even or odd) can be selected via the PARPOL bit" range="" rwaccess="RW">
<bitenum id="NOPARITY" value="0" token="NOPARITY" description="" />
<bitenum id="PARITY" value="1" token="PARITY" description="" />
</bitfield>
<bitfield id="WAITENA3" width="1" begin="21" end="21" resetval="0" description="Master waits for ENA signal from slave for data format 3 WAITENA is considered in master mode only. In slave mode this bit has no meaning. WAITENA enables a flexible SPI network where slaves with ENA signal and slaves without ENA signal can be mixed. WAITENA defines for each buffer whether the addressed slave generates the ENA signal or does not 0: The SPI does not wait for the ENA signal from the slaves and directly starts the transfer 1: Before the SPI starts the data transfer it waits for the ENA signal to become low. If the ENA signal is not pulled down by the addressed slave before the internal time-out counter (CE2DELAY) expires" range="" rwaccess="RW">
<bitenum id="NO_WAIT" value="0" token="NO_WAIT" description="" />
<bitenum id="WAIT" value="1" token="WAIT" description="" />
</bitfield>
<bitfield id="SHIFTDIR3" width="1" begin="20" end="20" resetval="0" description="Shift direction for data format 3 With bit SHIFTDIR3 the shift direction for data format 3  can be selected 0: Data format 3 shift direction: Most significant bit is shifted out first 1: Data format 3 shift direction: Least significant bit is shifted out first" range="" rwaccess="RW">
<bitenum id="MSB" value="0" token="MSB" description="" />
<bitenum id="LSB" value="1" token="LSB" description="" />
</bitfield>
<bitfield id="_RESV_7" width="2" begin="19" end="18" resetval="0" description="Reserved" range="" rwaccess="N"></bitfield>
<bitfield id="POLARITY3" width="1" begin="17" end="17" resetval="0" description="SPI data format 3 clock polarity POLARITY3 defines the clock polarity of data format 3. POLARITY3 can be modified in privilege mode only 0: If POLARITY3 is set to &quot;0&quot; the SPI clock signal is low-inactive, i.e. before and after data transfer the clock signal is low 1: If POLARITY3 is set to &quot;1&quot; the SPI clock signal is high-inactive, i.e. before and after data transfer the clock signal is high" range="" rwaccess="RW">
<bitenum id="LOW" value="0" token="LOW" description="" />
<bitenum id="HIGH" value="1" token="HIGH" description="" />
</bitfield>
<bitfield id="PHASE3" width="1" begin="16" end="16" resetval="0" description="SPI Data format 3 clock delay PHASE3 defines the clock delay of data format 3. PHASE3 can be modified in privilege mode only 0: If PHASE3 is set to &quot;0&quot; the SPI clock signal is not delayed versus the transmit / receive data stream. The first data bit is transmitted with the first clock edge and the first bit is received with the second (inverse) clock edge 1: If PHASE3 is set to &quot;1&quot; the SPI clock signal is delayed by a half SPI clock cycle versus the transmit / receive data stream. The first transmit bit has to output prior to the first clock edge. Master and slave receive the first bit with the first edge" range="" rwaccess="RW">
<bitenum id="NO_DELAY" value="0" token="NO_DELAY" description="" />
<bitenum id="DELAY" value="1" token="DELAY" description="" />
</bitfield>
<bitfield id="PRESCALE3" width="8" begin="15" end="8" resetval="0" description="SPI data format 3 prescaler PRESCALE3 can be modified in privilege mode only PRESCALE3 determines the bit transfer rate of data format 3 if the SPI is the network master. PRESCALE3 is directly derived from VBUSPCLK. If the SPI is configured as slave, PRESCALE3 DOES NOT NEED to be configured. When PRESCALE3 is set to zero (0), the SPI clock rate is VBUSPCLK/2" range="" rwaccess="RW"></bitfield>
<bitfield id="_RESV_11" width="3" begin="7" end="5" resetval="0" description="Reserved" range="" rwaccess="N"></bitfield>
<bitfield id="CHARLEN3" width="5" begin="4" end="0" resetval="0" description="SPI data format 3 data word length CHARLEN3 defines the word length of data format 3. Legal values are 0x02 (data word length = 2 bit) to 0x10 (data word length = 16). Illegal values, such as 0x00 or 0x1F are not detected and their effect is indeterminate" range="" rwaccess="RW"></bitfield>
</register>
     <register id="INTVECT0" acronym="INTVECT0" offset="0x0060" width="32" description="SPI Interrupt Vector Register 0">
<bitfield id="_RESV_1" width="26" begin="31" end="6" resetval="0" description="Reserved" range="" rwaccess="N"></bitfield>
<bitfield id="INTVECT0" width="5" begin="5" end="1" resetval="0" description="Interrupt vector for interrupt line INT0 INTVECT0 returns the vector of the pending interrupt at interrupt line INT0. If more than one interrupt is pending, INTVECT0 always references the highest prior interrupt source first The interrupts available for SPI, in the descending order of their priorities are as given below a) Receive Overrun Interrupt b) Receive Interrupt c) Transmission error Interrupt Vectors for each of these interrupts will be reflected on the INTVECT0 bits, when they occur. Reading the vectors for the Receive Overrun interrupt and Receive interrupt will automatically clear the respective flags in the SPIFLG register. On reading the INTVECT0 bits, the vector of the next highest priority interrupt (if any) will be then reflected on the INTVECT0 bits.If two or more interrupts occur simultaneously, the vector for the higest priority interrupt will be reflected on the INTVECT0 bits" range="" rwaccess="R"></bitfield>
<bitfield id="SUSPEND" width="1" begin="0" end="0" resetval="0" description="&quot;Transfer suspended&quot; or &quot;transfer finished&quot; interrupt Every time TGINTVECT0 is read by the host the corresponding interrupt flag of the referenced transfer group is cleared and TGINTVECT0 is updated with the vector coming next in the priority chain. In parallel the SUSPEND flag is updated depending on the type of interrupt 0: The interrupt type is a &quot;transfer finished&quot; interrupt. I.e. the buffer array referenced by INTVECT0 has asserted an interrupt, because all data from the whole transfer group has been transferred. The SUSPEND bit always returns value '0' in SPI 1: The interrupt type is a &quot;transfer suspended&quot; interrupt. I.e. the transfer group referenced by INTVECT0 has asserted an interrupt, because the buffer to be transferred next is in &quot;suspend to wait&quot; mode " range="" rwaccess="R">
<bitenum id="TRANSFER_FINISHED" value="0" token="TRANSFER_FINISHED" description="" />
<bitenum id="TRANSFER_SUSPENDED" value="1" token="TRANSFER_SUSPENDED" description="" />
</bitfield>
</register>
     <register id="INTVECT1" acronym="INTVECT1" offset="0x0064" width="32" description="SPI Interrupt Vector Register 1">
<bitfield id="_RESV_1" width="26" begin="31" end="6" resetval="0" description="Reserved" range="" rwaccess="N"></bitfield>
<bitfield id="INTVECT1" width="5" begin="5" end="1" resetval="0" description="Interrupt vector for interrupt line INT1 INTVECT1 returns the vector of the pending interrupt at interrupt line INT1. If more than one interrupt is pending, INTVECT1 always references the highest prior interrupt source first The interrupts available for SPI, in the descending order of their priorities are as given below a) Receive Overrun Interrupt b) Receive Interrupt c) Transmission error Interrupt Vectors for each of these interrupts will be reflected on the INTVECT1 bits, when they occur. Reading the vectors for the Receive Overrun interrupt and Receive interrupt will automatically clear the respective flags in the SPIFLG register. On reading the INTVECT1 bits, the vector of the next highest priority interrupt (if any) will be then reflected on the INTVECT1 bits.If two or more interrupts occur simultaneously, the vector for the higest priority interrupt will be reflected on the INTVECT1 bits" range="" rwaccess="R"></bitfield>
<bitfield id="SUSPEND" width="1" begin="0" end="0" resetval="0" description="&quot;Transfer suspended&quot; or &quot;transfer finished&quot; interrupt Every time TGINTVECT1 is read by the host the corresponding interrupt flag of the referenced transfer group is cleared and TGINTVECT1 is updated with the vector coming next in the priority chain. In parallel the SUSPEND flag is updated depending on the type of interrupt 0: The interrupt type is a &quot;transfer finished&quot; interrupt. I.e. the buffer array referenced by INTVECT1 has asserted an interrupt, because all data from the whole transfer group has been transferred. The SUSPEND bit always returns value '0' in SPI 1: The interrupt type is a &quot;transfer suspended&quot; interrupt. I.e. the transfer group referenced by INTVECT1 has asserted an interrupt, because the buffer to be transferred next is in &quot;suspend to wait&quot; mode " range="" rwaccess="R">
<bitenum id="TRANSFER_FINISHED" value="0" token="TRANSFER_FINISHED" description="" />
<bitenum id="TRANSFER_SUSPENDED" value="1" token="TRANSFER_SUSPENDED" description="" />
</bitfield>
</register>
</module>
