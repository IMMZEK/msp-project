"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.setupSynchronousClient = exports.ModuleTimeoutError = void 0;
const worker_threads_1 = require("worker_threads");
const path = require("path");
const events_1 = require("events");
const util_1 = require("util");
const child_process_1 = require("child_process");
var LogLevel;
(function (LogLevel) {
    LogLevel[LogLevel["Error"] = 0] = "Error";
    LogLevel[LogLevel["Warning"] = 1] = "Warning";
    LogLevel[LogLevel["Info"] = 2] = "Info";
    LogLevel[LogLevel["Debug"] = 3] = "Debug";
})(LogLevel || (LogLevel = {}));
const logThreshold = LogLevel.Error;
// For now we just log to console. It is likely that scripting will eventually have its
// own logging solution
function logMessage(level, msg) {
    if (level <= logThreshold) {
        console[level <= LogLevel.Error ? "error" : "log"](msg);
    }
}
function partial(fn, f) {
    return (...args) => fn.apply(null, [f, ...args]);
}
const logger = {
    error: partial(logMessage, LogLevel.Error),
    warn: partial(logMessage, LogLevel.Warning),
    info: partial(logMessage, LogLevel.Info),
    debug: partial(logMessage, LogLevel.Debug),
};
function isModuleResponse(response) {
    return !!response && "moduleKey" in response;
}
var RequestKind;
(function (RequestKind) {
    RequestKind[RequestKind["LaunchCloudAgent"] = 0] = "LaunchCloudAgent";
    RequestKind[RequestKind["Connect"] = 1] = "Connect";
    RequestKind[RequestKind["Command"] = 2] = "Command";
    RequestKind[RequestKind["Close"] = 3] = "Close";
})(RequestKind || (RequestKind = {}));
var ResponseKind;
(function (ResponseKind) {
    ResponseKind[ResponseKind["CloudAgentPort"] = 0] = "CloudAgentPort";
    ResponseKind[ResponseKind["LogMessage"] = 1] = "LogMessage";
    ResponseKind[ResponseKind["Connected"] = 2] = "Connected";
    ResponseKind[ResponseKind["ModuleMessage"] = 3] = "ModuleMessage";
    ResponseKind[ResponseKind["Closed"] = 4] = "Closed";
})(ResponseKind || (ResponseKind = {}));
// Default error if none is provided
class ModuleTimeoutError extends Error {
    /** @internal */
    constructor() {
        super("Operation timed out");
    }
}
exports.ModuleTimeoutError = ModuleTimeoutError;
function assertUnreachable(x) {
    // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
    throw new Error(`unreachable reached: ${x}`);
}
// override JSON serialization in this file (I want to avoid anything that could affect
// behavior in a user's script)
const JSON = {
    stringify: (data) => {
        function replacer(_, v) {
            return typeof v === "bigint" ? v.toString() : v;
        }
        return global.JSON.stringify(data, replacer);
    },
    parse: (str) => {
        function reviver(_, v) {
            // revive any bigints
            if (typeof v === "string" && v.startsWith("!bi:")) {
                return BigInt(v.substring(4));
            }
            return v;
        }
        return global.JSON.parse(str, reviver);
    }
};
function setupSynchronousClient(ccsBase, inProcess = false, TimeoutError = ModuleTimeoutError) {
    // Messaging scheme:
    // We create two MessageChannels, one for the main thread to send requests to the
    // worker, and the other for the worker to send back responses and events.
    // The worker thread will asynchronously handle requests sent by the main thread.
    // For communication back, we create a small shared buffer to keep track of the
    // messages pending on the response channel. To wait for a response, the main
    // thread will block until this number is non-zero. Atomic operations are used
    // to avoid race conditions on the shared buffer.
    //
    // Notes:
    // * We cannot use the worker's send method and the parentPort. It seems that they
    //   don't work when the main thread is blocked.
    // * We should not register a listener on the responseReceiver MessagePort. Doing
    //   so would cause the MessagePort's queue to empty if control is ever yielded to
    //   the Node.js event loop. (e.g. A script could await at the top level.)
    const { port1: requestSender, port2: requestReceiver } = new worker_threads_1.MessageChannel();
    const { port1: responseSender, port2: responseReceiver } = new worker_threads_1.MessageChannel();
    const sharedBuffer = new SharedArrayBuffer(4);
    const responsesPending = new Int32Array(sharedBuffer, 0, 1);
    const workerData = {
        sharedBuffer,
        requestReceiver,
        responseSender,
        ccsBase: path.resolve(ccsBase),
        inProcess,
    };
    const transferList = [requestReceiver, responseSender];
    // In-process communication requires setting the PATH so that dll's get loaded
    // properly. So we need the worker's changes to the environment variables to be
    // visible on the main thread and native add-ons.
    const env = inProcess ? worker_threads_1.SHARE_ENV : undefined;
    const worker = new worker_threads_1.Worker(__filename, { workerData, transferList, env });
    let nextModuleId = 1;
    const modules = {};
    function handleEvents(response) {
        const { kind, moduleKey } = response;
        switch (kind) {
            case ResponseKind.Connected:
                break;
            case ResponseKind.ModuleMessage:
                if ("event" in response.data) {
                    const { event, data } = response.data;
                    modules[moduleKey]?.emitEvent(event, data);
                }
                break;
            case ResponseKind.Closed:
                modules[moduleKey]?.onClose();
                break;
            default:
                assertUnreachable(kind);
        }
    }
    let timeout = 0;
    function getTimeoutTime() {
        return timeout > 0 ? Date.now() + timeout : undefined;
    }
    function setTimeout(ms) {
        if (typeof ms !== "number") {
            throw new TypeError("timeout value provided is not a number");
        }
        timeout = ms;
    }
    function send(data) {
        logger.debug(`[script thread] sending ${JSON.stringify(data)}`);
        requestSender.postMessage(data);
    }
    function receive(timeoutAt) {
        let timeout = undefined;
        if (timeoutAt) {
            timeout = timeoutAt - Date.now();
            if (timeout <= 0) {
                throw new TimeoutError();
            }
        }
        const status = Atomics.wait(responsesPending, 0, 0, timeout);
        if (status === "timed-out") {
            throw new TimeoutError();
        }
        const response = (0, worker_threads_1.receiveMessageOnPort)(responseReceiver)?.message;
        if (response) {
            Atomics.sub(responsesPending, 0, 1);
            if (response.kind === ResponseKind.LogMessage) {
                logMessage(response.level, `[socket thread] ${response.message}`);
            }
            else {
                logger.debug(`[script thread] received ${JSON.stringify(response)}`);
            }
            if (isModuleResponse(response)) {
                handleEvents(response);
            }
        }
        return response;
    }
    function receiveForModule(moduleKey, timeoutAt) {
        // We are waiting for a response for a particular module, but we could receive
        // events from other modules
        for (;;) {
            const response = receive(timeoutAt);
            if (isModuleResponse(response) && response.moduleKey === moduleKey) {
                return response;
            }
        }
    }
    function createModule(port, subProtocol, cleanup) {
        const subModules = {};
        const listeners = {};
        const moduleKey = nextModuleId++;
        function receiveResponse(timeoutAt) {
            return receiveForModule(moduleKey, timeoutAt);
        }
        function emitEvent(event, data) {
            const eventListeners = listeners[event];
            if (eventListeners) {
                for (const listener of eventListeners) {
                    if (listener) {
                        listener(data);
                    }
                }
            }
        }
        let execCommand;
        let onClose = () => {
            // Ensure we only call this once;
            onClose = () => { };
            execCommand = () => { throw new Error("Module Closed"); };
            logger.debug(`module has closed (port: ${port}, subProtocol: ${subProtocol || ''})`);
            delete modules[moduleKey];
            if (cleanup) {
                cleanup();
            }
        };
        function close() {
            send({ kind: RequestKind.Close, moduleKey });
            const timeoutAt = getTimeoutTime();
            for (;;) {
                const { kind } = receiveResponse(timeoutAt);
                if (kind === ResponseKind.Closed) {
                    break;
                }
            }
        }
        let nextCommandId = 1;
        execCommand = (command, data) => {
            const commandId = nextCommandId++;
            send({ kind: RequestKind.Command, moduleKey, data: { id: commandId, command, data } });
            const timeoutAt = getTimeoutTime();
            for (;;) {
                const response = receiveResponse(timeoutAt);
                const { kind: resKind } = response;
                switch (resKind) {
                    case ResponseKind.Closed:
                        throw new Error("Module Closed");
                    case ResponseKind.ModuleMessage:
                        if ("response" in response.data) {
                            const { response: id, data } = response.data;
                            if (id === commandId) {
                                return data;
                            }
                        }
                        else if ("error" in response.data) {
                            const { error: id, data } = response.data;
                            if (id === commandId) {
                                const err = new Error(data.message);
                                if (data.stack) {
                                    err.stack = data.stack + "\n" + err.stack;
                                }
                                throw err;
                            }
                        }
                        break;
                    case ResponseKind.Connected:
                        throw new Error("Internal Error: Received unexpected response");
                    default:
                        assertUnreachable(resKind);
                }
            }
        };
        function addListener(event, listener) {
            if (!listeners[event]) {
                listeners[event] = [];
            }
            listeners[event].push(listener);
        }
        function removeListener(event, listener) {
            const eventListeners = listeners[event];
            if (eventListeners) {
                const i = eventListeners.indexOf(listener);
                if (-1 !== i) {
                    eventListeners[i] = null;
                }
            }
        }
        function createModulePart(prefix = "") {
            return {
                addListener: (event, listener) => addListener(prefix + event, listener),
                removeListener: (event, listener) => removeListener(prefix + event, listener),
            };
        }
        function addCommand(part, command, prefix = "") {
            const [first, ...rest] = command.split(".");
            if (rest.length === 0) {
                part[first] = (...args) => execCommand(prefix + command, args);
            }
            else {
                prefix += first + ".";
                if (!part[first]) {
                    part[first] = createModulePart(prefix);
                }
                addCommand(part[first], rest.join("."), prefix);
            }
        }
        function listCommands() {
            return execCommand("listCommands", []).commands;
        }
        function createSubModule(name) {
            const { port, subProtocol } = execCommand("createSubModule", [name]);
            const cleanup = () => { delete subModules[name]; };
            return createModule(port, subProtocol, cleanup);
        }
        function getSubModule(subModuleName) {
            if (subModuleName in subModules) {
                return subModules[subModuleName];
            }
            const subModule = createSubModule(subModuleName);
            subModules[subModuleName] = subModule;
            return subModule;
        }
        send({ kind: RequestKind.Connect, port, subProtocol, moduleKey });
        const { kind } = receiveResponse(getTimeoutTime());
        if (kind !== ResponseKind.Connected) {
            onClose();
            throw new Error("Internal error: Received unexpected response when creating module");
        }
        const module = { ...createModulePart(), getSubModule, close };
        for (const command of listCommands()) {
            addCommand(module, command);
        }
        modules[moduleKey] = { close, emitEvent, onClose: onClose };
        return module;
    }
    function waitForEvent(obj, event) {
        let eventData = { received: false };
        const listener = (data) => { eventData = { received: true, data }; };
        obj.addListener(event, listener);
        try {
            const timeoutAt = getTimeoutTime();
            while (!eventData.received) {
                receive(timeoutAt);
            }
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            return eventData.data;
        }
        finally {
            obj.removeListener(event, listener);
        }
    }
    function shutdown() {
        const toClose = Object.values(modules);
        for (const module of toClose) {
            module.close();
        }
        void worker.terminate();
    }
    function launchCloudAgent() {
        send({ kind: RequestKind.LaunchCloudAgent });
        const timeoutAt = getTimeoutTime();
        for (;;) {
            const response = receive(timeoutAt);
            if (response?.kind === ResponseKind.CloudAgentPort) {
                const { data } = response;
                if ("port" in data) {
                    return data.port;
                }
                else {
                    throw new Error("Failed to start debugger: " + data.error);
                }
            }
        }
    }
    return { launchCloudAgent, createModule, waitForEvent, setTimeout, shutdown };
}
exports.setupSynchronousClient = setupSynchronousClient;
function runWebsocketThread() {
    const { sharedBuffer, requestReceiver, responseSender, ccsBase, inProcess } = worker_threads_1.workerData;
    const responsesPending = new Int32Array(sharedBuffer, 0, 1);
    function send(msg) {
        responseSender.postMessage(msg);
        Atomics.add(responsesPending, 0, 1);
        Atomics.notify(responsesPending, 0, 1);
    }
    function logMessage(level, message) {
        return send({ kind: ResponseKind.LogMessage, level, message });
    }
    const logger = {
        error: partial(logMessage, LogLevel.Error),
        warn: partial(logMessage, LogLevel.Warning),
        info: partial(logMessage, LogLevel.Info),
        debug: partial(logMessage, LogLevel.Debug),
    };
    let socketFunc;
    try {
        if (inProcess) {
            socketFunc = getInProcessSocket(ccsBase);
        }
        else {
            socketFunc = requireCloudAgentNodeModule(ccsBase, "ws");
        }
    }
    catch (err) {
        logger.error(`Error occurred during setup: ${err.message}`);
    }
    const modules = {};
    function connectToModule(moduleKey, port, subProtocol) {
        const ws = new socketFunc(`ws://127.0.01:${port}`, subProtocol);
        function sendResponse(msg) {
            send({ moduleKey, ...msg, });
        }
        ws.onopen = () => {
            sendResponse({ kind: ResponseKind.Connected });
            ws.onmessage = ({ data: rawData }) => {
                const data = JSON.parse(rawData);
                sendResponse({ kind: ResponseKind.ModuleMessage, data });
            };
        };
        ws.onclose = () => {
            sendResponse({ kind: ResponseKind.Closed });
            delete modules[moduleKey];
        };
        return {
            sendOnWS: (data) => {
                try {
                    ws.send(JSON.stringify(data));
                }
                catch (err) {
                    sendResponse({ kind: ResponseKind.Closed });
                }
            },
            closeWS: () => {
                ws.close();
            },
        };
    }
    function handleModuleRequest(request) {
        const { kind, moduleKey } = request;
        switch (kind) {
            case RequestKind.Connect:
                modules[moduleKey] = connectToModule(moduleKey, request.port, request.subProtocol);
                break;
            case RequestKind.Command:
                {
                    const module = modules[moduleKey];
                    if (!module) {
                        const { id } = request.data;
                        const data = { error: id, data: { message: "Internal error, unknown module." } };
                        send({ kind: ResponseKind.ModuleMessage, moduleKey, data });
                    }
                    module.sendOnWS(request.data);
                }
                break;
            case RequestKind.Close:
                {
                    const module = modules[moduleKey];
                    if (module) {
                        module.closeWS();
                    }
                    else {
                        // Close was called twice, or the module closed the connection.
                        // Just reply that we closed successfully.
                        send({ kind: ResponseKind.Closed, moduleKey });
                    }
                }
                break;
            default:
                assertUnreachable(kind);
        }
    }
    requestReceiver.on("message", (request) => {
        const { kind } = request;
        switch (kind) {
            case RequestKind.Connect:
            case RequestKind.Command:
            case RequestKind.Close:
                handleModuleRequest(request);
                break;
            case RequestKind.LaunchCloudAgent:
                if (inProcess) {
                    // port number doesn't matter, return an arbitrary value
                    send({ kind: ResponseKind.CloudAgentPort, data: { port: 1 } });
                }
                else {
                    startCloudAgent(ccsBase).then((port) => send({ kind: ResponseKind.CloudAgentPort, data: { port } }), (err) => send({ kind: ResponseKind.CloudAgentPort, data: { error: err.message } }));
                }
                break;
            default:
                assertUnreachable(kind);
        }
    });
    function requireCloudAgentNodeModule(ccsBase, module_name) {
        return require(path.join(ccsBase, "cloudagent", "src", "node_modules", module_name));
    }
    function getInProcessSocket(ccsBase) {
        // In order for dependent DLLs to be found, we need to have DebugServer/bin as the
        // working dir, or in the PATH.
        const dsBinDir = path.resolve(path.join(ccsBase, "DebugServer", "bin"));
        function fixPath() {
            if (process.env.PATH.indexOf(dsBinDir) === -1) {
                process.env.PATH += `;${dsBinDir}`;
            }
        }
        fixPath();
        // eslint-disable-next-line @typescript-eslint/no-var-requires
        const dsSocketAdapter = require(path.join(dsBinDir, "DSLiteNode")).dsSocketAdapter;
        (0, util_1.inherits)(dsSocketAdapter, events_1.EventEmitter);
        // process.env.Path doesn't stay changed for some reason, so we wrap the constructor
        class SocketAdapter extends dsSocketAdapter {
            constructor(address, protocol) {
                fixPath();
                super(address, protocol);
            }
        }
        return SocketAdapter;
    }
    function startCloudAgent(ccsBase) {
        return new Promise((resolve, reject) => {
            if (!path.isAbsolute(ccsBase)) {
                ccsBase = path.join(process.cwd(), ccsBase);
            }
            function stdoutHandler(data) {
                const dataStr = data.toString();
                logger.debug(`CloudAgent stdout: ${dataStr}`);
                if (dataStr.indexOf("Error") > -1) {
                    reject(new Error(dataStr));
                    return;
                }
                try {
                    const dataObj = JSON.parse(dataStr);
                    if (dataObj.port) {
                        logger.debug(`CloudAgent listening on port ${dataObj.port}`);
                        resolve(Number(dataObj.port));
                    }
                }
                catch (e) {
                    // ignore non json data
                }
            }
            try {
                const node = path.join(ccsBase, "cloudagent", "node");
                const script = path.join(ccsBase, "cloudagent", "src", "main.js");
                logger.debug(`spawning ${node} script`);
                const cloudAgent = (0, child_process_1.spawn)(node, [script], { detached: true, env: { ...process.env, NODE_OPTIONS: "" } });
                cloudAgent.stdout.on("data", stdoutHandler);
                cloudAgent.stderr.on("data", (data) => {
                    const dataStr = data.toString();
                    logger.error(`CloudAgent stderr: ${dataStr}`);
                    reject(new Error(dataStr));
                });
                cloudAgent.on("error", (err) => {
                    logger.error(`Failed to launch CloudAgent: ${err.toString()}`);
                    reject(err);
                });
            }
            catch (err) {
                logger.error(err.message);
            }
        });
    }
}
if (!worker_threads_1.isMainThread) {
    runWebsocketThread();
}
