// Copyright (c) 2024 Texas Instruments
// DO NOT EDIT THIS FILE!!!!
// This file was autogenerated using tsInterfaceDef.xdt
// from ds/code/cc_app_studio/Modules/JSONInterface/../AsyncInterface/include/AsyncInterface/Scripting/TaskObjects/Target.h

export interface Target {

	/**
	 * Connect or reconnect the debugger to the target.
	 *
	 * @remarks
	 * Returns once the target is connected and the debugger is idle.
	 *
	 * Will throw if the target target is already connected.
	 *
	 * @example
	 * ```
	 * // connects and disconnects from the target
	 * session.target.connect()
	 * session.target.disconnect()
	 * ```
	 */
	connect(): void;

	/**
	 * Disconnect the debugger from the target
	 *
	 * @remarks
	 * Returns once the target is disconnected and the debugger is idle.
	 *
	 * Will throw if not connected to the target.
	 *
	 * @example
	 * ```
	 * // connects and disconnects from the target
	 * session.target.connect()
	 * session.target.disconnect()
	 * ```
	 */
	disconnect(): void;

	/**
	 * Query if the target is connected
	 *
	 * @example
	 * ```
	 * session.target.connect();
	 * let status = session.target.isConnected(); // will be true
	 * session.target.disconnect();
	 * status = session.target.isConnected(); // will be false
	 * ```
	 */
	isConnected(): boolean;

	/**
	 * Query the target's available reset types.
	 *
	 * @returns A mapping where the keys are the reset types, and the associated values indicate
	 * whether is it currently valid to issue a reset of this type.
	 *
	 * @example
	 * ```
	 * // Get a list of the resets which can currently be performed
	 * let resets = session.target.getResets();
	 * // This might look like
	 * // resets = {
	 * //   "CPU Reset": true,
	 * //   "Board Reset": false
	 * // }
	 * let allowedResets = Object.keys(resets).filter((reset) => resets[reset]);
	 * // allowedResets = ["CPU Reset"];
	 * ```
	 */
	getResets(): Record<string, boolean>;

	/**
	 * Issue the specified reset on the target
	 *
	 * @param resetType - The type of reset to be issued. If not provided, the default reset is issued.
	 *
	 * @remarks
	 * Returns once the debugger is idle.
	 *
	 * If the reset requires the target to be halted, use {@link Target.halt} or {@link Target.waitForHalt}.
	 * 
	 * Does not throw if the reset fails.
	 *
	 * @example
	 * ```
	 * // Issue the System Reset (possible reset types vary by target)
	 * session.target.reset("System Reset");
	 * ```
	 */
	reset(resetType?: string): void;

	/**
	 * Issue a run command to the target, and wait until it has halted.
	 *
	 * @remarks
	 * By default, this will wait until the target has halted after running. If waitForHalt is false
	 * this will return as soon as the target begins to run.
	 *
	 * Will throw if the target is not halted.
	 *
	 * @example
	 * ```
	 * // run to foo
	 * session.breakpoints.add("foo");
	 * session.target.run();
	 *
	 * // run and return once the target is running
	 * session.target.run(false);
	 * ```
	 *
	 * @param waitForHalt - Whether the command should wait until the target halts. Defaults to true.
	 */
	run(waitForHalt?: boolean): void;

	/**
	 * Halt the target.
	 *
	 * @remarks
	 * Returns immediately if the target is already halted.
	 *
	 * @example
	 * ```
	 * session.target.halt();
	 * ```
	 */
	halt(): void;

	/**
	 * Waits until the target has halted for any reason.
	 *
	 * @example
	 * ```
	 * // run the target and separately wait until it is halted
	 * session.target.run(false);
	 * session.target.waitForHalt();
	 * ```
	 */
	waitForHalt(): void;

	/**
	 * Query if the target is halted.
	 *
	 * @example
	 * ```
	 * session.target.halt();
	 * let status = session.target.isHalted(); // will be true
	 * session.target.run(false);
	 * status = session.target.isHalted(); // will be false
	 * ```
	 */
	isHalted(): boolean;


}