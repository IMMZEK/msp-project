// Copyright (c) 2024 Texas Instruments
// DO NOT EDIT THIS FILE!!!!
// This file was autogenerated using tsInterfaceDef.xdt
// from ds/code/cc_app_studio/Modules/JSONInterface/../AsyncInterface/include/AsyncInterface/Scripting/TaskObjects/Memory.h

import { Address, DSLocation, Page } from "../common";

export interface Memory {

	/**
	 * Load a program file to the target, and load debug symbols (if any) for debugging.
	 * Accepts programs in ELF, COFF, and multiple hex formats.
	 *
	 * @remarks
	 * Loading a program will clear any previously loaded debug symbols.
	 *
	 * This returns once the program has been loaded to the target, the debugger is finished
	 * loading debug symbols, and the target is halted. By default, the debugger will run to
	 * the start of main. This behavior can be configured in the debugger settings.
	 *
	 * Will throw if the program load fails.
	 *
	 * @example
	 * ```
	 * // Load a program
	 * session.memory.loadProgram("C:/my_project/Debug/example.out");
	 * ```
	 *
	 * @param filepath - Full path to the file
	 */
	loadProgram(filepath: string): void;

	/**
	 * Load a binary program file to the target.
	 *
	 * @remarks
	 * This can be used to program flash memory.
	 *
	 * The target will be halted prior to the load.
	 *
	 * Unlike {@link Memory.loadProgram}, this will not clear previously loaded debug symbols.
	 *
	 * @param filepath - Full path to the file
	 * @param startAddress - The address at which the program should be loaded. On targets
	 * with memory pages, this address is assumed to be in the program memory page.
	 *
	 * @example
	 * ```
	 * // Load a binary program
	 * session.memory.loadBinaryProgram("C:/workspace/example.bin", 0x2400n);
	 * ```
	 */
	loadBinaryProgram(
		filepath: string,
		startAddress: Address,
	): void;

	/**
	 * Verifies a program file against what is in the target's memory.
	 * Accepts programs in ELF, COFF, and multiple hex formats.
	 * An error is thrown if the verification fails.
	 *
	 * @param filepath - Full path to the file
	 *
	 * @example
	 * ```
	 * // Verify a program
	 * try {
	 *   session.memory.verifyProgram("C:/my_project/Debug/example.out");
	 *   console.log("Program verification passed");
	 * } catch {
	 *   console.log("Program verification failed");
	 * }
	 * ```
	 */
	verifyProgram(filepath: string): void;

	/**
	 * Verifies a binary program file against what is in the target's memory. 
	 * An error is thrown if the verification fails.
	 *
	 * @param filepath - Full path to the file
	 * @param startAddress - The address at which the binary program is expected to be loaded in memory.
	 * On targets with memory pages, this address is assumed to lie in the program memory page.
	 *
	 * @example
	 * ```
	 * // Verify a binary program
	 * try {
	 *   session.memory.verifyBinaryProgram("C:/workspace/example.bin", 0x2400n);
	 *   console.log("Program verification passed");
	 * } catch {
	 *   console.log("Program verification failed");
	 * }
	 * ```
	 */
	verifyBinaryProgram(
		filepath: string,
		startAddress: Address,
	): void;

	/**
	 * Read a block of values from the target's memory.
	 * The memory contents are interpreted as unsigned integers of the specified bit size.
	 *
	 * @param location - The starting location to read from
	 * @param count - The number of values to read
	 * @param bitSize - The bit width of the values to be read. Defaults to the word size. Valid values are 8, 16, 24, 32, 40, 48, and 64.
	 * @returns An array of the values read
	 *
	 * @remarks
	 * Will throw if any part of the memory read encounters an error.
	 *
	 * @example
	 * ```
	 * // Read 10 words starting at 0x2400
	 * let values = session.memory.read(0x2400n, 10);
	 *
	 * // Read 2 64-bit values
	 * let [value1, value2] = session.memory.read(0x2400n, 2, 64);
	 * ```
	 */
	read(
		location: DSLocation,
		count: number,
		bitSize?: number,
	): bigint[];

	/**
	 * Like {@link Memory.read} but reads and returns a single value instead of an array.
	 *
	 * @example
	 * ```
	 * // Read one word at 0x24000
	 * let value = session.memory.readOne(0x2400n);
	 *
	 * // Read one 64-bit value
	 * let value = session.memory.readOne(0x2400n, 64);
	 * ```
	 */
	readOne(
		location: DSLocation,
		bitSize?: number,
	): bigint;

	/**
	 * Write a block of values to the target's memory.
	 *
	 * Negative values can be provided and will be written as a signed integer of the
	 * specified size. Values provided will be truncated to fit in an integer of the
	 * specified size and appropriate signedness.
	 *
	 * @param location - The starting location to write to
	 * @param values - The values to write. Can be a single value, or an array of values.
	 * Each value must be a bigint, or an integer represented as a string or a javascript number
	 * @param bitSize - The bit width of the values to be written. Defaults to the word size. Valid values are 8, 16, 24, 32, 40, 48, and 64.
	 *
	 * @remarks
	 * Will throw if any part of the memory write encounters an error.
	 *
	 * @example
	 * ```
	 * // Write 6 words starting at 0x2400
	 * // values can be specified as numbers, bigints, or strings
	 * session.memory.write(0x2400n, [0, 1n, -500, 0x4, "5", "-0x3"]);
	 *
	 * // Write one 64 bit value at 0x2400
	 * session.memory.write(0x2400n, 0x8765432187654312n, 64);
	 * // equivalently
	 * session.memory.write(0x2400n, [0x8765432187654312n], 64);
	 * ```
	 */
	write(
		location: DSLocation,
		values: bigint | number | string | (bigint | number | string)[],
		bitSize?: number,
	): void;

	/**
	 * Fill a block of memory with a specified value.
	 *
	 * @param location - The start address of the block of memory
	 * @param count - The number of values to fill in the block
	 * @param value - The value to use to fill memory
	 * @param bitSize - The bit width of the value. Defaults to the word size. Valid values are 8, 16, 24, 32, 40, 48, and 64.
	 *
	 * @example
	 * ```
	 * // Fill a block of 10 words, starting at 0x2400, with all 1s (assumes words are 32-bit on the target)
	 * session.memory.fill(0x2400n, 10, 0xFFFFFFFF);
	 *
	 * // Filling the same block with all 1s, but using 64-bit values
	 * session.memory.fill(0x2400n, 5, -1n, 64);
	 * ```
	 */
	fill(
		location: DSLocation,
		count: number,
		value: bigint | number | string,
		bitSize?: number,
	): void;

	/**
	 * Get a list of the supported formats to be used for {@link Memory.saveData}.
	 *
	 * @param page - The memory page. If not provided, assumes the default data access page.
	 * @returns A list of supported formats.
	 *
	 * @example
	 * ```
	 * let formats = session.memory.getSupportedFormats();
	 * // print all the formats
	 * for (const format : formats) {
	 *   console.log(format);
	 * }
	 * ```
	 */
	getSupportedFormats(page?: Page): string[];

	/**
	 * Save a block of target memory to a file in a human-readable format.
	 *
	 * @param location - The start address of the block of memory
	 * @param count - The number of words in the block of memory
	 * @param filepath - The full path of the file to be created
	 * @param format - The format in which the contents of memory should be written. A list of
	 * allowed formats for the target can be obtained from {@link Memory.getSupportedFormats}.
	 * @param append - A flag indicating if the data should be appended to the file, if it already
	 * exists. Different data formats should not be mixed in the same file.
	 * If not provided, defaults to false.
	 *
	 * @example
	 * ```
	 * // Save 5 words of memory in 32-bit hex format without a 0x prefix
	 * session.memory.saveData(0x2400n, 5, "C:/saveDataExample.dat", "32-Bit Hex - TI Style");
	 *
	 * // Save 24 words of memory in ascii character format
	 * session.memory.saveData(0x2400n, 24, "C:/saveDataExample.dat", "Character");
	 * ```
	 */
	saveData(
		location: DSLocation,
		count: number,
		filepath: string,
		format: string,
		append?: boolean,
	): void;

	/**
	 * Load a block of memory from a file created using {@link Memory.saveData}.
	 *
	 * @param location - The start address of the block of memory.
	 * @param count - The number of words to be loaded form the file.
	 * @param filepath - The full path to the data file.
	 *
	 * @remarks
	 * This command cannot be used to program flash. If you want to save and load
	 * data from and to flash, consider using {@link Memory.saveBinary} and
	 * {@link Memory.loadBinaryProgram}.
	 *
	 * @example
	 * ```
	 * session.memory.saveData(0x2400n, 5, "C:/loadDataExample.dat", "32-Bit Hex - TI Style");
	 * // Load the saved memory at a different location
	 * session.memory.loadData(0x3200n, 5, "C:/loadDataExample.dat");
	 * ```
	 */
	loadData(
		location: DSLocation,
		count: number,
		filepath: string,
	): void;

	/**
	 * Save a block of target memory to a binary file that can be loaded with {@link Memory.loadBinary}
	 * or {@link Memory.loadBinaryProgram} (see the descriptions of these commands for the differences in
	 * their behavior).
	 *
	 * @param location - The start address of the block of memory
	 * @param count - The number of words in the block of memory
	 * @param filepath - The full path of the file to be created
	 *
	 * @example
	 * ```
	 * // Save 256 words of memory to a binary file
	 * session.memory.saveBinary(0x2400n, 256, "C:/saveBinaryExample.bin");
	 * ```
	 */
	saveBinary(
		location: DSLocation,
		count: number,
		filepath: string,
	): void;

	/**
	 * Load a block of memory from a binary file, like the ones created with {@link Memory.saveBinary}.
	 *
	 * @remarks
	 * Unlike {@link loadBinaryProgram}, this is not considered a program load.
	 * That is, this cannot program flash memory, and the target will not be halted automatically.
	 * However, it can load to memory pages other than the program page.
	 *
	 * @param location - The start address of the block of memory
	 * @param filepath - The full path to the file to be loaded
	 *
	 * @example
	 * ```
	 * session.memory.saveBinary(0x2400n, 256, "C:/loadBinaryExample.bin");
	 * // Load the binary file at a different address
	 * session.memory.loadBinary(0x3200n, "C:/loadBinaryExample.bin");
	 * ```
	 */
	loadBinary(
		location: DSLocation,
		filepath: string,
	): void;


}